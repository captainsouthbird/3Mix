; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg020.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------
Tile_Layout_TS9:
	; This defines the individual 8x8 blocks used to construct one of the tiles
	; Referenced by Address_Per_Tileset, addressed by Level_Tileset
	; Stored by upper left, then lower left, then upper right, then lower right

	; Remember that palette is determined by the upper 2 bits of a TILE (not the PATTERN)
	; I.e. tiles starting at index $00, $40, $80, $C0 are each on that respective palette

	; Upper left 8x8 pattern per tile
	.byte $FC, $DC, $FF, $05, $05, $E8, $25, $25, $05, $29, $05, $4B, $05, $4C, $4B, $4E ; Tiles $00 - $0F
	.byte $FD, $FE, $00, $02, $FC, $23, $FF, $FC, $FC, $FC, $FC, $46, $FC, $47, $1D, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $20, $FF, $B8, $B8 ; Tiles $20 - $2F
	.byte $B8, $B8, $59, $2E, $2D, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DC, $05, $FC, $FE, $05, $05, $05, $F4, $F4, $F4, $29, $05, $05, $35, $D5, $B2 ; Tiles $40 - $4F
	.byte $46, $40, $4A, $05, $59, $13, $59, $59, $5A, $77, $77, $5A, $77, $77, $2D, $D8 ; Tiles $50 - $5F
	.byte $98, $98, $98, $98, $98, $98, $92, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4 ; Tiles $60 - $6F
	.byte $B4, $B8, $98, $98, $98, $98, $A4, $EC, $E4, $C0, $D5, $B2, $2E, $7A, $7C, $42 ; Tiles $70 - $7F
	.byte $05, $12, $FD, $FD, $12, $C4, $FD, $FD, $12, $FD, $FD, $37, $36, $3E, $3C, $05 ; Tiles $80 - $8F
	.byte $6C, $6E, $73, $75, $FC, $FD, $FE, $A8, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $90 - $9F
	.byte $1C, $0D, $FF, $FF, $FF, $FF, $FF, $10, $0E, $0E, $10, $10, $0E, $8C, $8E, $8C ; Tiles $A0 - $AF
	.byte $8E, $8C, $8E, $8C, $8E, $76, $76, $74, $70, $72, $AC, $AE, $B8, $8C, $8E, $76 ; Tiles $B0 - $BF
	.byte $60, $05, $64, $4B, $05, $4C, $4B, $4E, $52, $05, $05, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $05, $B3, $CC, $FC, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $18, $67, $51, $57, $8C, $57, $FF, $FF, $FF, $FF, $FF, $A4, $EC, $E4 ; Tiles $E0 - $EF
	.byte $53, $D7, $E0, $05, $53, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $F8, $FF ; Tiles $F0 - $FF

	; Lower left 8x8 pattern per tile
	.byte $FC, $DD, $FF, $06, $D6, $E9, $27, $27, $06, $2B, $06, $4B, $06, $4D, $4B, $4F ; Tiles $00 - $0F
	.byte $FD, $FE, $04, $0A, $22, $FC, $FF, $FC, $47, $0F, $FC, $46, $FC, $FC, $FC, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $30, $FF, $B9, $B9 ; Tiles $20 - $2F
	.byte $B9, $B9, $77, $2F, $2D, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DD, $06, $FC, $FE, $06, $06, $06, $F5, $F5, $F5, $28, $06, $34, $35, $B2, $B2 ; Tiles $40 - $4F
	.byte $FE, $3A, $4A, $06, $77, $5A, $77, $77, $5A, $77, $77, $32, $5B, $5B, $2D, $D9 ; Tiles $50 - $5F
	.byte $99, $99, $99, $99, $99, $99, $93, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5 ; Tiles $60 - $6F
	.byte $B5, $B9, $99, $99, $99, $99, $A5, $ED, $E4, $C1, $B2, $B2, $2F, $7B, $7D, $44 ; Tiles $70 - $7F
	.byte $06, $12, $FD, $FD, $16, $C4, $0C, $0C, $16, $FD, $1E, $36, $36, $3E, $FD, $06 ; Tiles $80 - $8F
	.byte $70, $72, $73, $78, $FC, $FD, $FE, $A8, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $90 - $9F
	.byte $0D, $0D, $FF, $FF, $FF, $FF, $FF, $12, $FD, $FD, $12, $16, $0C, $9C, $9E, $9C ; Tiles $A0 - $AF
	.byte $9E, $9C, $9E, $9C, $9E, $77, $77, $75, $71, $73, $AC, $AE, $B9, $9C, $9E, $77 ; Tiles $B0 - $BF
	.byte $62, $06, $66, $4B, $06, $4D, $4B, $4F, $62, $06, $66, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $E6, $CD, $CD, $CD, $FE, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $19, $69, $61, $57, $9C, $64, $FF, $FF, $FF, $FF, $FF, $A5, $ED, $E4 ; Tiles $E0 - $EF
	.byte $54, $06, $E1, $06, $55, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $F9, $FF ; Tiles $F0 - $FF

	; Upper right 8x8 pattern per tile	
	.byte $FC, $DE, $FF, $07, $07, $EA, $26, $07, $26, $07, $2A, $4B, $4D, $4B, $4F, $4B ; Tiles $00 - $0F
	.byte $FD, $FE, $01, $03, $22, $FC, $FF, $FC, $FC, $FC, $46, $FC, $1C, $47, $FC, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $21, $FF, $BA, $BA ; Tiles $20 - $2F
	.byte $BA, $BA, $59, $2E, $2D, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DE, $07, $FC, $FE, $07, $07, $07, $F6, $F6, $F6, $07, $2A, $34, $35, $D5, $B2 ; Tiles $40 - $4F
	.byte $47, $41, $07, $4A, $59, $59, $59, $14, $77, $77, $5C, $77, $77, $5C, $2D, $DA ; Tiles $50 - $5F
	.byte $9A, $9A, $9A, $9A, $9A, $9A, $CA, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6 ; Tiles $60 - $6F
	.byte $B6, $BA, $9A, $9A, $9A, $9A, $A6, $EE, $E5, $C2, $D5, $B2, $2E, $7A, $7C, $43 ; Tiles $70 - $7F
	.byte $07, $FD, $FD, $15, $FD, $C6, $FD, $15, $15, $1F, $1F, $07, $36, $3F, $3C, $6B ; Tiles $80 - $8F
	.byte $6D, $07, $74, $76, $FC, $FD, $FE, $A8, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $90 - $9F
	.byte $1D, $0F, $FF, $FF, $FF, $FF, $FF, $0E, $0E, $11, $11, $0E, $11, $8D, $8F, $8D ; Tiles $A0 - $AF
	.byte $8F, $8D, $8F, $8D, $8F, $7A, $7A, $78, $70, $72, $AD, $AF, $BA, $8D, $8F, $7A ; Tiles $B0 - $BF
	.byte $61, $07, $65, $4B, $4D, $4B, $4F, $07, $50, $07, $07, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $07, $B3, $CE, $FC, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $1A, $68, $51, $58, $8F, $58, $FF, $FF, $FF, $FF, $FF, $A6, $EE, $E5 ; Tiles $E0 - $EF
	.byte $55, $D7, $E2, $07, $54, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FA, $FF ; Tiles $F0 - $FF

	; Lower right 8x8 pattern per tile
	.byte $FC, $DF, $FF, $08, $D6, $EB, $28, $08, $28, $08, $2C, $4B, $4C, $4B, $4E, $4B ; Tiles $00 - $0F
	.byte $FD, $FE, $09, $0B, $FC, $23, $FF, $0D, $47, $FC, $46, $FC, $FC, $FC, $FC, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $31, $FF, $BB, $BB ; Tiles $20 - $2F
	.byte $BB, $BB, $77, $2F, $2D, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DF, $08, $FC, $FE, $08, $08, $08, $F7, $F7, $F7, $08, $2C, $35, $35, $B2, $B2 ; Tiles $40 - $4F
	.byte $FE, $3B, $08, $4A, $77, $77, $77, $5C, $77, $77, $5C, $5B, $5B, $33, $2D, $DB ; Tiles $50 - $5F
	.byte $9B, $9B, $9B, $9B, $9B, $9B, $CB, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7 ; Tiles $60 - $6F
	.byte $B7, $BB, $9B, $9B, $9B, $9B, $A7, $EF, $E5, $C3, $B2, $B2, $2F, $7B, $7D, $45 ; Tiles $70 - $7F
	.byte $08, $FD, $FD, $15, $0C, $C6, $0C, $17, $17, $1F, $24, $37, $36, $3F, $FD, $6F ; Tiles $80 - $8F
	.byte $71, $08, $74, $79, $FC, $FD, $FE, $A8, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $90 - $9F
	.byte $0F, $0F, $FF, $FF, $FF, $FF, $FF, $FD, $FD, $15, $15, $0C, $17, $9D, $9F, $9D ; Tiles $A0 - $AF
	.byte $9F, $9D, $9F, $9D, $9F, $7B, $7B, $79, $71, $73, $AD, $AF, $BB, $9D, $9F, $7B ; Tiles $B0 - $BF
	.byte $63, $08, $67, $4B, $4C, $4B, $4E, $08, $60, $63, $08, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $E7, $CF, $CF, $CF, $FE, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $1B, $6A, $61, $58, $9F, $65, $FF, $FF, $FF, $FF, $FF, $A7, $EF, $E5 ; Tiles $E0 - $EF
	.byte $56, $08, $E3, $08, $56, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FB, $FF ; Tiles $F0 - $FF

Tile_Attributes_TS9:
	.byte $2C, $54, $A7, $E2, $2E, $55, $AD, $E2


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS9
;
; Entry point for loading level layout data for Level_Tileset = 9
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ClearTS9_Tile:	.byte TILE9_BRICK_UM, TILE9_SKY

LevelLoad_TS9:
	LDY #6	; Offsets passed alternate layout/object pointers, second header byte
	LDA [Level_LayPtr_AddrL],Y
	
	LDY #0
	AND #LEVEL3_VERTICAL
	BEQ TS9Clear_NotVert	; If level is not vertical, jump to TS4Clear_NotVert

	INY

TS9Clear_NotVert:
	LDA ClearTS9_Tile,Y
	STA <Temp_Var1

	LDY #$00	 

	; Clearing in vertical mode
PRG020_A40A:
	LDA #TILE9_SKY
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$e0
	BNE PRG020_A40A

PRG020_A416:
	LDA <Temp_Var1	; Used as standard ground
	JSR Tile_Mem_ClearB
	INY	
	CPY #$f0
	BNE PRG020_A416

	JMP LevelLoad	; Begin actual level loading!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Generator_TS9
;
; Based on the values in Temp_Var15 and LL_ShapeDef, chooses an
; appropriate generator function to builds this piece of the
; level.  Tedious, but saves space and is paper-design friendly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG020_A423:
	.byte 0, 15, 30, 45, 60, 75, 90, 105

LoadLevel_Generator_TS9:
	; From level loader function:
	; * Temp_Var15, Temp_Var16, and LL_ShapeDef are three bytes read from the data


	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = upper 3 bits of Temp_Var15 (0-7) (selects a multiple of 15 as the base)

	LDA LL_ShapeDef
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = upper 4 bits of LL_ShapeDef shifted down
	ADD PRG020_A423,X	; Add multiple of 15
	TAX
	DEX
	TXA		 ; A = ((LL_ShapeDef >> 4) + PRG020_A423[X]) - 1


	; PRG015_A419 provides values well in excess of 55, but only 55
	; addresses are defined here; reserved for expansion...

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_LittleBlocks		;  0 - Side-by-side small horizontal blocks
	.word LoadLevel_BigBlocks		;  1 - Side-by-side big horizontal blocks
	.word LoadLevel_BiggerBlocks		;  2 - Side-by-side bigger blocks
	.word LoadLevel_BiggestBlocks		;  3 - Side-by-side biggest blocks
	.word LoadLevel_LittleVBlocks		;  4 - Stacked little vertical blocks going leftward
	.word LoadLevel_SandBrickBotCrnrs	;  5 - Run of alternating bottom brick tiles
	.word LoadLevel_SandBricks		;  6 - Side-by-side sand bricks
	.word LoadLevel_BigSandBricks		;  7 - Side-by-side big sand bricks
	.word LoadLevel_BiggerSandBricks	;  8 - Side-by-side bigger sand bricks
	.word LoadLevel_SandBrickRightDiags	;  9 - Run of alternating right side brick tiles diagonal left
	.word LoadLevel_LittleBlocksDiagRect	; 10 - Creates a rectangle of little blocks which shift diagonal left each line
	.word LoadLevel_BigBlocksDiagRect	; 11 - Creates a rectangle of big blocks which shift diagonal left each line
	.word LoadLevel_BiggerBlocksDiagRect	; 12 - Creates a rectangle of bigger blocks which shift diagonal left each line
	.word LoadLevel_BiggestBlockDiaRect	; 13 - Creates a rectangle of biggest blocks which shift diagonal left each line
	.word LoadLevel_ThinGround		; 14 - "Thin ground" with edges (UNUSED??)
	.word LoadLevel_BlockRun		; 15 - Run of bricks
	.word LoadLevel_BlockRun		; 16 - Run of '?' blocks with a coin
	.word LoadLevel_BlockRun		; 17 - Run of bricks with a coin
	.word LoadLevel_BlockRun		; 18 - Run of wood blocks
	.word LoadLevel_BlockRun		; 19 - Run of green note blocks (?)
	.word LoadLevel_BlockRun		; 20 - Run of note blocks
	.word LoadLevel_BlockRun		; 21 - Run of bouncing wood blocks
	.word LoadLevel_BlockRun		; 22 - Run of coins
	.word LoadLevel_VGroundPipeRun		; 23 - Vertical ground pipe 1 (alt level)
	.word LoadLevel_VGroundPipeRun		; 24 - Vertical ground pipe 2 (Big [?] area)
	.word LoadLevel_VGroundPipeRun		; 25 - Vertical ground pipe 3 (no entrance)
	.word LoadLevel_VCeilingPipeRun		; 26 - Vertical ceiling pipe 1 (alt level)
	.word LoadLevel_VCeilingPipeRun		; 27 - Vertical ceiling pipe 2 (no entrance)
	.word LoadLevel_HRightWallPipeRun	; 28 - Horizontal right-hand wall pipe (alt level)
	.word LoadLevel_HRightWallPipeRun	; 29 - Horizontal right-hand wall pipe (no entrance)
	.word LoadLevel_HLeftWallPipeRun	; 30 - Horizontal left-hand wall pipe (alt level)
	.word LoadLevel_HLeftWallPipeRun	; 31 - Horizontal left-hand wall pipe (no entrance)
	.word LoadLevel_Cannon			; 32 - Bullet bill cannon
	.word LoadLevel_CCBridge		; 33 - Cheep-Cheep style 'oo' bridge
	.word LoadLevel_CCBridge		; 34 - Would result in empty tiles?  (form of 33)
	.word LoadLevel_TopDecoBlocks		; 35 - Top-Deco Rectangle Waterfall
	.word LoadLevel_TopDecoBlocks		; 36 - Top-Deco Rectangle Left waving water pool
	.word LoadLevel_TopDecoBlocks		; 37 - Top-Deco Rectangle No current waving water pool
	.word LoadLevel_TopDecoBlocks		; 38 - Top-Deco Rectangle Right waving water pool
	.word LoadLevel_TopDecoBlocks		; 39 - Top-Deco Rectangle Water wrong-way BG
	.word LoadLevel_TopDecoBlocks		; 40 - Top-Deco Rectangle Diamond blocks (not really any deco on top)
	.word LoadLevel_TopDecoBlocks		; 41 - Top-Deco Rectangle Sand ground 
	.word LoadLevel_Quicksand2		; 42 - Top-Deco Rectangle orange block??
	.word LoadLevel_DiggableSand		; 43 - Run of ice bricks
	.word LoadLevel_VTransitPipeRun		; 44 - Vertical in-level transit pipe
	.word LoadLevel_DesertPillar		; 45 - Chain followed by pillar tiles (?)
	.word LoadLevel_MiscDesertTiles		; 46 - Run of cactus tiles
	.word LoadLevel_MiscDesertTiles		; 47 - Run of spikes upward
	.word LoadLevel_MiscDesertTiles		; 48 - Run of spikes downward
	.word LoadLevel_MiscDesertTiles		; 49 - Run of block things
	.word LoadLevel_LittleCloudRun		; 50 - Put in a run of those little smiling Judgem's type clouds
	.word LoadLevel_ChainLeft		; 51 - Left side chain
	.word LoadLevel_ChainRight		; 52 - Right side chain
	.word LoadLevel_SkyH_Unused		; 53 - Same functionality as 56, but not used??
	.word LoadLevel_Pipeworks		; 54 - Generates pipeworks structure
	.word LoadLevel_SkyV			; 55 - Run of sky tiles verticall
	.word LoadLevel_SkyH			; 56 - Run of sky tiles horizontally
	.word LoadLevel_20UNK			; 57 - Vertical run of unknown tile $F4
	.word LoadLevel_HRightWallPipeRun3	; 58 - Horizontal right-hand wall pipe 3 (no entrance)
	.word LoadLevel_PurpleCoins		; 59 - Run of Purple coins
	.word LoadLevel_PurpleCoinR		; 60 - Rectangle of Purple Coins


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LeveLoad_FixedSizeGen_TS9
;
; Much simpler generators that are fixed-size, commonly used for 
; just single tile placement styles (although a couple relatively 
; complex ones exist in here as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LeveLoad_FixedSizeGen_TS9:
	; It is verified before calling this function that all of
	; the upper 4 bits of LL_ShapeDef are ZERO

	; So the upper 3 bits of Temp_Var15 serve as the most significant bits
	; to a value where LL_ShapeDef provide the 4 least significant bits

	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	ADD LL_ShapeDef	
	TAX		 	; Resultant index is put into 'X'
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_SmallBlock_Pyramid	;  0 - Builds a pyramid out of small blocks
	.word LoadLevel_BigBlock_Pyramid	;  1 - Builds a pyramid out of big blocks
	.word LoadLevel_BiggerBlock_Pyramid	;  2 - Builds a pyramid out of bigger blocks
	.word LoadLevel_BiggestBlock_Pyramid	;  3 - Builds a pyramid out of biggest blocks
	.word LoadLevel_DesertTree		;  4 - Desert tree
	.word LoadLevel_CannonPlatform		;  5 - Cannon on a platform
	.word LoadLevel_DesertAltBG		;  6 - Clear to alternate background
	.word LoadLevel_PipeworkXtra		;  7 - Pipeworks 3-way junction tile
	.word LoadLevel_PipeworkXtra		;  8 - Pipeworks cracked pipe tile
	.word LoadLevel_PipeworksGround		;  9 - Pipeworks ground junction
	.word LoadLevel_DesertCloud		; 10 - Cloud
	.word LoadLevel_Door2			; 11 - Door style 2
	.word LoadLevel_BackgroundPyramid	; 12 - Constructs background pyramid
	.word LoadLevel_StarCoin1		; 13 - Star Coin 1
	.word LoadLevel_StarCoin2		; 14 - Star Coin 2
	.word LoadLevel_StarCoin3		; 15 - Star Coin 3
	.word LoadLevel_PowerBlock		; 16 - ? block with flower
	.word LoadLevel_PowerBlock		; 17 - ? block with leaf 
	.word LoadLevel_PowerBlock		; 18 - ? block with star
	.word LoadLevel_PowerBlock		; 19 - ? block with coin OR star
	.word LoadLevel_PowerBlock		; 20 - ? block with coin (??)
	.word LoadLevel_PowerBlock		; 21 - Muncher Plant!
	.word LoadLevel_PowerBlock		; 22 - Brick with flower
	.word LoadLevel_PowerBlock		; 23 - Brick with leaf
	.word LoadLevel_PowerBlock		; 24 - Brick with star
	.word LoadLevel_PowerBlock		; 25 - Brick with coin OR star
	.word LoadLevel_PowerBlock		; 26 - Brick with 10-coin
	.word LoadLevel_PowerBlock		; 27 - Brick with 1-up
	.word LoadLevel_PowerBlock		; 28 - Brick with vine
	.word LoadLevel_PowerBlock		; 29 - Brick with P-Switch
	.word LoadLevel_PowerBlock		; 30 - Invisible coin
	.word LoadLevel_PowerBlock		; 31 - Invisible 1-up
	.word LoadLevel_PowerBlock		; 32 - Invisible note
	.word LoadLevel_PowerBlock		; 33 - Note block with flower
	.word LoadLevel_PowerBlock		; 34 - Note block with leaf
	.word LoadLevel_PowerBlock		; 35 - Note block with star
	.word LoadLevel_PowerBlock		; 36 - Wood block with flower
	.word LoadLevel_PowerBlock		; 37 - Wood block with leaf
	.word LoadLevel_PowerBlock		; 38 - Wood block with star
	.word LoadLevel_PowerBlock		; 39 - Invisible note to coin heaven
	.word LoadLevel_PowerBlock		; 40 - P-Switch
	.word LoadLevel_EndGoal			; 41 - The end goal
	.word LoadLevel_ActionSwitch	; 42 - Action Switch
	.word LoadLevel_PipeRaiseHelper1	; 43 - Pipe Raise Helper 1
	.word LoadLevel_PipeRaiseHelper2	; 44 - Pipe Raise Helper 2
	.word LoadLevel_PipeRaiseHelper3	; 45 - Pipe Raise Helper 3
	.word LoadLevel_PipeRaiseHelper4	; 46 - Pipe Raise Helper 4


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LittleBlocks
;
; Generates 1-16 side-by-side little blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LittleBlocks:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG020_A526:
	LDA #TILE9_THINHBLOCK_L	 ; Thin horizontal block left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	LDA #TILE9_THINHBLOCK_R	 ; Thin horizontal block right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	BPL PRG020_A526	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BigBlocks
;
; Generates 1-16 side-by-side big blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_BigBlocks:
	.byte TILE9_BIGBLOCK_UL, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UR
	.byte TILE9_BIGBLOCK_LL, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LR

LoadLevel_BigBlocks:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0 (used a base index)

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var5		 ; Temp_Var5 = lower 4 bits of LL_ShapeDef

PRG020_A553:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var5
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var5

PRG020_A55A:
	LDA LL_BigBlocks,X	 ; Get big block tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++
	CPX #$04
	BEQ PRG020_A56B	 ; If X = 4, jump to PRG020_A56B

	CPX #$08	 
	BNE PRG020_A55A	 ; If X <> 8, loop!

PRG020_A56B:
	LDX <Temp_Var4		 ; X = Temp_Var4

	DEC <Temp_Var6		; Temp_Var6--
	BPL PRG020_A55A	 	; While Temp_Var6 >= 0, loop!

	JSR LL20_ReturnTileAndNextRow	 ; Next row

	LDA <Temp_Var4
	ADD #$04	
	STA <Temp_Var4	; Temp_Var4 += 4 (next row of tiles)

	TAX
	CPX #$08
	BNE PRG020_A553	 ; If X <> 8, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BiggerBlocks
;
; Generates 1-16 side-by-side bigger blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_BiggerBlock:
	.byte TILE9_BIGBLOCK_UL, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UR
	.byte TILE9_BIGBLOCK_ML, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MR
	.byte TILE9_BIGBLOCK_LL, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LR

LoadLevel_BiggerBlocks:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0 (used as a base index)

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var5		 ; Temp_Var5 = lower 4 bits of LL_ShapeDef

PRG020_A5A6:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var5
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var5

PRG020_A5AD:
	LDA LL_BiggerBlock,X	 ; Get big block tile 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++ (next tile)

	CPX #6
	BEQ PRG020_A5C2	 ; At index 6, go to next line

	CPX #12
	BEQ PRG020_A5C2	 ; At index 12, go to next line

	CPX #18
	BNE PRG020_A5AD	 ; If index <> 18, loop

PRG020_A5C2:
	LDX <Temp_Var4		 ; X = Temp_Var4

	DEC <Temp_Var6		 ; Temp_Var6-- (width decrement)
	BPL PRG020_A5AD	 	; While Temp_Var6 >= 0, loop!

	JSR LL20_ReturnTileAndNextRow	 ; Next row

	LDA <Temp_Var4
	ADD #$06
	STA <Temp_Var4	 ; Temp_Var4 += 6 (next row)

	TAX		
	CPX #18
	BNE PRG020_A5A6	 ; While X <> 18, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BiggestBlocks
;
; Generates 1-16 side-by-side biggest blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_BiggestBlock:
	.byte TILE9_BIGBLOCK_UL, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UM, TILE9_BIGBLOCK_UR 
	.byte TILE9_BIGBLOCK_ML, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MR
	.byte TILE9_BIGBLOCK_ML, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MM, TILE9_BIGBLOCK_MR
	.byte TILE9_BIGBLOCK_LL, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LM, TILE9_BIGBLOCK_LR

LoadLevel_BiggestBlocks:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0 (used as a base index)

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var5		 ; Temp_Var5 = lower 4 bits of LL_ShapeDef

PRG020_A60B:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var5
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var5

PRG020_A612:
	LDA LL_BiggestBlock,X	 ; Get big block tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++ (next block)

	CPX #8
	BEQ PRG020_A62B	 ; At index 8, go to next line

	CPX #16
	BEQ PRG020_A62B	 ; At index 16, go to next line

	CPX #24
	BEQ PRG020_A62B	 ; At index 24, go to next line

	CPX #32
	BNE PRG020_A612	 ; If index <> 32, loop

PRG020_A62B:
	LDX <Temp_Var4		 ; X = Temp_Var4

	DEC <Temp_Var6		 ; Temp_Var6-- (width decrement)
	BPL PRG020_A612	 	; While Temp_Var6 >= 0, loop!

	JSR LL20_ReturnTileAndNextRow	 ; Next row

	LDA <Temp_Var4
	ADD #$08
	STA <Temp_Var4	 ; Temp_Var4 += 8 (next row)

	TAX		
	CPX #32
	BNE PRG020_A60B	 ; While X <> 32, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LittleVBlocks
;
; Generates 1-16 stacked little blocks which trend diagonally
; to the left for some reason
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LittleVBlocks:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG020_A64A:
	LDA #TILE9_THINVBLOCK_T	; Little block vertical top
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA		 
	ADD #$10	 
	TAY		 
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	LDA #TILE9_THINVBLOCK_B	; Little block vertical bottom
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	DEY		 ; Y-- (left one column)
	TYA	
	AND #$0f
	CMP #$0f
	BNE PRG020_A677	 ; If we haven't crossed left screen boundary, jump to PRG020_A677

	; Otherwise... jump to previous screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH

	; Jump to right side of screen
	INY
	TYA
	ORA #$0f
	TAY	

PRG020_A677:
	STY TileAddr_Off	 ; TileAddr_Off = Y
	DEX		 ; X--
	BPL PRG020_A64A	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_SandBrickBotCrnrs
;
; Adds 1-16 alternating left/right bottom tiles of sand brick
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_SandBrickBotCrnrs:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG020_A687:
	LDA #TILE9_BRICK_LL	; Lower left of sand brick
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	LDA #TILE9_BRICK_LR	; Lower right of sand brick
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	BPL PRG020_A687	 ; While X >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_SandBricks
;
; Adds 1-16 side-by-side sand bricks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_SandBrick:
	.byte TILE9_BRICK_UL, TILE9_BRICK_UM, TILE9_BRICK_UM, TILE9_BRICK_UR
	.byte TILE9_BRICK_LL, TILE9_BRICK_LM, TILE9_BRICK_LM, TILE9_BRICK_LR

LoadLevel_SandBricks:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0 (base index)

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var5		 ; Temp_Var5 = lower 4 bits of LL_ShapeDef

PRG020_A6B4:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var5
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var5

PRG020_A6BB:
	LDA LL_SandBrick,X	 ; Get sand brick tile

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++ (next tile)

	CPX #$04
	BEQ PRG020_A6CC	 ; If X = 4, go to next row

	CPX #$08	
	BNE PRG020_A6BB	 ; If X <> 8, loop

PRG020_A6CC:
	LDX <Temp_Var4		 ; X = Temp_Var4

	DEC <Temp_Var6		 ; Temp_Var6-- (height decrement)
	BPL PRG020_A6BB	 	; While Temp_Var6 >= 0, loop

	JSR LL20_ReturnTileAndNextRow	 ; Next row

	LDA <Temp_Var4
	ADD #$04	
	STA <Temp_Var4	; Temp_Var4 += 4

	TAX		
	CPX #$08	
	BNE PRG020_A6B4	 ; If X <> 8, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BigSandBricks
;
; Adds 1-16 side-by-side big sand bricks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_BigSandBrick:
	.byte TILE9_BRICK_UL, TILE9_BRICK_UM, TILE9_BRICK_UM, TILE9_BRICK_UM, TILE9_BRICK_UM, TILE9_BRICK_UR
	.byte TILE9_BRICK_ML, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MR
	.byte TILE9_BRICK_LL, TILE9_BRICK_LM, TILE9_BRICK_LM, TILE9_BRICK_LM, TILE9_BRICK_LM, TILE9_BRICK_LR

LoadLevel_BigSandBricks:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0 (base index)
 
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var5		 ; Temp_Var5 = lower 4 bits of LL_ShapeDef

PRG020_A707:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var5
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var5 (width copy)

PRG020_A70E:
	LDA LL_BigSandBrick,X	 ; Get sand brick tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++ (next tile)

	CPX #6
	BEQ PRG020_A723	 ; If X = 6, go to next row

	CPX #12
	BEQ PRG020_A723	 ; If X = 12, go to next row

	CPX #18
	BNE PRG020_A70E	 ; If X <> 18, loop

PRG020_A723:
	LDX <Temp_Var4		 ; X = Temp_Var4

	DEC <Temp_Var6		 ; Temp_Var6--
	BPL PRG020_A70E	 	; If Temp_Var6 >= 0, loop

	JSR LL20_ReturnTileAndNextRow	 ; Next row

	LDA <Temp_Var4
	ADD #$06
	STA <Temp_Var4	 ; Temp_Var4 += 6

	TAX	
	CPX #18
	BNE PRG020_A707	 ; While X <> 18, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BiggerSandBricks
;
; Adds 1-16 side-by-side big sand bricks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_BiggerSandBrick:
	.byte TILE9_BRICK_UL, TILE9_BRICK_UM, TILE9_BRICK_UM, TILE9_BRICK_UM, TILE9_BRICK_UM, TILE9_BRICK_UM, TILE9_BRICK_UM, TILE9_BRICK_UR
	.byte TILE9_BRICK_ML, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MR
	.byte TILE9_BRICK_ML, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MM, TILE9_BRICK_MR
	.byte TILE9_BRICK_LL, TILE9_BRICK_LM, TILE9_BRICK_LM, TILE9_BRICK_LM, TILE9_BRICK_LM, TILE9_BRICK_LM, TILE9_BRICK_LM, TILE9_BRICK_LR

LoadLevel_BiggerSandBricks:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0 (base index)

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var5		 ; Temp_Var5 = lower 4 bits of LL_ShapeDef

PRG020_A76C:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var5
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var5

PRG020_A773:
	LDA LL_BiggerSandBrick,X	; Get sand brick tile 
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++ (next sand brick tile)

	CPX #8
	BEQ PRG020_A78C	 ; If X = 8, go to next row

	CPX #16
	BEQ PRG020_A78C	 ; If X = 16, go to next row

	CPX #24
	BEQ PRG020_A78C	 ; If X = 24, go to next row

	CPX #32
	BNE PRG020_A773	 ; If X <> 32, go to next row

PRG020_A78C:
	LDX <Temp_Var4		 ; X = Temp_Var4

	DEC <Temp_Var6		 ; Temp_Var6--
	BPL PRG020_A773	 	; While Temp_Var6 >= 0, loop

	JSR LL20_ReturnTileAndNextRow	 ; Next row

	LDA <Temp_Var4
	ADD #$08
	STA <Temp_Var4	 ; Temp_Var4 += 8

	TAX
	CPX #32
	BNE PRG020_A76C	 ; If X <> 32, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_SandBrickRightDiags
;
; Adds 1-16 diagonal left trailing right sides of sand brick
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_SandBrickRightDiags:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG020_A7AB:
	LDA #TILE9_BRICK_UR	 ; Sand brick upper right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	LDA #TILE9_BRICK_LR	 ; Sand brick lower right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	DEY		 ; Y-- (previous column)
	TYA		 
	AND #$0f	 
	BNE PRG020_A7D6	 ; If we haven't crossed left screen boundary, jump to PRG020_A7D6

	; Go to previous screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH

	INY
	TYA
	ORA #$0f
	TAY

PRG020_A7D6:
	STY TileAddr_Off	 ; TileAddr_Off = Y
	DEX		 ; X-- (width decrement)
	BPL PRG020_A7AB	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LittleBlocksDiagRect
;
; Generates 1-256 side-by-side little blocks and each iteration
; shifts one column to the left and does another row, for 1-16 rows
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LittleBlocksDiagRect:
	JSR LL20_GetLayoutByte_AndBackup	; Get byte from layout -> Temp_Var3, and backup Map_Tile_AddrL/H into Temp_Var1/2

	LDA TileAddr_Off
	STA <Temp_Var8		 ; Temp_Var8 = TileAddr_Off

	LDA #$00
	STA <Temp_Var9		 ; Temp_Var9 = 0

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var4		 ; Temp_Var4 = lower 4 bits of LL_ShapeDef (height of run)

PRG020_A7F0:
	LDX <Temp_Var3		 ; X = Temp_Var3 (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	JSR PRG020_A526	 	; For long width, repeat thin horizontal blocks

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA <Temp_Var8
	ADD #16
	STA <Temp_Var8
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	INC <Temp_Var9		 ; Temp_Var9++
	LDA <Temp_Var9
	AND #$01
	BEQ PRG020_A838	 	; On odd iterations of Temp_Var9, jump to PRG020_A838

	DEY		 	; Previous column
	TYA
	AND #$0f
	CMP #$0f
	BNE PRG020_A838	 	; If we haven't crossed left screen edge, jump to PRG020_A838

	; Go to previous screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	INY
	TYA
	AND #$f0
	ORA #$0f
	TAY	

PRG020_A838:
	STY TileAddr_Off	 ; TileAddr_Off = Y
	DEC <Temp_Var4		 ; Temp_Var4-- (height decrement)
	BPL PRG020_A7F0	 	; While Temp_Var4 >= 0, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BigBlocksDiagRect
;
; Generates 1-256 side-by-side big blocks and each iteration
; shifts two columns to the left and does another row, for 1-16
; rows (at two rows per block)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BigBlocksDiagRect:
	JSR LL20_GetLayoutByte_AndBackup2	; Get byte from layout -> Temp_Var5, and backup Map_Tile_AddrL/H into Temp_Var1/2

	LDA TileAddr_Off
	STA <Temp_Var8		 ; Temp_Var8 = TileAddr_Off

	LDA #$00
	STA <Temp_Var9		 ; Temp_Var9 = 0

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

PRG020_A853:
	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0

	JSR PRG020_A553	 ; For long width, repeat big blocks

	; Restore Map_Tile_Addr from backup
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Move down TWO lines by adding 32
	LDA <Temp_Var8
	ADD #32
	STA <Temp_Var8
	STA TileAddr_Off

	INC <Temp_Var9	 ; Temp_Var9++
	LDA <Temp_Var9
	AND #$01
	BEQ PRG020_A89A	 ; On odd iterations of Temp_Var9, jump to PRG020_A89A

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	DEY
	DEY		; Two columns to the left
	TYA
	AND #$0f
	CMP #$0e
	BLT PRG020_A897	 ; If we haven't crossed the left screen border, jump to PRG020_A897

	; Go to previous screen by subtracting $1B0
	STA <Temp_Var7
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH

	INY
	INY
	TYA
	AND #$f0
	ORA <Temp_Var7
	TAY		

PRG020_A897:
	STY TileAddr_Off	 ; TileAddr_Off = Y

PRG020_A89A:
	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG020_A853	 ; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BiggerBlocksDiagRect
;
; Generates 1-256 side-by-side bigger blocks and each iteration
; shifts three columns to the left and does another row, for 1-16
; rows (at three rows per block)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BiggerBlocksDiagRect:
	JSR LL20_GetLayoutByte_AndBackup2	; Get byte from layout -> Temp_Var5, and backup Map_Tile_AddrL/H into Temp_Var1/2

	LDA TileAddr_Off
	STA <Temp_Var8		 ; Temp_Var8 = TileAddr_Off

	LDA #$00
	STA <Temp_Var9		 ; Temp_Var9 = 0

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

PRG020_A8B2:
	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0

	JSR PRG020_A5A6	 ; For long width, repeat bigger blocks

	; Restore Map_Tile_Addr from backup
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Move down THREE lines by adding 48
	LDA <Temp_Var8
	ADD #48
	STA <Temp_Var8
	STA TileAddr_Off

	INC <Temp_Var9	 ; Temp_Var9++
	LDA <Temp_Var9
	AND #$01
	BEQ PRG020_A8FB	 ; On odd iterations of Temp_Var9, jump to PRG020_A8FB

	LDA TileAddr_Off
	SUB #$03	 ; Move left THREE columns
	TAY
	AND #$0f
	CMP #$0d
	BLT PRG020_A8F8	 ; If we haven't crossed the left screen boundary, jump to PRG020_A8F8

	; Go to previous screen by subtracting $1B0
	STA <Temp_Var7
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH
	INY
	INY
	INY
	TYA
	AND #$f0
	ORA <Temp_Var7
	TAY

PRG020_A8F8:
	STY TileAddr_Off	 ; TileAddr_Off = Y

PRG020_A8FB:
	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG020_A8B2	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BiggestBlockDiaRect
;
; Generates 1-256 side-by-side biggest blocks and each iteration
; shifts four columns to the left and does another row, for 1-16
; rows (at four rows per block)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BiggestBlockDiaRect:
	JSR LL20_GetLayoutByte_AndBackup2	; Get byte from layout -> Temp_Var5, and backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA TileAddr_Off
	STA <Temp_Var8		 ; Temp_Var8 = TileAddr_Off

	LDA #$00
	STA <Temp_Var9		 ; Temp_Var9 = 0

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

PRG020_A913:
	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0

	JSR PRG020_A60B	 ; For long width, repeat bigger blocks

	; Restore Map_Tile_Addr from backup
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Move down FOUR lines by adding 64
	LDA <Temp_Var8
	ADD #64
	STA <Temp_Var8
	STA TileAddr_Off

	INC <Temp_Var9	 ; Temp_Var9++
	LDA <Temp_Var9
	AND #$01
	BEQ PRG020_A59C	 ; On odd iterations of Temp_Var9, jump to PRG020_A59C

	LDA TileAddr_Off

	SUB #$04	 ; Move left FOUR columns
	TAY
	AND #$0f
	CMP #$0e
	BLT PRG020_A959	 ; If we haven't crossed the screen left edge, jump to PRG020_A959

	; Go to previous screen by subtracting $1B0
	STA <Temp_Var7
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH
	TYA	
	ADD #$04
	AND #$f0
	ORA <Temp_Var7
	TAY	

PRG020_A959:
	STY TileAddr_Off	 ; TileAddr_Off = Y

PRG020_A59C:
	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG020_A913	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ThinGround
;
; Generates 1-16 width run of "thin ground", which is a blue
; colored presumably unused thing that looks something like a log
; and has softened end tiles
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ThinGround:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE9_THINGROUND_REDGE 	; Brick ruin right edge
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	JSR LoadLevel_NextColumn	; Next column

	DEX		 ; X-- (width decrement)

PRG020_A972:
	LDA #TILE9_THINGROUND_BLUE	; blue colored thin ground
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X-- (width decrement)
	BNE PRG020_A972	 ; While X > 0, loop!

	LDA #TILE9_THINGROUND_LEDGE	; Brick ruin left edge
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DesertPillar
;
; Adds a 1-16 height thing with pillar tiles; unclear what the
; intended difference of the "pillar" tiles may have meant to be
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_DesertPillar:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE9_CHAIN_LEFT_PILLAR	; Right "pillar" tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG020_A995	 ; Jump to PRG020_A995

PRG020_A991:
	LDA #TILE9_CHAIN_LEFT_PILLAR	; Left "pillar" tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG020_A995:
	; Go to next row by adding 16
	TYA	
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	DEX		 ; X-- (height decrement)
	BPL PRG020_A991	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_MiscDesertTiles
;
; Adds a 1-16 width run of one of the four following tiles:
; Cactus, Spikes upward, Spikes downward, and ... some block!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL20_MiscTiles:	.byte TILE9_CACTUS, TILE9_SPIKEUP, TILE9_SPIKEDOWN, TILE9_BLOCK

LoadLevel_MiscDesertTiles:
	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	SUB #$20
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	PLA		 ; Restore LL_ShapeDef
	AND #$0f
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG020_A9BC:
	LDA LL20_MiscTiles,X	 ; Get misc tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG020_A9BC	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ChainLeft
;
; Adds a 1-16 height run of left side chain
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ChainLeft:
	LDX #$00	 ; X = 0 (left chain)
	BEQ PRG020_A9D1	 ; Jump (technically always) to PRG020_A9D1


LL_DesertChains:	.byte TILE9_CHAIN_LEFT, TILE9_CHAIN_RIGHT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ChainRight
;
; Adds a 1-16 height run of right side chain
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ChainRight:
	LDX #$01	 ; X = 1 (right chain)

PRG020_A9D1:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of run)
	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG020_A9DB:
	LDA LL_DesertChains,X	 ; Get chain tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEC <Temp_Var3	 ; Temp_Var3-- (height decrement)
	BPL PRG020_A9DB	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_SkyH_Unused
;
; Identical duplicate of LoadLevel_SkyH??  
; Only difference is they did not appear to use this one!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_SkyH_Unused:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG020_A9F9:
	LDA #TILE9_SKY
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X-- (width decrement)
	BPL PRG020_A9F9	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Pipeworks
;
; The pipeworks generator is actually pretty fixed, and fix-ups
; post-generation are often employed so it can be trimmed to fit.
;
; The generator will ALWAYS GENERATE 5 ROWS of horizontal pipes
; at a specified width in multiple of 16 (16, 32, 48, ... 256),
; at the left edge and roughly the center of each 16 width 
; segment.  After that, other generators trim to fit.  Each pass
; of vertical tiles that hits a horizontal one automatically
; generates the corner tile.  So we wind up with:
;
; *------*--------
; |      |
; |      |
; |      |
; *------*--------
; |      |
; |      |
; |      |
; *------*--------
; |      |
; |      |
; |      |
; *------*--------
; |      |
; |      |
; |      |
; *------*--------  ... at a minimum
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Pipeworks:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX LL_ShapeDef
	INX
	TXA
	AND #$0f
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef incremented and shifted up by 4... (16, 32, 48, 64, ...)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; Every time this generator is employed, FIVE PIPES are put down;
	; level modifications selectively remove others
	LDX #$04	 	; X = 4

PRG020_AA1E:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

PRG020_AA22:
	LDA #TILE9_PIPEWORKS_H	 ; Horizontal pipeworks tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var4		 ; Temp_Var4--
	LDA <Temp_Var4
	CMP #$ff
	BNE PRG020_AA22	 	; While Temp_Var4 > 0, loop

	; Restore Map_Tile_Addr from backup
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go down FOUR rows by adding 64
	LDA TileAddr_Off
	ADD #64
	STA TileAddr_Off
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	DEX		 ; X-- (row decrement)
	BPL PRG020_AA1E	 ; While X >= 0, loop

	JSR LoadLevel_Set_TileMemAddr	; Reset TileMemAddr

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; This runs vertical pipes down the left and right sides of the five pipes
PRG020_AA63:
	LDX #16	 	; X = 16

PRG020_AA65:
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE9_PIPEWORKS_H
	BNE PRG020_AA70	 	; If tile is not a horizontal pipeworks tile, jump to PRG020_AA70

	LDA #TILE9_PIPEWORKS_CORNER	 ; Pipeworks corner tile
	JMP PRG020_AA72	 ; Jump to PRG020_AA72

PRG020_AA70:
	LDA #TILE9_PIPEWORKS_V	 ; Pipeworks vertical tile

PRG020_AA72:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X-- 
	BPL PRG020_AA65	 ; While X >= 0, loop

	; Restore Map_Tile_Addr from backup
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Move over 8 tiles to next spot
	LDA TileAddr_Off
	EOR #$08	 
	STA TileAddr_Off
	TAY
	AND #$08
	BNE PRG020_AA63	 ; If bit is set, don't need to move to next screen (keeps going 8 to the right)

	; Go to next screen by adding $1B0
	LDA <Map_Tile_AddrL
	ADD #$b0
	STA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2
	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG020_AA63	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_SkyV
;
; Adds a 1-16 height run of sky tiles
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_SkyV:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (height of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG020_AAB6:
	LDA #TILE9_SKY		; Sky tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X-- (height decrement)
	BPL PRG020_AAB6	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_SkyH
;
; Adds a 1-16 width run of sky tiles
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_SkyH:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG020_AAD2:
	LDA #TILE9_SKY		; Sky tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X-- (width decrement)
	BPL PRG020_AAD2	; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_20UNK
;
; Adds a 1-16 height run of unknown tile
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_20UNK:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG020_AAE6:
	LDA #$f4	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #$10
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	DEX		 ; X--
	BPL PRG020_AAE6	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_SmallBlock_Pyramid
;
; Constructs a pyramid out of small blocks, but it is very 
; specific in that it wants to end when the tile offset 
; exceeds $A0... not sure how to describe that
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_SmallBlock_Pyramid:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var5	 ; Temp_Var5 = 0

PRG020_AB05:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var5
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var5

PRG020_AB0C:
	LDA #TILE9_THINHBLOCK_L	; Small block left tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	LDA #TILE9_THINHBLOCK_R	 ; Small block right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEC <Temp_Var6		 ; Temp_Var6--
	BPL PRG020_AB0C	 	; While Temp_Var6 >= 0, loop

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	BCC PRG020_AB41	 ; If haven't crossed offset boundary, jump to PRG020_AB41

	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA <Temp_Var15
	ADD #16
	STA <Temp_Var15	; Temp_Var15 += 16

PRG020_AB41:
	DEY		 ; Previous column
	TYA
	AND #$0f
	CMP #$0f
	BNE PRG020_AB61	 ; If we haven't crossed screen boundary, jump to PRG020_AB61

	; Go back to previous screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	INY
	TYA
	AND #$f0
	ORA #$0f
	TAY

PRG020_AB61:
	STY TileAddr_Off	 ; TileAddr_Off = Y
	INC <Temp_Var5		 ; Temp_Var5++

	LDA <Temp_Var15
	AND #$10
	BEQ PRG020_AB05	 	; On every other jump to PRG020_AB05

	LDA TileAddr_Off
	CMP #$a0	 
	BLT PRG020_AB05	 ; If the tile offset hasn't hit $A0, jump to PRG020_AB05

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BigBlock_Pyramid
;
; Constructs a pyramid out of big blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BigBlock_Pyramid:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0
	STX <Temp_Var5	 ; Temp_Var5 = 0

PRG020_AB82:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var5
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var5

PRG020_AB89:
	LDA LL_BigBlocks,X	 ; Get big block tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column
	INX		 	; X++
	CPX #$04
	BEQ PRG020_AB9A	 	; If X = 4, jump to PRG020_AB9A

	CPX #$08	 
	BNE PRG020_AB89	 	; If X <> 8, jump to PRG020_AB89

PRG020_AB9A:
	LDX <Temp_Var4		 ; X = Temp_Var4

	DEC <Temp_Var6		 ; Temp_Var6--
	BPL PRG020_AB89	 	 ; While Temp_Var6 >= 0, loop

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	BCC PRG020_ABC2	 ; If haven't crossed offset boundary, jump to PRG020_ABC2

	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA <Temp_Var15	
	ADD #16
	STA <Temp_Var15		 ; Temp_Var15 += 16

PRG020_ABC2:
	LDA <Temp_Var4
	ADD #$04
	STA <Temp_Var4	 ; Temp_Var4 += 4

	TAX	
	CPX #$08
	BNE PRG020_AB82	 ; If X <> 8, jump to PRG020_AB82

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	DEY
	DEY		; Move back TWO columns
	TYA
	AND #$0f
	CMP #$0e
	BLT PRG020_ABF5	 ; If haven't crossed screen boundary, jump to PRG020_ABF5

	; Go back one screen by subtracting $1B0
	STA <Temp_Var7
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	SBC #$01	
	STA <Map_Tile_AddrH
	STA <Temp_Var2	

	INY	
	INY	
	TYA	
	AND #$f0
	ORA <Temp_Var7
	TAY		

PRG020_ABF5:
	STY TileAddr_Off	 ; TileAddr_Off = Y

	LDX #$00	 	; X = 0
	STX <Temp_Var4		 ;Temp_Var4 = 0

	INC <Temp_Var5		 ; Temp_Var5++

	LDA <Temp_Var15		
	AND #$10	 
	BEQ PRG020_AC0C	 ; On every other jump to PRG020_AC0C

	LDA TileAddr_Off	 ; $AC04 
	CMP #$90	 ; $AC07 
	BLT PRG020_AC0C	 ; $AC09 

	RTS		 ; Return


PRG020_AC0C:
	JMP PRG020_AB82	 ; Jump to PRG020_AB82

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BiggerBlock_Pyramid
;
; Constructs a pyramid out of bigger blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BiggerBlock_Pyramid:

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0
	STX <Temp_Var5	 ; Temp_Var5 = 0

PRG020_AC1D:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA <Temp_Var5
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var5

PRG020_AC24:
	LDA LL_BiggerBlock,X	 ; Get bigger block tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++

	CPX #6
	BEQ PRG020_AC39	 ; If X = 6, jump to PRG020_AC39

	CPX #12
	BEQ PRG020_AC39	 ; If X = 12, jump to PRG020_AC39

	CPX #18
	BNE PRG020_AC24	 ; If X <> 18, jump to PRG020_AC24

PRG020_AC39:
	LDX <Temp_Var4		 ; X = Temp_Var4

	DEC <Temp_Var6		 ; Temp_Var6--
	BPL PRG020_AC24	 	; While Temp_Var6 >= 0, loop

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	BCC PRG020_AC61	 ; If offset boundary crossed, jump to PRG020_AC61

	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA <Temp_Var15
	ADD #16
	STA <Temp_Var15		 ; Temp_Var15 += 16

PRG020_AC61:
	LDA <Temp_Var4
	ADD #$06
	STA <Temp_Var4		 ; Temp_Var4 += 6

	TAX
	CPX #18
	BNE PRG020_AC1D	 ; If X <> 18, loop

	LDA TileAddr_Off
	SUB #$03	; Move THREE columns back
	AND #$0f
	CMP #$0d
	BCC PRG020_AC95	 ; If haven't crossed screen boundary, jump to PRG020_AC95

	; Go to previous screen by subtracting $1B0
	STA <Temp_Var7
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	INY
	INY
	INY
	TYA
	AND #$f0
	ORA <Temp_Var7
	TAY	

PRG020_AC95:
	STY TileAddr_Off	 ; TileAddr_Off = Y

	LDX #$00		 ; X = 0
	STX <Temp_Var4		 ; Temp_Var4 = 0

	INC <Temp_Var5	 ; Temp_Var5++

	LDA <Temp_Var15
	AND #$10
	BEQ PRG020_ACAC	 ; On every other jump to PRG020_ACAC

	LDA TileAddr_Off
	CMP #$80
	BLT PRG020_ACAC	; If offset < $80, loop

	RTS		 ; Return

PRG020_ACAC:
	JMP PRG020_AC1D	 ; Jump to PRG020_AC1D


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BiggestBlock_Pyramid
;
; Constructs a pyramid out of biggest blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BiggestBlock_Pyramid:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0
	STX <Temp_Var5	 ; Temp_Var5 = 0

PRG020_ACBD:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var5
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var5

PRG020_ACC4:
	LDA LL_BiggestBlock,X	 ; Get biggest tile block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++

	CPX #8
	BEQ PRG020_ACDD	 ; If X = 8, jump to PRG020_ACDD

	CPX #16
	BEQ PRG020_ACDD	 ; If X = 16, jump to PRG020_ACDD

	CPX #24
	BEQ PRG020_ACDD	 ; If X = 24, jump to PRG020_ACDD

	CPX #32
	BNE PRG020_ACC4	 ; If X <> 32, loop

PRG020_ACDD:
	LDX <Temp_Var4		 ; X = Temp_Var4

	DEC <Temp_Var6		 ; Temp_Var6--
	BPL PRG020_ACC4	 	; While Temp_Var6 >= 0, loop

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	BCC PRG020_AD05		; If haven't crossed offset boundary, jump to PRG020_AD05

	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA <Temp_Var15
	ADD #16
	STA <Temp_Var15		 ; Temp_Var15 += 16

PRG020_AD05:
	LDA <Temp_Var4
	ADD #$08
	STA <Temp_Var4	 ; Temp_Var4 += 8

	TAX
	CPX #32
	BNE PRG020_ACBD	 ; If X <> 32, loop

	LDA TileAddr_Off
	SUB #$04	 ; Move back FOUR columns
	TAY		
	AND #$0f	
	CMP #$0c	
	BCC PRG020_AD3A	 ; If haven't crossed screen boundary, jump to PRG020_AD3A

	; Go to previous screen by subtracting $1B0
	STA <Temp_Var7
	LDA <Map_Tile_AddrL
	SUB #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	SBC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	TYA
	ADD #$04
	AND #$f0
	ORA <Temp_Var7
	TAY	

PRG020_AD3A:
	STY TileAddr_Off	 ; TileAddr_Off = Y

	LDX #$00	 ; X = 0
	STX <Temp_Var4	 ; Temp_Var4 = 0

	INC <Temp_Var5	 ; Temp_Var5++

	LDA <Temp_Var15
	AND #$10	
	BEQ PRG020_AD51	 ; On every other, jump to PRG020_AD51

	LDA TileAddr_Off
	CMP #$70
	BLT PRG020_AD51	 ; If offset < $70, loop

	RTS		 ; Return

PRG020_AD51:
	JMP PRG020_ACBD	 ; $AD51 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DesertTree
;
; Builds a desert tree with a three tile tall trunk
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_DesertTree:	.byte TILE9_TREETOP_RIGHT, TILE9_TREETOP_MIDDLE, TILE9_TREETOP_LEFT

LoadLevel_DesertTree:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	; Copies in the tree top tiles
	LDX #$02	 ; X = 2
	LDY TileAddr_Off ; Y = TileAddr_Off

PRG020_AD64:
	LDA LL_DesertTree,X	 ; Get tree top tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	BPL PRG020_AD64	 ; While X >= 0, loop

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH

	; Did they forget this is defined as a function?
	INY		; Next column	 
	TYA		 
	AND #$0f	
	BNE PRG020_AD9C	 ; If crossed screen boundary, jump to PRG020_AD9C

	; Go to next screen by adding $1B0
	LDA <Map_Tile_AddrL
	ADD #$b0	 
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH

	DEY		 
	TYA		 
	AND #$f0	 
	TAY		 

	; Three tall trunk
PRG020_AD9C:
	LDX #$02	 ; X = 2

PRG020_AD9E:
	LDA #TILE9_TREE	 	; Tree trunk tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BPL PRG020_AD9E	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DesertCloud
;
; Adds a cloud
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_DesertCloud:
	LDY TileAddr_Off

	LDA #TILE9_CLOUD_L
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	LDA #TILE9_CLOUD_R
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BackgroundPyramid
;
; Constructs the background pyramid until there's no more sky
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BackgroundPyramid:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0
	STX <Temp_Var3	 ; Temp_Var3 = 0

PRG020_ADCC:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE9_SKY
	BNE PRG020_AE2F	 	; If tile is not sky, jump to PRG020_AE2F

	LDA #TILE9_PYRAMID_SLOPE ; Pyramid slope tile
	JMP PRG020_ADDC	 	; Jump to PRG020_ADDC

PRG020_ADDA:
	LDA #TILE9_PYRAMID	; Pyramid fill tile

PRG020_ADDC:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	BPL PRG020_ADDA	 ; While X >= 0, loop

	LDX <Temp_Var3	 ; X = Temp_Var3
	BEQ PRG020_ADF2	 ; $ADE6 

PRG020_ADE8:
	LDA #TILE9_PYRAMIDSH	; Shaded pyramid fill tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEX		 ; X--
	BNE PRG020_ADE8	 ; While X > 0, loop

PRG020_ADF2:
	LDA #TILE9_PYRAMIDSH_SLOPE	; Shaded pyramid slope tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Add 16 and subtract 1 to move down one row and left one column
	LDA TileAddr_Off
	ADD #16
	TAY	
	DEY	
	TYA	
	AND #$0f
	CMP #$0f
	BNE PRG020_AE25		; If haven't crossed boundary, jump to PRG020_AE25

	; Jump to previous screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	SBC #$01	
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	INY
	TYA
	AND #$f0
	ORA #$0f
	TAY	

PRG020_AE25:
	STY TileAddr_Off	 ; TileAddr_Off = Y
	INC <Temp_Var3		 ; Temp_Var3++

	LDX <Temp_Var3	; X = Temp_Var3
	JMP PRG020_ADCC	 ; Jump to Temp_Var3

PRG020_AE2F:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_CannonPlatform
;
; Builds a specific cannon on a platform
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_CannonPlatform:	
	.byte TILE9_CANNONBLOCK, TILEA_WOODBLOCK, TILE9_CANNONBLOCK
LL_CannonPlatform_End

LoadLevel_CannonPlatform:
	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA #TILE9_CANNONTOP1	; Top of cannon
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	LDA #TILE9_CANNONTOP2	; Below top of cannon
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEY		 ; Y-- previous column
	TYA	
	AND #$0f
	CMP #$0f
	BNE PRG020_AE6E	 ; If haven't crossed screen boundary, jump to PRG020_AE6E

	; Go to previous screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH

	INY
	TYA
	ORA #$0f
	TAY

PRG020_AE6E:
	LDX #(LL_CannonPlatform_End - LL_CannonPlatform - 1)

PRG020_AE70:
	LDA LL_CannonPlatform,X	 ; Get cannon platform block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	BPL PRG020_AE70	 ; While X >= 0, loop
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DesertAltBG
;
; Clear to alternate background tile
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_DesertAltBG:
	LDY #$00
PRG020_AE7E:
	LDA #TILE9_ALTBACKGROUND
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$e0
	BNE PRG020_AE7E
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PipeworkXtra
;
; Pipeworks extra tiles (3-way junction, break)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_PipeworkXtra:	.byte TILE9_PIPEWORKS_JCT, TILE9_PIPEWORKS_CRACK

LoadLevel_PipeworkXtra:
	LDA LL_ShapeDef
	SUB #$07	
	TAX		 ; X = relative index

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_PipeworkXtra,X	 ; Get Pipework extra tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PipeworksGround
;
; Generates the ground connector for a pipeworks structure
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_PipeworksGround:	.byte TILE9_PIPEWORKS_GROUNDL, TILE9_PIPEWORKS_GROUND, TILE9_PIPEWORKS_GROUNDR

LoadLevel_PipeworksGround:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDX #$01	 	; X = 1 (two rows of vertical)
PRG020_AEA5:
	LDA #TILE9_PIPEWORKS_V
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BPL PRG020_AEA5	 ; While X >= 0, loop

	LDX #$00	 ; X = 0

	DEY		 ; Y-- (go left one column)
	TYA
	AND #$0f
	CMP #$0f
	BNE PRG020_AED5	 ; If haven't crossed screen boundary, jump to PRG020_AED5

	; Go to previous screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH

	INY
	TYA
	AND #$f0
	ORA #$0f
	TAY

PRG020_AED5:
	STY TileAddr_Off	 ; TileAddr_Off = Y

PRG020_AED8:
	LDA LL_PipeworksGround,X ; Get pipeworks ground junction
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++
	CPX #$03
	BNE PRG020_AED8	 ; If X <> 3, loop

	RTS		 ; Return


	; Routine to get a byte from the layout, put it into Temp_Var3,
	; and advance the Level_LayPtr_Addr pointer...
	; Also backup Map_Tile_AddrL/H into Temp_Var1/2
LL20_GetLayoutByte_AndBackup:
	LDY #$00	 
	LDA [Level_LayPtr_AddrL],Y	; Get another byte from layout data
	STA <Temp_Var3		 	; Store it into Temp_Var3

PRG020_AEEC:
	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2
	RTS		 ; Return

	; Same as above, except Temp_Var5 instead of Temp_Var3
LL20_GetLayoutByte_AndBackup2:
	LDY #$00	 
	LDA [Level_LayPtr_AddrL],Y	; Get another byte from layout data
	STA <Temp_Var5		 	; Store into Temp_Var5
	JMP PRG020_AEEC			; Continue with LL20_GetLayoutByte_AndBackup


LL20_ReturnTileAndNextRow:
	; Restore Map_Tile_Addr from backup
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DiggableSand
;
; Adds a rectangle (width 1-256 / height 1-16) of Ghost House brick
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_DiggableSand:
	LDY #$00	 ; Y = 0

	LDA [Level_LayPtr_AddrL],Y
	STA <Temp_Var4		; Get next byte from layout -> Temp_Var4 (height of run)

	; Level_LayPtr_Addr += 1
	LDA <Level_LayPtr_AddrL
	ADD #$01	 
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	
	AND #$0f	
	STA <Temp_Var3	; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	; Y = TileAddr_Off

DigSand_WallRowLoop:
	LDA <Temp_Var3
	STA <Temp_Var5		; Width of run -> Temp_Var5

DigSand_WallWidthLoop:
	LDA #TILE9_DIGSAND	 ; Get sand tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Go to next column

	DEC <Temp_Var5		 ; Temp_Var5--
	BPL DigSand_WallWidthLoop	 	 ; While Temp_Var5 > 0, loop!

	JSR LL20_ReturnTileAndNextRow	; Next row / return column

	DEC <Temp_Var4
	BPL DigSand_WallRowLoop	; While Temp_Var4 >= 0, loop!


PRG020_D398:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Quicksand2
;
; Generates a rectangle (width 1-256 / height 1-16) of quicksand.
;
; In this case, the lower 4 bits of LL_ShapeDef specify the 
; HEIGHT of the following blocks, while a byte pulled from the
; level data stream contains the WIDTH (so large 1-256 widths
; are supported by this routine.)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Quicksand2:
	LDX #11
	JMP LoadLevel_TopDecoBlocksX

	; Broken into another file for ease of integration in NoDice editor
	.include "PRG/levels/Desert.asm"
