; Source generated by DCC6502 version v1.4
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg008.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------

	; SB: Moved from bank 0
	; This table grants a couple (dis)abilities to certain
	; power-ups; specifically:
	; Bit 0 (1) = Able to fly/flutter (Raccoon tail wagging); SB: specific disable for Rabbit Mario near PRG008_AC9E
	; Bit 1 (2) = NOT able to slide on slopes
PowerUp_Ability:
	;     Small, Big, Fire, Leaf, Penguin, Rabbit, Hammer
	.byte $00,   $00, $00,  $05,  $00,  $01,     $02

	; Defines 4 frames of animation to use while Player walks
Player_WalkFramesByPUp:
	.byte PF_WALKSMALL_BASE, PF_WALKSMALL_BASE+1, PF_WALKSMALL_BASE, PF_WALKSMALL_BASE+1	; 0 - Small
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 1 - Big
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 2 - Fire
	.byte PF_WALKSPECIAL_BASE, PF_WALKSPECIAL_BASE+1, PF_WALKSPECIAL_BASE+2, PF_WALKSPECIAL_BASE+1	; 3 - Leaf
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 4 - Penguin
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1	; 5 - Rabbit
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 6 - Hammer

	; Frames used during the "power up" sequence from small -> Big
Player_GrowFrames:
	.byte PF_WALKBIG_BASE+2, PF_MIDGROW_HALFWAY, PF_WALKBIG_BASE+2, PF_MIDGROW_HALFWAY, PF_WALKBIG_BASE+2
	.byte PF_MIDGROW_HALFWAY, PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY, PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY
	.byte PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY

	; Stores frame to be used while traversing a pipe
	; Order is small, small + kuribo, other, other + kuribo
PipeMove_Frame:
	.byte PF_INPIPE_SMALL, PF_SLIDE_SMALL, PF_INPIPE_BIG, PF_SLIDE_BIG

	; Frame used when Player is "skidding"
Player_SkidFrame:
	.byte PF_SKID_SMALL, PF_SKID_BIG	; First value is for small, the other for everything else

Player_SwimActiveFrames:
	; Everything but small
	.byte PF_SWIMACTIVE_BIG, PF_SWIMACTIVE_BIG+1, PF_SWIMACTIVE_BIG+2, PF_SWIMACTIVE_BIG, PF_SWIMACTIVE_BIG+1, PF_SWIMACTIVE_BIG+2	
	; Small
	.byte PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+1, PF_SWIMIDLE_SMALL+2, PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+1, PF_SWIMIDLE_SMALL+2

	; Player sprite frames for swimming; first four are all power-up/suits
	; EXCEPT small, and the other four are for small
Player_SwimIdleFrames:
	.byte PF_SWIMIDLE_BIG, PF_SWIMIDLE_BIG+1, PF_SWIMIDLE_BIG-8, PF_SWIMIDLE_BIG+1	; Everything but small
	.byte PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+3, PF_SWIMIDLE_SMALL+3	; Small

	; Player's tail attack frames
Player_TailAttackFrames:
	.byte PF_TAILATKGROUND_BASE, PF_TAILATKGROUND_BASE+1, PF_TAILATKGROUND_BASE, PF_TAILATKGROUND_BASE+2, PF_TAILATKGROUND_BASE	; On ground
	.byte PF_TAILATKINAIR_BASE, PF_TAILATKINAIR_BASE-5, PF_TAILATKINAIR_BASE, PF_TAILATKINAIR_BASE-4, PF_TAILATKINAIR_BASE	; In air


	; Player duck frame
Player_DuckFrame:
	; First value is for everything EXCEPT Raccoon power; value on right is for raccoon power
	.byte PF_DUCK_NOTRACCOON,  PF_DUCK_RACCOON

	; The three sprite frames for when Player shoots a fireball/hammer
Player_FireOnGround:	.byte PF_THROWONGROUND_BASE, PF_THROWONGROUND_BASE+3, PF_THROWONGROUND_BASE+2
Player_FireInAir:	.byte PF_THROWINAIR_BASE, PF_THROWINAIR_BASE+1, PF_THROWINAIR_BASE+2

	; Frames used while penguin hopping
Player_PenguinHopFrames:
	.byte PF_PENGUINHOP_BASE, PF_PENGUINHOP_BASE+2, PF_PENGUINHOP_BASE+1, PF_PENGUINHOP_BASE


	; The raccoon power uses rotations of three frames based on different conditions
Player_TailWagFlyFrames:
	.byte PF_TAILWAGFLY_BASE+2, PF_TAILWAGFLY_BASE+1, PF_TAILWAGFLY_BASE	; Flying
	.byte PF_TAILWAGFLY_BASE+1, PF_TAILWAGFLY_BASE+2, PF_TAILWAGFLY_BASE	; Flying, apex
	.byte PF_JUMPRACCOON, PF_JUMPRACCOON, PF_JUMPRACCOON			; Jump/fall
	.byte PF_TAILWAGFALL+2, PF_TAILWAGFALL+1, PF_TAILWAGFALL		; Flutter wag

	; Bunny ears
	.byte PF_JUMPBIG, PF_JUMPBIG, PF_JUMPBIG			; Jump/fall
	.byte PF_JUMPBIG, PF_BUNNYFLAP, PF_BUNNYFLAP		; Flutter wag


	; Airship "caught anchor" frame or general vine climbing
Player_ClimbFrame:
	.byte PF_CLIMB_SMALL, 	PF_CLIMB_SMALL_BACK	; Small
	.byte PF_CLIMB_BIG, 	PF_CLIMB_BIG_BACK	; Big
	.byte PF_CLIMB_BIG, 	PF_CLIMB_BIG_BACK	; Fire
	.byte PF_CLIMB_BIG, 	PF_CLIMB_BIG_BACK	; Leaf
	.byte PF_CLIMB_PENGUIN,	PF_CLIMB_BIG_BACK	; Penguin
	.byte PF_CLIMB_BIG, 	PF_CLIMB_BIG_BACK	; Rabbit
	.byte PF_CLIMB_BIG, 	PF_CLIMB_BIG_BACK; Hammer

	; Airship jump frame used by power up
Airship_JumpFrameByPup:
	.byte PF_JUMPFALLSMALL		; Small
	.byte PF_JUMPBIG		; Big
	.byte PF_JUMPBIG		; Fire
	.byte PF_JUMPRACCOON		; Leaf
	.byte PF_JUMPBIG	; Penguin
	.byte PF_JUMPBIG		; Rabbit
	.byte PF_JUMPBIG		; Hammer


Player_WaterSplash:
	JMP_THUNKC 30, Player_WaterSplash30

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoGameplay
;
; This subroutine is MAJOR; it performs a LOT of tasks which make
; the Player gameplay; too much to discuss here, so go through it!
; About the only thing it doesn't cover is colliding with other
; objects; this is handled elsewhere...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DoGameplay:
	LDA #$04	; A = 4

	LDY Level_TilesetIdx	 ; Y = Level_TilesetIdx
	CPY #10
	BNE PRG008_A14C	 ; If Level_TilesetIdx <> 10 (Giant World), jump to PRG008_A14C

	LDA #60		; A = 60

PRG008_A14C:
	STA PatTable_BankSel+3	 ; Set VROM page (2/4 sprites)

	; Set Level_TilesetIdx by the current Tileset
	; Basically amounts to (Level_Tileset - 1)
	LDY Level_Tileset
	DEY
	STY Level_TilesetIdx

	JSR Level_Initialize	 ; Initialize level if needed
	JSR LevelJunction_PartialInit	 

	; NOTE: If a partial initialization occurred (above),
	; it will NOT return here!  It will be back up at PRG030...

	LDA Map_Starman
	BEQ PRG008_A17B	 ; If Player did not use a Starman, jump to PRG008_A17B

	; The following is used to prevent the invincibility star 
	; from being wasted on the airship's intro
	;LDA Level_Objects+1
	;CMP #OBJ_TOADANDKING
	;BEQ PRG008_A17B	 	; If the first object ID of this level is OBJ_TOADANDKING, then don't do invincibility yet (dodgy!)
	;CMP #OBJ_AIRSHIPANCHOR
	;BEQ PRG008_A17B	 	; If the first object ID of this level is OBJ_AIRSHIPANCHOR, then don't do invincibility yet (dodgy!)
	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BEQ PRG008_A17B

	DEC Map_Starman	 ; Map_Starman = 0 (or so it assumes)

	LDA #$FF
	STA Player_StarInv	 ; Player_StarInv = $FF (255 ticks of invincible fun)

	LDA #MUS2A_INVINCIBILITY
	STA Sound_QMusic2	 ; Queue invincibility song!

PRG008_A17B:

	; Quick clears all the sprites by setting all hardware
	; sprite Y positions to $F8
	LDY #$1c
	LDA #$f8
PRG008_A17F:
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$20,Y
	STA Sprite_RAM+$40,Y
	STA Sprite_RAM+$60,Y
	STA Sprite_RAM+$80,Y
	STA Sprite_RAM+$A0,Y
	STA Sprite_RAM+$C0,Y
	STA Sprite_RAM+$E0,Y
	DEY
	DEY
	DEY
	DEY
	BPL PRG008_A17F

	; Makes for "wobbly" raising of the airship at least..
	LDA Counter_Wiggly
	AND #$F0
	SUB #$90
	STA Counter_Wiggly

	JSR Player_Update	 ; WHERE THE PLAYER DOES EVERYTHING!! (Except touch other objects)

	; If Player is...
	LDA <Player_IsDying	; ... dying ....
	ORA Level_PipeMove	; ... moving through a pipe ...
	ORA Player_SuitLost	; ... just lost his suit ...
	ORA Player_StarOff	; ... starman is wearing off ...
	ORA Player_Grow		; ... is growing/shrinking ...
	STA Player_HaltGame	; ... means he's halting the gameplay for now

	BNE PRG008_A1C1	 	; And if that's the case, jump to PRG008_A1C1

	INC Level_NoStopCnt	; As long as none of the above is happening, continue the "no stop" counter...

PRG008_A1C1:
	LDA Level_ChgTileEvent
	CMP #CHNGTILE_DELETECOIN
	BNE PRG008_A1D7	 ; If Level_ChgTileEvent <> CHNGTILE_DELETECOIN, jump to PRG008_A1D7

	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BNE PDGP_NotPurpleComet

	; Purple Comet ... actually decrease the purple comet coin count
	LDA Level_PCometCoins
	SUB #1
	STA Level_PCometCoins
	LDA Level_PCometCoins+1
	SBC #0
	STA Level_PCometCoins+1
	
	ORA Level_PCometCoins
	BNE PDGP_NotDone	; If Level_PCometCoins is not overall zero, jump to PDGP_NotDone

	JSR_THUNKC 30, Level_EndComet

PDGP_NotDone:
	JMP PRG008_A1D7

PDGP_NotPurpleComet:
	; Otherwise... Score_Earned += 5(0) points
	LDA Score_Earned
	ADD #$05
	STA Score_Earned

	INC Coins_Earned	 ; One more coin earned!
	INC Coins_ThisLevel	 ; One more coin collected this level

PRG008_A1D7:

	LDA Player_LowClearance

	; Clear Player_LowClearance
	LDA #$00
	STA Player_LowClearance

	; Decrement several adjacent counters!
	LDX #$07	 ; X = 7

PRG008_A1DE:
	LDA Event_Countdown,X
	BEQ PRG008_A1E6	 ; If counter is = 0, jump to PRG008_A1E6

	DEC Event_Countdown,X	 ; Otherwise, decrement it!

PRG008_A1E6:
	DEX		 ; X--
	BPL PRG008_A1DE	 ; While X >= 0, loop!

	LDA Level_PSwitchCnt
	BEQ PRG008_A20C	 ; If Level_PSwitchCnt = 0 (P-Switch not active), jump to PRG008_A20C

	CMP #$01
	BNE PRG008_A203	 ; If Level_PSwitchCnt <> 1, jump to PRG008_A203

	LDY #$0A	 ; Y = $0A (Invincibility song)

	LDA Player_StarInv
	CMP #$20
	BGE PRG008_A1FE	 ; If Player_StarInv >= $20, jump to PRG008_A1FE

	LDY Level_MusicQueueRestore	 ; Y = regular BGM

PRG008_A1FE:
	LDA Objects_State+5
	CMP #OBJSTATE_DEADEMPTY
	BEQ PSw_RestoreMusOK	; If slot 5 doesn't have anything (let alone a Coin Snake), jump to PSw_RestoreMusOK

	; Something in slot 5...
	LDA Level_ObjectID+5
	CMP #OBJ_COINSNAKE
	BEQ PRG008_A203		; If Coin Snake is still active, can't restore music yet, jump to PRG008_A203

PSw_RestoreMusOK:
	STY Sound_QMusic2 ; Restore appropriate music
	BNE PRG008_A209	 ; If Level_PSwitchCnt > 0, jump to PRG008_A209

PRG008_A203:
	LDA <Counter_1
	AND #$03	 ; Cap 0 - 3
	BNE PRG008_A20C	 ; If 1 - 3, jump to PRG008_A20C (RTS)

PRG008_A209:
	DEC Level_PSwitchCnt	 ; Level_PSwitchCnt--

PRG008_A20C:
	RTS		 ; Return


	; Just amounts to calling Player_Draw, but takes care of switching to page 29 and back
Player_Draw29:
	JMP_THUNKC 29, Player_Draw	 		; Draw Player


Player_DrawAndDoActions29:
	LDA #29
	JSR PRG008_ROM_Change_C000	; Change page @ C000 to 29

	LDA #$00	 
	STA Player_InPipe 		; Player_InPipe = 0

	JSR Player_DrawAndDoActions	; Draw Player and do actions (going to coin heaven, the airship intro, going through pipes, ...)

	INC Player_InPipe	 ; Player_InPipe = 1

PRG008_A224:

	; If Player did NOT enter a pipe, we jump here...

	; Pull return address (so we do NOT return to the original Player_DrawAndDoActions 
	; call, thus not setting Player_InPipe flag... seems like a stupid way to 
	; conditionalize that, but hey, I didn't program in the 80s...)
	PLA
	PLA

	LDA #0
	JMP PRG008_ROM_Change_C000	 ; Jump to PRG008_ROM_Change_C000 (switch C000 back to page 0 and return)


	; SB: Retooled this subroutine to be generic page changer
	; Formerly PChg_C000_To_29 and PChg_C000_To_0
PRG008_ROM_Change_C000:
	; Change page @ C000 to 'A'
	STA PAGE_C000
	JMP PRGROM_Change_C000


Level_Initialize:
	LDA <Player_XStart	
	BEQ PRG008_A242	 ; If Player_XStart = 0 (not yet initialized), jump to PRG008_A242
	RTS		 ; Return

PRG008_A242:
	JMP_THUNKC 30, Level_Initialize30


LevelJunction_PartialInit:
	LDA LevelPartialInit
	BEQ PRG008_A388	 ; If LevelPartialInit = 0, jump to PRG008_A388

	JSR_THUNKC 30, LevelJunction_PartialInit30

	; Pulls prior return address, meaning this function
	; will return to the caller's caller!
	PLA
	PLA

PRG008_A388:
	RTS		 ; Return

Event_Countdown_Init:
	; 0 = Not used, 1 = Up, 2 = Down, 3 = Right, 4 = Left
	; Ticks to initialize Event_Countdown
	.byte $00, $3F, $07, $20, $20

Yoshi_PipeSkip_Y:
	; Up, Down, Right, Left
	.byte -32, 16, 0, 0
	
Yoshi_PipeSkip_YHi:
	.byte $FF,  0, 0, 0

PRG008_A38E:

	; Common point for exiting and entering from pipe
	; and some other routines... (if Level_PipeMove = 0,
	; then clearly there's no pipe action going on)

	LDA Level_PipeMove
	BEQ PRG008_A3C9	 ; If Level_PipeMove = 0, jump to PRG008_A3C9 (RTS)

	; Queue pipe sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPIPE
	STA Sound_QPlayer

	LDA <Player_X	
	STA <Pipe_PlayerX	 ; Pipe_PlayerX = Player_X

	LDA <Player_Y
	AND #$F0
	STA <Pipe_PlayerY
	DEC <Pipe_PlayerY 	; Pipe_PlayerY = Player_Y aligned to nearest 16, minus 1

	LDA Level_7Vertical
	BNE PRG008_A3B6	 	; If level is vertical, jump to PRG008_A3B6
	
	; For non-vertical levels...
	LDA <Vert_Scroll
	STA Level_VertScroll	; Level_VertScroll = Vert_Scroll

	LDA <Vert_Scroll_Hi
	STA Level_VertScrollH	; Level_VertScrollH = Vert_Scroll_Hi

PRG008_A3B6:
	LDA Level_PipeExitDir
	BNE PRG008_A3C0	 	; If Level_PipeExitDir <> 0, jump to PRG008_A3C0

	LDA #$02	 
	STA Level_PipeExitDir	 ; If Level_PipeExitDir is not set, assume we're coming out the bottom

PRG008_A3C0:
	AND #$0f	 ; Ensure Level_PipeExitDir is capped (note, though, only 0-3 is valid)
	TAY		 
	LDA Event_Countdown_Init,Y
	STA Event_Countdown	 ; Event_Countdown = Event_Countdown_Init[Y]

	LDA Player_Kuribo
	BEQ PRG008_A3C9		; If Player is not on Yoshi, jump to PRG008_A3C9
	
	; Yoshi is too much trouble to fix for pipe junctions, so we'll just skip the transition
	LDA #1
	STA Event_Countdown
	
	LDA Player_Y
	ADD Yoshi_PipeSkip_Y-1,Y
	STA Player_Y
	LDA Player_YHi
	ADC Yoshi_PipeSkip_YHi-1,Y
	STA Player_YHi

PRG008_A3C9:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Update
;
; Responsible for ALL of the magic; does everything
; needed to make a functional Player object!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Update:

	; SB: Added junction request so that the Touch Warp
	; Special Object doesn't execute junction at a bad
	; time (from that location caused only a half-jct)
	LDA Level_JctCtl_Req
	BEQ Player_Update_JctCtl_Req_NoReq	; If we don't have a Level Junction request, jump to Player_Update_JctCtl_Req_NoReq

	; Otherwise, queue it!
	STA Level_JctCtl

	; Clear it!
	LDA #0
	STA Level_JctCtl_Req

Player_Update_JctCtl_Req_NoReq:
	LDA Player_QueueSuit
	BEQ PRG008_A3FA	 ; If we don't have a suit change queued, jump to PRG008_A3FA

	CMP #$0f
	BLS PRG008_A3EC	 ; If Player_QueueSuit < $0F (statue enable), jump to PRG008_A3EC

	CMP #$80
	BNE PRG008_A3DC	 ; If Player_QueueSuit <> $80 (Kuribo's shoe), jump to PRG008_A3DC

	; Kuribo's shoe enable!
	INC Player_Kuribo	; Set the Player_Kuribo flag
	BNE PRG008_A3F2	 ; Jump (expectedly always) to PRG008_A3F2

PRG008_A3DC:
	CMP #$40
	BEQ PRG008_A3E7	 ; If Player_QueueSuit = $40 (make a splash), jump to PRG008_A3E7

	LDA #$c0
	STA Player_Statue	; Player_Statue = $C0
	BNE PRG008_A3F2	 	; Jump (technically always) to PRG008_A3F2

PRG008_A3E7:
	INC Player_InWater	; Set "in water" flag
	BNE PRG008_A3F2	 	; Jump (technically always) to PRG008_A3F2

PRG008_A3EC:
	; Suit queue
	AND #$0f
	TAY	
	DEY		 ; Y = Player_QueueSuit - 1
	STY <Player_Suit ; Store into Player_Suit

PRG008_A3F2:
	LDA #$00
	STA Player_QueueSuit	  ; Clear Player_QueueSuit

	JSR Level_SetPlayerPUpPal ; Set power up's correct palette

PRG008_A3FA:
	LDA <Player_IsDying
	ORA Player_HaltTick
	BNE PRG008_A472_fix	 ; If gameplay is halted by Player_HaltTicks OR Player is dying, jump to PRG008_A472

	; Non-halted gameplay normal flow...

	LDA Level_GetWandState
	CMP #$03
	BGS PRG008_A472_fix 	; If Level_GetWandState >= 3 (got the wand!), jump to PRG008_A472

	; SB: Reverse gravity will actually kill if you're off the top instead
	LDA Player_ReverseGrav
	BNE Player_FallAndDie_Rev

	LDA Player_AboveTop
	BNE PRG008_A427_fix	 ; If Player_AboveTop <> 0 (Player is above the top of screen), jump to PRG008_A427

	; "Fall in a pit and die"!
	LDA <Player_SpriteY
	AND #$F0
	CMP #$c0
	BNE PRG008_A427_fix	 ; If Player_SpriteY < $C0 && Player_SpriteY > $CF, jump to PRG008_A427

Player_FellAndDied:
	; Fell in a pit and died
	LDA #PLAYERSUIT_SMALL
	STA <Player_Suit ; Player_Suit = PLAYERSUIT_SMALL

	JSR Player_Die	 ; Begin death sequence

	LDX Player_Current
	LDA Player_Lives,X
	BNE Player_PitNoGO
	
	LDA #4
	STA <Player_IsDying
	BNE PRG008_A472_fix
	
Player_PitNoGO:
	; This jumps the initial part of the death sequence
	LDA #$c0
	STA Event_Countdown ; Event_Countdown = $C0
	LDA #$02
	STA <Player_IsDying	; Player_IsDying = 2 (already dropped off screen)

PRG008_A472_fix:
	JMP PRG008_A472
PRG008_A427_fix:
	JMP PRG008_A427


Player_FallAndDie_Rev:
	; If Player is off top of screen in reverse gravity, that's potentially death!
	LDA Player_AboveTop
	BEQ PRG008_A427

	LDA <Player_SpriteY
	AND #$F0
	CMP #$E0
	BNE PRG008_A427	 ; If Player_SpriteY < $E0 && Player_SpriteY > $EF, jump to PRG008_A427
	BEQ Player_FellAndDied

PRG008_A427:
	LDA Debug_Flag
	CMP #$80
	BEQ PRG008_A45A	 ; If debug mode is enabled, jump to PRG008_A45A

	LDA Level_TimerEn
	AND #$7f
	BNE PRG008_A472	 ; If the clock is disabled, jump to PRG008_A472

	LDA Level_TimerMSD
	ORA Level_TimerMid
	ORA Level_TimerLSD
	BNE PRG008_A45A	 ; If there's some sort of time left, jump to PRG008_A45A

	; TIME UP!
	JSR Player_Die	 ; Begin death sequence

	LDA #$03
	STA <Player_IsDying	 ; Player_IsDying = 3 (Death due to TIME UP)


	LDA #$ff
	STA <Pipe_PlayerX ; Pipe_PlayerX = $FF
	STA <Pipe_PlayerY ; Pipe_PlayerY = $FF

PRG008_A44D:
	LDA #$01	 
	STA Player_QueueSuit	 ; Queue change to small (superfluous, Player_Die sets it to 1)

	LDA #$50	 ; Event_Countdown to be set to $50

	STA Event_Countdown
	JMP PRG008_A472	 	; Jump to PRG008_A472

PRG008_A45A:
	; Still have time left OR in debug mode...

	LDA <Player_SpriteX
	CMP #$f8
	BLT PRG008_A472	 ; Intended meaning: If Player_SpriteX > -8, jump to PRG008_A472

	; Player_SpriteX has been pushed too far left! Assumed crushed!
	; (Except in Vertical levels or if the level was completed)

	LDA Level_7Vertical
	ORA Player_EndLevel
	BNE PRG008_A472	 ; If either a vertical level or the level was completed, jump to PRG008_A472

	; Player was crushed!

	JSR Player_Die	 ; Begin death sequence
	
	LDA #$01
	STA <Player_IsDying	 ; Player_IsDying = 1 (superfluous, Player_Die sets it to 1)

	JMP PRG008_A44D	 ; Jump to PRG008_A44D

PRG008_A472:
	; The following are always called, dead or alive...

	JSR Player_DrawAndDoActions29	; Draw Player and perform reactions to various things (coin heaven, pipes, etc lots more)
	JSR Player_Control	 		; Controllable actions
	JSR Player_PowerUpdate	 	; Update "Power Meter"
	JSR Player_DoScrolling	 	; Scroll relative to Player against active rules
	JSR AScrlURDiag_HandleWrap 	; Handle the diagonal autoscroller wrapping
	JSR Player_DetectSolids		; Handle solid tiles, including slopes if applicable
	JSR Player_TailAttack_HitBlocks	; Do Tail attack against blocks
	JSR Player_DoSpecialTiles	; Handle unique-to-style tiles!
	JSR Player_DoVibration		; Shake the screen when required to do so!
	;JSR Player_SetSpecialFrames	; Set special Player frames
	;JSR Player_Draw29	 	; ... and if you get through all that, draw the Player!!
	JSR_THUNKC 29, Player_SetSpecialFramesAndDraw	; SB: Combined above two
	
	LDA #$00
	STA Player_XVelAdj	 ; Player_XVelAdj = 0

	RTS		 ; Return

	; Simple function which updates the "Shake" effect from something heavy
Player_DoVibration:
	LDA Level_Vibration	 
	BEQ PRG008_A4BE		; If level is NOT vibrating, jump to PRG008_A4BE

	JMP_THUNKC 29, Player_DoVibration29

PRG008_A4BE:
	STA Vert_Scroll_Off	 ; Update Vert_Scroll_Off
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_PowerUpdate
;
; Handles updating the "Power Meter" as appropriate,
; and plays the annoying "ringing" noise :)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_PowerUpdate:
	JMP_THUNKC 29, Player_PowerUpdate29

	
	; SB: Pushed out into bank 30 to make room
Level_SetPlayerPUpPal:

	JMP_THUNKC 30, Level_SetPlayerPUpPal30


	; This is the main value of X acceleration applied
Player_XAccelMain:

	; F = "Friction" (stopping rate), "N = "Normal" accel, S = "Skid" accel, X = unused
	; Without B button	With B button
	;      F   N   S   X     F   N   S   X
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Small
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Big
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Fire
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Leaf
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Penguin
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Rabbit
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Hammer

Player_XAccelMain_UW:
	; If on the ground	If swimming above the ground
	.byte -1,  1,  1,  0, 	-1,  0,  0,  0

	.byte -1,  0,  0,  0, 	-1,  0,  1,  0
	.byte -1,  0,  0,  0, 	-1,  0,  0,  0


	; The following values are added to the "Counter_Wiggly"
	; value in an attempt to push the likelihood of a carry
	; which gives just a slight boost to the Player's X
	; velocity acceleration; way of making it sort of a
	; fractional increase while he moves...
Player_XAccelPseudoFrac:

	; F = "Friction" (stopping rate), "N = "Normal" accel, S = "Skid" accel, X = unused
	; Without B button		With B button
	;       F    N    S    X          F    N    S    X
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Small
	.byte $20, $E0, $00, $00,	$20, $E0, $00, $00	; Big
	.byte $20, $E0, $00, $00, 	$20, $E0, $00, $00	; Fire
	.byte $20, $E0, $00, $00, 	$20, $E0, $00, $00	; Leaf
	.byte $20, $E0, $00, $00, 	$20, $E0, $00, $00	; Penguin
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Rabbit
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Hammer

Player_XAccelPseudoFrac_UW:
	; If on the ground		If swimming above the ground
	.byte $30, $00, $00, $00, 	$E0, $30, $80, $00

	.byte $A0, $E0, $C0, $00, 	$A0, $E0, $20, $00
	.byte $D0, $E0, $60, $00, 	$D0, $E0, $C0, $00

	.byte $10, $F0


	; Maximum tick count for walking animation tick counter
	; (i.e. what tick value to reach to go to next anim frame)
Player_WalkAnimTickMax:
	; 0-15 POSSIBLE, but only 0-7 defined (due to game's max X vel of $38)
	; Index is Player_XVel >> 3
	.byte $07, $06, $05, $04, $03, $02, $01, $01, $01	; Lower number = faster animation


	; Based on how fast Player is running, the jump is
	; increased just a little (this is subtracted, thus
	; for the negative Y velocity, it's "more negative")
Player_SpeedJumpInc:	.byte $00, $02, $04, $08



	; Bit which must be set in FloatLevel_PlayerWaterStat to override 
	; system and assume that we're underwater no matter what tile detected
FloatLevel_StatCheck:
	.byte $40, $80


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_CheckIfTileUnderwater
;
; This checks if the given tile in Temp_Var1/2 (depending on 'X')
; is "underwater", based on Temp_Var3 (Level_TilesetIdx << 2) and
; the tile's "quadrant", which index "Level_MinTileUWByQuad"
;
; The result can be overridden if the proper bit in 
; FloatLevel_PlayerWaterStat is set, which will force the
; report to say underwater...
;
; CARRY: The "carry flag" will be set and the input tile not
; otherwise tested if the tile is in the "solid floor" region!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_CheckIfTileUnderwater:
	
	; X = 0 or 1

	LDY #$01
	STY <Temp_Var15	 ; Temp_Var15 = 1 (Indicates underwater)

	; UNDERWATER OVERRIDE (for "floating" levels that have fixed water at the bottom)
	LDA FloatLevel_PlayerWaterStat
	AND FloatLevel_StatCheck,X
	BNE PRG008_A6A8	 ; If bit is set, jump to PRG008_A6A8

	; SB: Ghost house override; no tiles in $E2+ will be "underwater"
	LDA Level_TilesetIdx
	CMP #4
	BNE Player_NotGHUWChk	; If this is not a Ghost House, jump to Object_NotGHUWChk

	; Check for any $E2+ range tiles
	LDA <Temp_Var1,X
	CMP #$E2
	BGE Player_ForceNoWater	; If tile >= $E2+, jump to Player_ForceNoWater

Player_NotGHUWChk:
	LDA <Temp_Var1,X
	ASL A
	ROL A
	ROL A
	AND #$03
	TAY		 ; Y = Quadrant of tile (i.e. 0-3 for $00, $40, $80, $C0)

	LDA <Temp_Var1,X
	CMP Tile_AttrTable,Y
	BGE PRG008_A6A9	 ; If tile is solid floor, jump to PRG008_A6A9 (RTS)

	CMP #TILEA_PSWITCH_PRESSED
	BNE PRG008_A68D	 ; If tile is not the pressed P-Switch, jump to PRG008_A68D

Player_ForceNoWater:
	LDY #$00	 ; Y = 0
	BEQ PRG008_A6A6	 ; Jump (technically always) to PRG008_A6A6

PRG008_A68D:

	; Temp_Var3 is (Level_TilesetIdx << 2), which is OR'ed into 'Y' here
	; So the value is expected to be in the range of 0 to (4 * 15) = 60
	; Basically there are 4 values per tileset, one for each tile quadrant 
	TYA
	ORA <Temp_Var3
	TAY

	; Get the minimum tile value for this quadrant which is considered
	; underwater (NOTE: If there are no underwater tiles in this quadrant,
	; the mostly unreachable value of $FF is what we get here)
	LDA Level_MinTileUWByQuad,Y

	LDY #$00	 ; Y = 0 (Not under water)

	CMP <Temp_Var1,X 
	BGE PRG008_A6A6	 ; If the starting underwater tile is greater than the detected tile, jump to PRG008_A6A6

	; Otherwise...

	INY		 ; Y = 1 (Underwater)

	LDA <Temp_Var1,X

	CMP #TILE1_WFALLTOP
	BEQ PRG008_A6A5	 ; If tile is the top of the waterfall, jump to PRG008_A6A5

	CMP #TILE1_WFALLMID
	BNE PRG008_A6A6	 ; If tile is NOT the middle part of the waterfall, jump to PRG008_A6A6

PRG008_A6A5:
	INY		 ; Y = 2 (In waterfall)

PRG008_A6A6:
	STY <Temp_Var15	 ; Store Y -> Temp_Var15 (0, 1, or 2)

PRG008_A6A8:
	CLC		 ; Clear carry (tile was not in the solid floor region)

PRG008_A6A9:
	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Control
;
; Pretty much all controllable Player actions like ducking,
; sliding, tile detection response, doors, vine climbing, and 
; including basic power-up / suit functionality (except the actual 
; throwing of fireballs / hammers for some reason!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Control:
	LDA <Player_FlipBits
	STA Player_FlipBits_OLD

	LDA <Player_InAir
	STA Player_InAir_OLD

	LDA Player_EndLevel
	BNE PRG008_A6D2	 ; If Player is running off at the end of the level, jump to PRG008_A6D2

	LDA Player_VibeDisable
	BEQ PRG008_A6DA	 	; If Player is not "vibrationally disabled", jump to PRG008_A6DA

	DEC Player_VibeDisable	 ; Otherwise Player_VibeDisable--

PRG008_A6D2:

	; Remove horizontal velocity and cancel controller inputs
	LDA #$00	
	STA <Player_XVel
	STA <Pad_Holding
	STA <Pad_Input	

PRG008_A6DA:
	LDA Player_Slide
	BEQ PRG008_A6E5	 	; If Player is NOT sliding down slope, jump to PRG008_A6E5

	LDA <Pad_Input
	AND #~PAD_B
	STA <Pad_Input		; Otherwise, disable 'B' button

PRG008_A6E5:
	LDA Level_Objects+1
	;CMP #OBJ_TOADANDKING
	;BNE PRG008_A6F2	 	; If first object is not "Toad and the King" (i.e. we're in the end of world castle), jump to PRG008_A6F2

	;LDA <Pad_Holding
	;AND #~(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	;STA <Pad_Holding	; Otherwise, disable all directional inputs

;PRG008_A6F2:
	LDY <Player_Suit
	BEQ PRG008_A70E	 	; If Player is small, jump to PRG008_A70E

	;CPY #PLAYERSUIT_PENGUIN
	;BEQ PRG008_A70E	 	; If Player is Penguin, jump to PRG008_A70E

	LDA Player_IsHolding
	ORA Player_Slide
	ORA Player_Kuribo
	BNE PRG008_A70E	 	; If Player is holding something, sliding down a slope, or in a Kuribo's shoe, jump to PRG008_A70E 

	LDA <Player_InAir
	BEQ PRG008_A71C	 	; If Player is NOT mid air, jump to PRG008_A71C

	LDA Player_InWater
	BEQ PRG008_A715	 	; If Player is NOT in water, jump to PRG008_A715

PRG008_A70E:
	; Forcefully disable any ducking
	LDA #$00
	STA Player_IsDucking	; Player_IsDucking = 0

	BEQ PRG008_A736	 	; Jump (technically always) to PRG008_A736

PRG008_A715:
	LDA Player_IsDucking
	BNE PRG008_A733	 	; If Player is ducking down, jump to PRG008_A733
	BEQ PRG008_A736	 	; Otherwise, jump to PRG008_A736

PRG008_A71C:
	LDA #$00
	STA Player_IsDucking	; Player_IsDucking = 0

	LDA Level_SlopeEn
	BEQ PRG008_A72B	 	; If slopes are not enabled, jump to PRG008_A72B

	LDA Player_SlideRate 
	BNE PRG008_A736	 	; If Player has a slide magnitude, jump to PRG008_A736

PRG008_A72B:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	CMP #PAD_DOWN
	BNE PRG008_A736	 	; If Player is not just holding down, jump to PRG008_A736

PRG008_A733:
	STY Player_IsDucking	; Set ducking flag (uses non-zero suit value)

PRG008_A736:
	LDY #20		 	; Y = 20 (ducking or small)

	LDA <Player_Suit 	
	BEQ PRG008_A743	 	; If Player is small, jump to PRG008_A743

	LDA Player_IsDucking
	BNE PRG008_A743	 	; If Player is ducking, jump to PRG008_A743

	LDY #10		 	; Otherwise, Y = 10 (not ducking, not small)

PRG008_A743:
	STY <Temp_Var10		; Temp_Var10 (Y offset) = 20 or 10

	LDA #$08
	STA <Temp_Var11		; Temp_Var11 (X offset) = 8

	JSR Player_GetTileAndSlope ; Get tile above Player

	STA Level_Tile_Head	 ; -> Level_Tile_Head
	STA <Temp_Var1		 ; -> Temp_Var1

	LDA Level_Tile_GndL	 ; Get left ground tilee
	STA <Temp_Var2		 ; -> Temp_Var2

	LDA Player_Behind	
	STA Player_Behind_En	; Default enable with being behind the scenes
	BEQ PRG008_A77E	 	; If Player is not behind the scenes, jump to PRG008_A77E

	; SB: No longer time limited

	;LDA <Counter_1
	;LSR A	
	;BCC PRG008_A766	 	; Every other tick, jump to PRG008_A766

	;DEC Player_Behind	; Player_Behind--

;PRG008_A766:
	LDY #$00	 ; Y = 0 (disable "behind the scenes")

	; If tile behind Player's head is $41 or TILE1_SKY, jump to PRG008_A77B
	LDA <Temp_Var1
	CMP #$41
	BEQ PRG008_A77B
	CMP #TILE2_BLACK	; SB: Supporting being behind the fence
	BEQ PRG008_A77B
	CMP #TILE1_SKY
	BEQ PRG008_A77B

	INY		 	; Y = 1 (enable "behind the scenes")

	LDA Player_Behind
	BNE PRG008_A77B	 	; If Player is behind the scenes, jump to PRG008_A77B

	STY Player_Behind	; Set Player as behind the scenes

PRG008_A77B:
	STY Player_Behind_En	; Store whether Player is actually behind scenery

PRG008_A77E:
	LDA <Temp_Var1
	AND #$c0
	ASL A
	ROL A
	ROL A
	TAY		 ; Y = uppermost 2 bits down by 6 (thus 0-3, depending on which "quadrant" of tiles we're on, $00, $40, $80, $C0)

	; Checks for solid tile at Player's head
	LDA <Temp_Var1	 
	CMP Tile_AttrTable+4,Y	; Wall/ceiling-solid tile quadrant limits begin at Tile_AttrTable+4
	BLT PRG008_A7AD	 ; If tile index is less than value in Tile_AttrTable (not solid for wall/ceiling), jump to PRG008_A7AD

	LDA <Player_InAir
	ORA Player_InWater
	ORA Level_PipeMove
	BNE PRG008_A7AD	 	; If Player is mid air, in water, or moving in a pipe, jump to PRG008_A7AD

	; Solid tile at Player's head; Player is stuck in a low clearance (or worse stuck in the wall!)

	; A is logically zero here...

	; Stop Player horizontally, disable controls
	STA <Player_XVel
	STA <Pad_Input

	;AND #~PAD_A
	;STA <Pad_Input	; ?? it's still zero?

	; Player_LowClearance = 1 (Player is in a "low clearance" situation!)
	LDA #$01
	STA Player_LowClearance

	; SB: This is too buggy, and I gave up on the shifting maze concept, so fuck it

	;LDX Level_AScrlSelect
	;CPX #4
	;BNE Player_NormalLowClearance	; If this is not the shifting maze, jump to Player_NormalLowClearance


	; For support of SMW-esque shifting levels, CRUSH Player, don't just slide!
	;LDA #0
	;STA <Player_Suit
	;JSR Player_GetHurt
	;JMP PRG008_A7AD

;Player_NormalLowClearance:
	; This makes the Player "slide" when he's in a space too narrow
	ADD <Player_X
	STA <Player_X	 ; Player_X += 1
	BCC PRG008_A7AD	 ; If not carry, jump to PRG008_A7AD
	INC <Player_XHi	 ; Otherwise, apply carry

PRG008_A7AD:

	; This will be used in Level_CheckIfTileUnderwater 
	; as bits 2-3 of an index into Level_MinTileUWByQuad
	LDA Level_TilesetIdx
	ASL A
	ASL A
	STA <Temp_Var3	 ; Temp_Var3 = Level_TilesetIdx << 2

	LDX #$00	; Checks Temp_Var1 for tile and $40 override bit in UNK_584
	JSR Level_CheckIfTileUnderwater

	; Carry is set by Level_CheckIfTileUnderwater if tile was in the
	; "solid floor" region regardless of being "underwater"
	BCS PRG008_A7BE	 ; If carry set (tile was in solid region), jump to PRG008_A7BE

	; 'Y' is the result of Level_CheckIfTileUnderwater:
	; 0 = Not under water, 1 = Underwater, 2 = Waterfall
	TYA		 
	BNE PRG008_A812	 ; If Y <> 0 (somehow under water), jump to PRG008_A812

PRG008_A7BE:

	; NOT underwater!

	LDA Player_InWater
	BEQ PRG008_A827	 ; If Player was not previously in water, jump to PRG008_A827

	LDA <Player_InAir
	BNE PRG008_A7CB	 ; If Player is mid air, jump to PRG008_A7CB

	; Player is NOT flagged as mid air...

	BCS PRG008_A827	 ; If tile was in the floor solid region, jump to PRG008_A827
	BCC PRG008_A80B	 ; If tile was NOT in the floor solid region, jump to PRG008_A80B

PRG008_A7CB:

	; Player is known as mid air!

	BCS PRG008_A7D1	 ; If tile was in floor solid region, jump to PRG008_A7D1

	LDA <Player_YVel
	BMI PRG008_A7E2	 ; If Player's Y velocity < 0 (moving upward), jump to PRG008_A7E2

PRG008_A7D1:

	; Player's Y velocity >= 0...
	; OR Player just hit a solid tile with the head

	ROR A		 ; The important concept here is to save the previous carry flag
	STA <Temp_Var16	 ; Temp_Var16 (most importantly) contains the previous carry flag in bit 7

	LDX #$01	 ; Checks Temp_Var2 for tile and $80 override bit in UNK_584
	JSR Level_CheckIfTileUnderwater

	BCS PRG008_A7DE	 ; If tile was in the floor solid region, jump to PRG008_A7DE

	TYA
	BEQ PRG008_A80B	 ; If Y = 0 (Not underwater), jump to PRG008_A80B

PRG008_A7DE:
	LDA <Temp_Var16
	BMI PRG008_A812	 ; If we had a floor solid tile in the last check, jump to PRG008_A812

	; Did NOT hit a solid floor tile with head last check

PRG008_A7E2:
	LDY <Player_YVel
	CPY #-$0C
	BGS PRG008_A7EA	 ; If Player_YVel >= -$0C, jump to PRG008_A7EA

	; Prevent Player_YVel from being less than -$0C
	LDY #-$0C

PRG008_A7EA:
	LDA <Counter_1
	AND #$07
	BNE PRG008_A7F1

	INY		 ; 1:8 chance velocity will be dampened just a bit

PRG008_A7F1:
	STY <Player_YVel ; Update Player_YVel

	LDA <Pad_Input
	AND #~PAD_A
	STA <Pad_Input	 ; Strip out 'A' button press

	LDA <Pad_Holding
	TAY		 ; Y = Pad_Holding

	AND #~PAD_UP
	STA <Pad_Holding ; Strip out 'Up'

	TYA		 ; A = original Pad_Holding
	AND #(PAD_UP | PAD_A)
	CMP #(PAD_UP | PAD_A)
	BNE PRG008_A827	 ; If Player is not pressing UP + A, jump to PRG008_A827

	; Player wants to exit water!
	LDA #-$34
	STA <Player_YVel ; Player_YVel = -$34 (exit velocity from water)

PRG008_A80B:

	; Player NOT marked as "in air" and last checked tile was NOT in the solid region
	; OR second check tile was not underwater

	LDY #$00	 
	STY Player_SwimCnt ; Player_SwimCnt = 0
	BEQ PRG008_A819	   ; Jump (technically always) to PRG008_A819

PRG008_A812:

	; Solid floor tile at head last check

	LDY <Temp_Var15
	CPY Player_InWater
	BEQ PRG008_A827	   ; If Player_InWater = Temp_Var15 (underwater flag = underwater status), jump to PRG008_A827

PRG008_A819:

	; Player's underwater flag doesn't match the water he's in...

	TYA
	ORA Player_InWater
	STY Player_InWater	; Merge water flag status
	CMP #$02	 
	BEQ PRG008_A827	 	; If it equals 2, jump to PRG008_A827

	JSR Player_WaterSplash	 ; Hit water; splash!

PRG008_A827:

	; Player not flagged as "under water"
	; Player not flagged as "mid air" and last checked tile was in solid region

	LDA <Player_FlipBits
	AND #%01111111	 
	STA <Player_FlipBits	 ; Clear vertical flip on sprite

	LDY Level_TilesetIdx	 ; Y = Level_TilesetIdx

	LDA #TILEA_DOOR2
	SUB <Temp_Var1	
	BEQ PRG008_A83F	 ; If tile is DOOR2's tile, jump to PRG008_A83F

	; Only fortresses and Ghost Houses can use DOOR1
	CPY #$04
	BEQ Door1_OK
	CPY #$01
	BNE PRG008_A86C	 ; If Level_TilesetIdx <> 1 (fortress style), jump to PRG008_A86C

Door1_OK:
	CMP #$01
	BEQ PRG008_A83F	 ; If tile is DOOR1, jump to PRG008_A83F

	; SB: Also the old "final door" is now a door door
	LDA #TILE2_ENDDOOR_LR
	SUB <Temp_Var1
	CMP #4
	BGE PRG008_A86C	; SB: If not one of the ex-final door tiles, jump to PRG008_A86C

PRG008_A83F:

	; DOOR LOGIC

	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BEQ PRG008_A86C	 ; If Purple Comet is active, jump to PRG008_A86C

	LDA <Pad_Input
	AND #PAD_UP
	BEQ PRG008_A86C	 ; If Player is not pressing up in front of a door, jump to PRG008_A86C

	LDA <Player_InAir
	BNE PRG008_A86C	 ; If Player is mid air, jump to PRG008_A86C

	; If Level_PipeNotExit is set, we use Level_JctCtl = 3 (the general junction)
	; Otherwise, a value of 1 is used which flags that pipe should exit to map

	LDY #$01	; Y = 1

	LDA Level_PipeNotExit
	BEQ PRG008_A852	 ; If pipe should exit to map, jump to PRG008_A852

	LDY #$03	 ; Otherwise, Y = 3

PRG008_A852:
	STY Level_JctCtl ; Set appropriate value to Level_JctCtl

	LDY #0
	STY Map_ReturnStatus	 ; Map_ReturnStatus = 0

	STY <Player_XVel	 ; Player_XVel = 0

	LDA <Player_X
	AND #$08
	BEQ PRG008_A864	 ; If Player is NOT halfway across door, jump to PRG008_A864

	LDY #16		 ; Otherwise, Y = 16

PRG008_A864:
	TYA	
	ADD <Player_X	 ; Add offset to Player_X if needed
	AND #$F0	 ; Lock to nearest column (place directly in doorway)
	STA <Player_X	 ; Update Player_X

PRG008_A86C:

	; VINE CLIMBING LOGIC

	LDA Player_InWater
	ORA Player_IsHolding
	ORA Player_Kuribo
	BNE PRG008_A890	 ; If Player is in water, holding something, or in Kuribo's shoe, jump to PRG008_A890

	LDA <Temp_Var1
	JSR CheckTile_IsClimbable
	BNE PRG008_A890	 ; If tile is not climbable, jump to PRG008_A890

	LDA Player_IsClimbing
	BNE PRG008_A898	 ; If climbing flag is set, jump to PRG008_A898

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_A890	 ; If Player is not pressing up or down, jump to PRG008_A890

	LDY <Player_InAir
	BNE PRG008_A898	 ; If Player is in the air, jump to PRG008_A898

	AND #PAD_UP
	BNE PRG008_A898	 ; If Player is pressing up, jump to PRG008_A898

PRG008_A890:
	LDA #$00
	STA Player_IsClimbing	 ; Player_IsClimbing = 0 (Player is not climbing)
	STA Player_ClimbJumpUpFlag	; Player_ClimbJumpUpFlag = 0 (player free to start climbing at any time)

	BEQ PRG008_A8F9	 ; Jump to PRG008_A8F9

PRG008_A898:
	LDA Player_ClimbJumpUpFlag
	BEQ Player_CJUF_NotSet	; If Player_ClimbJumpUpFlag is not set, jump to Player_CJUF_NotSet
	
	; Player_ClimbJumpUpFlag is set... but is Player falling now?
	LDA <Player_YVel
	BMI PRG008_A8F9		; Flag is set, player is not falling, jump to PRG008_A8F9 (not able to climb yet)
	
	; Player is falling; clear Player_ClimbJumpUpFlag and allow climbing!
	LDA #0
	STA Player_ClimbJumpUpFlag

Player_CJUF_NotSet:
	LDA #$01
	STA Player_IsClimbing	 ; Player_IsClimbing = 1 (Player is climbing)

	; Kill Player velocities
	LDA #$00
	STA <Player_XVel
	STA <Player_YVel

	LDY #$10 	; Y = $10 (will be Y velocity down if Player is pressing down)

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_A8CA	 ; If Player is not pressing up or down, jump to PRG008_A8CA

	; Player is pressing UP or DOWN...

	AND #PAD_UP
	BEQ PRG008_A8C8	 ; If Player is NOT pressing UP, jump to PRG008_A8C8

	; Player is pressing UP...

	LDY #16		; Y = 16

	LDA <Player_Suit
	BEQ PRG008_A8B7	 ; If Player is small, jump to PRG008_A8B7

	LDY #0	 	; Otherwise, Y = 0

PRG008_A8B7:
	STY <Temp_Var10	 ; Temp_Var10 = 16 or 0 (if small) (Y Offset for Player_GetTileAndSlope)

	LDA #$08
	STA <Temp_Var11	 ; Temp_Var11 = 8 (X Offset for Player_GetTileAndSlope)

	JSR Player_GetTileAndSlope	; Get tile

	JSR CheckTile_IsClimbable
	BNE PRG008_A8CA	 ; If tile is NOT another climbable tile, jump to PRG008_A8CA

	LDY #-$10
	STY <Player_InAir ; Flag Player as "in air"

PRG008_A8C8:
	STY <Player_YVel  ; Set Player's Y Velocity

PRG008_A8CA:
	LDY #$10	 ; Y = $10 (rightward X velocity)

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_A8DA	 ; If Player is NOT pressing LEFT or RIGHT, jump to PRG008_A8DA

	AND #PAD_LEFT
	BEQ PRG008_A8D8	 ; If Player is NOT pressing LEFT, jump to PRG008_A8D8

	LDY #-$10	 ; Y = -$10 (leftward X velocity)

PRG008_A8D8:
	STY <Player_XVel ; Set Player's X Velocity

PRG008_A8DA:
	LDA Player_IsClimbing
	BEQ PRG008_A8EC	 ; If Player is NOT climbing, jump to PRG008_A8EC

	; Player is climbing...
	
	LDA <Pad_Input
	BPL PlayerClimb_NotJumping	; If Player is not pressing 'A' while climbing, jump to PlayerClimb_NotJumping
	
	; Clear Player_IsClimbing and allow Player to jump!
	LDA #0
	STA Player_IsClimbing
	
	; Set Player_ClimbJumpUpFlag
	INC Player_ClimbJumpUpFlag
	
	JMP PRG008_AC41

PlayerClimb_NotJumping:
	LDA <Player_InAir
	BNE PRG008_A8EC	 ; If Player is in air, jump to PRG008_A8EC

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BNE PRG008_A8EC	 ; If Player is pressing UP or DOWN, jump to PRG008_A8EC

	STA Player_IsClimbing	 ; Set climbing flag

PRG008_A8EC:

	; Apply Player's X and Y velocity for the vine climbing
	JSR Player_ApplyXVelocity
	JSR Player_ApplyYVelocity

	JSR Player_DoClimbAnim	 ; Animate climbing
	JMP Player_Draw29	 ; Draw Player

PRG008_A8F9:

	; Player not climbing...

	LDA Player_SlideRate
	BEQ PRG008_A906	 ; If Player sliding rate is zero, jump to PRG008_A906

	; Otherwise, apply it
	LDA <Player_XVel
	ADD Player_SlideRate
	STA <Player_XVel

PRG008_A906:
	JSR Player_ApplyXVelocity	 ; Apply Player's X Velocity

	LDA Player_SlideRate	 
	BEQ PRG008_A916	 ; If Player is not sliding, jump to PRG008_A916

	; Otherwise, apply it AGAIN
	LDA <Player_XVel
	SUB Player_SlideRate
	STA <Player_XVel

PRG008_A916:

	LDA #$00
	STA Player_SlideRate	 ; Player_SlideRate = 0 (does not persist)

	LDY #$02	 ; Y = 2 (moving right)

	LDA <Player_XVel
	BPL PRG008_A925	 ; If Player's X Velocity is rightward, jump to PRG008_A925

	JSR Negate	 ; Negate X Velocity (get absolute value)

	DEY		 ; Y = 1 (moving left)

PRG008_A925:
	BNE PRG008_A928	 ; If Player's X Velocity is not zero (what is intended by this check), jump PRG008_A928

	; Player's velocity is zero
	TAY		 ; And thus, so is Y (not moving left/right)

PRG008_A928:
	STA <Temp_Var3	 ; Temp_Var3 = absolute value of Player's X Velocity

	STY Player_MoveLR	; Set Player_MoveLR appropriately
 
	LDA <Player_InAir
	BEQ PRG008_A940	 ; If Player is not mid air, jump to PRG008_A940

	LDA <Player_YHi
	BPL PRG008_A93D	 ; If Player is on the upper half of the screen, jump to PRG008_A93D

	; Player is mid air, lower half of screen...

	LDA <Player_Y
	BMI PRG008_A93D	 ; If Player is beneath the half point of the lower screen, jump to PRG008_A93D

	LDA <Player_YVel
	BMI PRG008_A940	 ; If Player is moving upward, jump to PRG008_A940

PRG008_A93D:
	LDA Level_7Vertical
	BNE Player_YVelOK		; If level is vertical, jump to Player_YVelOK
	LDA Player_ReverseGrav
	BEQ Player_YVelOK		; If Player's gravity is not reversed, jump to Player_YVelOK

	LDA <Player_YVel
	BPL Player_YVelOK
	
	; Limit check to keep player from going too low which causes funkiness in scrolling
	LDA <Player_YHi
	CMP #1
	BLT Player_YVelOK	; If YHi <> 1, Player can't be too low, jump to Player_YVelOK

	LDA <Player_Y
	AND #$F0
	CMP #$E0
	BGE PRG008_A940
	
Player_YVelOK:
	JSR Player_ApplyYVelocity	 ; Apply Player's Y velocity
	
PRG008_A940:
	JSR Player_CommonGroundAnims	 ; Perform common ground animation routines

	; SB: Not doing Kuribo's shoe special logic this way...

	;LDA Player_Kuribo
	;BEQ PRG008_A94C	 ; If Player is not wearing Kuribo's shoe, jump to PRG008_A94C

	; If in Kuribo's shoe...

	;LDA #14		 ; A = 14 (Kuribo's shoe code pointer)
	;BNE PRG008_A956	 ; Jump (technically always) to PRG008_A956

;PRG008_A94C:
	LDA <Player_Suit

	LDY Player_InWater
	BEQ PRG008_A956	 ; If Player is not under water, jump to PRG008_A956

	ADD #$07	 ; Otherwise, add 7 (underwater code pointers)

PRG008_A956:
	ASL A		 ; 2-byte pointer
	TAY		 ; -> Y

	; MOVEMENT LOGIC PER POWER-UP / SUIT

	; NOTE: If you were ever one to play around with the "Judgem's Suit"
	; glitch power-up, and wondered why he swam in the air and Kuribo'ed
	; in the water, here's the answer!


	; Get proper movement code address for power-up 
	; (ground movement, swimming, Kuribo's shoe)
	LDA PowerUpMovement_JumpTable,Y
	STA <Temp_Var1
	LDA PowerUpMovement_JumpTable+1,Y
	STA <Temp_Var2

	LDA #0
	STA Player_DebugNoHitFlag
	LDA Debug_Flag
	CMP #$80
	BNE PUM_NoFreeMove

	LDY Player_Current
	LDA Controller1,Y
	AND #PAD_SELECT
	BEQ PUM_NoFreeMove
	
	JSR_THUNKC 30, Debug_FreeMovement

PUM_NoFreeMove:
	JMP [Temp_Var1]	 ; Jump into the movement code!

PowerUpMovement_JumpTable:
	; Ground movement code
	.word GndMov_Small	; 0 - Small
	.word GndMov_Big	; 1 - Big
	.word GndMov_FireHammer	; 2 - Fire
	.word GndMov_Leaf	; 3 - Leaf
	.word GndMov_Penguin	; 4 - Penguin
	.word GndMov_Rabbit	; 5 - Rabbit
	.word GndMov_FireHammer	; 6 - Hammer

	; Underwater movement code
	.word Swim_SmallBigLeaf	; 0 - Small
	.word Swim_SmallBigLeaf	; 1 - Big
	.word Swim_FireHammer	; 2 - Fire
	.word Swim_SmallBigLeaf	; 3 - Leaf
	.word Swim_Penguin		; 4 - Penguin
	.word Swim_Rabbit	; 5 - Rabbit
	.word Swim_FireHammer	; 6 - Hammer

	; Kuribo's shoe
	;.word Move_Kuribo


GndMov_Small:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_YoshiMove	   ; Update Yoshi

	LDA Player_SandSink
	LSR A		 
	BCS PRG008_A9A3	 ; If bit 0 of Player_SandSink was set, jump to PRG008_A9A3 (RTS)

	LDA Player_AllowAirJump
	BNE PRG008_A9A3	 ; If Player_AllowAirJump, jump to PRG008_A9A3 (RTS)

	LDA <Player_InAir
	BEQ PRG008_A9A3	 ; If Player is not mid air, jump to PRG008_A9A3 (RTS)

	; Player is mid-air...

	LDA #PF_JUMPFALLSMALL	; Standard jump/fall frame

	LDY Player_FlyTime
	BEQ PRG008_A9A1	 ; If Player_FlyTime = 0, jump to PRG008_A9A1

	LDA #PF_FASTJUMPFALLSMALL	 ; High speed jump frame

PRG008_A9A1:
	STA <Player_Frame ; Set appropriate frame

PRG008_A9A3:
	RTS		 ; Return


	; Use: BEQ if is climbable, BNE is not climbable
CheckTile_IsClimbable:
	PHA		; Save input

	LDA Level_Tileset
	CMP #2
	BNE VineClimb_NotFort	; If tileset <> 2 (Fortress), jump to VineClimb_NotFort
	
	; Fortress only -- SB: NEW climb the hanging globe thing
	PLA		; Restore tile
	PHA		; Save again (in case we need it)
	SUB #TILE2_HANGGLOBE_TOP
	CMP #2
	BLT VineClimb_FortOverride	; If this is the hanging globe chain or connector tile, jump to VineClimb_FortOverride
	
	PLA		; Restore tile
	PHA		; Save again (in case we need it)
	SUB #TILE2_FENCE_UL
	CMP #(TILE2_FENCE_LR - TILE2_FENCE_UL + 1)
	BLT VineClimb_FortOverride	; If this is a fence tile, jump to VineClimb_FortOverride
	
VineClimb_NotFort:
	PLA		; Restore tile
	CMP #TILE1_VINE
	RTS
	
VineClimb_FortOverride:
	PLA		; Discard
	LDA #0
	RTS


Swim_SmallBigLeaf:
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	JMP Player_YoshiMove	   ; Update Yoshi

GndMov_Big:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	JMP Player_YoshiMove	   ; Update Yoshi

GndMov_FireHammer:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	JSR Player_ShootAnim ; Do Player shooting animation
	JMP Player_YoshiMove	   ; Update Yoshi

Swim_FireHammer:
	LDA Player_Kuribo
	BNE Swim_SmallBigLeaf	; If Player is on Yoshi, do normal swimming

	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	JSR Player_ShootAnim ; Do Player shooting animation
	JMP Player_YoshiMove	   ; Update Yoshi

GndMov_Leaf:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_AnimTailWag ; Do Player's tail animations
	JSR Player_TailAttackAnim ; Do Player's tail attack animations
	JMP Player_YoshiMove	   ; Update Yoshi

GndMov_Penguin:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag

	; RAS
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	JSR Player_ShootAnim ; Do Player shooting animation
	JMP Player_YoshiMove	   ; Update Yoshi

Penguin_SwimSoundMask:
	.byte $07, $07

	; Base frame for the different swimming directions of the penguin
Penguin_BaseFrame:
	; Down, Up, Left/Right
	.byte PF_PENGUINSWIM_DOWNBASE, PF_PENGUINSWIM_UPBASE, PF_PENGUINSWIM_LRBASE

	; Frame offset to frames above
Penguin_FrameOffset:
	.byte $02, $02, $02, $01, $00, $01, $02, $02

	; Base velocity for penguin swim right/down, left/up
Penguin_Velocity:
	.byte 16, -16

Swim_Penguin:
	LDA Player_EndLevel
	BEQ Swim_Penguin_Normal

	; Force Player to swim down!
	LDA #(PAD_DOWN | PAD_A)
	STA <Pad_Holding
	BNE Player_EndLevel_SwimForce

Swim_Penguin_Normal:
	LDA Player_Kuribo
	BNE Swim_SmallBigLeaf	; If Player is on Yoshi, do normal swimming

	LDX #$ff	 ; X = $FF

Player_EndLevel_SwimForce:
	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_AA61	 ; If Player is NOT pressing up/down, jump to PRG008_AA61

	; 
	STA <Player_InAir

	LSR A
	LSR A
	LSR A
	TAX		 ; X = 1 if pressing up, else 0

	LDA Penguin_Velocity,X	; Get base penguin velocity
	BPL PRG008_AA4D	 ; If value >= 0 (if pressing down), jump to PRG008_AA4D

	LDY Player_AboveTop
	BPL PRG008_AA4D	 ; If Player is not off top of screen, jump to PRG008_AA4D

	LDA #$00	 ; A = 0

PRG008_AA4D:
	LDY <Pad_Holding
	BPL PRG008_AA52	 ; If Player is not pressing 'A', jump to PRG008_AA52

	ASL A		 ; Double vertical speed

PRG008_AA52:
	CMP #(PLAYER_PENGUIN_MAXYVEL+1)
	BLT PRG008_AA5C	 

	LDY <Player_InAir
	BNE PRG008_AA5C	 ; If Player is swimming above ground, jump to PRG008_AA5C

	LDA #PLAYER_PENGUIN_MAXYVEL	 ; Cap swim speed

PRG008_AA5C:
	STA <Player_YVel ; Set Y Velocity
	JMP PRG008_AA6E	 ; Jump to PRG008_AA6E

PRG008_AA61:
	LDY <Player_YVel
	BEQ PRG008_AA6E	 ; If Y Velocity = 0, jump to PRG008_AA6E

	INY		 ; Y++

	LDA <Player_YVel
	BMI PRG008_AA6C	 ; If Player_YVel < 0, jump to PRG008_AA6C

	DEY
	DEY		 ; Y -= 2

PRG008_AA6C:
	STY <Player_YVel ; Update Y Velocity

PRG008_AA6E:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_AA84	 ; If Player is not pressing left or right, jump to PRG008_AA84

	; Player is pressing left/right...

	LSR A
	TAY
	LDA Penguin_Velocity,Y	; Get base penguin velocity

	LDY <Pad_Holding
	BPL PRG008_AA7E	 ; If Player is not pressing 'A', jump to PRG008_AA7E

	ASL A		 ; Double horizontal velocity

PRG008_AA7E:
	STA <Player_XVel ; Update X Velocity

	LDX #$02	 ; X = 2
	BNE PRG008_AA9C	 ; Jump (technically always) to PRG008_AA9C

PRG008_AA84:
	LDY <Player_XVel
	BEQ PRG008_AA94	 ; If Player is not moving horizontally, jump to PRG008_AA94

	INY		 ; Y++

	LDA <Player_XVel
	BMI PRG008_AA8F	 ; If Player_XVel < 0, jump to PRG008_AA8F

	DEY
	DEY		 ; Y -= 2

PRG008_AA8F:
	STY <Player_XVel ; Update X Velocity
	JMP PRG008_AA9C	 ; Jump to PRG008_AA9C

PRG008_AA94:
	LDA <Player_InAir
	BNE PRG008_AA9C	 ; If Player is swimming above ground, jump to PRG008_AA9C

	LDA #$15	 ; A = $15
	BNE PRG008_AAD2	 ; Jump (technically always) to PRG008_AAD2

PRG008_AA9C:
	TXA		 
	BMI PRG008_AAC8	 ; If X < 0, jump to PRG008_AAC8

	LDA <Counter_1
	LSR A
	LSR A

	LDY #$00	 ; Y = 0

	BIT <Pad_Holding
	BMI PRG008_AAAB	 ; If Player is holding 'A', jump to PRG008_AAAB

	LSR A		 ; Otherwise, reduce velocity adjustment
	INY		 ; Y++

PRG008_AAAB:
	AND #$07
	TAY	
	BNE PRG008_AABF	

	LDA <Counter_1
	AND Penguin_SwimSoundMask,Y
	BNE PRG008_AABF	 ; If timing is not right for penguin swim sound, jump to PRG008_AABF

	; Play swim sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

PRG008_AABF:
	LDA Penguin_BaseFrame,X
	ADD Penguin_FrameOffset,Y
	BNE PRG008_AAD2

PRG008_AAC8:
	LDY #PF_PENGUINSWIM_IDLEBASE

	LDA <Counter_1
	AND #$08
	BEQ PRG008_AAD1

	INY

PRG008_AAD1:
	TYA

PRG008_AAD2:
	STA <Player_Frame ; Update Player_Frame
	RTS		 ; Return

GndMov_Rabbit:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_AnimTailWag ; Do Player's tail animations
	JMP Player_YoshiMove	   ; Update Yoshi

Swim_Rabbit:
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	JMP Player_YoshiMove	   ; Update Yoshi

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GroundHControl
;
; Routine to control based on Player's left/right pad input (not
; underwater); configures walking/running
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Table of values that have to do with Player_UphillSpeedIdx override
Player_UphillSpeedVals:
	.byte $00, $16, $15, $14, $13, $12, $11, $10, $0F, $0E, $0D

Player_GroundHControl:
	LDA Player_UphillFlag
	BEQ PRG008_AB56	 ; If Player is not going up hill, jump to PRG008_AB56

	INC Player_WalkAnimTicks	; Player_WalkAnimTicks++

	LDY #10	 ; Y = 10 (Player NOT holding B)

	BIT <Pad_Holding
	BVC PRG008_AB5B	 ; If Player is NOT holding 'B', jump to PRG008_AB5B

	LDY #1	 ; Y = 1 (Player holding B)
	BNE PRG008_AB5B	 ; Jump (technically always) to PRG008_AB5B

PRG008_AB56:

	; Use override value
	
	LDY Player_UphillSpeedIdx	 ; Y = Player_UphillSpeedIdx
	BEQ PRG008_AB62	 ; If Player_UphillSpeedIdx = 0 (not walking uphill), jump to PRG008_AB62

PRG008_AB5B:
	LDA Player_UphillSpeedVals,Y	 ; Get uphill speed value
	TAY		 	; -> Y
	JMP PRG008_AB83	 ; Jump to PRG008_AB83

PRG008_AB62:
	LDY #PLAYER_TOPWALKSPEED

	BIT <Pad_Holding
	BVC PRG008_AB83	; If Player is NOT holding 'B', jump to PRG008_AB83

	; Player is holding B...

	LDA <Player_InAir
	ORA Player_Slide
	BNE PRG008_AB78	 ; If Player is mid air or sliding, jump to PRG008_AB78

	LDA <Temp_Var3
	CMP #PLAYER_TOPRUNSPEED
	BMI PRG008_AB78	 ; If Player's X Velocity magnitude is less than PLAYER_TOPRUNSPEED, jump to PRG008_AB78

	; Player is going fast enough while holding B on the ground; flag running!
	INC Player_RunFlag ; Player_RunFlag = 1

PRG008_AB78:
	; Start with top run speed
	LDY #PLAYER_TOPRUNSPEED ; Y = PLAYER_TOPRUNSPEED

	LDA Player_Power
	CMP #$7f
	BNE PRG008_AB83	 ; If Player has not hit full power, jump to PRG008_AB83

	; Otherwise, top power speed
	LDY #PLAYER_TOPPOWERSPEED	 ; Y = PLAYER_TOPPOWERSPEED

PRG008_AB83:
	STY <Temp_Var14	 ; Store top speed -> Temp_Var14

	LDY Player_Slippery
	BEQ PRG008_AB98	 ; If ground is not slippery at all, jump to PRG008_AB98

	INC Player_WalkAnimTicks ; Player_WalkAnimTicks++

	DEY
	TYA
	ASL A
	ASL A
	ASL A
	ADD #$40
	TAY		 ; Y = ((selected top speed - 1) << 3) + $40 ??
	BNE PRG008_AB9E	 ; And as long as that's not zero, jump to PRG008_AB9E

PRG008_AB98:
	LDA <Player_Suit
	ASL A
	ASL A
	ASL A
	TAY		 ; Y = Player_Suit << 3

PRG008_AB9E:
	BIT <Pad_Holding
	BVC PRG008_ABA6	 ; If Player is NOT pressing 'B', jump to PRG008_ABA6

	; Otherwise...
	INY
	INY
	INY
	INY	; Y += 4 (offset 4 inside Player_XAccel* tables)

PRG008_ABA6:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG008_ABB8	 ; If Player is pressing LEFT or RIGHT, jump to PRG008_ABB8

	; Player not pressing LEFT/RIGHT...

	LDA <Player_InAir
	BNE PRG008_AC01	 ; If Player is mid air, jump to PRG008_AC01 (RTS)

	LDA <Player_XVel
	BEQ PRG008_AC01	 ; If Player is not moving horizontally, jump to PRG008_AC01 (RTS)
	BMI PRG008_ABD3	 ; If Player is moving leftward, jump to PRG008_ABD3
	BPL PRG008_ABEB	 ; If Player is moving rightward, jump to PRG008_ABEB

PRG008_ABB8:

	; Player is pressing left/right...

	INY
	INY		 ; Y += 2 (offset 2 within Player_XAccel* tables, the "skid" rate)

	AND Player_MoveLR
	BNE PRG008_ABCD	  ; If Player suddenly reversed direction, jump to PRG008_ABCD

	DEY		 ; Y-- (back one offset, the "normal" rate)

	LDA <Temp_Var3	 
	CMP <Temp_Var14	 
	BEQ PRG008_AC01	 ; If Player's current X velocity magnitude is the same as the selected top speed, jump to PRG008_AC01 (RTS)
	BMI PRG008_ABCD	 ; If it's less, then jump to PRG008_AC01

	LDA <Player_InAir
	BNE PRG008_AC01	 ; If Player is mid air, jump to PRG008_AC01

	DEY		 ; Y-- (back one offset, the "friction" stopping rate)

PRG008_ABCD:


	; At this point, 'Y' contains the current power-up in bits 7-3, 
	; bit 2 is set if Player pressed B, bit 1 is set if the above
	; block was jumped, otherwise bit 0 is set if the X velocity is
	; less than the specified maximum, clear if over the max


	LDA <Pad_Holding
	AND #PAD_RIGHT
	BNE PRG008_ABEB	 ; If Player is holding RIGHT, jump to PRG008_ABEB (moving rightward code)

PRG008_ABD3:

	; Player moving leftward

	LDA #$00	 
	SUB Player_XAccelPseudoFrac,Y ; Negate value from Player_XAccelPseudoFrac[Y]
	STA <Temp_Var1	  ; -> Temp_Var1

	LDA Player_XAccelMain,Y ; Get Player_XAccelMain[Y]
	EOR #$ff	 ; Negate it (sort of)
	STA <Temp_Var2	 ; -> Temp_Var2

	LDA <Temp_Var1
	BNE PRG008_ABF5	 ; If Temp_Var1 <> 0, jump to PRG008_ABF5

	INC <Temp_Var2	 ; Otherwise, Temp_Var2++
	JMP PRG008_ABF5	 ; Jump to PRG008_ABF5

PRG008_ABEB:

	; Player moving rightward

	LDA Player_XAccelPseudoFrac,Y ; Get value from Player_XAccelPseudoFrac[Y]
	STA <Temp_Var1	  ; -> Temp_Var1

	LDA Player_XAccelMain,Y ; Get value from Player_XAccelMain[Y]
	STA <Temp_Var2	  ; -> Temp_Var2

PRG008_ABF5: 
	LDA <Temp_Var1
	ADD Counter_Wiggly	; actual value not used, looking for a semi-random carry

	LDA <Player_XVel
	ADC <Temp_Var2
	STA <Player_XVel	; Player_XVel += Temp_Var2 (and sometimes carry)

PRG008_AC01:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_UnderwaterHControl
;
; Routine to control based on Player's left/right pad input underwater
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_UnderwaterHControl:
	LDY #(Player_XAccelMain_UW - Player_XAccelMain)	; Y = index to appropriate under water values

	LDA #%00001000
	STA <Temp_Var14	 ; Temp_Var14 = pretend like Player is definitely hitting UP

	LDA <Player_InAir
	BEQ PRG008_AC14	 ; If Player is not in the air, jump to PRG008_AC14

	LDA #Pad_Input
	STA <Temp_Var14	 ; Temp_Var14 = actual Pad_Input (as compared to what happened above)

	INY
	INY
	INY
	INY		 ; Y += 4 (offset into Player_XAccel* tables)
 
PRG008_AC14:
	LDA <Player_InAir
	PHA		 ; Save Player_InAir

	LDA #$00
	STA <Player_InAir ; Player_InAir= 0

	JSR PRG008_ABA6	 ; Reuses part of normal movement code

	; Muck speed limiter
	LDA Level_WaterMuck
	BEQ Water_NotMuck

	LDA <Player_XVel
	CMP #(PLAYER_TOPWALKSPEED / 4)
	BLS WaterMuck_Not2FastR

	LDA #(PLAYER_TOPWALKSPEED / 4)
	BNE WaterMuck_StoreXVel

WaterMuck_Not2FastR:
	CMP #-(PLAYER_TOPWALKSPEED / 4)
	BGS Water_NotMuck
	
	LDA #-(PLAYER_TOPWALKSPEED / 4)

WaterMuck_StoreXVel:
	STA <Player_XVel

Water_NotMuck:
	PLA		 
	STA <Player_InAir ; Restore Player_InAir

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_JumpFlyFlutter
;
; Controls the acts of jumping, flying, and fluttering (tail wagging)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG008_AC22:
	.byte $D0, $CE, $CC, $CA, $CA, $CA

Player_JumpFlyFlutter:
	LDA Player_AllowAirJump
	BEQ PRG008_AC30	 ; If Player_AllowAirJump = 0, jump to PRG008_AC30

	DEC Player_AllowAirJump ; Player_AllowAirJump--

PRG008_AC30:

	LDA <Pad_Input
	AND #PAD_A
	STA <Temp_Var1	 ; Temp_Var1 = $80 if Player is pressing 'A', otherwise 0
	BEQ PRG008_AC9E	 ; If Player is NOT pressing 'A', jump to PRG008_AC9E

	LDA Player_AllowAirJump
	BNE PRG008_AC41	 ; If Player_AllowAirJump <> 0, jump to PRG008_AC41

	LDA <Player_InAir
	BNE PRG008_AC9E	 ; If Player is mid air, jump to PRG008_AC9E

PRG008_AC41:

	; Play jump sound
	LDA #SND_PLAYERJUMP	 

	LDX <Player_Suit
	BNE PlayerJump_NormalSound
	
	LDA #SND_PLAYERJUMPSM
	
PlayerJump_NormalSound:
	STA Sound_QPlayer

	LDA Player_StarInv
	BEQ PRG008_AC6C	 ; If Player is not invincible by star, jump to PRG008_AC6C

	LDA Player_Power
	CMP #$7f
	BEQ PRG008_AC6C	 ; If Player is at max power, jump to PRG008_AC6C

	LDA Player_IsHolding
	BNE PRG008_AC6C	 ; If Player is holding something, jump to PRG008_AC6C

	LDA <Player_Suit
	BEQ PRG008_AC6C	 ; If Player is small, jump to PRG008_AC6C
	CMP #PLAYERSUIT_PENGUIN
	BEQ PRG008_AC6C	 ; If Player is wearing penguin suit, jump to PRG008_AC6C

	; Otherwise, mark as mid air AND backflipping
	;STA Player_Flip	; SB: Does anyone like this really?
	STA <Player_InAir

	LDA #$00
	STA Player_AllowAirJump	 ; Cut off Player_AllowAirJump

PRG008_AC6C:

	; Get absolute value of Player's X velocity
	LDA <Player_XVel
	BPL PRG008_AC73
	JSR Negate
PRG008_AC73:

	LSR A
	LSR A
	LSR A
	LSR A
	TAX	 ; X = Magnitude of Player's X Velocity >> 4 (the "whole" part)

	LDA #PLAYER_JUMP	 	; Get initial jump velocity
	SUB Player_SpeedJumpInc,X	; Subtract a tiny bit of boost at certain X Velocity speed levels
	STA <Player_YVel		; -> Y velocity

	LDA #$01
	STA <Player_InAir ; Flag Player as mid air

	LDA #$00	
	STA Player_WagCount	 ; Player_WagCount = 0
	STA Player_AllowAirJump	 ; Player_AllowAirJump = 0

	LDA Player_Power
	CMP #$7f
	BNE PRG008_AC9E		; If Player is not at max power, jump to PRG008_AC9E

	LDY <Player_Suit
	CPY #PLAYERSUIT_RABBIT
	BEQ PRG008_AC9E		; If Player is Rabbit Mario, jump to PRG008_AC9E (don't "fly"!)

	LDA Player_FlyTime
	BNE PRG008_AC9E	 	; If Player still has flight time left, jump to PRG008_AC9E

	LDA #$80
	STA Player_FlyTime	; Otherwise, Player_FlyTime = $80

PRG008_AC9E:
	LDA <Player_InAir
	BNE PRG008_ACB3		; If Player is mid air, jump to PRG008_ACB3

	LDY <Player_Suit
	LDA PowerUp_Ability,Y	; Get "ability" flags for this power up
	AND #$01
	BNE PRG008_AD1A	 	; If power up has flight ability, jump to PRG008_AD1A

	LDA #$00
	STA Player_FlyTime	; Otherwise, Player_FlyTime = 0 :(
	JMP PRG008_AD1A	 ; Jump to PRG008_AD1A

Gravity_Delta:
	.byte $05, $01

PRG008_ACB3:

	; Player is mid air...

	; This is sort of the gravity / A-jump-extend code

	LDY Player_GravityEffect
	LDA Gravity_Delta,Y
	TAY

	LDA <Player_YVel
	BPL Player_GravityReset
	
Player_GravityModComplete
	CMP #-$20
	BGS PRG008_ACC8	 ; If Player's Y velocity >= -$20, jump to PRG008_ACC8

	LDA Player_mGoomba
	BNE PRG008_ACCD	 ; If Player has got a microgoomba stuck to him, jump to PRG008_ACCD

	LDA <Pad_Holding
	BPL PRG008_ACC8	 ; If Player is NOT pressing 'A', jump to PRG008_ACC8

	LDY #$01	 ; Y = 1
	BNE PRG008_ACCD	 ; Jump (technically always) to PRG008_ACCD

PRG008_ACC8:
	LDA #$00
	STA Player_mGoomba ; Player_mGoomba = 0

PRG008_ACCD:
	TYA	
	ADD <Player_YVel
	STA <Player_YVel ; Player_YVel += Y

	LDA <Player_WagCount
	BEQ PRG008_ACD9	 ; If Player_WagCount = 0, jump to PRG008_ACD9

	DEC <Player_WagCount ; Otherwise, $F0--

PRG008_ACD9:
	;LDA Player_Kuribo
	;BNE PRG008_ACEF	 ; If Player is wearing Kuribo's shoe, jump to PRG008_ACEF

	LDX <Player_Suit

	LDA PowerUp_Ability,X	; Get "ability" flags for this power up
	AND #$01	 
	BEQ PRG008_ACEF	 	; If this power up does not have flight, jump to PRG008_ACEF

	; SB: Refactored logic; now you can just hold 'A' instead of mash 'A' to fly/flutter
	LDA <Pad_Holding
	AND #PAD_A
	BEQ PRG008_ACEF	 	; If Player is not holding 'A', jump to PRG008_ACEF

	; SB: Player is holding 'A'...
	LDA <Player_WagCount
	BNE PRG008_ACEF		; Loop Player_WagCount

	LDA #$10
	STA <Player_WagCount 	; Otherwise, Player_WagCount = $10

PRG008_ACEF:
	LDA <Player_WagCount
	BEQ PRG008_AD1A	 	; If Player has not wag count left, jump to PRG008_AD1A

	; RACCOON / RABBIT TAIL WAG LOGIC

	LDA <Player_YVel
	CMP #PLAYER_FLY_YVEL
	BLS PRG008_AD1A	 ; If Player's Y velocity is < PLAYER_FLY_YVEL, jump to PRG008_AD1A

	LDY #PLAYER_FLY_YVEL	 ; Y = PLAYER_FLY_YVEL

	LDA Player_FlyTime
	BEQ PRG008_AD0E	 ; If Player is not flying, jump to PRG008_AD0E

	CMP #$0f
	BGE PRG008_AD18	 ; If Player has a great amount of flight time left, jump to PRG008_AD18

	; Player has a small amount of flight time left

	LDY #$F0
	AND #$08	 
	BNE PRG008_AD18	 ; Every 8 ticks, jump to PRG008_AD18

	LDY #$00	 ; Y = 0 (at apex of flight, Player no longer rises)
	BEQ PRG008_AD18	 ; Jump (technically always) to PRG008_AD18

PRG008_AD0E:
	JSR WagYVel_GetProper
	STA <Temp_Var1
	
	LDA <Player_YVel
	BMI PRG008_AD1A	 ; If Player's Y velocity < 0 (moving upward), jump to PRG008_AD1A

	CMP <Temp_Var1
	BLT PRG008_AD1A	 ; If Player's Y velocity < PLAYER_TAILWAG_YVEL, jump to PRG008_AD1A

	LDY <Temp_Var1 ; Y = PLAYER_TAILWAG_YVEL

PRG008_AD18:
	STY <Player_YVel ; Set appropriate Y velocity

PRG008_AD1A:
	LDA Player_UphillSpeedIdx
	BEQ PRG008_AD2E	 ; If Player_UphillSpeedIdx = 0 (not walking uphill), jump to PRG008_AD2E

	LSR A
	TAY		 ; Y = Player_UphillSpeedIdx >> 1

	LDA <Player_YVel
	BPL PRG008_AD2E	 ; If Player's Y vel >= 0, jump to PRG008_AD2E (RTS)

	CMP PRG008_AC22,Y
	BLS PRG008_AD2E	; If Player's uphill speed < Y velocity, jump to PRG008_AD2E

	LDA #$20
	STA <Player_YVel ; Player_YVel = $20

PRG008_AD2E:
	RTS		 ; Return

Player_GravityReset:
	
	; Temporary low gravity... going down, so cancel it
	LDA #0
	STA Player_GravityEffect
	JMP Player_GravityModComplete

WagYVel_GetProper:
	LDA #PLAYER_TAILWAG_YVEL

	LDY <Player_Suit
	CPY #PLAYERSUIT_RABBIT
	BNE WagYVel_NotRabbit

	LDA #(PLAYER_TAILWAG_YVEL / 2)

WagYVel_NotRabbit:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SwimV
;
; Controls the acts of swimming (the up/down part only), not
; including the Penguin Suit style (which is totally different)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 4th value is for muck swim start
SwimSpeedStart:	.byte PLAYER_SWIMSTART_YVEL,	PLAYER_SWIMSTART_YVEL / 3,	PLAYER_SWIMSTART_YVEL * 3, -$1E
SwimSpeedDelta:	.byte PLAYER_SWIM_YVEL, 		PLAYER_SWIM_YVEL / 3, 		PLAYER_SWIM_YVEL * 3, $1E

Player_SwimV:
	LDA <Pad_Input		 
	BPL PRG008_AD4C	 ; If Player is NOT pressing 'A', jump to PRG008_AD4C

	; Player swimming sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	; Muck speed limiter
	LDA Level_WaterMuck
	BEQ SwimV_NotMuck

	LDY #1
	
	LDA <Player_InAir
	BNE SwimV_Muck

	LDY #3
	BNE SwimV_Muck

SwimV_NotMuck:
	; Set 'Y' to index based on Player's use of up/down to limit swim speeds
	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	LSR A
	LSR A
	TAY		; 0 if not pressing up or down, 1 if pressing down, 2 if pressing up

SwimV_Muck:
	LDA <Player_InAir
	BNE PRG008_AD45	 ; If Player is swimming above ground, jump to PRG008_AD4A

	LDA SwimSpeedStart,Y
	STA <Player_InAir ; "mid air" underwater
	BNE PRG008_AD4A	 ; Jump (technically always) to PRG008_AD4A

PRG008_AD45:

	; Swimming speed the rest of the time

	LDA <Player_YVel
	SUB SwimSpeedDelta,Y

PRG008_AD4A:
	STA <Player_YVel ; Set Player_YVel appropriately

PRG008_AD4C:
	LDA <Player_InAir
	BEQ PRG008_AD7E	 ; If Player is on the ground, jump to PRG008_AD7E

	LDA <Player_YVel
	BMI PRG008_AD5A	 ; If Player's Y velocity is < 0 (moving upward), jump to PRG008_AD5A

	LDA <Counter_1
	AND #$02
	BNE PRG008_AD5C	 ; Every 4 ticks, jump to PRG008_AD5C

PRG008_AD5A:

	; Player's sink rate...

	INC <Player_YVel ; Player_YVel++

PRG008_AD5C:
	LDY #PLAYER_SWIM_YVEL	 ; Y = PLAYER_SWIM_YVEL

	LDA <Player_YVel
	BPL PRG008_AD75	 ; If Player's Y velocity is < 0 (moving upward), jump to PRG008_AD75

	LDY Player_AboveTop
	BPL PRG008_AD73	 ; If Player is not above top of screen, jump to PRG008_AD73

	LDY Player_SpriteY
	CPY #-8	 
	BGE PRG008_AD73	 ; If Player sprite is a bit high up, jump to PRG008_AD73

	ADD #$10
	STA <Player_YVel ; Player_YVel += $10

PRG008_AD73:
	LDY #PLAYER_SWIMSTART_YVEL	 ; Y = PLAYER_SWIMSTART_YVEL

PRG008_AD75:
	ADD #PLAYER_SWIM_YVEL
	CMP #PLAYER_MAXSPEED
	BLT PRG008_AD7E	 ; If result is less than Player's max speed, jump to PRG008_AD7E

	STY <Player_YVel ; Otherwise, update it

PRG008_AD7E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SwimAnim
;
; Animates Player for swimming
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SwimAnim:
	LDA <Player_InAir
	BEQ PRG008_ADBC	 ; If Player is NOT swimming above ground, jump to PRG008_ADBC (RTS)

	LDA <Pad_Input
	BPL PRG008_AD9A	 ; If Player is NOT pressing 'A', jump to PRG008_AD9A

	LDA Player_SwimCnt
	BNE PRG008_AD97	 ; If Player_SwimCnt <> 0, jump to PRG008_AD97

PRG008_AD8C:
	LDA #$00
	STA Player_SwimCnt	 ; Player_SwimCnt = 0
	STA Counter_ByPlayerSpd	 ; Counter_ByPlayerSpd = 0
	STA Player_WalkAnimTicks ; Player_WalkAnimTicks = 0

PRG008_AD97:
	INC Player_SwimCnt	 ; Player_WalkAnimTicks++

PRG008_AD9A:
	LDA Player_SwimCnt
	BNE PRG008_ADBD	 ; If Player_SwimCnt <> 0, jump to PRG008_ADBD

	LDA <Player_XVel
	BNE PRG008_ADAD	 ; If Player is moving left or right, jump to PRG008_ADAD

	; Player NOT moving left/right

	LDA <Counter_1
	AND #$30
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	STA <Player_WalkFrame	 ; Choose a "walk" (swim) relative frame based on game counter

PRG008_ADAD:
	LDY <Player_WalkFrame

	LDA <Player_Suit
	BNE PRG008_ADB7	 ; If Player is not small, jump to PRG008_ADB7

	INY
	INY
	INY
	INY	; Otherwise, use Player_WalkFrame + 4

PRG008_ADB7:
	LDA Player_SwimIdleFrames,Y	 ; Get appropriate swim frame
	STA <Player_Frame	 ; Set it!

PRG008_ADBC:
	RTS		 ; Return


PRG008_ADBD:
	LDA Counter_ByPlayerSpd
	CMP #$06
	BLT PRG008_ADCB	 ; If Counter_ByPlayerSpd < 6, jump to PRG008_ADCB

	DEC Player_SwimCnt	; Player_SwimCnt--
	BNE PRG008_AD8C	 	; If Player_SwimCnt > 0, jump to PRG008_AD8C

	LDA #$05	 ; A = 5

PRG008_ADCB:
	LDY <Player_Suit ; Y = Player_Suit
	BNE PRG008_ADD2	 ; If Player is not small, jump to PRG008_ADD2

	ADD #$06	 ; For small, A = 11

PRG008_ADD2:
	TAY		 ; Y = 5 or 11

	; Set Player swimming frame
	LDA Player_SwimActiveFrames,Y
	STA <Player_Frame

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_YoshiMove
;
; Routine to modify Player movements to function with Yoshi
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_YoshiMove:
	LDA Player_Kuribo
	BEQ PYM_NoYoshi		; If not riding Yoshi, jump to PYM_NoYoshi

	JSR PRG008_AEB6		; Set slide frame

PYM_NoYoshi:
	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_CommonGroundAnims
;
; Performs "common" animations for walking around on the ground
; (walking/standing, ducking, sliding) and, for some reason, also
; contains the debug mode power-up cycle logic (SELECT to cycle
; through all available power-ups and toggle Kuribo's shoe)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_CommonGroundAnims:

	; Get absolute value of Player_XVel
	LDA <Player_XVel
	BPL PRG008_ADE0
	JSR Negate
PRG008_ADE0:

	LSR A
	LSR A
	LSR A
	TAY		 ; Y = Absolute value of Player's X Velocity shifted right by 3 (1 bit left of "whole" part)

	INC Player_WalkAnimTicks
	LDA Player_WalkAnimTicks
	CMP Player_WalkAnimTickMax,Y
	BMI PRG008_AE03	 ; If we haven't reached the rollover point in the walking animation ticks, jump to PRG008_AE03

	LDA #$00
	STA Player_WalkAnimTicks ; Player_WalkAnimTicks = 0

	INC <Player_WalkFrame	 ; Next Player frame
	INC Counter_ByPlayerSpd	 ; Increment Player-speed-based counter

	; Cap Player_WalkFrame at 0-3 (why not just AND it?)
	LDA <Player_WalkFrame
	CMP #$04
	BMI PRG008_AE03

	LDA #$00
	STA <Player_WalkFrame

PRG008_AE03:

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG008_AE11	 ; If Player is pressing left or right, jump to PRG008_AE11

	; Player NOT pressing left/right

	LDA <Player_XVel
	BNE PRG008_AE11	 ; If Player_XVel <> 0, jump to PRG008_AE11

	LDA #$02
	STA <Player_WalkFrame	 ; Otherwise, force Player_WalkFrame to 2 (standing still)

PRG008_AE11:
	LDA Player_TailAttack
	BNE PRG008_AE26	 ; If Player is performing tail attack, jump to PRG008_AE26

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_AE26	 ; If Player is NOT pressing left or right, jump to PRG008_AE26

	; Player is pressing left/right

	LDY #$00	; No flip

	AND #%00000010
	BNE PRG008_AE24	 ; If Player is pressing left, jump to PRG008_AE24

	LDY #SPR_HFLIP	; Horizontal flip

PRG008_AE24:
	STY <Player_FlipBits	; Set appropriate flip

PRG008_AE26:

	LDA <Player_Suit
	ASL A
	ASL A
	ORA <Player_WalkFrame	 ; Take the walk frame and push the current power-up to bit 2
	TAY		 ; -> Y
	LDA Player_WalkFramesByPUp,Y	 ; Get appropriate sprite frame
	STA <Player_Frame		 ; -> Player_Frame

	LDA Player_InWater
	BNE PRG008_AE90	 ; If Player is in water, jump to PRG008_AE90

	; Player not in water...

	LDA <Player_XVel
	ADD #$01
	CMP #$03
	BLT PRG008_AE90	 ; If (Player_XVel + 1) < 3, jump to PRG008_AE90

	LDA Player_MoveLR
	AND <Pad_Holding
	BEQ PRG008_AE90	 ; If Player is pressing the opposite direction from his movement, jump to PRG008_AE90

	LDY <Player_Suit
	BEQ PRG008_AE7F	 ; If Player is small, jump to PRG008_AE7F

	LDY #$01	 ; Otherwise, Y = 1

PRG008_AE7F:
	LDA <Player_InAir
	BNE PRG008_AE90	 ; If Player is mid air, jump to PRG008_AE90

	; Play "skid" sound
	LDA Sound_QLevel2
	ORA #SND_LEVELSKID
	STA Sound_QLevel2

	LDA Player_SkidFrame,Y
	STA <Player_Frame ; Set skid frame

PRG008_AE90:
	LDA Player_IsDucking
	BEQ PRG008_AEA2	 ; If Player is not ducking

	LDY <Player_Suit
	LDA PowerUp_Ability,Y	; Get "ability" bits for suit
	AND #$01	 	; Bit 0 specifies that the power up can do raccoon style flying and fluttering
	TAY		 
	LDA Player_DuckFrame,Y	; Get appropriate duck frame
	STA <Player_Frame	; Set frame!

PRG008_AEA2:
	LDA Player_Slide
	BEQ PRG008_AEC0	 ; If Player is not sliding, jump to PRG008_AEC0

	; Player is sliding...

	LDA <Player_InAir
	BNE PRG008_AEB1	 ; If Player is mid air, jump to PRG008_AEB1

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP)
	BEQ PRG008_AEB6	 ; If Player is not holding LEFT, RIGHT, or UP, jump to PRG008_AEB6

PRG008_AEB1:

	; Otherwise, cancel the sliding
	; Aside: Did you know pressing UP would stop you from sliding in Mario 3?  I didn't :P

	LDA #$00
	STA Player_Slide ; Player_Slide = 0 (stop sliding)

PRG008_AEB6:
	LDA #PF_SLIDE_BIG	 ; Frame for anything besides small
	LDY <Player_Suit
	BNE PRG008_AEBE	 ; If Player is not small, jump to PRG008_AEBE

	LDA #PF_SLIDE_SMALL	 ; Frame for small

PRG008_AEBE:
	STA <Player_Frame ; Set appropriate Player frame

PRG008_AEC0:
	RTS		 ; Return



	; Player's climb "animation", which is really just flipping the sprite
Player_DoClimbAnim:
	LDA Player_IsClimbing
	BEQ PRG008_B035	 ; If Player is NOT climbing, jump to PRG008_B035 (RTS)

	; SB: Supporting "behind the scenes" alternate climb frame; now it's 2 different climb frames
	LDA <Player_Suit
	ASL A				; x 2
	ADD Player_Behind	; Assuming this will only ever be 0/1
	TAY		; -> 'Y'
	
	LDA Player_ClimbFrame,Y	 ; Get appropriate climbing frame
	STA <Player_Frame	 ; Store into Player_Frame

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN | PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_B035	 ; If Player is NOT pressing a direction, jump to PRG008_B035

	; Every 8 ticks, flip Player horizontally
	LDA <Counter_1
	AND #$08
	ASL A	
	ASL A	
	ASL A	
	STA <Player_FlipBits

PRG008_B035:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_AnimTailWag
;
; Animates the Player's tail wag for flying and fluttering
; Also plays the "wag" sound as appropriate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_AnimTailWag:
	LDA Player_SandSink
	LSR A
	BCS PRG008_B09F	 ; If bit 0 of Player_SandSink is set, jump to PRG008_B09F (RTS)

	LDA Player_AllowAirJump
	BNE PRG008_B09F	 ; If Player_AllowAirJump, jump to PRG008_B09F (RTS)

	LDA <Player_InAir
	BEQ PRG008_B09F	 ; If Player is NOT mid air, jump to PRG008_B09F (RTS)

	LDA Player_IsDucking
	BNE PRG008_B082	 ; If Player is ducking, jump to PRG008_B082

	LDA <Pad_Holding	; RAS
	BPL PRG008_B062	 ; If Player is NOT HOLDING A, jump to PRG008_B062


	; The following replaces what would be a queued jump sound with the "wag" sound
	LDA Sound_QPlayer
	CMP #SND_PLAYERJUMP
	BEQ PRG008_B05D	 ; If jump sound is NOT queued, jump to PRG008_B05D

	; SB: New logic -- Player must either be flying or falling to play wag
	LDA Player_FlyTime
	BNE PATW_PlayWag	; If Player is flying, definitely play wag
	
	LDA <Player_YVel
	BMI PRG008_B05D		; Otherwise, must be falling (wagging) to play wag sound

PATW_PlayWag:
	; Plays the tail wag sound
	LDA Sound_QLevel1
	ORA #SND_LEVELTAILWAG
	STA Sound_QLevel1

PRG008_B05D:
	; SB: Reset Player_TailCount when it reaches zero (for holding 'A' and continous flutter)
	LDA Player_TailCount
	BNE PRG008_B062

	LDA #10
	STA Player_TailCount	 ; Player_TailCount = $10

PRG008_B062:
	LDA Player_TailCount
	LSR A
	LSR A
	STA <Temp_Var1	 ; Temp_Var1 = Player_TailCount >> 2

	LDA #$00	; A = 0 (flying!)

	LDY Player_FlyTime
	BNE PRG008_B072	 ; If flying, jump to PRG008_B072

	LDA #$06	 ; A = 6 (fluttering/falling)

PRG008_B072:
	LDY <Player_YVel
	BMI PRG008_B079	 ; If Player Y velocity < 0, jump to PRG008_B079

	ADD #$03	 ; Otherwise, add 3 (apex, when just running out of power, flying steady)

PRG008_B079:
	LDY <Player_Suit
	CPY #PLAYERSUIT_RABBIT
	BNE PATW_NotBunnyEars

	; +6 for Bunny Ears
	ADD #$06

PATW_NotBunnyEars:
	ADD <Temp_Var1	 ; Add specific frame offset
	TAY		 ; A -> Y
	LDA Player_TailWagFlyFrames,Y	 ; Get correct frame

PATW_BunnyEars:
	STA <Player_Frame ; And set it!

PRG008_B082:
	LDA Player_FlyTime
	ORA Player_WagCount
	BEQ PRG008_B09F	 ; If flying or fluttering, jump to PRG008_B09F (RTS)

	LDY #-1		 ; Y = -1
	LDA <Player_XVel
	BPL PRG008_B095	 ; If Player_XVel >= 0, jump to PRG008_B095

	LDY #1		 ; Y = 1
	JSR Negate	 ; Negate Player_XVel (get absolute value)

PRG008_B095:

	; Y = -1 and Player_XVel >= 0
	;    OR
	; Y = 1 and Player_XVel < 0
	;    (but magnitude is in 'A' either way)

	CMP #PLAYER_TOPWALKSPEED	
	BLS PRG008_B09F	 ; If X Velocity magnitude is < PLAYER_TOPWALKSPEED, jump to PRG008_B09F (RTS)

	; Otherwise add 'Y', which gives a slow acceleration up to that speed when in air as raccoon
	TYA
	ADD <Player_XVel
	STA <Player_XVel

PRG008_B09F:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SoarJumpFallFrame
;
; Sets Player's frame appropriate for "soaring" (high speed jump),
; standard jumping, or falling...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SoarJumpFallFrame:
	LDA Player_SandSink
	LSR A
	BCS PRG008_B0C5	 ; If bit 0 of Player_SandSink is set, jump to PRG008_B0C5

	LDA Player_AllowAirJump
	BNE PRG008_B0C5	 ; If Player_AllowAirJump, jump to PRG008_B0C5 (RTS)

	LDA <Player_InAir
	BEQ PRG008_B0C5	 ; If Player is mid air, jump to PRG008_B0C5 (RTS)

	LDA Player_IsDucking
	BNE PRG008_B0C5	 ; If Player is ducking, jump to PRG008_B0C5 (RTS)

	LDA #PF_FASTJUMPBIG	 ; High speed "soar" jump frame

	LDY Player_FlyTime
	BNE PRG008_B0C3	 ; If Player has jumped at high speed, jump to PRG008_B0C3

	LDA #PF_JUMPBIG	 ; Normal "fist pump" jump frame

	LDY <Player_YVel
	BMI PRG008_B0C3	 ; If Player is moving upward, jump to PRG008_B0C3

	LDA #PF_FALLBIG	 ; Standard "fall" frame

PRG008_B0C3:
	STA <Player_Frame ; Set appropriate frame

PRG008_B0C5:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_TailAttackAnim
;
; Animate tail attack
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_TailAttackAnim:
	LDA Player_DisTailAtk
	BNE Player_DisableTailAtk	; SB: If Player_DisTailAtk is set, jump to Player_DisableTailAtk

	LDA <Pad_Holding
	AND #PAD_DOWN
	BNE PRG008_B109	 ; If Player is holding down, jump to PRG008_B109

	BIT <Pad_Input
	BVC PRG008_B0E2	 ; If Player is NOT pressing 'B', jump to PRG008_B0E2

	LDA Player_TailAttack
	BNE PRG008_B0E2	 ; If Player is performing tail attack, jump to PRG008_B0E2

	LDA #$12
	STA Player_TailAttack	 ; Player_TailAttack = $12

	; Plays the tail wag sound
	LDA Sound_QLevel1
	ORA #SND_LEVELTAILWAG
	STA Sound_QLevel1

PRG008_B0E2:
	LDA Player_TailAttack
	BEQ PRG008_B109	 ; If Player is not performing tail attack, jump to PRG008_B109

	LSR A
	LSR A
	TAY		 ; Y = Player_TailAttack >> 2

	LDA <Player_InAir
	BEQ PRG008_B0F3	 ; If Player is NOT in mid air, jump to PRG008_B0F3

	INY
	INY
	INY
	INY
	INY		 ; Y += 5 (use mid air tail attack frames)

PRG008_B0F3:
	LDA Player_TailAttackFrames,Y	 ; Get appropriate tail attack frame
	STA <Player_Frame		 ; Store it


	; Flips player at particular times

	LDA Player_TailAttack
	CMP #$0b
	BEQ PRG008_B103

	CMP #$03
	BNE PRG008_B109

PRG008_B103:
	LDA <Player_FlipBits
	EOR #SPR_HFLIP
	STA <Player_FlipBits

PRG008_B109:
	RTS		 ; Return

Player_DisableTailAtk:

	; SB: Disable tail attack briefly
	LDA #0
	STA Player_DisTailAtk

	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ShootAnim
;
; Animate shooting a fireball / hammer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ShootAnim:
	LDA Player_FireCount
	BEQ PRG008_B11E	 ; If Player has not just shot something, jump to PRG008_B11E

	LSR A
	LSR A		; A = Player_FireCount >> 2

	LDY <Player_InAir
	BEQ PRG008_B118	 ; If Player is mid air, jump to PRG008_B118

	ADD #(Player_FireInAir - Player_FireOnGround)	 ; Otherwise, offset to "on ground" frames

PRG008_B118:
	TAY		 ; A -> Y
	LDA Player_FireOnGround,Y ; Get appropriate frame
	STA <Player_Frame	 ; Set it!

PRG008_B11E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoScrolling
;
; Scrolls screen horizontally and vertically (including Raster
; Effects) as appropriate for Player's position
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DoScrolling:

	; This is to work around a weird quirk where, for one frame 
	; right when the level starts, player input can cause a
	; misjudged need to scroll, which generally results in the
	; player getting horizontally misplaced from their starting
	; point. This is due to no actual display of the player 
	; having occurred yet. This dodgy check is to see if the 
	; player X and Y sprite variables are both zero (i.e. the
	; player's relative screen position has not yet been computed)
	; in which case it does not update scrolling.
	LDA Player_SpriteX
	ORA Player_SpriteY
	BEQ PRG008_B11E

	LDA Level_7Vertical
	BEQ PRG008_B127	 ; If Level is not vertical, jump to PRG008_B127

	JMP PRG008_B2AB	 ; Otherwise, jump to PRG008_B2AB

PRG008_B127:
	LDA LevelJctBQ_Flag
	BEQ PRG008_B12F	 ; If we're NOT in a Big Question Block area, jump to PRG008_B12F

	JMP PRG008_B1CE	 ; Otherwise, jump to PRG008_B1CE

PRG008_B12F:
	LDY Level_AScrlConfig
	BEQ PRG008_B150	 ; If no raster effects, jump to PRG008_B150
	BMI PRG008_B150	 ; If ASCONFIG_HDISABLE is set, jump to PRG008_B150

	; Sets horizontal scroll to auto scroll alternate values

	LDA Level_AScrlPosH
	PHA		 ; Save Level_AScrlPosH

	SUB <Horz_Scroll
	STA Level_ScrollDiffH	 ; Difference between horizontal scroll and Level_AScrlPosH

	PLA		 ; Restore Level_AScrlPosH
	STA <Horz_Scroll ; Set as new horizontal scroll

	LDA Level_AScrlPosHHi
	STA <Horz_Scroll_Hi	 ; Set proper "high" position for raster

	LDA Level_AScrlSclLastDir
	STA <Scroll_LastDir	 ; Set "Scroll_LastDir" as appropriate for raster

	JMP PRG008_B208		; Jump to PRG008_B208

PRG008_B150:

	; No raster effects or horizontal auto scroll not desired

	LDA <Player_X
	SUB <Horz_Scroll
	BPL PRG008_B195	 ; If Player_X >= Horz_Scroll, jump to PRG008_B195

	LDA <Horz_Scroll_Hi
	STA <Temp_Var1		; Temp_Var1 = Horz_Scroll_Hi

	LDA #$80
	ADD <Horz_Scroll
	STA <Temp_Var2	 ; Temp_Var2 = $80 + Horz_Scroll
	BCC PRG008_B166	 ; If no carry, jump to PRG008_B166

	INC <Temp_Var1	 ; Apply carry

PRG008_B166:
	LDA <Player_XHi
	CMP <Temp_Var1
	BLS PRG008_B1CE	 ; If Player_XHi < Temp_Var1 (Horizontal scroll as appropriate when adding $80), jump to PRG008_B1CE

	LDA <Player_X
	SUB <Temp_Var2
	BEQ PRG008_B1CE	 ; If Player_X = Temp_Var2 ($80 + Horz_SCroll), jump to PRG008_B1CE
	BMI PRG008_B1CE	 ; If Player_X < Temp_Var2 ($80 + Horz_SCroll), jump to PRG008_B1CE

	STA Level_ScrollDiffH	 ; Result stored into Level_ScrollDiffH

	ADD <Horz_Scroll
	STA <Horz_Scroll	 ; Horz_Scroll += Level_ScrollDiffH
	BCC PRG008_B181	 	; If no carry, jump to PRG008_B181
	INC <Horz_Scroll_Hi	 ; Otherwise, apply carry

PRG008_B181:
	LDA #$00	 
	STA <Scroll_LastDir	 ; Scroll_LastDir = 0 (screen last moved right)

	LDA <Horz_Scroll_Hi
	CMP <Level_Width
	BLS PRG008_B1CE	 	; If Horz_Scroll_Hi < Level_Width, jump to PRG008_B1CE

	; Otherwise...
	LDA #$00
	STA <Horz_Scroll	 ; Horz_Scroll = 0
	STA Level_ScrollDiffH	 ; Level_ScrollDiffH = 0
	JMP PRG008_B1CE	 	; Jump to PRG008_B1CE

PRG008_B195:
	LDA <Horz_Scroll_Hi
	STA <Temp_Var1		; Temp_Var1 = Horz_Scroll_Hi

	LDA #$70
	ADD <Horz_Scroll
	STA <Temp_Var2		; Temp_Var2 = $70 + Horz_Scroll
	BCC PRG008_B1A4	 	; If no carry, jump to PRG008_B1A4
	INC <Temp_Var1		 ; Otherwise, apply carry

PRG008_B1A4:
	LDA <Temp_Var1
	CMP <Player_XHi
	BLS PRG008_B1CE	 	; If Temp_Var1 < Player_XHi, jump to PRG008_B1CE

	LDA <Player_X
	SUB <Temp_Var2
	BPL PRG008_B1CE	 	; If Player_X >= Temp_Var2, jump to PRG008_B1CE

	STA Level_ScrollDiffH	; Store difference into Level_ScrollDiffH

	ADD <Horz_Scroll
	STA <Horz_Scroll	; Horz_Scroll += Level_ScrollDiffH
	BCS PRG008_B1BD	 	; If carry set, jump to PRG008_B1BD
	DEC <Horz_Scroll_Hi	; Otherwise, remove carry

PRG008_B1BD:
	LDA #$01
	STA <Scroll_LastDir	; Scroll_LastDir = 1 (last moved left)

	LDA <Horz_Scroll_Hi
	BPL PRG008_B1CE	 	; If Horz_Scroll_Hi >= 0, jump to PRG008_B1CE

	; Clear a bunch
	LDA #$00	 
	STA <Horz_Scroll_Hi
	STA <Horz_Scroll
	STA Level_ScrollDiffH

PRG008_B1CE:
	LDA <Player_SpriteX

	LDY <Player_XVel
	BMI PRG008_B1DD	 ; If Player X velocity < 0 (moving leftward), jump to PRG008_B1DD

	; Player moving rightward...

	CMP #232
	BLT PRG008_B208	 ; If Player_SpriteX < 232, jump to PRG008_B1DD

	LDA #232	; Cap max at 232
	JMP PRG008_B1E3	 ; Jump to PRG008_B1E3

PRG008_B1DD:
	CMP #17
	BGE PRG008_B208	 ; If Player_SpriteX >= 17, jump to PRG008_B208
	LDA #16	 	; Cap min at 16

PRG008_B1E3:
	STA <Player_SpriteX ; Update Player_SpriteX

	LDY #$00	 ; Y = 0 (offset of Player_XHi)

	SUB <Player_X
	BPL PRG008_B1EE	 ; If Player_SpriteX >= Player_X, jump to PRG008_B1EE

	LDY #$ff	 ; Y = $FF (offset of Player_XHi, sign extended high part of negative)

PRG008_B1EE:
	ADD <Player_X	 
	STA <Player_X	 ; Player_X += difference between this and Player_SpriteX
	BCC PRG008_B1F6	 ; If no carry, jump to PRG008_B1F6

	INY		 ; Otherwise, apply carry

PRG008_B1F6:
	TYA		 ; A = Y ("high" part offset)
	ADD <Player_XHi	 ; Apply high adjustment
	STA <Player_XHi	 ; And store it!

	LDA <Player_XVel
	PHP		 ; Save processor status

	AND #%00001111	 ; Just take lower 4 bits (the "fractional" part)

	PLP		 ; Restore processor status

	BPL PRG008_B206	 ; If Player_XVel >= 0, jump to PRG008_B206

	ORA #$F0	 ; Otherwise, provide negative sign extention for fractional part

PRG008_B206:
	STA <Player_XVel ; Revise Player_XVel with only signed fractional part!

PRG008_B208:

	LDA Level_FreeVertScroll
	BEQ PRG008_B214	 ; If Level_FreeVertScroll = 0 (not freely scrolling), jump to PRG008_B214

	CMP #$01
	BEQ PRG008_B258	 ; If Level_FreeVertScroll = 1 (freely scrolling), jump to PRG008_B258

	; Otherwise, arbitrarily locked (whatever Vert_Scroll is)...
	JMP PRG008_B2A0	 ; Jump to PRG008_B2A0

PRG008_B214:

	; Not freely vertical scrolling (which persists as "NEVER" if 
	; Auto Scroll is active, but otherwise MAY be overridden)

	LDA Level_AScrlConfig
	BEQ PRG008_B246	 ; If auto scroll effect active, jump to PRG008_B246

	; Calculates Player Y based on auto scroll position
AutoScroll_CalcPlayerY:
	LDA Level_AScrlPosV
	PHA		 ; Save "Level_AScrlPosV"

	SUB <Vert_Scroll
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = difference of current scroll position from Level_AScrlPosV

	PLA		 	; Restore "Level_AScrlPosV"
	STA <Vert_Scroll 	; Becomes the new Vert_Scroll
	STA Level_VertScroll	; Becomes the new Level_VertScroll

	LDA <Player_InAir
	BEQ PRG008_B245	 ; If Player is not mid-air, jump to PRG008_B245 (RTS)

	LDA Player_IsClimbing
	ORA AScrlURDiag_WrapState_Copy
	BNE PRG008_B245	 ; If Player is climbing or diagonal autoscroller is wrapping, jump to PRG008_B245

	LDA Level_ScrollDiffV
	BPL PRG008_B23C	 ; If Level_ScrollDiffV >= 0, jump to PRG008_B23C

	DEC <Player_YHi	; Player_YHi--

PRG008_B23C:
	ADD <Player_Y
	STA <Player_Y	 ; Player_Y = Level_ScrollDiffV + Player_Y

	BCC PRG008_B245	 ; If no carry, jump to PRG008_B245

	INC <Player_YHi	 ; Otherwise, carry into Player_YHi

PRG008_B245:
	RTS		 ; Return


PRG008_B246:

	; VERTICAL SCROLL LOCK LOGIC

	; Checking whether vertical scrolling should be allowed in levels that explicitly disable it.
	; When set to not allow it by default, so long as no raster effects are going on (see above),
	; then we may allow it if the Player is flying (or high speed jumping) or climbing a vine.

	; Once the scroll point has reached Vert_Scroll = $EF (lowest scroll point) it stays there
	; unless one of the above specified overrides occur.  And here we go...

	LDA <Vert_Scroll
	CMP #$ef
	BNE PRG008_B258	 ; If Vert_Scroll <> $EF (lowest scroll point), jump to PRG008_B258 (allow free while Vert_Scroll < $EF)

	LDA Player_FlyTime
	ORA Player_IsClimbing
	PHP		 ; Save processor status

	LDA #$ef	 ; A = $EF (locked vertical scroll value)

	PLP		 ; Restore processor status

	; Optional free vertical scroll override...

	BEQ PRG008_B2A2	 ; If Player is not flying or climbing, jump to PRG008_B2A2

PRG008_B258:

	; Free vertical scrolling allowed

	LDA <Player_Y
	SUB Level_VertScroll
	STA <Temp_Var1		; Temp_Var1 = Player_Y - Level_VertScroll (difference between Player_Y and vertical scroll)

	LDA <Player_YHi
	SBC Level_VertScrollH
	BMI PRG008_B272	 ; If (Player_YHi - Level_VertScrollH) < 0, jump to PRG008_B272

	LDA <Temp_Var1
	SUB #$30
	BCS PRG008_B284	 ; If there was no borrow, jump to PRG008_B284

	; Minimum vertical scroll delta is -4 (SB: Bumped to -4 so reverse gravity falls keep up with Player)
	CMP #-4
	BGE PRG008_B274	 ; If difference is -4 or above, jump to PRG008_B274

PRG008_B272:
	LDA #-4	 	; Otherwise, enforce -4 minimum

PRG008_B274:
	STA Level_ScrollDiffV ; Store as vertical difference

	ADD <Vert_Scroll   ; Add Vert_Scroll 
	BCS PRG008_B281	   ; If carry occurred, jump to PRG008_B281

	LDA #$00
	STA Level_ScrollDiffV	; Level_ScrollDiffV = 0

PRG008_B281:
	JMP PRG008_B29E	 ; Jump to PRG008_B29E

PRG008_B284:
	LDA <Temp_Var1
	SUB #$58
	BCC PRG008_B2A0	 ; If borrow occurred, jump to PRG008_B2A0

	STA Level_ScrollDiffV	; Store as vertical difference

	ADD <Vert_Scroll
	BCS PRG008_B297	 ; If carry occurred, jump to PRG008_B297

	CMP #$ef
	BLT PRG008_B29E	 ; If calculated value is less than $EF, we're not at the bottom yet, and so jump to PRG008_B29E

PRG008_B297:
	LDA #$00
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = 0

	LDA #$ef	 ; Bottom scroll position is $EF

PRG008_B29E:
	STA <Vert_Scroll	 ; Update Vert_Scroll

PRG008_B2A0:
	LDA <Vert_Scroll	

PRG008_B2A2:

	; Entry point if free vertical scrolling is disabled and Player did not override it

	STA Level_VertScroll	 ; Set Level_VertScroll

	LDA #$00
	STA Level_VertScrollH	 ; Level_VertScroll = 0

	RTS		 ; Return

PRG008_B2AB:
	; Vertical style for Player_DoScrolling

	LDA #$00	 
	STA <Player_XHi	 ; Player_XHi = 0 (never used in vertical mode)

	LDY <Level_Width ; Y = Level_Width ("height" actually, in this context)

	; Get address starting this screen -> Temp_Var1/2
	LDA VertLevel_ScreenH,Y
	STA <Temp_Var1		
	LDA VertLevel_ScreenL,Y	
	STA <Temp_Var2

	LDA <Player_Y
	SUB Level_VertScroll
	TAY		 ; Y = Player_Y - Level_VertScroll

	LDA <Player_YHi
	SBC Level_VertScrollH
	BNE PRG008_B345	 ; If Player_YHi <> Level_VertScrollH, jump to PRG008_B345 (RTS)

	TYA		 ; A = Player_Y - Level_VertScroll
	SUB #$30
	BCS PRG008_B2F9	 ; If no borrow occurred, jump to PRG008_B2F9

	; Minimum vertical scroll delta value is -4 (SB: Bumped to -4 so reverse gravity falls keep up with Player)
	DEC Level_VertScrollH
	CMP #-4
	BGE PRG008_B2D8

	LDA #-4

PRG008_B2D8:
	STA Level_ScrollDiffV	 ; Set difference

	ADD Level_VertScroll
	STA Level_VertScroll	 ; Level_VertScroll += Level_ScrollDiffV

	LDA #$00
	STA <Scroll_LastDir	 ; Scroll_LastDir = 0 (last scrolled up)

	ADC Level_VertScrollH	; Apply carry, if any
	BPL PRG008_B2F3	 	; If Level_VertScrollH >= 0, jump to PRG008_B2F3

	; Otherwise clear Level_VertScroll and Level_ScrollDiffV
	LDA #$00
	STA Level_VertScroll
	STA Level_ScrollDiffV

PRG008_B2F3:
	STA Level_VertScrollH	 ; Update Level_VertScrollH
	JMP PRG008_B338	 ; Jump to PRG008_B338

PRG008_B2F9:
	TYA		 ; A = Player_Y - Level_VertScroll
	SBC #$58
	BCC PRG008_B345	 ; If borrow occurred, jump to PRG008_B345 (RTS)

	; Maximum vertical scroll delta value is 4
	CMP #$04
	BLT PRG008_B304	 ; If value is < 4, jump to PRG008_B304

	LDA #$04	 ; A = 4

PRG008_B304:
	STA Level_ScrollDiffV	 ; Store vertical difference

	ADD Level_VertScroll
	STA Level_VertScroll	 ; Level_VertScroll += Level_ScrollDiffV

	LDA #$00
	ADC Level_VertScrollH
	STA Level_VertScrollH	 ; Apply carry, if any

	CMP <Temp_Var1

	PHP		 ; Save processor status

	LDA #$01
	STA <Scroll_LastDir	 ; Scroll_LastDir = 1 (last scrolled down)

	PLP		 ; Restore processor status

	BLT PRG008_B338		; If Level_VertScrollH < Temp_Var1 (base screen high address start), jump to PRG008_B338
	BNE PRG008_B329		; If Level_VertScrollH <> Temp_Var1 (base screen high address start), jump to PRG008_B329

	LDA Level_VertScroll
	CMP <Temp_Var2
	BLT PRG008_B338	 	; If Level_VertScroll < Temp_Var2, jump to PRG008_B338

PRG008_B329:

	; Update Level_VertScrollH and Level_VertScroll
	LDA <Temp_Var1
	STA Level_VertScrollH
	LDA <Temp_Var2
	STA Level_VertScroll

	LDA #$00
	STA Level_ScrollDiffV	 ; Level_VertScrollH = 0

PRG008_B338:
	LDA Level_VertScroll
	LDY Level_VertScrollH

	JSR LevelJct_GetVScreenH

	STA <Vert_Scroll
	STY <Vert_Scroll_Hi

PRG008_B345:
	RTS		 ; Return


	; Offsets used for tile detection in non-sloped levels
	; +16 if moving downward
	; +8 if on the right half of the tile
TileAttrAndQuad_OffsFlat:
	;     Yoff Xoff

	; Not small or ducking moving downward - Left half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $0E	; In-front lower
	.byte $0E, $0E	; In-front upper

	; Not small or ducking moving downward - Right half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $01	; In-front lower
	.byte $0E, $01	; In-front upper

	; Not small or ducking moving upward - Left half
	.byte $06, $08	; Ground left
	.byte $06, $08	; Ground right
	.byte $1B, $0E	; In-front lower
	.byte $0E, $0E	; In-front upper

	; Not small or ducking moving upward - Right half
	.byte $06, $08	; Ground left
	.byte $06, $08	; Ground right
	.byte $1B, $01	; In-front lower
	.byte $0E, $01	; In-front upper


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; SB: NEW REVERSE GRAVITY OFFSETS
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TileAttrAndQuad_OffsFlat_Rev:
	; Not small or ducking moving downward - Left half
	.byte $00, $04	; Ground left
	.byte $00, $0B	; Ground right
	.byte $05, $0E	; In-front lower
	.byte $12, $0E	; In-front upper

	; Not small or ducking moving downward - Right half
	.byte $00, $04	; Ground left
	.byte $00, $0B	; Ground right
	.byte $05, $01	; In-front lower
	.byte $12, $01	; In-front upper

	; Not small or ducking moving upward - Left half
	.byte $1A, $08	; Ground left
	.byte $1A, $08	; Ground right
	.byte $05, $0E	; In-front lower
	.byte $12, $0E	; In-front upper

	; Not small or ducking moving upward - Right half
	.byte $1A, $08	; Ground left
	.byte $1A, $08	; Ground right
	.byte $05, $01	; In-front lower
	.byte $12, $01	; In-front upper



TileAttrAndQuad_OffsFlat_Sm:
	; Small or ducking moving downward - Left half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $0D	; In-front lower
	.byte $14, $0D	; In-front upper

	; Small or ducking moving downward - Right half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $02	; In-front lower
	.byte $14, $02	; In-front upper

	; Small or ducking moving upward - Left half
	.byte $10, $08	; Ground left
	.byte $10, $08	; Ground right
	.byte $1B, $0D	; In-front lower
	.byte $14, $0D	; In-front upper

	; Small or ducking moving upward - Right half
	.byte $10, $08	; Ground left
	.byte $10, $08	; Ground right
	.byte $1B, $02	; In-front lower
	.byte $14, $02	; In-front upper


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; SB: NEW REVERSE GRAVITY OFFSETS
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Small or ducking moving downward - Left half
	.byte $00, $04	; Ground left
	.byte $00, $0B	; Ground right
	.byte $05, $0D	; In-front lower
	.byte $0C, $0D	; In-front upper

	; Small or ducking moving downward - Right half
	.byte $00, $04	; Ground left
	.byte $00, $0B	; Ground right
	.byte $05, $02	; In-front lower
	.byte $0C, $02	; In-front upper

	; Small or ducking moving upward - Left half
	.byte $10, $08	; Ground left
	.byte $10, $08	; Ground right
	.byte $05, $0D	; In-front lower
	.byte $0C, $0D	; In-front upper

	; Small or ducking moving upward - Right half
	.byte $10, $08	; Ground left
	.byte $10, $08	; Ground right
	.byte $05, $02	; In-front lower
	.byte $0C, $02	; In-front upper



	; Offsets used for tile detection in sloped levels
TileAttrAndQuad_OffsSloped:
	; Offsets pushed into Player_GetTileAndSlope
	;    Yoff Xoff

	; Not small or ducking - Left half
	.byte $20, $08	; feet
	.byte $05, $08	; head
	.byte $18, $03	; in-front lower
	.byte $0C, $03	; in-front upper

	; Not small or ducking - Right half
	.byte $20, $08	; feet
	.byte $05, $08	; head
	.byte $18, $0D	; in-front lower
	.byte $0C, $0D	; in-front upper

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; SB: NEW REVERSE GRAVITY OFFSETS
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TileAttrAndQuad_OffsSloped_Rev:
	; Not small or ducking - Left half
	.byte $00, $08	; feet
	.byte $1B, $08	; head
	.byte $08, $03	; in-front lower
	.byte $14, $03	; in-front upper

	; Not small or ducking - Right half
	.byte $00, $08	; feet
	.byte $1B, $08	; head
	.byte $08, $0D	; in-front lower
	.byte $14, $0D	; in-front upper

TileAttrAndQuad_OffsSloped_Sm:
	; Small or ducking - Left half
	.byte $20, $08	; feet
	.byte $12, $08	; head
	.byte $18, $03	; in-front lower
	.byte $17, $03	; in-front upper

	; Small or ducking - Right half
	.byte $20, $08	; feet
	.byte $12, $08	; head
	.byte $18, $0D	; in-front lower
	.byte $17, $0D	; in-front upper

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; SB: NEW REVERSE GRAVITY OFFSETS
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Small or ducking - Left half
	.byte $00, $08	; feet
	.byte $0E, $08	; head
	.byte $08, $03	; in-front lower
	.byte $09, $03	; in-front upper

	; Small or ducking - Right half
	.byte $00, $08	; feet
	.byte $0E, $08	; head
	.byte $08, $0D	; in-front lower
	.byte $09, $0D	; in-front upper


	; Explicitly for walking off an edge in a sloped area
TileAttrAndQuad_OffsSlopeEdge:
	.byte $20, $04	; Right half
	.byte $20, $0B	; Left half

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; SB: NEW REVERSE GRAVITY OFFSETS
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TileAttrAndQuad_OffsSlopeEdgR:
	.byte $00, $04	; Right half
	.byte $00, $0B	; Left half

PlayerY_HeightOff:	.byte $12, $05	; Left value is Player_Y offset for small/ducking, right for otherwise
PRG008_B3AC:	
	.byte $02, $0E	; Left/Right half, not small
	.byte $03, $0D	; Left/Right half, small

PRG008_B3B0:	.byte $04, $0D

	; If $01, this is treated as a "not floor" tile, which means to watch out
	; for the Player to hit his head rather than track the sloped floor...
	;
	; SB: New value of $02 means ALWAYS treat as non-floor (in this case,
	; used for index 0 / BG tiles to prevent reverse gravity from treating
	; them like some kind of floor) and $80 to indicate always treat as
	; floor (in this case, to protect index 3 / solid square tiles and
	; index 4 / wall tiles)
Slope_IsNotFloorShape:
	.byte $02, $00, $00, $80, $80, $01, $01, $00	; $00-$07
	.byte $01, $01, $00, $01, $00, $00, $00, $00	; $08-$0F
	.byte $01, $01, $01, $01, $01			; $10-$14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTileAndSlope
;
; Gets tile and attribute of tile for either non-vertical or
; vertical levels based on Player's position
;
; Temp_Var10 is a Y offset (e.g. 0 for Player's feet, 31 for Player's head)
; Temp_Var11 is an X offset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetTileAndSlope:

	LDA #$00
	STA Temp_VarNP0 ; Temp_VarNP0 = 0

	LDA Level_7Vertical
	BEQ Player_GetTAndS_NotVert
	JMP PRG008_B442	 ; If level is vertical, jump to PRG008_B442

Player_GetTAndS_NotVert:
	LDA Player_PartDetEn
	BEQ PRG008_B3F7	 ; If Player_PartDetEn is not set, jump to PRG008_B3F7
	BPL Player_GetTAndS_NoFixedC

	LDA <Player_Y
	ADD <Temp_Var10		; Temp_Var10 is the Y offset 
	SUB Level_VertScroll	; Make relative to Vertical Scroll
	
	CMP #32
	BGE Player_GetTAndS_NoFixedC

	AND #$F0	; Align to tile grid
	STA <Temp_Var14	; -> Temp_Var14

	LDA #$00
	STA <Temp_Var13	 ; Temp_Var13 = 0 (implied high byte / carry)
	STA Temp_VarNP0 ; Temp_VarNP0 = 0
	BEQ PRG008_B406
	
Player_GetTAndS_NoFixedC:
	; Bottom two tile rows forced detection enabled when Player Y >= 160...

	LDA Player_AboveTop
	BNE PRG008_B3F7	 ; If Player is above top of screen, jump to PRG008_B3F7

	LDA <Player_Y
	ADD <Temp_Var10		; Temp_Var10 is the Y offset 
	SUB Level_VertScroll	; Make relative to Vertical Scroll

	CMP #160
	BLT PRG008_B3F7	 ; If result < 160, jump to PRG008_B3F7

	; Player is low enough to the visual floor... detect the bottom two rows of tiles!

	SBC #16		; - 16
	AND #$F0	; Align to tile grid
	STA <Temp_Var14	; -> Temp_Var14

	LDA #$01
	STA <Temp_Var13	 ; Temp_Var13 = 1 (implied high byte / carry)
	STA Temp_VarNP0 ; Temp_VarNP0 = 1
	BNE PRG008_B406	 ; Jump (technically always) to PRG008_B406

PRG008_B3F7:
	LDA <Player_YHi
	STA <Temp_Var13	 ; Temp_Var13 = Player_YHi

	LDA <Temp_Var10	 ; Temp_Var10 is the Y offset 
	ADD <Player_Y	 
	STA <Temp_Var14	 ; Temp_Var14 = Temp_Var10 + Player_Y

	BCC PRG008_B406	 ; If no carry, jump to PRG008_B406

	INC <Temp_Var13	 ; Apply carry to Temp_Var13

PRG008_B406:
	LDA <Temp_Var13
	BEQ PRG008_B419	 ; If Temp_Var13 (high byte / carry) = 0, jump to PRG008_B419

	; When carry exists..

	CMP #$01
	BNE PRG008_B414	 ; If Temp_Var13 <> 1, jump to PRG008_B414

	LDA <Temp_Var14
	CMP #$b0	
	BLT PRG008_B419	 ; If Temp_Var14 < $B0, jump to PRG008_B419

PRG008_B414:
	LDA #$00
	STA <Player_Slopes	 ; Player_Slopes = 0 

	RTS		 ; Return


PRG008_B419:
	LDA <Player_XHi
	STA <Temp_Var15	 ; Temp_Var15 = Player_XHi

	LDA <Temp_Var11
	BPL PRG008_B423	 ; If Temp_Var11 >= 0, jump to PRG008_B423

	DEC <Temp_Var15	 ; Temp_Var15--

PRG008_B423:
	LDA <Player_X
	ADD <Temp_Var11
	STA <Temp_Var16	 ; Temp_Var16 = Player_X + Temp_Var11
	BCC PRG008_B42E	 ; If no carry, jump to PRG008_B42E

	INC <Temp_Var15	 ; Temp_Var15++ (apply carry to Temp_Var15)

PRG008_B42E:

	; So in total we've calculated:
	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	; X/Y were not modified, so as inputs:
	; X = 0 (going down) or 1 (going up)
	; Y = Player_YVel

	STY <Temp_Var10	 ; Temp_Var10 = Player_YVel
	STX <Temp_Var11	 ; Temp_Var11 = 0 or 1

	JSR Player_GetTileAndSlope_Normal	 ; Set Level_Tile and Player_Slopes

	LDX <Temp_Var11	 	; Temp_Var11 = 0 (going down) or 1 (going up)
	LDY Level_PipeMove	; Y = Level_PipeMove (movement command in $8x form)
	BNE PRG008_B43F	 	; If Level_PipeMove <> 0, jump to PRG008_B43F

	JSR PSwitch_SubstTileAndAttr	 ; Otherwise, substitute tile if effected by P-Switch

PRG008_B43F:


	LDY Temp_VarNP0
	BEQ Player_32PP_NoBump	; If Player is not on 32-pixel-partition floor, jump to Player_32PP_Bump
	
	LDY Level_AScrlSelect
	CPY #4
	BNE Player_32PP_NoBump	; If not in the shifting maze, jump to Player_32PP_NoBump
	
	; Check if Player needs to be "bumped up" to detect rising maze
	PHA
	JSR_THUNKC 30, Player_32PP_BumpCheck
	PLA
	
Player_32PP_NoBump:
	

	LDY <Temp_Var10	 ; Y = Player_YVel	
	RTS		 ; Return

PRG008_B442:
	LDA <Player_YHi
	STA <Temp_Var13	 ; Temp_Var13 = Player_YHi

	LDA <Temp_Var10
	ADD <Player_Y
	STA <Temp_Var14	 ; Temp_Var14 = Temp_Var10 + Player_Y
	BCC PRG008_B451	 ; If there's no carry, jump to PRG008_B451

	INC <Temp_Var13	 ; Otherwise, apply the carry

PRG008_B451:
	LDA <Temp_Var13	
	BPL PRG008_B458	 ; If Temp_Var13 (the "High" part) >= 0, jump to PRG008_B458

	; Otherwise...
	LDA #$00	 ; A = 0
	RTS		 ; Return

PRG008_B458:
	LDA <Player_X
	ADD <Temp_Var11
	STA <Temp_Var16	 ; Temp_Var16 = Player_X + Temp_Var11

	STY <Temp_Var10	 ; Temp_Var10 = Y

	JSR Player_GetTileV	 ; Get tile, set Level_Tile

	LDY Level_PipeMove	 ; Y = Level_PipeMove
	BNE PRG008_B46C	 	; If Level_PipeMove <> 0, jump to PRG008_B46C

	JSR PSwitch_SubstTileAndAttr	 ; Otherwise, substitute tile if effected by P-Switch

PRG008_B46C:
	LDY #$00
	STY <Temp_Var15	 ; Temp_Var15 = 0

	LDY <Temp_Var10	 ; Y = Temp_Var10
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DetectSolids
;
; Handles Player's collision against solid tiles (wall and ground,
; handles slopes and sliding on them too!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DetectSolids:
	LDA #$00
	STA Player_HitCeiling ; Clear Player_HitCeiling
	STA Level_32PPSlopeFlag	; Clear Level_32PPSlopeFlag

	LDA Level_PipeMove
	BEQ PRG008_B47E	 ; If not going through a pipe, jump to PRG008_B47E

	RTS		 ; Return


PRG008_B47E:
	; SB: Refactored to do away with unnecessary constant in PRG000)
	LDA #LOW(Slope_LUT)
	STA <Level_GndLUT_L

	LDA #HIGH(Slope_LUT)
	STA <Level_GndLUT_H

	LDA Level_SlopeEn
	BEQ PRG008_B4A5	 ; If not a sloped level, jump to PRG008_B4A5

	LDA Level_Tileset
	CMP #$03
	BEQ PRG008_B4A2	 ; If Level_Tileset = 3 (Hills style), jump to PRG008_B4A2
	CMP #14
	BEQ PRG008_B4A2	 ; If Level_Tileset = 14 (Underground style), jump to PRG008_B4A2

	; Non-sloped levels use this:
	; SB: Unused, and still wrong, but same wrong as SMB3 (just getting rid of unnecessary constant in PRG000)

	LDA #LOW(Level_LayPtrOrig_AddrH)
	STA <Level_GndLUT_L

	LDA #HIGH(Level_LayPtrOrig_AddrH)
	STA <Level_GndLUT_H

PRG008_B4A2:
	JMP PRG000_B9D8	 ; Jump to PRG000_B9D8

PRG008_B4A5:
	; Slopes not enabled...

	LDY #(TileAttrAndQuad_OffsFlat_Sm - TileAttrAndQuad_OffsFlat) + 6	; 6 = 3 * 2 (the offset we start on below) and work backwards from

	LDA <Player_Suit
	BEQ PRG008_B4B2	 ; If Player is small, jump to PRG008_B4B2

	LDA Player_IsDucking
	BNE PRG008_B4B2	 ; If Player is ducking, jump to PRG008_B4B2

	LDY #6		; 6 = 3 * 2 (the offset we start on below) and work backwards from

PRG008_B4B2:

	; SB: Switch to reverse gravity offsets if needed
	LDA Player_ReverseGrav
	BEQ Player_TileOffs_NoRev

	TYA
	ADD #(TileAttrAndQuad_OffsFlat_Rev - TileAttrAndQuad_OffsFlat)
	TAY

Player_TileOffs_NoRev:
	LDX #$03	 ; X = 3 (the reason for +6 above)

	LDA <Player_YVel 
	BPL PRG008_B4BD	 ; If Player_YVel >= 0 (moving downward), jump to PRG008_B4BD

	; Otherwise, add 16 to index
	TYA
	ADD #16
	TAY

PRG008_B4BD:
	LDA <Player_X
	AND #$0f
	CMP #$08
	BLS PRG008_B4CA	 ; If Player is on the left half of the tile, jump to PRG008_B4CA

	; If on the right half, add 8 to index
	TYA	
	ADD #$08
	TAY	

PRG008_B4CA:
	TYA		 ; Offset -> 'A'
	PHA		 ; Save offset

	; Get X/Y offset for use in detection routine
	LDA TileAttrAndQuad_OffsFlat,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)
	LDA TileAttrAndQuad_OffsFlat+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)

	JSR Player_GetTileAndSlope	 ; Get tile
	STA Level_Tile_GndL,X	 ; Store it

	PHA		 ; Save tile

	AND #%11000000	 ; Get quadrant
	ASL A		 
	ROL A		 
	ROL A		 ;
	STA Level_Tile_Quad,X	 ; Store quadrant number

	PLA		 ; Restore tile

	JSR Level_DoCommonSpecialTiles	 ; Handle tile apporiately

	PLA		 
	TAY		 ; Restore 'Y' index
	DEY
	DEY		 ; Y -= 2 (next pair of offsets)

	DEX		 ; X--

	BMI PRG008_B4F3	 ; If X < 0, jump to PRG008_B4F3
	JMP PRG008_B4CA	 ; Otherwise, loop!

PRG008_B4F3:
	; Wall hit detection
	LDY #$02	 ; Y = 2 (checking "in front" tiles, lower and upper)

	JSR Level_CheckGndLR_TileGTAttr
	BCC PRG008_B53B	 ; If not touching a solid tile, jump to PRG008_B53B

	LDA Player_LowClearance	 
	BNE PRG008_B53B	 ; If Player_LowClearance is set, jump to PRG008_B53B

	INC Player_WalkAnimTicks	 ; Player_WalkAnimTicks++

	LDY #$01	 ; Y = 1
	LDX #$00	 ; X = 0

	LDA <Player_X
	AND #$0f	
	CMP #$08	
	BGS PRG008_B511	 ; If Player is on the right side of the tile, jump to PRG008_B511

	; Otherwise...
	LDY #-1		 ; Y = -1
	INX		 ; X = 1

PRG008_B511:
	LDA <Player_Suit
	BNE PRG008_B517	 ; If Player is NOT small, jump to PRG008_B517

	INX		 
	INX		 ; X += 2 (X = 2 or 3)

PRG008_B517:
	LDA PRG008_B3AC,X
	ADD <Player_X	 ; Add appropriate offset to Player_X

	AND #$0f
	BEQ PRG008_B53B	 ; If Player is on new tile, jump to PRG008_B53B

	TYA		 ; A = 1 or -1
	BPL PRG008_B526	 ; If the positive version, jump to PRG008_B526

	DEC <Player_XHi	 ; When negative, decrement the "Hi" component

PRG008_B526:
	ADD <Player_X	 ; Add +1/-1 to Player_X
	STA <Player_X	 ; Update Player_X

	BCC PRG008_B52F	 ; If no carry, jump to PRG008_B52F
	INC <Player_XHi	 ; Otherwise, apply carry

PRG008_B52F:
	INY		 ; Y++

	LDA <Player_XVel
	BPL PRG008_B536	 ; If Player_XVel >= 0, jump to Player_XVel

	; This basically amounts to a single decrement of 'Y' if Player_XVel < 0
	DEY
	DEY

PRG008_B536:
	TYA		
	BNE PRG008_B53B	 ; If Y <> 0, jump to PRG008_B53B

	STA <Player_XVel ; Otherwise, halt Player horizontally

PRG008_B53B:
	; If tileset = 5 (Ghost House), jump to FloorChk_GhostHouseStair
	LDA Level_Tileset
	CMP #5
	BEQ FloorChk_GhostHouseStair

FloorChk_NotGhostHouseStair:
	; Player cannot be on stairs
	LDA #0
	STA Player_OnStairs

	LDA <Player_YVel
	BPL PRG008_B55B	 ; If Player Y velocity >= 0 (moving downward), jump to PRG008_B55B

	LDA <Player_InAir
	BEQ PRG008_B55B	 ; If Player is NOT mid air, jump to PRG008_B55B

	LDY #$00	 ; Y = 0

	JSR Level_CheckGndLR_TileGTAttr
	BCC PRG008_B55A	 ; If not touching a solid tile, jump to PRG008_B55A

	INY		 ; Y = 1
	STY Player_HitCeiling	 ; Flag Player as having just hit head off ceiling

	LDA Level_AScrlVVel	; Get autoscroll vertical velocity
	JSR Negate	 ; Negate it
	BPL PRG008_B558	 ; If positive, jump to PRG008_B558

	; Otherwise, just use 1
	LDA #$01	

PRG008_B558:
	STA <Player_YVel ; Update Player_YVel

PRG008_B55A:
	RTS		 ; Return

FloorChk_GhostHouseStair:

	LDA <Player_YVel
	BMI FloorChk_NotGhostHouseStair	; If Player is moving upward, don't detect stairs

	; Do stair logic
	JSR_THUNKC 30, GhostHouse_Stairs

	; If 'A' is non-zero, stairs failed, jump to FloorChk_NotGhostHouseStair
	BNE FloorChk_NotGhostHouseStair

	; Else, stairs "succeeded", so just RTS
	RTS

	;;;;;;;;;;;;;;;;;;;;;

PRG008_B55B:
	LDX Level_Tile_Quad+1	 ; Get right tile quadrant
	LDA Level_Tile_GndR	 ; Get right tile
	CMP Tile_AttrTable,X	
	BGE PRG008_B57E	 	 ; If the tile is >= the attr value, jump to PRG008_B57E

	LDX Level_Tile_Quad	 ; Get left tile quadrant
	LDA Level_Tile_GndL	 ; Get left tile
	CMP Tile_AttrTable,X	
	BGE PRG008_B57E	 	 ; If the tile is >= the attr value, jump to PRG008_B57E


	LDA <Player_InAir
	BNE PRG008_B5BB	 ; If Player is mid air, jump to PRG008_B5BB

	; Otherwise...

	STA <Player_YVel ; Halt Player vertically

	LDA #$01
	STA <Player_InAir ; Mark Player as mid air

	JMP PRG008_B5BB	 ; Jump to PRG008_B5BB

PRG008_B57E:
	LDA Temp_VarNP0
	BEQ PRG008_B59C		; If did not use "high" Y last call to Player_GetTileAndAttr, jump to PRG008_B59C

	LDA <Player_Y		; Get Player Y
	SUB Level_VertScroll	; Make scroll relative
	AND #$F0	 	; Nearest 16
	ADD #$01	 	; +1
	ADD Level_VertScroll	; Make un-relative
	STA <Player_Y		; Set Player_Y!

	LDA #$00
	ADC #$00
	STA <Player_YHi		; Apply carry if needed
	BPL PRG008_B5B2	 	; If carry >= 0, jump to PRG008_B5B2

PRG008_B59C:

	; SB: Floor lock code, need "reverse" version
	LDA Player_ReverseGrav
	BNE Player_HitFloor_Reverse

	LDA <Player_Y
	AND #$0f	; Relative to tile vertical position
	CMP #$06
	BGE PRG008_B5BB	 ; If Player's vertical tile position >= 6, jump to PRG008_B5BB

	LDA <Player_Y
	AND #$0f	 ; Relative to tile vertical position
	BEQ PRG008_B5B2	 ; If zero, jump to PRG008_B5B2

	CMP #$01	 
	BEQ PRG008_B5B0	 ; If 1, jump to PRG008_B5B0

	DEC <Player_Y	 ; Player_Y--

PRG008_B5B0:
	DEC <Player_Y	 ; Player_Y--


PRG008_B5B2:

	LDA #$00	 
	STA <Player_InAir ; Player NOT mid air
	STA <Player_YVel  ; Halt Player vertically

	; SB: SMW style tallying when invincible
	LDA Player_StarInv
	BNE PRG008_B5BB		; If Player has Star Man, do not reset kill tally, jump to PRG008_B5BB (RTS)

	; Not Star Man invincible; clear tally plz
	LDA #0
	STA Kill_Tally	  ; Reset Kill_Tally

PRG008_B5BB:
	RTS		 ; Return


Player_HitFloor_Reverse:
	LDA <Player_Y
	AND #$0f	; Relative to tile vertical position
	CMP #$0A
	BLT PRG008_B5BB	 ; If Player's vertical tile position < A, jump to PRG008_B5BB

	LDA <Player_Y
	AND #$0f	 ; Relative to tile vertical position
	CMP #$0f
	BEQ PRG008_B5B2	 ; If 15, jump to PRG008_B5B2

	CMP #$0E	 
	BEQ PRG008_B5B0	 ; If 14, jump to PRG008_B5B02

	INC <Player_Y	 ; Player_Y++

PRG008_B5B02:
	INC <Player_Y	 ; Player_Y++
	JMP PRG008_B5B2


	; This checks if the given tile is greater-than-or-equal-to
	; the related "AttrTable" slot and, if so, returns 'carry set'
Level_CheckGndLR_TileGTAttr:

	LDX Level_Tile_Quad+1,Y	; Get this particular "quad" (0-3) index
	LDA Level_Tile_GndR,Y		; Check the tile here
	CMP Tile_AttrTable+4,X
	BGE PRG008_B5D0			; If the tile is >= the attr value, jump to PRG008_B5D0 (NOTE: Carry set when true)

	LDX Level_Tile_Quad,Y		; Get this particular "quad" (0-3) index
	LDA Level_Tile_GndL,Y		; Check the tile here
	CMP Tile_AttrTable+4,X		; Set carry if tile is >= the attr value

PRG008_B5D0:

	; NOTE: The return value is "carry set" for true!

	RTS		 ; Return


	; Handle all common special tiles (ice blocks, P-Switches, bump blocks, etc.)
	; Does not include things like instant-kill lava tiles...
Level_DoCommonSpecialTiles:
	TYA		 ; A = Y (offset into TileAttrAndQuad_OffsSloped)
	PHA		 ; Save it

	LDY Player_Kuribo
	BNE PRG008_B604	 ; If Player is in Kuribo's shoe, jump to PRG008_B604

	LDY Level_Tileset
	CPY #9
	BNE PRG008_B604	 ; If Level_Tileset <> 9 (Desert), jump to PRG008_B604

	LDA #TILE9_DIGSAND
	CMP Level_Tile_GndL,X
	BNE PRG008_B604	 ; If Player is not touching an ice block, jump to PRG008_B604
 
	; SB: This code just makes digging in sand annoying, so fuck it
 
	;LDA <Player_X
	;ADD #5
	;AND #$0F
	;CMP #9
	;BGE PRG008_B604	 ; If Player is not centered enough, jump to PRG008_B604
 
	LDA <Player_XVel
	BNE PRG008_B604	; If player is moving horizontally, jump to PRG008_B604
 
	; Player is touching an ice block...
	BIT <Pad_Input
	BVC PRG008_B604	 ; If Player is not pushing 'B', jump to PRG008_B604

	CPX #$02
	BGE PRG008_B604	 ; If tile in front of Player, jump to PRG008_B604

	LDA Level_ChgTileEvent
	BNE PRG008_B604	 ; If Level_ChgTileEvent <> 0 (tile change already queued), jump to PRG008_B604

	; Otherwise...

	LDA #$01
	STA Player_DisTailAtk	 ; Disable any tail attacking

	LDA #CHNGTILE_DELETETOBG
	JSR Level_QueueChangeBlock	 ; Queue a block change to erase to background!

	TXA
	PHA		 ; Save 'X' (current tile index) 

	JSR Level_DigSand_Poof ; Grab a new ice block object!  (If there's room)

	PLA		 ; Restore current tile index -> 'A'
	TAX		 ; X = A


	JMP PRG008_B652	 ; Jump to PRG008_B652

PRG008_B604:

	; Not an ice block or if it was, Player was not interested in it...
	LDA Level_Tile_GndL,X

	LDY <Map_EnterViaID
	CPY #MAPOBJ_PURPLECOMET
	BNE LDCST_NotPurpleComet	; If Purple Comet not active, jump to LDCST_NotPurpleComet

	; Purple Comet Active! Accept TILEA_PURPLECOIN as coin...
	CMP #TILEA_PURPLECOIN
	BNE LDCST_NotPurpleComet	; If not a purple coin, jump to LDCST_NotPurpleComet
	
	; Otherwise...
	BEQ LDSCT_PurpleCoin

LDCST_NotPurpleComet:
	CMP #TILEA_COIN
	BNE PRG008_B623	 ; If Player is not touching coin, jump to PRG008_B623

LDSCT_PurpleCoin:
	LDA #CHNGTILE_DELETECOIN
	JSR Level_QueueChangeBlock	 ; Queue a block change to erase to background!
	JSR Level_RecordBlockHit	 ; Record having grabbed this coin so it does not come back

	; Play coin collected sound!
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1

	LDA #$00
	STA Level_Tile_GndR	; Clear this tile detect (probably to prevent "double collecting" a coin the Player is straddling)

	JMP PRG008_B652	 ; Jump to PRG008_B652

PRG008_B623:

	; Player not touching coin...

	CMP #TILEA_PSWITCH
	BNE PRG008_B64F	 ; If Player is not touching P-Switch, jump to PRG008_B64F

	; Player touching P-Switch...

	CPX #$02
	BGS PRG008_B64F	 ; If it is being detected by Player's head, then jump to PRG008_B64F (don't hit with head!)

	LDA #CHNGTILE_PSWITCHSTOMP	; P-Switch hit tile change

	CMP Level_ChgTileEvent
	BEQ PRG008_B64F	 ; If we've already got a tile change in the queue, jump to PRG008_B64F

	; Queue tile change 9!
	JSR Level_QueueChangeBlock

	LDA Level_7Vertical
	BNE PSwitch_NoVibe	; Vibration effect doesn't work right in vertical

	LDA #$10
	STA Level_Vibration	; Level_Vibration = $10 (little shake effect)

PSwitch_NoVibe:
	; Wham! sound effect
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA #$DF
	STA Level_PSwitchCnt	 ; Level_PSwitchCnt = $DF (duration of switch; RAS)

	; Play P-Switch song
	LDA #MUS2B_PSWITCH
	STA Sound_QMusic2

	JMP PRG008_B652	 ; Jump to PRG008_B652

PRG008_B64F:
	CPX #$02
	BGS Collect_CheckStarCoin	 ; If it is being detected by Player's head, then jump to Collect_CheckStarCoin (don't hit with head!)

	; Only going to check tiles at player's head continuing...

	LDY Level_ActSwAction
	BNE Collect_CheckStarCoin	; If we've already got an action switch in progress, jump to Collect_CheckStarCoin

	LDY Level_Tileset
	CPY #8
	BNE Collect_CheckActionSwitch	; If not tileset 8 (Pipe Maze), jump to Collect_CheckActionSwitch

	CMP #TILE8_EXSWITCHR
	BNE Collect_CheckActionSwitch	; If not a reverse action switch, jump to Collect_CheckActionSwitch

	; Reverse action switch!
	LDA #CHNGTILE_PSWITCHSTOMPR	; Action Switch hit tile change
	BNE RActSw_Entry	; Jump (technically always) to RActSw_Entry

Collect_CheckActionSwitch:
	LDY Level_Tileset
	CPY #10
	BEQ Collect_CheckStarCoin	; If tileset 10 (Airship), jump to Collect_CheckStarCoin

	CMP #TILEA_EXSWITCH
	BNE Collect_CheckStarCoin ; If Player is not touching Action Switch, jump to Collect_CheckStarCoin

	; Player touching Action Switch...
	
	LDA #CHNGTILE_PSWITCHSTOMP	; Action Switch hit tile change

RActSw_Entry:
	LDY Level_ChgTileEvent
	BNE Collect_CheckStarCoin	 ; If we've already got a tile change in the queue, jump to Collect_CheckStarCoin

	; Queue tile change 9!
	JSR Level_QueueChangeBlock

	; Pressed sound effect
	LDA Sound_QMap
	ORA #SND_MAPPATHMOVE
	STA Sound_QMap

	JSR ExSwitch_Press

	JMP PRG008_B652	 ; Jump to PRG008_B652

ExSwitch_Press:
	; Queue switch action
	LDA Level_ActSwEvent
	STA Level_ActSwAction

	; Store coordinates
	LDA <Temp_Var13
	STA Level_ActSwYHi
	LDA <Temp_Var14
	STA Level_ActSwY

	; Store change X Hi and Lo
	LDA <Temp_Var15
	STA Level_ActSwXHi
	LDA <Temp_Var16	
	STA Level_ActSwX

	; Set to init state
	LDA #0
	STA Level_ActSwState

	; Store tile into Var3 by default
	LDA Level_Tile_GndL,X
	STA Level_ActSwVar3

	RTS

Collect_CheckStarCoin:
	; SB: Detect star coin
	LDY Level_Tileset
	SUB Level_StarCoinByTileset,Y	; Subtract star coin for THIS tileset
	CMP #3
	BGE CollectNotStarCoin	; If subtraction results in value greater than 2, jump to CollectNotStarCoin

	STA <Temp_Var3
	
	TXA
	PHA

	; Get Star coin!
	LDA <Temp_Var3
	JSR Player_GetStarCoinAndUpdate
	
	PLA
	TAX

	LDA #CHNGTILE_DELETECOIN
	JSR Level_QueueChangeBlock	 ; Queue a block change to erase to background!

	LDA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

	; 4000 points!  (400 = $190)
	LDA #$90
	STA Score_Earned
	LDA #$01
	STA Score_Earned+1

	BNE PRG008_B652	

CollectNotStarCoin:
	JSR Level_DoBumpBlocks	 ; Handle any bumpable blocks (e.g. ? blocks, note blocks, etc.)

PRG008_B652:
	PLA		 
	TAY		 ; Restore offset into TileAttrAndQuad_OffsSloped -> 'Y'

	RTS		 ; Return


Level_DigSand_Poof:
	JMP_THUNKC 30, Level_DigSand_Poof30


	; After a block is hit, it does the little bounce thing, and then 
	; a power up MAY come from it!  This defines which power-up will
	; appear, if any:
	; 0 = None, 1 = Mushroom/Flower, 2 = Mushroom/Leaf, 3 = Star, 4 = Coin, 5 = Coin/Star
	; 6 = brick behavior (i.e. bump/smash), 7 = Vine, 8 = 10 coin,  = 1-up, A = P-Switch
	; SB: 	C = Rabbit (??) Suit, D = Penguin (Peng??) Suit, E = Hammer Suit
	; LATP = Level_ActionTiles powerup
	; Note that this array should match elements with the LATR_'s below!
LATP_PowerUps:
LATP_GNote:	.byte $00
LATP_HNote:	.byte $00
LATP_Notes:	.byte $00, $01, $02, $03
LATP_Woodblocks:.byte $0C, $0D, $0E, $0F	; SB: These are additional [?] blocks now
LATP_QBlocks:	.byte $01, $02, $03, $04, $05, $04, $00, $06, $01, $02, $03, $04, $05, $08, $09, $07, $0A
LATP_InvisCoin:	.byte $04, $09, $00
LATP_InvisNote:	.byte $00
LATP_PWrksJct:	.byte $0B	; UNUSED breakable pipeworks junction tile!
LATP_End


	; After a block is hit, it does the little bounce thing, and then 
	; "restores" the tile which was previously there; this defines what
	; tile that is exactly...
	;
	; NOTE: This does not fix the attribute colors (immediately), so
	; you shouldn't mix and match differently palettized blocks!
	;
	; $10 - Coin Heaven note block
	; $20 - "Metal plate" post-? block hit
	; $30 - Empty brick
	; $40 - Generic note block
	; $50 - Wood block
	; $60 - Brick (with coins)
	; $70 - ??

	; LATR = Level_ActionTiles restore
	; Note that this array should match elements with the LATP_'s above!
LATR_BlockResult:
LATR_GNote:	.byte $00
LATR_HNote:	.byte $10
LATR_Notes:	.byte $40, $40, $40, $40
LATR_Woodblocks:.byte $20, $20, $20, $20
LATR_QBlocks:	.byte $20, $20, $20, $20, $20, $20, $20, $30, $20, $20, $20, $20, $20, $60, $20, $20, $20
LATR_InvisCoin:	.byte $20, $20, $10
LATR_InvisNote:	.byte $40
LATR_PWrksJct:	.byte $70	; UNUSED breakable pipeworks junction tile!


	; This defines a "range" passed the base tile defined in Level_ActionTiles
	; where a related effect takes place; so see Level_ActionTiles for the bases!
Level_ActionTiles_Range:
	; Tiles activated anytime
	.byte (LATP_HNote - LATP_GNote), (LATP_Notes - LATP_HNote), (LATP_Woodblocks - LATP_Notes)

	; Tiles activated only when Player is moving upward
	.byte (LATP_QBlocks - LATP_Woodblocks), (LATP_InvisCoin - LATP_QBlocks), (LATP_InvisNote - LATP_InvisCoin), (LATP_PWrksJct - LATP_InvisNote)

	; And in the desert only... (UNUSED, would be a breakable tile in a pipeworks structure!)
	.byte (LATP_End - LATP_PWrksJct)


	; Offset fix applied to the selected "action tile" set
LATR_Off .func (\1 - LATR_GNote)
Level_ActionTiles_OffFix:
	; Tiles activated anytime
	.byte LATR_Off(LATR_GNote), LATR_Off(LATR_HNote), LATR_Off(LATR_Notes)

	; Tiles activated only when Player is moving upward
	.byte LATR_Off(LATR_Woodblocks), LATR_Off(LATR_QBlocks), LATR_Off(LATR_InvisCoin), LATR_Off(LATR_InvisNote)

	; And in the desert only... (UNUSED, would be a breakable tile in a pipeworks structure!)
	.byte LATR_Off(LATR_PWrksJct)


	; This defines the base tile index for "action tiles", tiles which, when the
	; Player hits them right, causes something to happen...
Level_ActionTiles:
	; Tiles activated anytime
	.byte TILEA_GNOTE, TILEA_HNOTE, TILEA_NOTE

	; Tiles activated only when Player is moving upward
	.byte TILEA_WOODBLOCKBOUNCE, TILEA_QBLOCKFLOWER, TILEA_INVISCOIN, TILEA_NOTEINVIS

	; And in the desert only... (UNUSED, would be a breakable tile in a pipeworks structure!)
	.byte TILE9_PIPEWORKS_JCT

	; Hit Enable bits specify whether blocks can be hit horizontally
	; vertically, or both!  While they can be somewhat refined to only
	; act on a particular detection "half", the typical use is:
	;	%0011 - Enable hitting from top and bottom
	;	%1100 - Enable hitting from left and right
	;	%1111 - Enable hitting in all directions
	; Note that certain tiles are just not checked by behavior noted
	; in the comments, e.g. to enable hitting ? blocks from the top,
	; the code must be reworked to not disable checking them if the 
	; Player is not moving upward!
Level_ActionTiles_HitEnable:
	; Tiles activated anytime
	.byte %1111, %1111, %1111

	; Tiles activated only when Player is moving upward
	.byte %0010, %0010, %0010, %0010

	; And in the desert only... (UNUSED, would be a breakable tile in a pipeworks structure!)
	.byte %0010


	; Bit set based on which index of the tile detection we're on;
	; matches up to the type of hit which will occur on the block!
Level_ActionTiles_TIHitBit:
	.byte %0001, %0010, %0100, %1000, %1111


	; Logic to handle "bump blocks", e.g. ? blocks, note blocks, etc.
Level_DoBumpBlocks:
	TYA		 
	PHA		 ; Save offset into TileAttrAndQuad_OffsSloped

	LDY #$02	 ; Y = 2 (by default, only consider first 3 tiles of Level_ActionTiles)

	CPX #$04
	BEQ PRG008_B6E4	 ; If tile index = 4, jump to PRG008_B6E4

	LDA <Player_YVel
	BPL PRG008_B6EF	 ; If Player is moving downward, jump to PRG008_B6EF

PRG008_B6E4:
	INY
	INY
	INY
	INY		 ; Y += 4 (consider next 4 tiles for moving upward)

	LDA Level_TilesetIdx
	CMP #$08	 
	BNE PRG008_B6EF	 ; If Level_TilesetIdx <> 8 (desert levels), jump to PRG008_B6EF
	INY		 ; Otherwise, Y += 1 (and in the desert only, the UNUSED breakable pipeworks tile)

PRG008_B6EF:
	LDA Level_Tile_GndL,X	 ; Get tile index
	SUB Level_ActionTiles,Y
	CMP Level_ActionTiles_Range,Y
	BCC PRG008_B701	 ; If the tile is in range, jump to PRG008_B701!

PRG008_B6FB:
	DEY		 ; Y--
	BPL PRG008_B6EF	 ; While Y >= 0, loop!
	JMP PRG008_B78B	 ; Otherwise, jump to PRG008_B78B

PRG008_B701:
	ADD Level_ActionTiles_OffFix,Y	 ; Add an offset fix to this tile
	STA <Temp_Var6		 ; -> Temp_Var6

	LDA Level_ActionTiles_TIHitBit,X	 ; Get bitfield value appropriate for this tile detect index
	AND Level_ActionTiles_HitEnable,Y	 ; Mask to check if this block should respond
	BEQ PRG008_B6FB	 ; If block does not respond to this hit, jump to PRG008_B6FB

	; Block's getting hit...!

	; Splash_DisTimer = $10 (disables water splahes briefly, probably to make sure it doesn't effect the bounce block sprites?)
	LDA #$10
	STA Splash_DisTimer

	LDY <Temp_Var6	 	; Y = Tile detected relative index with offset fix
	LDA LATP_PowerUps,Y	; Get appropriate power-up for this block
	JSR LATP_HandleSpecialBounceTiles	; Do what this special tile ought to do!
	TYA		 ; Power up result (if any) is in 'Y'!
	BNE PRG008_B722	 ; If there's a powerup to spawn, jump to PRG008_B722

	JMP PRG008_B78B	 ; Otherwise, jump to PRG008_B78B

PRG008_B722:
	BMI PRG008_B74A	 ; If Y = $80, a brick was busted!  Jump to PRG008_B74A

	LDY <Temp_Var6	 ; Y = Tile detected relative index with offset fix
	ORA LATR_BlockResult,Y	 ; Get block which should result
	STA Player_Bounce	 ; Indicate to Player he should bounce

	; Play bump sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	LDA #CHNGTILE_DELETETOBG
	STA <Temp_Var12	 ; Temp_Var12 = CHNGTILE_DELETETOBG

	CPX #$02
	BLS PRG008_B74A	 ; If tile detected index < 2, jump to PRG008_B74A

	LDY #$02	 ; Y = 2 (bounce left)

	LDA <Player_X
	AND #$0f	 ; Tile relative X
	CMP #$08
	BLS PRG008_B747	 ; If Player was on the left half of the block, jump to PRG008_B747

	INY		 ; Otherwise Y = 3 (bounce right)

PRG008_B747:
	JMP PRG008_B75B	 ; Jump to PRG008_B75B

PRG008_B74A:
	LDY #$00	 ; Y = 0 (bounce down)
	LDA Level_SlopeEn
	BEQ PRG008_B756	 ; If not a sloping level, jump to PRG008_B756

	TXA		 
	BEQ PRG008_B75B	 ; If tile detect index = 0, jump to PRG008_B75B (keeps Y = 0)
	BNE PRG008_B75A	 ; Otherwise, jump to PRG008_B75A (sets Y = 1)

PRG008_B756:
	LDA <Player_YVel
	BPL PRG008_B75B	 ; If Player not moving upward, jump to PRG008_B75B (keeps Y = 0)

PRG008_B75A:
	INY		 ; Y = 1 (bounce up)

PRG008_B75B:

	STY Player_BounceDir	 ; Set Player bounce direction

	LDY #$06	; Y = 6

	LDA Objects_State,Y
	BEQ PRG008_B766	 ; If this object is dead/empty, jump to PRG008_B766
	INY		 ; Y++

PRG008_B766:

	; Align Y lo to tile grid
	LDA <Temp_Var14
	AND #$F0
	STA <Temp_Var14
	STA Objects_Y,Y	 ; Store into object slot

	LDA <Temp_Var13
	STA Objects_YHi,Y ; Store Y Hi into object slot

	LDA <Temp_Var15	
	STA Objects_XHi,Y ; Store X Hi into object slot

	LDA <Temp_Var16
	STA Objects_X,Y	 ; Store X Lo into object slot

	JSR BlockBump_Init	; Init the block bump effect!

	LDA Player_BounceDir
	BEQ PRG008_B78B	 ; If Player_BounceDir = 0 (bounce up), jump to PRG008_B78B

	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars	 ; Change tile (in grid memory, not immediate display)

PRG008_B78B:
	PLA		 ; Restore offset into TileAttrAndQuad_OffsSloped
	TAY		 ; -> 'Y'

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LATP_HandleSpecialBounceTiles
;
; Ever wondered where the code was that makes ? blocks emerge 
; powerups, music note blocks bounce you around, and bricks bust?
; Well, here it is!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LATP_HandleSpecialBounceTiles:
	STA <Temp_Var1	 ; Backup power-up request -> Temp_Var1 
	CMP #$0F	; [!]-like
	BNE LATP_NotExSwLike
	
	; Can't let this happen if action is occurring...
	LDA Level_ActSwAction
	BNE PRG008_B7B7		; If action is occuring, cancel, jump to PRG008_B7B7
	
LATP_NotExSwLike:
	LDA Player_Bounce
	BNE PRG008_B7B7	 ; If Player is already in a bounce, jump to PRG008_B7B7

	LDY #$06	 ; Y = 6 (object slot index)
	LDA Objects_State,Y	; Check this object's state
	ORA Level_BlkBump	; And block bump 1...
	BEQ PRG008_B7A7	 	; If item is "dead/empty" and block bump 1 isn't in use, jump to PRG008_B7A7

	LDA Objects_State+1,Y ; Check next object's state
	ORA Level_BlkBump+1  ; And block bump 2...
	BNE PRG008_B7B7	 	; If item is NOT "dead/empty" or block bump 2 is in use, jump to PRG008_B7B7

PRG008_B7A7:
	LDY #$05	 ; Y = 5 (object slot index)

	LDA Objects_Timer,Y
	BEQ PRG008_B7BA	 ; If timer expired, jump to PRG008_B7BA

	LDA <Temp_Var16	 ; Player detect X low
	AND #$F0	 ; Aligned to tile grid
	CMP Objects_X,Y	 
	BNE PRG008_B7BA	 ; If this object's X does not match the aligned detect X, jump to PRG008_B7BA

PRG008_B7B7:
	LDY #$00	 ; Y = 0 (no space for bounce object found)

 
	RTS		 ; Return


PRG008_B7BA:

	; Align X Detect low to tile grid
	LDA <Temp_Var16
	AND #$F0
	STA <Temp_Var16

	LDA <Temp_Var1	 ; Get power-up value
	ASL A		 ; Make into 2-byte index
	TAY		 ; -> 'Y'

	; Load jump address as per block tile type...
	LDA LATP_JumpTable,Y
	STA <Temp_Var1	
	LDA LATP_JumpTable+1,Y
	STA <Temp_Var2	

	JMP [Temp_Var1]	 ; Handle special block!

LATP_JumpTable:
	.word LATP_None		; 0 = None
	.word LATP_Flower	; 1 = Mushroom/Flower
	.word LATP_Leaf		; 2 = Mushroom/Leaf
	.word LATP_Star		; 3 = Star
	.word LATP_Coin		; 4 = Coin
	.word LATP_CoinStar	; 5 = Coin/Star
	.word LATP_Brick	; 6 = Standard brick behavior
	.word LATP_Vine		; 7 = Vine
	.word LATP_10Coin	; 8 = 10 coin
	.word LATP_1up		; 9 = 1-up
	.word LATP_PSwitch	; A = P-Switch
	.word LATP_BrickAltClear; B = Brick which clears to alternate tile when smashed
	.word LATP_ExtPowerUp	; C = Penguin (TEMP)
	.word LATP_ExtPowerUp	; D = Rabbit
	.word LATP_ExtPowerUp	; E = Hammer
	.word LATP_LikeExSwitch	; F = Like hitting an [!] switch (multipurpose)

LATP_None:
	LDY #1		; Y = 1 (spawn .. nothing?) (index into PRG001 Bouncer_PUp)
	RTS		 ; Return

LATP_Flower:
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDY #$05	 ; Y = 5 (spawn a mushroom) (index into PRG001 Bouncer_PUp)

	LDA <Player_Suit
	BEQ PRG008_B7F9	 ; If Player is small, jump to PRG008_B7F9

	LDY #$02	 ; Y = 2 (spawn a fire flower) (index into PRG001 Bouncer_PUp)

PRG008_B7F9:
	RTS		 ; Return


LATP_Leaf:
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDY #$05	 ; Y = 5 (spawn a mushroom) (index into PRG001 Bouncer_PUp)

	LDA <Player_Suit
	BEQ PRG008_B807	 ; If Player is small, jump to PRG008_B807

	LDY #$03	 ; Y = 3 (spawn a leaf) (index into PRG001 Bouncer_PUp)

PRG008_B807:
	RTS		 ; Return

LATP_Star:
	LDA #$80
	STA PUp_StarManFlash	 ; PUp_StarManFlash = $80 (activate star man flash)

	LDY #$04	 ; Y = 4 (spawn a starman) (index into PRG001 Bouncer_PUp)

	RTS		 ; Return

LATP_ExtPowerUp:
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDA <Player_Suit
	BEQ LATP_ExtPowerUp_Sm	 ; If Player is small, jump to LATP_ExtPowerUp_Sm


	TYA	; 'Y' -> 'A'
	LSR A	; Return to index value
	SUB #4	; Base at 8
	TAY	; Y = 8 to 10 (spawn a suit) (index into PRG001 Bouncer_PUp)

	SUB #7	; Base 1-3
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 1 to 3 (trigger super suit)

	RTS		 ; Return

LATP_ExtPowerUp_Sm:
	LDY #$05	 ; Y = 5 (spawn a mushroom) (index into PRG001 Bouncer_PUp)
	RTS


LATP_Coin:
	JSR LATP_CoinCommon	 ; Do common "power up" coin routine

	LDY #$01	 ; Y = 1 (spawn a coin) (index into PRG001 Bouncer_PUp, i.e. nothing)

	LDA <Temp_Var16
	ORA <Temp_Var15	; Regenerate 10 coin block ID
	CMP B10Coin_ID
	BNE PRG008_B82F	; If this is a DIFFERENT coin block than the last one we started, jump to PRG008_B82F (RTS)

	LDA B10Coin_Timer
	BEQ PRG008_B82F	; In any case, if a 10 coin timer is not still on, jump to PRG008_B82F (RTS)

	LDA B10Coin_Count
	BMI PRG008_B82F	; If you've already got 10 coins (ideally), jump to PRG008_B82F (RTS)

	DEC B10Coin_Count	 ; B10Coin_Count--

	LDA #$17
	STA <Temp_Var6	 ; Temp_Var6 = $17

PRG008_B82F:
	RTS		 ; Return

LATP_CoinStar:
	LDA #$80
	STA PUp_StarManFlash	 ; Get that Starman flash ready just in case...

	LDY #$04	 	; Y = 4 (spawn a starman) (index into PRG001 Bouncer_PUp)

	LDA Player_StarInv
	BNE PRG008_B83F	 ; If Player if invincible, jump to PRG008_B83F!

	; Otherwise, sorry, just a coin :(
	JMP LATP_Coin

PRG008_B83F:
	RTS		 ; Return

LATP_Brick:
	JSR LATP_GetCoinAboveBlock	; Get coin above block, if any

	CPX #$04
	BEQ PRG008_B84E	 ; If on tile check index 4 (tail attack's tile), jump to PRG008_B84E (bust brick!)

	LDA <Player_Suit
	BNE PRG008_B84E	 ; If Player is not small, jump to PRG008_B84E (bust brick!)

	LDY #$01	 ; Y = 1 (spawn a coin) (index into PRG001 Bouncer_PUp, i.e. nothing)

	RTS		 ; Return

PRG008_B84E:
	; Crumbling sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; If a brick is busting in slot 1, move it to slot 2

	LDA #$02
	STA BrickBust_En	 ; Set brick bust enable

	; Y
	LDA <Temp_Var14
	AND #$F0
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr	 ; Store upper brick segment Y

	ADD #$08
	STA BrickBust_YLwr	 ; Store lower brick segment Y

 	; X
	LDA <Temp_Var16
	SUB <Horz_Scroll
	STA BrickBust_X	 ; Store X base coordinate

	LDA #$00	 
	STA BrickBust_XDist	 ; Reset X fan out distance
	STA BrickBust_HEn	 ; Reset horizontal enablers

	LDA #-6	 
	STA BrickBust_YVel	 ; Y velocity = -6

	LDA #$01	
	STA Score_Earned	 ; 10 points!

	LDY #CHNGTILE_DELETETOBG
	STY <Temp_Var12		 ; Temp_Var12 = CHNGTILE_DELETETOBG

	LDY #$80	 	; Y = $80
	RTS		 ; Return

LATP_Vine:
	LDY #$00	 ; Y = 0 (??)

	; Vine raise sound!
	LDA Sound_QLevel1
	ORA #SND_LEVELVINE
	STA Sound_QLevel1

	LDY #$06	 ; Y = 6 (vine) (index into PRG001 Bouncer_PUp)
	RTS		 ; Return

LATP_10Coin:
	LDA <Temp_Var16
	ORA <Temp_Var15
	STA B10Coin_ID	 ; X & Y are merged into a sort of unique ID for this block

	LDA #$09
	STA B10Coin_Count ; Set coin counter to 9

	LDA #200
	STA B10Coin_Timer ; B10Coin_Timer = 200

	JMP LATP_Coin	; Jump to common coin routine...

LATP_1up:
	JSR Level_RecordBlockHit	 ; Record having grabbed this 1-up so it does not come back

	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDY #$07	 ; Y = 7 (1-up) (index into PRG001 Bouncer_PUp)

	RTS		 ; Return

LATP_PSwitch:
	LDY #$05	 ; Y = 5

PRG008_B8BE:
	LDA SpecialObj_ID,Y
	BEQ PRG008_B8C9	 ; If this is a free spawn event slot, jump to PRG008_B8C9
	DEY		 ; Y--
	BPL PRG008_B8BE	 ; While Y >= 0, loop!
	JMP PRG008_B8D3	 ; Jump to PRG008_B8D3

PRG008_B8C9:
	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y	 ; Special object "poof"
	LDA #$20	 
	STA SpecialObj_Data,Y	 ; Used as "counter" while poof is in effect

PRG008_B8D3: 
	LDA <Temp_Var14	 ; Get Y Low
	AND #$F0	 ; Align to tile grid
	SUB #16		 ; Above hit tile
	PHP		 ; Save processor status

	CPY #$00
	BLS PRG008_B8E2	 ; If index < 0, then we don't have a special object, and skip setting Y Lo

	STA SpecialObj_YLo,Y	 ; Otherwise, store Y Lo

PRG008_B8E2:
	STA Level_BlockChgYLo	 ; Store block change Y low coord
	PLP		 ; Restore processor status

	LDA <Temp_Var13	 ; Get Y high
	SBC #$00	 ; Apply carry as necessary from previous subtraction

	CPY #$00	 
	BLS PRG008_B8F1	 ; If index < 0, then we don't have a special object, and skip setting Y Hi
	STA SpecialObj_YHi,Y	 ; Otherwise, store Y Hi

PRG008_B8F1:
	STA Level_BlockChgYHi	 ; Store block change Y high coord

	LDA <Temp_Var16	 ; Get X Low

	CPY #$00
	BLS PRG008_B8FD	 ; If index < 0, then we don't have a special object, and skip setting X Lo
	STA SpecialObj_XLo,Y	 ; Otherwise, store X Lo

PRG008_B8FD:
	STA Level_BlockChgXLo	 ; Store block change X low coord

	LDA <Temp_Var15		 ; Get X Hi
	STA Level_BlockChgXHi	 ; Store block change X high coord

	LDA #CHNGTILE_PSWITCHAPPEAR	 
	STA Level_ChgTileEvent	 ; Queue P-Switch appear!

	LDY #$01	 ; Y = 1 (index into PRG001 Bouncer_PUp, i.e. nothing)
	RTS		 ; Return

LATP_BrickAltClear:
	JSR LATP_Brick	 ; Act like a brick!  ('A' = 0 when small)
	BEQ PRG008_B916	 ; If Player is small, then do nothing...

	LDA #CHNGTILE_DELETETOBGALT
	STA <Temp_Var12	 ; Temp_Var12 = 12

PRG008_B916:
	RTS		 ; Return

LATP_CoinCommon:
	INC Coins_Earned ; One more coin earned
	INC Coins_ThisLevel	 ; One more coin earned this level

	; Y Lo - into Temp_Var1
	LDA <Temp_Var14	
	STA <Temp_Var1	

	; X Lo - center it up, shove into Temp_Var2
	LDA <Temp_Var16
	ORA #$04
	STA <Temp_Var2

	JMP PRG000_C49B	 ; Jump to PRG000_C49B (common "power up" coin entry)


	; Special routine which gets a coin above a ? block, if one is present!
LATP_GetCoinAboveBlock:
	; SB: Bug: If you bump a P-Switch induced "temporary brick" beneath
	; another temporary brick, you'll get a "coin" (because they really
	; are still coin blocks!)  This worked in original SMB3 as well.  In
	; any case, if P-Switch is active, cancel this logic!
	LDA Level_PSwitchCnt
	BNE GCAB_PSwitch_Cancel

	LDA <Temp_Var14
	PHA		 ; Save Temp_Var14 (Y Lo)
	SUB #16	
	STA <Temp_Var14	 ; Temp_Var14 -= 16 (get tile above)

	STX <Temp_Var5	 ; Backup X into Temp_Var5
	JSR Player_GetTileAndSlope_Normal	 ; Get a tile here
	LDX <Temp_Var5	 ; Restore X into Temp_Var5

	CMP #TILEA_COIN
	BNE PRG008_B948	 ; If tile above is not a coin, jump to PRG008_B948

	; Tile above was a coin...
	; The following will collect the coin along with the ? block hit!

	LDA #CHNGTILE_DELETETOBG
	JSR Level_QueueChangeBlock	; Delete to background

	PLA		 
	STA <Temp_Var14		 ; Restore Temp_Var14
	JMP LATP_CoinCommon	 ; Jump to common coin routine

PRG008_B948:
	PLA		 
	STA <Temp_Var14	 ; Restore Temp_Var14

GCAB_PSwitch_Cancel:
	RTS		 ; Return


LATP_LikeExSwitch:
	LDY #1
	JSR ExSwitch_Press
	RTS


Player_TailAttack_Offsets: ; (Y and X)
	.byte 28, -6	; Player not horizontally flipped
	.byte 28, 21	; Player horizontally flipped

	; SB: New reverse gravity offsets
	.byte 4, -6	; Player not horizontally flipped
	.byte 4, 21	; Player horizontally flipped

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_TailAttack_HitBlocks
;
; Short routine that handles the tail attack hitting blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_TailAttack_HitBlocks:
        LDA Player_TailAttack
        CMP #$09
        BNE PRG008_B979        ; If Player_TailAttack <> 9, jump to PRG008_B979

        LDY #$00         ; Y = 0 (Player not flipped)

	LDA <Player_FlipBits
	BNE PRG008_B95F	 ; If Player is horizontally flipped, jump to PRG008_B95F

	LDY #$02	 ; Y = 2 (Player flipped)

PRG008_B95F:

	LDA Player_ReverseGrav
	BEQ Player_TailAtk_NoRev

	INY
	INY
	INY
	INY	; Y += 4

Player_TailAtk_NoRev:
	LDA Player_TailAttack_Offsets,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)
	LDA Player_TailAttack_Offsets+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)

	JSR Player_GetTileAndSlope	 ; Get tile near tail

	LDX #$04	 
	STA Level_Tile_GndL,X	 ; Store into tail's special slot
	JSR Level_DoBumpBlocks	 ; Handle blocks that can be "bumped"

	LDA #$01
	STA Player_BounceDir	 ; Player_BounceDir = 1 (bounced sideways)

PRG008_B979:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_BumpOffBlocks
;
; Handle a kicked shelled object bouncing off blocks.  Modifies
; Level_Tile_Whack as part of the logic (i.e. like the Player
; tail-attacked whatever block got hit) 
; A = input detected tile by kicked shelled object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_BumpOffBlocks:
	LDX #$04	 ; X = 4 
	STA Level_Tile_GndL,X	 ; Essentially store into Level_Tile_Whack
 
	LDA Player_Bounce 
	BNE PRG008_B9D3	 ; If Player is bouncing, jump to PRG008_B9D3 
 
	JSR Level_DoBumpBlocks	 ; Have kicked object hit bumpable blocks

	LDA Player_Bounce 
	BEQ PRG008_B994	 ; If block is NOT a bouncing type, jump to PRG008_B994  

	; Set bounce direction and flag that it was an object that bounced
	LDA #$01 
	STA Player_BounceDir 
	STA Player_BounceObj 

PRG008_B994:
	LDA Level_TilesetIdx
	CMP #10
	BNE PRG008_B9D3	 ; If Level_TilesetIdx <> 10 (Giant World), jump to PRG008_B9D3 (RTS)
 
	LDX #$04	 ; X = 4 

	LDA Objects_Timer,X 
	BNE PRG008_B9D3	 ; If this object's timer is NOT expired, jump to PRG008_B9D3

	; Object's YHi = Temp_Var13 (aligns to initiator's tile detect Y Hi) 
	LDA <Temp_Var13	 
	STA <Objects_YHi,X

	; Object's Y = Temp_Var14 - 16 (aligns to one tile above the initator's tile detect Y)
	LDA <Temp_Var14 
	SUB #16 
	BCS PRG008_B9AF 
	DEC <Objects_YHi,X	; Apply carry if needed
PRG008_B9AF: 
	AND #$e0	 ; Keep value sane 
	ORA #$10	 
	STA <Objects_Y,X
 
	; Object's XHi = Temp_Var15 (aligns to initiator's tile detect X Hi) 
	LDA <Temp_Var15	 
	STA <Objects_XHi,X

	; Object's X = Temp_Var16 (aligns to initator's tile detect X)
	LDA <Temp_Var16 
	AND #$e0	 ; Keep value sane 
	STA <Objects_X,X 

	SUB <Horz_Scroll 
	TAY		 ; Y = screen scroll relative X
 
	LDA <Objects_XHi,X 
	SBC <Horz_Scroll_Hi 
	BNE PRG008_B9D3	 ; If Object is not on same screen, jump to PRG008_B9D3 (RTS)
 
	CPY #224
	BGE PRG008_B9D3	 ; If object X is further than screen coordinate 224, jump to PRG008_B9D3 (RTS)  

	; Set object's Var2 to object detected by Player's tail attack
	LDA Level_Tile_Whack 
	STA Objects_Var2,X 

PRG008_B9D3:
	RTS		 ; Return

PRG008_BA58_fix:
	JMP PRG008_BA58

	; "Slope correction" values; as Player transitions from one slope tile to the next,
	; slight Player_Y correction is needed to keep him on track.  The left value pairs
	; are for when moving up a slope, the right pair is for when moving down a slope.
	; Thus -1 to bump up to then next tile going up, or +16 to bump down when going down
Slope_CorrectH:	.byte $FF, $00
Slope_CorrectL:	.byte -1, 16

PRG000_B9D8:	; <-- go back up from here

        LDY #(TileAttrAndQuad_OffsSloped_Sm - TileAttrAndQuad_OffsSloped) + 6         ; Y = $16 (Player small or ducking)

        LDA Player_IsDucking 
        BNE PRG008_B9E5  ; If Player is ducking, jump to PRG008_B9E5

        LDA <Player_Suit
        BEQ PRG008_B9E5  ; If Player is small, jump to PRG008_B9E5
 
	LDY #$06	 ; Y = $06 (Player not small, not ducking; 6 because of 3 * 2 = 6, based on X = 3 down below)

PRG008_B9E5:

	; SB: Switch to reverse gravity offsets if needed
	LDA Player_ReverseGrav
	BEQ Player_TileSlope_NoRev

	TYA
	ADD #(TileAttrAndQuad_OffsSloped_Rev - TileAttrAndQuad_OffsSloped)
	TAY

Player_TileSlope_NoRev:

	LDA <Player_X
	AND #$0f	 ; offset within tile column
	CMP #$08	 
	BPL PRG008_B9F2	 ; If Player is >= halfway across current tile, jump to PRG008_B9F2

	; Player is on left half of tile
	TYA		 
	ADD #$08
	TAY		 ; Y += 8	 

PRG008_B9F2:
	LDX #$03	 ; X = 3 (reason for +6 init to 'Y')

	; This loop handles detecting tiles at or near a detection point
	; Makes tile detection just a little fuzzier for sake of the Player
PRG008_B9F4:
	JSR Player_GetTileSlopeAndQuad	 ; Get quadrant and tile attribute info
	JSR Level_DoCommonSpecialTiles	 ; Handle any common special tiles

	DEY
	DEY		 ; Y -= 2

	DEX		 ; X--
	BPL PRG008_B9F4	 ; While X >= 0, loop!


	LDX #$00	 ; X = 0 (slope at feet)

	LDY #$00	 ; Y = 0 

	LDA Level_Tile_Slope,X	 ; Get this slope "shape"

	CMP #$04
	BEQ PRG008_BA58_fix	 ; If slope "shape" = 4 (wall), jump to PRG008_BA58

	; SB: If Player is reversed gravity, "unsloped ceiling" (8) is actually our
	; "unsloped floor", so we need to check 7 instead...

	PHA 	; Save slope shape value

	LDA Player_ReverseGrav
	BEQ Player_CeilChk_NoRev

	; Reverse check
	PLA	; Restore slope shape value

	CMP #$07 
	BEQ PRG008_BA58_fix  ; If slope "shape" = 7 (unsloped floor [ceiling in our case]), jump to PRG008_BA58

	BNE Player_CeilChk_Done	; Otherwise, jump to Player_CeilChk_Done

Player_CeilChk_NoRev:
	PLA	; Restore slope shape value

	CMP #$08
	BEQ PRG008_BA58_fix  ; If slope "shape" = 8 (unsloped ceiling), jump to PRG008_BA58

Player_CeilChk_Done:
	LDY <Player_InAir
	BNE PRG008_BA1B	 ; If Player is mid air, jump to PRG008_BA1B

	LDY Player_NoSlopeStick
	BNE PRG008_BA1B	 ; If Player_NoSlopeStick is set (don't stick to slopes), jump to PRG008_BA1B

	CMP #$00
	BEQ PRG008_BA4F	 ; If slope "shape" = 0 (BG tile), jump to PRG008_BA58

PRG008_BA1B:

	LDY #$00
	STY Player_NoSlopeStick ; Clear Player_NoSlopeStick

	INX	; X = 1 (slope at head)
	LDA Level_Tile_Slope,X	 ; Get this slope "shape"

	; SB: If Player is reversed gravity, "unsloped floor" (7) is actually our
	; "unsloped ceiling", so we need to check 8 instead...

	PHA 	; Save slope shape value

	LDA Player_ReverseGrav
	BEQ Player_FloorChk_NoRev

	; Reverse check
	PLA	; Restore slope shape value

	CMP #$08 
	BEQ PRG008_BA2C  ; If slope "shape" = 8 (unsloped ceiling [floor in our case]), jump to PRG008_BA2C

	BNE Player_FloorChk_Done	; Otherwise, jump to Player_FloorChk_Done

Player_FloorChk_NoRev:
	PLA	; Restore slope shape value

	CMP #$07
	BEQ PRG008_BA2C  ; If slope "shape" = 7 (unsloped ground, not square tiles), jump to PRG008_BA2C

Player_FloorChk_Done:

	CMP #$04	 
	BNE PRG008_BA77_fix	 ; If slope "shape" <> 4 (wall), jump to PRG008_BA77

PRG008_BA2C:
	; Note: Jump here for slope "shape" of 7 (unsloped ground) or 4 (wall)
	; Use for Player rubbing against sloped ceiling, specifically for the
	; "solid square" type of tiles listed above, "push" the Player completely
	; beneath the block so that he (crudely) tracks the ceiling slope

	; XX/
	; X/   <-- Where 'X' is e.g. a type 4 slope, Player is pushed to its
	; /        bottom, keep him at the ceiling and not creeping into it

	LDX <Player_Suit
	BEQ PRG008_BA38	 ; If Player is small, jump to PRG008_BA38

	LDX #$01	 ; X = 1

	LDA Player_IsDucking
	BEQ PRG008_BA38	 ; If Player is NOT ducking, jump to PRG008_BA38

	DEX		 ; Otherwise, X = 0

PRG008_BA38:

	LDA Player_ReverseGrav
	BEQ Player_CeilRub_NoRev

	; Subtract on reverse
	LDA <Player_Y
	SUB PlayerY_HeightOff,X ; Subtract appropriate offset based on ducking or not
	ADD #1
	AND #$0f	 ; Tile-relative vertical position
	STA <Temp_Var1

	LDA <Player_Y	 ; Add this with Player_Y
	SUB <Temp_Var1
	BCS PRG008_BA4A	 ; If no carry, jump to PRG008_BA4A

	DEC <Player_YHi	 ; Otherwise, apply carry

	JMP PRG008_BA4A

Player_CeilRub_NoRev:
	LDA <Player_Y
	ADD PlayerY_HeightOff,X ; Add appropriate offset to where the top of the Player's "head" should be
	JSR Negate	 ; Negate this value
	AND #$0f	 ; But keep only lower 4 bits (essentially, we calculated 15 - offset)
	ADD <Player_Y	 ; Add this with Player_Y
	BCC PRG008_BA4A	 ; If no carry, jump to PRG008_BA4A

	INC <Player_YHi	 ; Otherwise, apply carry

PRG008_BA4A:
	STA <Player_Y	 ; Update Player_Y

	JMP PRG008_BA69	 ; Jump to PRG008_BA69

PRG008_BA77_fix:
	JMP PRG008_BA77

PRG008_BA4F:

	; Note Y = 0 here

	LDA Player_ReverseGrav
	BEQ SlopeOffChk_NoRev

	; Reverse slope check
	LDA <Player_Y
	AND #$0f	 ; Tile row offset of Player Y
	CMP #6
	BGE PRG008_BA77	 ; If Player's row offset is greater-equal to 6, jump to PRG008_BA77
	BLS SlopeOffChk_Done	; Otherwise, jump to SlopeOffChk_Done

SlopeOffChk_NoRev:
	LDA <Player_Y
	AND #$0f	 ; Tile row offset of Player Y
	CMP #10
	BLS PRG008_BA77	 ; If Player's row offset is less than 10, jump to PRG008_BA77

SlopeOffChk_Done:
	INY		 ; Otherwise, Y = 1

PRG008_BA58:
	; Note: Direct jump on slope shapes 0 (BG tile), 4 (wall), and [8 ceiling normal / 7 floor reversed]
	; Used for corrections while Player runs along a slope

	LDA Player_ReverseGrav
	BEQ SlopeCorrect_NoRev

	; Reverse gravity correction
	LDA <Player_Y
	AND #$F0	 	; Tile grid aligned Y
	ADD #15			; Base at bottom of tile
	SUB Slope_CorrectL,Y	; Subtract appropriate offset based on Player's relative vertical position within tile
	STA <Player_Y		; Update Player Y

	; Apply carry as needed
	LDA <Player_YHi
	SBC Slope_CorrectH,Y
	STA <Player_YHi	

	JMP PRG008_BA69		; Jump to PRG008_BA69

SlopeCorrect_NoRev:

	LDA <Player_Y
	AND #$F0	 	; Tile grid aligned Y
	ADD Slope_CorrectL,Y	; Add appropriate offset based on Player's relative vertical position within tile
	STA <Player_Y		; Update Player Y

	; Apply carry as needed
	LDA <Player_YHi
	ADC Slope_CorrectH,Y
	STA <Player_YHi	

PRG008_BA69:

	; Get proper base offset into TileAttrAndQuad_OffsSloped for checking at Player's feet or head
	LDA Slope_ChkFeetOrHead,X	 ; X = 0 for floor, 1 for ceiling

	LDY <Player_Suit
	BEQ PRG008_BA73	 ; If Player is small, jump to PRG008_BA73

	ADD #(TileAttrAndQuad_OffsSloped_Sm - TileAttrAndQuad_OffsSloped)	; Otherwise, add 16 to height at this point on slope (NOTE: Ducking included!)

PRG008_BA73:

	; SB: Switch to reverse gravity offsets if needed
	LDY Player_ReverseGrav
	BEQ Player_TileSlopeHF_NoRev

	ADD #(TileAttrAndQuad_OffsSloped_Rev - TileAttrAndQuad_OffsSloped)

Player_TileSlopeHF_NoRev:

	TAY		 ; Y = A
	JSR Player_GetTileSlopeAndQuad	 ; Get quadrant and tile attribute info

PRG008_BA77:
	; Note: Jump here for something not an unsloped floor or wall
	; Generally all paths drop you here...

	LDY #$02	 ; Y = 2 (checking "in front" tiles, lower and upper)
	JSR Level_CheckGndLR_TileGTAttr
	BCC PRG008_BABC	 ; If not touching a solid tile, jump to PRG008_BABC

	LDA Player_LowClearance
	BNE PRG008_BABC	 ; If Player_LowClearance is set, jump to PRG008_BABC

	LDX #$00	 ; X = 0
	LDY #$01	 ; Y = 0
	LDA <Player_X	
	AND #$0f	 
	CMP #$08
	BGS PRG008_BA92	 ; If Player is more than halfway across the tile, jump to PRG008_BA92

	; Otherwise...
	INX		 ; X = 1
	LDY #-1		 ; Y = -1

PRG008_BA92:
	LDA PRG008_B3B0,X ; Get appropriate offset
	ADD <Player_X	 ; Add Player_X
	AND #$0f	 ; Make tile relative
	BEQ PRG008_BABC	 ; If result = 0, jump to PRG008_BABC

	TYA
	BPL PRG008_BAA1	 ; If Y is not -1, jump to PRG008_BAA1

	DEC <Player_XHi	 ; Otherwise, Player_XHi--

PRG008_BAA1:
	ADD <Player_X	 ; Add Player_X to offset
	STA <Player_X	 ; Update Player_X

	BCC PRG008_BAAA	 ; If no carry, jump to PRG008_BAAA

	INC <Player_XHi	 ; Otherwise, apply carry

PRG008_BAAA:
	INY		 ; Y++ (0 or 1, depending)

	LDA <Player_XVel
	BPL PRG008_BAB1	 ; If Player is moving rightward, jump to PRG008_BAB1

	DEY		 
	DEY		 ; Y -= 2 (guarantees 'Y' is not zero)

PRG008_BAB1:
	TYA		 
	BNE PRG008_BABC	 ; If Y <> 0, jump to PRG008_BAB1

	; Player hit wall; stop!
	STA <Player_XVel
	STA Player_Slide
	INC Player_WalkAnimTicks

PRG008_BABC:
	LDX #$00	 ; X = 0
	LDY Level_Tile_Slope	 ; Y = Level_Tile_Slope (slope "shape" index at feet)
	LDA Slope_IsNotFloorShape,Y
	EOR Player_ReverseGrav		; SB: If reversed, floors are ceilings, and vice versa [some exceptions]
	BMI PRG008_BAC7	 ; If bit 7 set, force as floor, jump to PRG008_BAC7
	BEQ PRG008_BAC7	 ; If 0 (this is a floor slope tile), jump to PRG008_BAC7

	; We hit a ceiling type tile; set X = 1, so to check ceiling tiles
	INX	; X = 1

PRG008_BAC7:

	LDA <Player_X		 
	ADD TileAttrAndQuad_OffsSloped+1	; SB: Reverse gravity not needed here, though this is an evil hardcode
	AND #$0f	 
	STA <Temp_Var1		 ; Temp_Var1 = (Player_X + [TileAttrAndQuad_OffsSloped+1]) & $0F (offset locked across tile)

	LDA Level_Tile_Slope,X	; will be slope at feet or head, depending on 'X'
	TAY		; Y = slope "shape" index

	; Tile "shape" index values $1x will add 1 to Level_GndLUT_H
	; Because of 16 entries per tile in Slope_LUT
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ADD <Level_GndLUT_H
	STA <Level_GndLUT_H

	; Lower 4 bits of "shape" index value shifted up (so $0-$F * $10)
	; Because of 16 entries per tile in Slope_LUT
	TYA
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var1	; Apply existing offset across tile
	STA <Temp_Var1	; -> Temp_Var1 (now offset into Slope_LUT for specific height of slope)

	LDA Slope_PlayerVel_Effect,Y
	STA <Temp_Var16	 ; Temp_Var16 = effect on velocity by this slope

	LDY <Temp_Var1	 ; Y = Temp_Var1 (calculated height from slope)
	TXA		 ; A = 0 (floor slope tile) or 1 (non-floor slope tile)
	BNE PRG008_BAF4	 ; If non-floor slope, jump to PRG008_BAF4
	JMP PRG008_BB69	 ; Otherwise, jump to PRG008_BB69

PRG008_BAF4:

	; Non-floor slope...

	LDA Level_Tile_Slope+1	; Assumed since X = 1 anyway
	CMP #$00
	BNE PRG008_BB1B	 ; If slope tile at head <> 0 (BG tile), jump to PRG008_BB1B

	; Slope tile at head is a BG tile...

	LDA <Player_InAir
	BNE PRG008_BB1A	 ; If Player is mid air, jump to PRG008_BB1A (RTS)

	; This has to do with Player walking off an edge (e.g. cliff-like) on a sloped level
	; The tile being stepped off from does not necessarily need to be a slope-related tile.

	LDX #4		; X = 4
	LDY #(TileAttrAndQuad_OffsSlopeEdge - TileAttrAndQuad_OffsSloped)

	; SB: Switch to reverse gravity offsets if needed
	LDA Player_ReverseGrav
	BEQ Player_SlopeEdge_NoRev

	TYA
	ADD #(TileAttrAndQuad_OffsSlopeEdgR - TileAttrAndQuad_OffsSlopeEdge)
	TAY

Player_SlopeEdge_NoRev:

	LDA <Player_X	
	AND #$0f	
	CMP #$08	
	BGS PRG008_BB0D	 ; If Player is on right half of current tile, jump to PRG008_BB0D

	; Otherwise, Y += 2 (on left half)
	INY
	INY

PRG008_BB0D:
	JSR Player_GetTileSlopeAndQuad	 ; Get tile slope and quadrants
	CMP #$03	 
	BEQ PRG008_BB1A	 ; If slope = 3, jump to PRG008_BB1A (RTS)

	LDA #$00
	STA <Player_YVel	 ; Player_YVel = 0 (stop vertical movement)

	INC <Player_InAir	 ; Set Player in mid air!

PRG008_BB1A:
	RTS		 ; Return

PRG008_BB1B:

	; Player head ceiling tile check, not BG tile

	LDX <Player_Suit
	BEQ PRG008_BB27	 ; If Player is small, jump to PRG008_BB27

	LDX #$01	 ; X = 1

	LDA Player_IsDucking
	BEQ PRG008_BB27	 ; If Player is NOT ducking, jump to PRG008_BB27

	DEX		 ; X = 0 (they could've just put the duck check before X = 1, right?)
	
PRG008_BB27:

	; Ceiling slope impact

	; SB: Use "floor" slope if we're reverse gravity
	LDA Player_ReverseGrav
	BEQ Player_CeilSlope_NoRev

	; Use the "floor" component instead if we're flipped
	LDA [Level_GndLUT_L],Y
	AND #$0F			; Use "floor" part
	STA <Temp_Var2		; -> Temp_Var2 

	LDA <Player_Y		 ; Get Player Y
	SUB PlayerY_HeightOff,X	 ; Subtract appropriate offset based on ducking or not
	AND #$0f	 	; Make Y relative to current tile
	STA <Temp_Var1		 ; -> Temp_Var1

	SUB <Temp_Var2		; Note: Temp_Var2 (height on slope) minus Temp_Var1 (Player vert rel pos), reverse of "normal" case
	
	BMI PRG008_BB68	 ; If Temp_Var1 (relative vertical position on tile) < Temp_Var2 (height at this point on slope), jump to PRG008_BB68 (RTS)
	BPL Player_CeilSlope_Done	; Otherwise, jump to Player_CeilSlope_Done

Player_CeilSlope_NoRev:
	LDA <Player_Y		 ; Get Player Y
	ADD PlayerY_HeightOff,X	 ; Add appropriate offset based on ducking or not
	AND #$0f	 	; Make Y relative to current tile
	STA <Temp_Var1		 ; -> Temp_Var1

	LDA [Level_GndLUT_L],Y
	LSR A
	LSR A
	LSR A
	LSR A	; The upper 4 bits hold the ceiling slope height value, so need to shift right by 4
	STA <Temp_Var2		 ; ceiling slope height

	SUB <Temp_Var1
	BMI PRG008_BB68	 ; If Temp_Var1 (relative vertical position on tile) > Temp_Var2 (height at this point on slope), jump to PRG008_BB68 (RTS)

Player_CeilSlope_Done:

	INC Player_HitCeiling	 ; Flag Player as having hit head off this sloped ceiling

	PHA		 ; Save difference

	LDA <Player_YVel
	BPL PRG008_BB52	 ; If Player_YVel >= 0 (Player moving downward), jump to PRG008_BB52

	LDA Level_AScrlVVel	 ; Get autoscroll vertical velocity
	JSR Negate	 ; Negate it
	BPL PRG008_BB50	 ; If positive, jump to PRG008_BB50

	LDA #$00	 ; Otherwise, just set to zero

PRG008_BB50:
	STA <Player_YVel ; Store as Player's Y velocity

PRG008_BB52:

	LDY Level_Tile_Slope+1
	CPY #$03
	BNE PRG008_BB5F	 ; If Level_Tile_Slope+1 <> 3 (solid square tile), jump to PRG008_BB5F

	LDY Player_LowClearance
	BNE SlopeLowCeil_RTS	 ; If Player_LowClearance is set, jump to SlopeLowCeil_RTS (RTS)
	
PRG008_BB5F:

	; SB: Player offset must be applied the OTHER way (i.e. subtraction)
	LDA Player_ReverseGrav
	BNE Player_CeilSlopeOffset_Rev
	
	PLA		 ; Restore difference

	ADD <Player_Y	 
	STA <Player_Y	 ; Add to Player_Y

	BCC PRG008_BB68	 ; If no carry, jump to PRG008_BB68 (RTS)
	
	INC <Player_YHi	 ; Otherwise, apply carry!

PRG008_BB68:

	RTS		 ; Return

SlopeLowCeil_RTS:
	PLA		; Need to pop this lest we have a bad stack
	RTS

Player_CeilSlopeOffset_Rev:
	PLA		 ; Restore difference
	STA <Temp_Var1	; -> Temp_Var1

	LDA <Player_Y
	SUB <Temp_Var1
	STA <Player_Y	 ; Add to Player_Y

	BCS Player_CeilSlopeOffset_NC	 ; If no carry, jump to Player_CeilSlopeOffset_NC (RTS)

	DEC <Player_YHi	 ; Otherwise, apply carry!

Player_CeilSlopeOffset_NC:

	RTS		 ; Return


PRG008_BB69:

	; Player feet floor tile check

	LDX <Temp_Var16	 ; X = Temp_Var16 (effect on velocity by this slope)

	LDA <Player_Y
	STA <Temp_Var14
	LDA <Player_YHi
	STA <Temp_Var13

	LDA Level_32PPSlopeFlag
	BEQ L32PP_NoFlag

	; Use adjusted Player_Y
	LDA <Temp_Var14
	SUB <Vert_Scroll	; Make relative to Vertical Scroll
	STA <Temp_Var14
	LDA <Temp_Var13
	SBC #0
	STA <Temp_Var13

L32PP_NoFlag:

	LDA <Player_InAir
	BEQ PRG008_BB7E	 ; If Player is NOT mid air, jump to PRG008_BB7E

	; Player is mid air...

	LDA <Player_YVel
	CMP #-$1c
	BLS Player_FloorSlopeHChk_RTS	 ; If Player Y velocity < -$1C, jump to Player_FloorSlopeHChk_RTS (RTS)

	; Get difference between Player and ground slope height

	; SB: Use "ceiling" slope if we're reverse gravity
	LDA Player_ReverseGrav
	BEQ Player_FloorSlopeHChk_NoRev

	; Since we're using the ceiling values, we need to shift up the Player's tile-relative vertical
	; position (i.e. the lower 4 bits) so that we can do a proper subtraction comparison here...
	LDA <Temp_Var14
	ASL A
	ASL A
	ASL A
	ASL A
	CMP [Level_GndLUT_L],Y	 ; NOTE: This makes an assumption that the would-be floor component is always zero!! 
	BEQ PRG008_BB7E	 ; If 'A' (relative vertical position on tile) > (height at this point on slope), jump to PRG008_BB7E
	BLT PRG008_BB7E	 ; If 'A' (relative vertical position on tile) > (height at this point on slope), jump to PRG008_BB7E

Player_FloorSlopeHChk_RTS:

	RTS

Player_FloorSlopeHChk_NoRev:
	LDA <Temp_Var14
	AND #$0f		; Get Player's vertical position within tile
	SUB [Level_GndLUT_L],Y	 ; NOTE: This makes an assumption that the would-be ceiling component is always zero!! 
	BMI Player_FloorSlopeHChk_RTS	 ; If 'A' (relative vertical position on tile) > (height at this point on slope), jump to Player_FloorSlopeHChk_RTS (RTS)

PRG008_BB7E:
	LDA #$00
	STA <Player_InAir ; Player is no longer mid air!
	STA <Player_YVel  ; Player hit solid!
	STA Kill_Tally	  ; Reset Kill_Tally

	; Ground slope impact
	;LDA #2
	;STA Player_Slippery

	; SB: Use "ceiling" slope if we're reverse gravity
	LDA Player_ReverseGrav
	BEQ Player_FloorSlope_NoRev

	; Use the "ceiling" component instead if we're flipped
	LDA [Level_GndLUT_L],Y
	LSR A
	LSR A
	LSR A
	LSR A		; Upper 4 bits hold the "ceiling" version of the slope
	STA <Temp_Var1	 ; Temp_Var1 = fractional slope value

	JMP Player_FloorSlope_Store	; Jump to Player_CeilSlope_Store

Player_FloorSlope_NoRev:

	LDA [Level_GndLUT_L],Y
	AND #$0f		; Lower 4 bits hold ground slope height
	STA <Temp_Var1	 ; Temp_Var1 = fractional slope value

Player_FloorSlope_Store:
	LDA <Temp_Var14
	AND #$F0
	ADD <Temp_Var1	; Slope height adjustment
	;ADD Level_32PPSlopeFlag	; OLD EX
	STA <Temp_Var14	 ; Set Player's position on slope!

	BCC PRG008_BB9A	 ; If no carry, jump to PRG008_BB9A

	INC <Temp_Var13	 ; Otherwise, apply carry

PRG008_BB9A:
	TXA		 ; Effect on velocity -> 'A'
	BEQ PRG008_BBA1	 ; If none, jump to PRG008_BBA1

	; Otherwise...
	EOR <Player_XVel 
	AND #$80	 ; Sort of aboslute

PRG008_BBA1:
	STA Player_UphillFlag ; Set whether player is marching uphill!

	LDA Player_InWater
	BEQ PRG008_BBB0	 ; If Player is NOT underwater, jump to PRG008_BBB0

	LDA #$00
	STA Player_Slide ; Otherwise, stop sliding!

	BEQ PRG008_BC0D	 ; Jump (technically always) to PRG008_BC0D

PRG008_BBB0:
	TXA		 ; Effect on velocity -> 'A'

	LDY Player_Slide 
	BEQ PRG008_BBBF	 ; If Player is NOT sliding, jump to PRG008_BBBF

	; Get absolute value of slide
	BPL PRG008_BBBB	 
	JSR Negate 
PRG008_BBBB:

	CMP #$00
	BLS PRG008_BBFD	 ; If slide < 0, jump to PRG008_BBFD (should never happen because of absolute value??)

PRG008_BBBF:
	LDA Player_Slide
	BNE PRG008_BBE0	 ; If Player is sliding, jump to PRG008_BBE0

	; Check ability to slide

	TXA		 ; Effect on velocity -> 'A'
	BEQ PRG008_BC0D	 ; If no effect (flat ground), jump to PRG008_BC0D

	LDY <Player_Suit
	LDA PowerUp_Ability,Y
	AND #$02	 
	BNE PRG008_BC0D	 ; If the Player's suit CANNOT slide on slopes, jump to PRG008_BC0D

	LDA Player_Kuribo
	BNE PRG008_BC0D	 ; If Player is wearing Kuribo's shoe, jump to PRG008_BC0D

	LDA <Pad_Holding
	AND #(PAD_DOWN | PAD_LEFT | PAD_RIGHT)	; checking down/left/right
	CMP #PAD_DOWN	; but we only want down
	BNE PRG008_BC0D	 ; If NOT only pressing ONLY down, jump to PRG008_BC0D

	JSR PRG008_AEB6	 ; Set sliding frame

PRG008_BBE0:
	TXA		 ; Effect on velocity -> 'A'
	ADD Player_Slide
	STA Player_Slide ; Apply effect to Player_Slide

	; Absolute value of Player_Slide
	BPL PRG008_BBED	
	JSR Negate	
PRG008_BBED:

	CMP #$40
	BLS PRG008_BBFD	 ; If magnitude of Player_Slide < $40, jump to PRG008_BBFD

	; Player is sliding too fast!! 
	; If Player_Slide is negative, stop it at -$40, otherwise stop it at $40
	LDY #$40
	LDA Player_Slide
	BPL PRG008_BBFA
	LDY #-$40	
PRG008_BBFA:
	STY Player_Slide

PRG008_BBFD:
	DEC Player_Slide ; Player_Slide--
	BPL PRG008_BC08	 ; If Player_Slide >= 0, jump to PRG008_BC08

	; Amounts to a single increment (against the above decrement) for negative Player_Slide
	INC Player_Slide
	INC Player_Slide

PRG008_BC08:
	LDA Player_Slide
	STA <Player_XVel ; Player_XVel = Player_Slide

PRG008_BC0D:
	LDA <Player_XVel
	BEQ PRG008_BC14	 ; If Player_XVel = 0 (came to a stop), jump to PRG008_BC14 (RTS)

	STX Player_SlideRate	 ; Otherwise, update Player_SlideRate with velocity effect value

PRG008_BC14:

	LDA <Temp_Var14
	STA <Player_Y
	LDA <Temp_Var13
	STA <Player_YHi

	LDA Level_32PPSlopeFlag
	BEQ L32PP_NoSlope

	; Correct Player Y
	INC <Temp_Var14		; Hack way to keep Player from bumping around when maze is moving upward
	LDA <Temp_Var14
	ADD <Vert_Scroll
	STA <Player_Y
	LDA <Temp_Var13
	ADC #0
	STA <Player_YHi

	LDA #0
	STA Level_32PPSlopeFlag

L32PP_NoSlope:
	RTS		 ; Return

	; Offset into TileAttrAndQuad_OffsSloped for checking at Player's feet or head
Slope_ChkFeetOrHead:	.byte $00, $02	; Left value is for floor, right value for ceiling

	; Fills in the Level_Tile_Quad[rant] and Level_Tile_Slope values
Player_GetTileSlopeAndQuad:

	; 'X' defines which tile index to do
	; 'Y' defines an X and Y offset index for the TileAttrAndQuad_OffsSloped table

	LDA TileAttrAndQuad_OffsSloped,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)
	LDA TileAttrAndQuad_OffsSloped+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)

	JSR Player_GetTileAndSlope ; Get tile
	STA Level_Tile_GndL,X	 ; Store into appropriate location

	AND #$c0	 ; Get quadrant of tile
	ASL A
	ROL A
	ROL A		 ; A = 0-3, based on quadrant
	STA Level_Tile_Quad,X	; Store quadrant

	LDA <Player_Slopes	 ; Get slope
	STA Level_Tile_Slope,X	 ; Store slope
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoSpecialTiles
;
; Handles special tiles unique to level styles:
; Pipe logic, conveyors, spikes, muncher/jelectro, white block, 
; quicksand, toad house treasure chests... 
; Good place to put custom-by-Tileset tiles!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; This table enables certain pipe tiles by tileset 
	; (since some have more pipe tile types than others)
	; bit 6 enables TILE8_PIPEH3_B
	; bit 7 enables TILE3_PIPETB5_L/R
PipeTile_EnableByTileset:
	; Indexed by Level_TilesetIdx
	.byte %00000000	;  0 Plains style
	.byte %00000000	;  1 Mini Fortress style
	.byte %10000000	;  2 Hills style
	.byte %00000000	;  3 High-Up style
	.byte %10000000	;  4 Ghost House
	.byte %10000000	;  5 water world
	.byte %00000000	;  6 Toad House
	.byte %11000000	;  7 Vertical pipe maze
	.byte %01000000	;  8 desert levels
	.byte %00000000	;  9 Airship
	.byte %11000000	; 10 Giant World
	.byte %00000000	; 11 Ice level
	.byte %11000000	; 12 Sky level
	.byte %10000000	; 13 Underground

PRG008_BC43:
	.byte $08, $04, $04	; Offset applied to Player_X when: in air or level is sloped, Player is NOT small, Player is small

Pipe_PadDirForEnter:	
	.byte PAD_RIGHT, PAD_LEFT	; What to press to enter a horizontal pipe; pad right and left, respectively
	.byte PAD_DOWN, PAD_UP		; What to press to enter a vertical pipe; pad down and up, respectively


	; The sliding values applied when Player is touching a conveyor
ConveyorSlide:	.byte 16, -16

	.byte $01, $0F

Player_DoSpecialTiles:

	LDA Player_Statue
	ORA Player_TailAttack
	ORA Player_Flip	 
	BNE PRG008_BCA7	 ; If Player is a Rabbit Statue, tail attacking, or invincibility flipping, jump to PRG008_BCA7

	LDY Level_TilesetIdx	 ; Y = Level_TilesetIdx

	; Copy in the mask of allowable pipe tiles -> Temp_Var16
	LDA PipeTile_EnableByTileset,Y
	STA <Temp_Var16

	LDA <Player_InAir
	BNE PRG008_BCAA	 	; If Player is mid air, jump to PRG008_BCAA

	LDA Level_Tile_InFL	 ; Get tile near head...

	LDY Level_7Vertical
	BEQ PRG008_BC79	 ; If Level is NOT a vertical level, jump to PRG008_BC79

	; Vertical level...

	LDY #$02	 ; Y = 2
	CMP #TILE8_SCENPIPE_ENDH1B
	BEQ PRG008_BC87	 ; If tile near head is TILE8_SCENPIPE_ENDH1B, jump to PRG008_BC87

	LDY #$00	 ; Y = 0

PRG008_BC79:
	CMP #TILE1_PIPEH1_B
	BEQ PRG008_BC87	 ; If tile near head is TILE1_PIPEH1_B, jump to PRG008_BC87

	BIT <Temp_Var16	 ; PipeTile_EnableByTileset value
	BVC PRG008_BCAA	 ; If Temp_Var16 bit 6 is clear (TILE8_PIPEH3_B disabled), jump to PRG008_BCAA

	LDY #$03	 ; Y = 3

	CMP #TILE8_PIPEH3_B
	BNE PRG008_BCAA	 ; If tile near head is NOT TILE8_PIPEH3_B, jump to PRG008_BCAA

PRG008_BC87:
	LDX #$00	 ; X = 0 

	LDA <Player_X
	AND #$0f	
	CMP #$08	
	BLS PRG008_BC92	 ; If Player is on left half of tile, jump to PRG008_BC92
 
	INX		 ; X = 1

PRG008_BC92:
	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BEQ PRG008_BCAA		; If Purple Comet is active, no pipes!

	LDA <Pad_Holding
	AND Pipe_PadDirForEnter,X
	BEQ PRG008_BCAA	 ; If Player is NOT pressing correct direction to enter pipe, jump to PRG008_BCAA

	; Correct direction to enter pipe...

	TYA
	BNE PRG008_BCA4	 ; If pipe type (Y) is not 0, jump to PRG008_BCA4

	LDY #$01	 ; Y = 1 

	LDA LevelJctBQ_Flag	
	BEQ PRG008_BCA4	 ; If not currently junctioning, jump to PRG008_BCA4

	DEY		 ; Y = 0 

PRG008_BCA4:
	JSR PipeEntryPrepare	 ; Prepare pipe entry

PRG008_BCA7:
	JMP PRG008_BD4B	 ; Jump to PRG008_BD4B

PRG008_BCAA:
	LDX #$02	 ; X = 2
	LDA Level_Tile_GndL	 

	LDY <Player_InAir
	BEQ PRG008_BCC4	 ; If Player is NOT mid air, jump to PRG008_BCC4

	LDY Player_HitCeiling
	BEQ PRG008_BCA7	 ; If Player has not just hit off a ceiling, jump to PRG008_BCA7

	LDY Player_IsDucking
	BEQ PRG008_BCC0	 ; If Player is NOT ducking, jump to PRG008_BCC0

	JMP PRG008_BD4B	 ; Otherwise, jump to PRG008_BD4B

PRG008_BCC0:
	INX		 ; X = 3

	LDA Level_Tile_GndR	 

PRG008_BCC4:
	STA <Temp_Var1		 ; Store tile -> Temp_Var1
	STX <Temp_Var3		 ; Store pipe mode -> Temp_Var3

	LDA #TILE1_PIPETB2_R
	SUB <Temp_Var1	
	CMP #$04		; Looking to compare the pipe tile against any of the vertical pipe 1 & 2 end tiles

	LDY LevelJctBQ_Flag
	BEQ PRG008_BCD6	 ; If not in a Big Question Block area, jump to PRG008_BCD6
 
	AND #$01	 ; Not sure what they need this for?

PRG008_BCD6:
	TAY		 ; Tile index result -> 'A'
	BCC PRG008_BCFA	 ; If tile was in range (from CMP above), jump to PRG008_BCFA

	; Not a pipe 1 or 2 end tile...

	LDY <Temp_Var16	 ; PipeTile_EnableByTileset value
	BPL PRG008_BCE8	 ; If bit 7 is clear (TILE3_PIPETB5_L/R disabled), jump to PRG008_BCE8

	LDA #TILE3_PIPETB5_R
	SUB <Temp_Var1
	CMP #$02
	LDY #$06	 ; Y = 6
	BCC PRG008_BCFA	 ; If tile was in range (Pipe 5 left/right), jump to PRG008_BCFA

PRG008_BCE8:
	LDA #TILE1_PIPETB4_R
	LDY Level_7Vertical
	BEQ PRG008_BCF1	 ; If NOT a vertical level, jump to PRG008_BCF1

	LDA #TILE8_SCENPIPE_ENDVR

PRG008_BCF1:
	SUB <Temp_Var1
	CMP #$02	
	BCS PRG008_BD4B	 ; If this pipe tile wasn't in range EITHER, jump to PRG008_BD4B

	; Pipe tile in range...

	LDY #$04	 ; Y = 4

PRG008_BCFA:
	STY <Temp_Var1	 ; Store pipe type -> Temp_Var1

	AND #$01	 ; Determine left vs right tile (odd/bit 0 indicates right tile)
	ASL A
	ASL A
	ASL A
	ASL A		 ; Multiply 0/1 by 16
	STA <Temp_Var2	 ; Temp_Var2 = 0 or 16

	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BEQ PRG008_BD4B		; If Purple Comet is active, no pipes!

	LDA <Pad_Holding
	AND Pipe_PadDirForEnter,X
	BEQ PRG008_BD4B	 ; If Player is NOT pressing the correct direction to enter pipe, jump to PRG008_BD4B

	LDA Level_PipeMove
	BNE PRG008_BD4B	 ; If Player is already in pipe, jump to PRG008_BD4B

	LDY #$00	 ; Y = 0 (Player is mid-air or level is sloped)

	LDA <Player_InAir
	ORA Level_SlopeEn
	BNE PRG008_BD1F	 ; If Player is mid air or this is a sloping level, jump to PRG008_BD1F

	INY		 ; Y = 1 (Player is NOT small)
	LDA <Player_Suit
	BNE PRG008_BD1F	 ; If Player is NOT small, jump to PRG008_BD1F

	INY		 ; Y = 2 (Player is small)

PRG008_BD1F:
	LDA <Player_X	
	AND #$0f	
	PHA		 ; Save Player's relative X across tile

	ADD PRG008_BC43,Y ; Add appropriate offset
	AND #$10	 ; Check if on "odd" tile (only true on Player_X 16, 48, 80, etc.) AKA right tile
	BNE PRG008_BD30	 ; If so, jump to PRG008_BD30

	PLA		 ; Restore Player's relative X across tile
	ORA #$F0	 ; Make negative, sort of
	PHA		 ; Save it again

PRG008_BD30:
	PLA		 ; Restore Player's relative X across tile
	ADD <Temp_Var2	 ; 0 or 16, left or right tile
	SUB #3	 
	CMP #10
	BGE PRG008_BD4B	 ; If Player_X >= 10 after subtracting 3 (??), jump to PRG008_BD4B

	LDA <Temp_Var1	 ; Get pipe type
	LSR A		 
	TAY		 
	JSR PipeEntryPrepare	 ; Prepare entry into pipe!
	JSR PipeMove_SetPlayerFrame	 ; Update Player frame!
	JSR Player_Draw29	 ; Draw Player

	; Do not return to caller!!
	PLA		 
	PLA

	RTS		 ; Return

PRG008_BD4B:
	LDY Level_TilesetIdx

	LDA <Player_InAir
	BNE PRG008_BD73	 ; If Player is mid air, jump to PRG008_BD73

	LDA Level_PSwitchCnt
	BNE PRG008_BD73	 ; If P-Switch is active, jump to PRG008_BD73


	; CONVEYOR BELT LOGIC!

	LDX #$01	 ; X = 1 (check one tile by foot, then check the other!)

PRG008_BD59:
	LDA ConveyorEnable,Y
	BEQ PRG008_BD73	 ; If value is zero, jump to PRG008_BD73

	; Otherwise...
	SUB Level_Tile_GndL,X	 ; Subtract value we just retrieved 
	CMP #$02	 
	BGE PRG008_BD70	 ; If tile is >= 2, this is not a conveyor tile, jump to PRG008_BD70

	; We're on a conveyor tile!!

	EOR Player_ReverseGrav
	TAX		 	; Transfer conveyor tile index -> 'X'
	LDA ConveyorSlide,X	; Get appropriate conveyor slide amount
	STA Player_SlideRate	; Set slide factor for conveyor
	JMP PRG008_BD73		; Jump to PRG008_BD73

PRG008_BD70:
	DEX		 ; X--
	BPL PRG008_BD59	 ; While X >= 0, loop!

	; SPIKE TILE LOGIC

PRG008_BD73:
	LDX #$02	 ; X = 2

PRG008_BD75:
	LDA SpikesEnable,Y
	CMP #$ff	 
	BEQ PRG008_BD96	 ; If specified value is $FF, no spikes here, jump to PRG008_BD96

	; Otherwise...
	SUB Level_Tile_Head,X
	CMP #$02
	BLT PRG008_BD89	 ; If this is a spike tile, jump to PRG008_BD89
	DEX		 ; X--
	BPL PRG008_BD75	 ; While X >= 0, loop!
	BMI PRG008_BD96	 ; Not a spike tile, jump to PRG008_BD96

PRG008_BD89:

	; It's a spike tile...

	LDA Player_Kuribo
	BEQ PRG008_BD93	 ; If Player is NOT in a Kuribo's shoe, jump to PRG008_BD93

	LDA Player_HitCeiling
	BEQ PRG008_BD96	 ; If Player has not just hit head off ceiling, jump to PRG008_BD96

PRG008_BD93:
	JMP Player_GetHurt	; Hurt Player!!

PRG008_BD96:
	LDX #$03	 ; X = 3

PRG008_BD98:
	LDA Level_Tile_GndL,X
	CPY #7
	BEQ PipeMaze_MJCheck	; If this is the pipe maze tileset, jump to PipeMaze_MJCheck
	CPY #1
	BNE NotFort_MJCheck		; If not the fortress tileset, jump to NotFort_MJCheck
	
PipeMaze_MJCheck:
	; Fortress / Pipe Maze only...
	SUB #TILE2_ZAPPER_L
	CMP #2
	BLT PRG008_BDA4		; If Player is touching zapper tile, jump to PRG008_BDA4

NotFort_MJCheck:
	LDA Level_Tile_GndL,X
	CMP MuncherJelectroSet,Y
	BNE PRG008_BDB1		; If Player is NOT touching muncher/jelectro (whichever is appropriate), jump to PRG008_BDB1

	; Kuribo-on-muncher handling
PRG008_BDA4:
	LDA Player_Kuribo
	BEQ PRG008_BDAE	 ; If Player does NOT have Kuribo's shoe, jump to PRG008_BDAE (get hurt!)

	LDA Player_HitCeiling
	BEQ PRG008_BDB4	 ; If Player has not just hit off ceiling, jump to PRG008_BDB4

PRG008_BDAE:
	JMP Player_GetHurt	 ; Get hurt!

PRG008_BDB1:
	DEX		 ; X--
	BPL PRG008_BD98	 ; While X >= 0, loop!

PRG008_BDB4:

	; SLIPPERY, ICY GROUND LOGIC

	LDA #$00
	STA Player_Slippery	 ; Player_Slippery = 0 (default ground not slippery)

	; If Player is in penguin suit, never slippery!
	LDA <Player_Suit
	CMP #PLAYERSUIT_PENGUIN
	BEQ PRG008_BE31

	LDA Level_SlopeEn
	BEQ Icy_NotSlopes	; If not a sloped level, jump to Icy_NotSlopes
	
	; For slopes, supporting slipperiness if Level_BG_Page1_2 is 25
	; and slope tile is from quad zero... kinda dodgy, but fuck it
	LDA Level_BG_Page1_2
	CMP #25
	BNE Icy_NotSlopes
	
	LDA Level_Tile_GndL
	AND #%11000000
	BNE Icy_NotSlopes	; If not quad 0, jump to Icy_NotSlopes
	
	LDA #2
	STA Player_Slippery
	
Icy_NotSlopes:
	LDA Level_TilesetIdx
	CMP #11
	BNE PRG008_BE31	 ; If not in an ice level, jump to PRG008_BE31

	LDA <Player_InAir
	BNE PRG008_BE31	 ; If Player is in air, jump to PRG008_BE31

	LDX #$01	 ; X = 1

PRG008_BDFD:
	LDA Level_Tile_GndL,X
	TAY		 ; Tile -> 'Y'

	SUB #TILE12_SNOWBLOCK_UL
	CMP #$03
	BLT PRG008_BE10	 ; If Player is on top of snow block, jump to PRG008_BE10	

	TYA		 ; Restore tile -> 'A'
	SUB #TILE12_GROUND_L
	CMP #$03
	BGE PRG008_BE16	 ; If Player is not on bottom ground, jump to PRG008_BE16

PRG008_BE10:
	INC Player_Slippery	 ; Player_Slippery = 1 (bottom ground is a little slippery!)
	JMP PRG008_BE31	 	; Jump to PRG008_BE31

PRG008_BE16:
	TYA		 ; Restore tile -> 'A'
	SUB #TILE12_LARGEICEBLOCK_UL
	CMP #$05
	BLT PRG008_BE26	 ; If Player is touching any of the small or large ice blocks, jump to PRG008_BE26

	CPY #TILE12_FROZENCOIN	
	BEQ PRG008_BE26	 ; If Player is touching frozen coin blocks, jump to PRG008_BE26

	CPY #TILE12_FROZENMUNCHER
	BNE PRG008_BE2E	 ; If Player is NOT touching frozen muncher blocks, jump to PRG008_BE2E

PRG008_BE26:
	LDA #$02	 
	STA Player_Slippery	 ; Player_Slippery = 2 (ground is REALLY slippery!)

	JMP PRG008_BE31	 ; Jump to PRG008_BE31

PRG008_BE2E:
	DEX		 ; X--
	BPL PRG008_BDFD	 ; While X >= 0, loop!

PRG008_BE31:

	; SB: Removed -- no more special white block support

	;LDA Level_TilesetIdx
	;CMP #$00
	;BNE PRG008_BE76	 ; If Player is NOT in a Plains style level, jump to PRG008_BE76

	;LDY #$01	 ; Y = 1

;PRG008_BE3A:
	;LDA Level_Tile_GndL,Y

	;SUB #TILE1_WBLOCKTH
	;CMP #$03
	;BLT PRG008_BE4E	 ; If Player is on a big white block, jump to PRG008_BE4E

	;DEY		 ; Y--
	;BPL PRG008_BE3A	 ; While Y >= 0, loop!

	; Not on a white block...

;PRG008_BE47:
	;LDA #$00	 
	;STA Player_WhiteBlkCnt	 ; Reset white block counter if not on a white block!
	;BEQ PRG008_BE76	 ; Jump (technically always) to PRG008_BE76

;PRG008_BE4E:
	;LDA <Pad_Holding
	;AND #PAD_DOWN
	;BEQ PRG008_BE47	 ; If Player is NOT pressing down, jump to PRG008_BE47

	;INC Player_WhiteBlkCnt	 ; Player_WhiteBlkCnt++

	;LDA Player_WhiteBlkCnt
	;CMP #$F0	 
	;BNE PRG008_BE76	 ; If Player_WhiteBlkCnt <> $F0, jump to PRG008_BE76

	; Count max reached!  Fall into background...

	;LDA #$F0	 ; Superfluous!
	;STA Player_Behind	 ; Set Player as behind the scene...

	; To make Player fall, do everything in our power to make sure
	; the Player doesn't get a chance to jump or anything else :)
	;LDA #$00
	;STA <Player_YVel	 ; Halt Player vertically 

	;LDA <Player_Y
	;ADD #$06
	;STA <Player_Y		; Force Player down by 6 pixels (fall)

	;INC <Player_InAir	 ; Set Player as in air

	; Don't register 'A' button
	;LDA <Pad_Input
	;AND #~PAD_A
	;STA <Pad_Input

;PRG008_BE76:

	; QUICKSAND LOGIC

	LDY Level_TilesetIdx
	LDA QuicksandEnable,Y
	BEQ PRG008_BEE5	 ; If value is zero, jump to PRG008_BEE5

	LDA <Player_YVel
	BMI PRG008_BEE5	 ; If Player is moving upward, jump to PRG008_BEE5

	LDX #$03	 ; X = 3 

PRG008_BE87:
	LDA QuicksandEnable,Y
	SUB Level_Tile_GndL,X	 ; Subtract value we just retrieved 
	CMP #$02	 
	BLT PRG008_BE9D	 ; If tile is < 2, this is a quicksand tile, jump to PRG008_BE9D

	DEX		 ; X--
	BPL PRG008_BE87	 ; While X >= 0, loop!

	LDA #$00
	STA Player_SandSink	 ; Player is not sinking in sand!

	JMP PRG008_BEE5	 ; Jump to PRG008_BEE5

PRG008_BE9D:

	; Sinking in quicksand!!

	LDA #$00	 
	STA Player_IsDucking	 ; Player is not ducking
	STA Player_Slide	 ; Player is not sliding

	LDA Player_SandSink
	BNE PRG008_BEAC	 	; If Player was already sinking in quicksand, jump to PRG008_BEAC

	LDA <Player_Y		 ; Get Player_Y at initial quicksand hit only...

PRG008_BEAC:
	AND #%11110000	 	; Keep only upper 4 bits
	STA Player_SandSink	 ; Set as Player_SandSink value

	LDA <Player_Y	
	SUB Player_SandSink	 ; Get difference between Player_Y and top of quicksand

	LDY #-$20	 ; Y = -$20 (escape jump vel)
	TAX		 ; difference -> 'X'
	AND #%11110000	 ; Keep only upper 4 bits
	BNE PRG008_BEC7	 ; If Player is not at top of sand, jump to PRG008_BEC7

	; Player must be close to top of sand...
	TXA		 ; difference back to 'A'
	AND #%00001111	 ; Keep only lower 4 bits
	CMP #$03	 
	BGE PRG008_BEC7	 ; If still at least 3 pixels under, jump to PRG008_BEC7

	LDY #-$30	 ; Otherwise, Y = -$30 (escape jump vel, almost out!)

PRG008_BEC7:
	LDA <Pad_Input
	BMI PRG008_BED2	 ; If Player is pressing 'A', jump to PRG008_BED2

	INC Player_SandSink	; Set bit 0 of Player_SandSink (sinking)

	LDY #$06	 ; Y = $06 (sinking vel)
	BNE PRG008_BEDA	 ; Jump (technically always) to PRG008_BEDA

PRG008_BED2:
	; Player is trying to escape!  Play jump sound!
	LDA #SND_PLAYERJUMP	
	
	LDX <Player_Suit
	BNE PlayerQSJump_Big

	; Small Mario jump
	LDA #SND_PLAYERJUMPSM
	
PlayerQSJump_Big:
	STA Sound_QPlayer

PRG008_BEDA:

	STY <Player_YVel ; Set Player's Y velocity

	; Limit Player's horizontal movement
	;LDA <Player_XVel
	;ASL A		
	;ROR <Player_XVel
	;BPL PRG008_BEE5
	;INC <Player_XVel
	
	LDA <Player_XVel
	BPL SandSpeedChk_NotNeg

	; Absolute value...
	NEG
	
SandSpeedChk_NotNeg:
	CMP #(PLAYER_TOPWALKSPEED / 4)
	BLT PRG008_BEE5		; If Player isn't moving too fast in sand, jump to PRG008_BEE5
	
	; Else, halve it
	LDA <Player_XVel
	ASR
	STA <Player_XVel

PRG008_BEE5:

	; SB: Old Toad House code removed

	RTS		 ; Return


PipeMove_SetPlayerFrame:
	LDY <Player_Suit
	BEQ PRG008_BF0A	 ; If small, jump to PRG008_BF0A

	LDY #$02	 ; Otherwise, Y = 2

PRG008_BF0A:
	LDA Player_Kuribo
	BEQ PRG008_BF10	 ; If not wearing Kuribo's shoe, jump to PRG008_BF10

	INY		 ; Otherwise Y++

PRG008_BF10:
	LDA PipeMove_Frame,Y ; Get appropriate pipe traversal frame
	STA <Player_Frame	  ; Store as Player frame

	; ******************** FIXME ***********************
	; Need face-forward Yoshi frame drawn as overlay!!
	
	RTS		 ; Return


PipeEntryPrepare:
	JMP_THUNKC 30, PipeEntryPrepare30


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_QueueChangeBlock
;
; Changes a block, used for tiles which appear/disappear
;
; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
; Temp_Var15 / Temp_Var16 -- X Hi and Lo
;
; Register 'A' as input sets Level_ChgTileEvent
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_QueueChangeBlock: 
	STA Level_ChgTileEvent	 ; Store type of block change!

	; Store change Y Hi and Lo
	LDA <Temp_Var13
	STA Level_BlockChgYHi
	LDA <Temp_Var14
	AND #$F0		; Align to nearest grid coordinate
	STA Level_BlockChgYLo

	; Store change X Hi and Lo
	LDA <Temp_Var15
	STA Level_BlockChgXHi
	LDA <Temp_Var16	
	AND #$F0	 	; Align to nearest grid coordinate
	STA Level_BlockChgXLo

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyXVelocity
;
; Applies Player's X velocity and makes sure he's not moving
; faster than the cap value (PLAYER_MAXSPEED)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ApplyXVelocity:
	LDX #$00	; X = 0
	LDY #PLAYER_MAXSPEED	; Y = PLAYER_MAXSPEED

	LDA <Player_XVel
	BPL PRG008_BFAC	 ; If Player_XVel >= 0, jump to Player_ApplyXVelocity 

	LDY #-PLAYER_MAXSPEED	 ; Y = -PLAYER_MAXSPEED

	; Negate Player_XVel (get absolute value)
	NEG

PRG008_BFAC:
	STA <Temp_Var16		; Store absolute value Player_XVel -> Temp_Var166
	CMP #PLAYER_MAXSPEED
	BLS Player_ApplyVelocity ; If we haven't hit the PLAYER_MAXSPEED yet, apply it!
	STY <Player_XVel	 ; Otherwise, cap at max speed!
	JMP Player_ApplyVelocity

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyVelocity
;
; Applies Player's velocity for X or Y (depending on register 'X')
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; SB: Applying reverse velocity for reverse gravity
Player_ApplyRevVelocity:
	LDA <Player_XVel,X
	NEG
	BNE Player_ApplyVelocity_Cont


Player_ApplyVelocity:
	; X may specify offset to YVel, or else be zero

	LDA <Player_XVel,X	; Get velocity

Player_ApplyVelocity_Cont:
	CPX #$00	 
	BNE PRG008_BFBE	 	; If we're not doing the X velocity, jump to PRG008_BFBE

	; X Velocity only:
	ADD Player_XVelAdj	; Add Player_XVelAdj

PRG008_BFBE:
	PHA		 ; Save result

	ASL A
	ASL A
	ASL A
	ASL A		 ; Get "fractional" part of velocity
	STA <Temp_Var12	 ; Store into Temp_Var12

	LDY #$00	 ; Y = 0

	PLA		 ; Restore prior result

	LSR A
	LSR A
	LSR A
	LSR A		 ; Get "whole" part of velocity

	; "Whole" part is like a 4-bit signed integer
	; $0 - $7 is therefore rightward
	; $8 - $F is therefore leftward
	CMP #$08
	BLT PRG008_BFD3	 ; If whole part is less than 8, jump to PRG008_BFD3

	DEY		 ; Y = $FF (sign extended negative)

	; Turn "whole part" into a full 8-bit signed
	ORA #$F0

PRG008_BFD3:
	STA <Temp_Var11	 ; Store velocity into Temp_Var11 (low part)
	STY <Temp_Var13	 ; Temp_Var13 = 0 or $FF (High part)

	; Accumulating fractional component
	LDA Player_XVelFrac,X
	ADD <Temp_Var12	
	STA Player_XVelFrac,X

	; Apply velocity to X if there's carry
	LDA <Player_X,X
	ADC <Temp_Var11
	STA <Player_X,X

	; Apply velocity to XHi if there's carry
	LDA <Player_XHi,X
	ADC <Temp_Var13	
	STA <Player_XHi,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyYVelocity
;
; Applies Player's Y velocity and makes sure he's not falling 
; faster than the cap value (FALLRATE_MAX)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ApplyYVelocity:
	LDA <Player_YVel
	BMI PRG008_BFF9	 ; If PRG008_BFF9 < 0, jump to PRG008_BFF9

	CMP #FALLRATE_MAX
	BLS PRG008_BFF9	 ; If PRG008_BFF9 < FALLRATE_MAX, jump to PRG008_BFF9

	; Cap Y velocity at FALLRATE_MAX
	LDA #FALLRATE_MAX
	STA <Player_YVel ; Player_YVel = FALLRATE_MAX

PRG008_BFF9:
	LDX #(Player_YVel - Player_XVel) ; Do the Y velocity

	LDA Level_PipeMove
	BNE Player_ApplyVelocity	; If moving through pipe, always apply "normal" gravity (otherwise screws up pipe motion)

	LDA Player_ReverseGrav
	BNE Player_ApplyRevVelocity	; Otherwise if gravity is reversed, apply "reversed" gravity

	; Not reverse gravity
	BEQ Player_ApplyVelocity	; Finally, just apply "normal" gravity


	
	
