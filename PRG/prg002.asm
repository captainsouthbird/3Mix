; Source generated by DCC6502 version v1.4
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg002.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup01 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $01 (i.e. objects starting at ID $24) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup01_InitJumpTable:
	.word ObjInit_Albatoss	; Object $24 - OBJ_ALBATOSS
	.word ObjInit_PipewayCtlr	; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjInit_WoodenPlat	; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjInit_WoodenPlat	; Object $27 - OBJ_OSCILLATING_H
	.word ObjInit_WoodenPlat	; Object $28 - OBJ_OSCILLATING_V
	.word ObjInit_TowardsPlayer	; Object $29 - OBJ_SPIKE
	.word ObjInit_Patooie		; Object $2A - OBJ_PATOOIE
	.word ObjInit_TowardsPlayer		; Object $2B - OBJ_REX
	.word ObjInit_CloudPlatform	; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjInit_ChasingFish	; Object $2D - OBJ_BIGBERTHA
	.word ObjInit_InvisibleLift	; Object $2E - OBJ_INVISIBLELIFT
	.word ObjInit_Boo		; Object $2F - OBJ_BOO
	.word ObjInit_HotFootShy	; Object $30 - OBJ_HOTFOOT_SHY
	.word ObjInit_Goblin		; Object $31 - OBJ_GOBLIN
	.word ObjInit_DoNothing		; Object $32 - OBJ_BIRDOEGG
	.word ObjInit_DoNothing		; Object $33 - OBJ_NIPPER
	.word ObjInit_Toad		; Object $34 - OBJ_TOAD
	.word ObjInit_Princess		; Object $35 - OBJ_PRINCESS
	.word ObjInit_WoodenPlatform	; Object $36 - OBJ_WOODENPLATFORM
	.word ObjInit_OscillatingShort	; Object $37 - OBJ_OSCILLATING_HS
	.word ObjInit_OscillatingShort	; Object $38 - OBJ_OSCILLATING_VS
	.word ObjInit_NipperHopping	; Object $39 - OBJ_NIPPERHOPPING
	.word ObjInit_FallingPlatform	; Object $3A - OBJ_FALLINGPLATFORM
	.word ObjInit_ChasingFish	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjInit_WoodenFallingPlat	; Object $3C - OBJ_WOODENPLATFORMFALL
	.word ObjInit_DoNothing		; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjInit_FloatWoodenPlat	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjInit_TowardsPlayer	; Object $3F - OBJ_DRYBONES
	.word ObjInit_DesertBones	; Object $40 - OBJ_DESERTBONES
	.word ObjInit_EndLevelCard	; Object $41 - OBJ_ENDLEVELCARD
	.word ObjInit_TowardsPlayer		; Object $42 - OBJ_REX_PARTLYSQUASHED
	.word ObjInit_DoNothing		; Object $43
	.word ObjInit_FallingPlatform	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word ObjInit_HotFoot		; Object $45 - OBJ_HOTFOOT
	.word ObjInit_PiranhaSpikeBall	; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjInit_DoNothing		; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup01_NormalJumpTable:
	.word ObjNorm_Albatoss		; Object $24 - OBJ_ALBATOSS
	.word ObjNorm_PipewayCtlr	; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjNorm_WoodenPlatRider	; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjNorm_OscillatingH	; Object $27 - OBJ_OSCILLATING_H
	.word ObjNorm_OscillatingV	; Object $28 - OBJ_OSCILLATING_V
	.word ObjNorm_Spike		; Object $29 - OBJ_SPIKE
	.word ObjNorm_Patooie		; Object $2A - OBJ_PATOOIE
	.word ObjNorm_Rex	; Object $2B - OBJ_REX
	.word ObjNorm_CloudPlat		; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjNorm_BigBertha		; Object $2D - OBJ_BIGBERTHA
	.word ObjNorm_InvisibleLift	; Object $2E - OBJ_INVISIBLELIFT
	.word ObjNorm_Boo		; Object $2F - OBJ_BOO
	.word ObjNorm_HotfootShy	; Object $30 - OBJ_HOTFOOT_SHY
	.word ObjNorm_Goblin		; Object $31 - OBJ_GOBLIN
	.word ObjNorm_BirdoEgg		; Object $32 - OBJ_BIRDOEGG
	.word ObjNorm_Nipper		; Object $33 - OBJ_NIPPER
	.word ObjNorm_Toad		; Object $34 - OBJ_TOAD
	.word ObjNorm_Toad	; Object $35 - OBJ_PRINCESS
	.word ObjNorm_WoodenPlatform	; Object $36 - OBJ_WOODENPLATFORM
	.word ObjNorm_OscillatingH	; Object $37 - OBJ_OSCILLATING_HS
	.word ObjNorm_OscillatingV	; Object $38 - OBJ_OSCILLATING_VS
	.word ObjNorm_Nipper		; Object $39 - OBJ_NIPPERHOPPING
	.word ObjNorm_PathFollowPlat	; Object $3A - OBJ_FALLINGPLATFORM
	.word ObjNorm_CharginCheepCheep	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjNorm_PathFollowPlat	; Object $3C - OBJ_WOODENPLATFORMFALL
	.word ObjNorm_NipperFireBreathe	; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjNorm_WoodenPlatFloat	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjNorm_DryBones		; Object $3F - OBJ_DRYBONES
	.word ObjNorm_DesertBones	; Object $40 - OBJ_DESERTBONES
	.word ObjNorm_EndLevelCard	; Object $41 - OBJ_ENDLEVELCARD
	.word ObjNorm_RexPartlySquashed	; Object $42 - OBJ_REX_PARTLYSQUASHED
	.word ObjNorm_DoNothing	; Object $43
	.word ObjNorm_PathFollowPlat	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word ObjNorm_Hotfoot		; Object $45 - OBJ_HOTFOOT
	.word ObjNorm_PiranhaSpikeBall	; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjNorm_GiantBlockCtl	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup01_CollideJumpTable:
	.word ObjHit_CloudPlat		; Object $24 - OBJ_ALBATOSS
	.word ObjHit_DoNothing		; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjHit_DoNothing		; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjHit_DoNothing		; Object $27 - OBJ_OSCILLATING_H
	.word ObjHit_DoNothing		; Object $28 - OBJ_OSCILLATING_V
	.word ObjHit_DoNothing		; Object $29 - OBJ_SPIKE
	.word Player_GetHurt		; Object $2A - OBJ_PATOOIE
	.word ObjHit_DoNothing		; Object $2B - OBJ_REX
	.word ObjHit_CloudPlat		; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjHit_DoNothing		; Object $2D - OBJ_BIGBERTHA
	.word ObjHit_DoNothing		; Object $2E - OBJ_INVISIBLELIFT
	.word Player_GetHurt		; Object $2F - OBJ_BOO
	.word Player_GetHurt		; Object $30 - OBJ_HOTFOOT_SHY
	.word ObjHit_DoNothing		; Object $31 - OBJ_GOBLIN
	.word ObjHit_DoNothing		; Object $32 - OBJ_BIRDOEGG
	.word Player_GetHurt		; Object $33 - OBJ_NIPPER
	.word ObjHit_DoNothing		; Object $34 - OBJ_TOAD
	.word ObjHit_DoNothing		; Object $35 - OBJ_PRINCESS
	.word ObjHit_DoNothing		; Object $36 - OBJ_WOODENPLATFORM
	.word ObjHit_DoNothing		; Object $37 - OBJ_OSCILLATING_HS
	.word ObjHit_DoNothing		; Object $38 - OBJ_OSCILLATING_VS
	.word Player_GetHurt		; Object $39 - OBJ_NIPPERHOPPING
	.word ObjHit_DoNothing		; Object $3A - OBJ_FALLINGPLATFORM
	.word Player_GetHurt		; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjHit_DoNothing		; Object $3C - OBJ_WOODENPLATFORMFALL
	.word Player_GetHurt		; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjHit_DoNothing		; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjHit_DryBones		; Object $3F - OBJ_DRYBONES
	.word ObjHit_DoNothing		; Object $40 - OBJ_DESERTBONES
	.word ObjHit_DoNothing		; Object $41 - OBJ_ENDLEVELCARD (RAS: Not using touch anymore)
	.word ObjHit_DoNothing		; Object $42 - OBJ_REX_PARTLYSQUASHED
	.word ObjHit_DoNothing		; Object $43
	.word ObjHit_DoNothing		; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word Player_GetHurt		; Object $45 - OBJ_HOTFOOT
	.word Player_GetHurt		; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjHit_DoNothing		; Object $47 - OBJ_GIANTBLOCKCTL

	
	; Object group $01 (i.e. objects starting at ID $24) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup01_Attributes:
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $24 - OBJ_ALBATOSS
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $25
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $27 - OBJ_OSCILLATING_H
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $28 - OBJ_OSCILLATING_V
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $29 - OBJ_SPIKE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $2A - OBJ_PATOOIE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $2B - OBJ_REX
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $2D - OBJ_BIGBERTHA
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $2E - OBJ_INVISIBLELIFT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2F - OBJ_BOO
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $31 - OBJ_GOBLIN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $32 - OBJ_BIRDOEGG
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $33 - OBJ_NIPPER
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $34 - OBJ_TOAD
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $35 - OBJ_PRINCESS
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3F - OBJ_DRYBONES
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $40 - OBJ_DESERTBONES
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $42 - OBJ_REX_PARTLYSQUASHED
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $43
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $45 - OBJ_HOTFOOT
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $47 - OBJ_GIANTBLOCKCTL

	; Object group $01 (i.e. objects starting at ID $24) second set attribute bits

	; Attribute bits for objects:
	;	Bits 0: If set, object is NOT a "shelled" enemy
	;	Bits 1: Subtly modifies Player detection response; see comments in PRG000_D205
	;	Bits 2: If set, object doesn't respond if stomped (indifferent, not same as attr 3, bit 5 which leads to hurting player)
	;	Bits 3: Object uses 16-bit X value (otherwise, Object_XHi will be zeroed)
	;	Bits 4-7: Pick root tile detection group offset (from Object_TileDetectOffsets)

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup01_Attributes2:
	.byte OA2_TDOGRP2	; Object $24 - OBJ_ALBATOSS
	.byte OA2_TDOGRP0	; Object $25
	.byte OA2_TDOGRP2	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA2_TDOGRP2	; Object $27 - OBJ_OSCILLATING_H
	.byte OA2_TDOGRP2	; Object $28 - OBJ_OSCILLATING_V
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $29 - OBJ_SPIKE
	.byte OA2_TDOGRP2	; Object $2A - OBJ_PATOOIE
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP2	; Object $2B - OBJ_REX
	.byte OA2_TDOGRP2	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA2_TDOGRP0	; Object $2D - OBJ_BIGBERTHA
	.byte OA2_TDOGRP0	; Object $2E - OBJ_INVISIBLELIFT
	.byte OA2_TDOGRP1	; Object $2F - OBJ_BOO
	.byte OA2_TDOGRP0	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA2_NOSHELLORSQUASH | OA2_GNDPLAYERMOD | OA2_TDOGRP2	; Object $31 - OBJ_GOBLIN
	.byte OA2_NOSHELLORSQUASH | OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $32 - OBJ_BIRDOEGG
	.byte OA2_TDOGRP1	; Object $33 - OBJ_NIPPER
	.byte OA2_TDOGRP2	; Object $34 - OBJ_TOAD
	.byte OA2_TDOGRP2	; Object $35 - OBJ_PRINCESS
	.byte OA2_TDOGRP2	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA2_TDOGRP2	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA2_TDOGRP2	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA2_TDOGRP1	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA2_TDOGRP9	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA2_TDOGRP9	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA2_TDOGRP9	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA2_TDOGRP1	; Object $3F - OBJ_DRYBONES
	.byte OA2_TDOGRP2	; Object $40 - OBJ_DESERTBONES
	.byte OA2_TDOGRP0	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $42 - OBJ_REX_PARTLYSQUASHED
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $43
	.byte OA2_TDOGRP9	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA2_TDOGRP0	; Object $45 - OBJ_HOTFOOT
	.byte OA2_TDOGRP2	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA2_TDOGRP1	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup01_Attributes3:
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $24 - OBJ_ALBATOSS
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $25
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $27 - OBJ_OSCILLATING_H
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $28 - OBJ_OSCILLATING_V
	.byte OA3_HALT_SPIKESPECIAL 	; Object $29 - OBJ_SPIKE
	.byte OA3_HALT_PIRANHASPECIAL 	; Object $2A - OBJ_PATOOIE
	.byte OA3_HALT_JUSTDRAWTALL | OA3_SQUASH 	; Object $2B - OBJ_REX
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA3_HALT_NORMALONLY 	; Object $2D - OBJ_BIGBERTHA
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $2E - OBJ_INVISIBLELIFT
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $2F - OBJ_BOO
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA3_HALT_NORMALONLY	; Object $31 - OBJ_GOBLIN
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $32 - OBJ_BIRDOEGG
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $33 - OBJ_NIPPER
	.byte OA3_HALT_JUSTDRAWTALL | OA3_TAILATKIMMUNE	; Object $34 - OBJ_TOAD
	.byte OA3_HALT_JUSTDRAWTALL | OA3_TAILATKIMMUNE	; Object $35 - OBJ_PRINCESS
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA3_HALT_JUSTDRAW 	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $3F - OBJ_DRYBONES
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $40 - OBJ_DESERTBONES
	.byte OA3_HALT_ENDCARDSPECIAL | OA3_TAILATKIMMUNE	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA3_HALT_JUSTDRAW | OA3_SQUASH  	; Object $42 - OBJ_REX_PARTLYSQUASHED
	.byte OA3_HALT_JUSTDRAW 	; Object $43
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $45 - OBJ_HOTFOOT
	.byte OA3_HALT_PIRANHASPECIAL 	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup01_PatTableSel:
	.byte OPTS_NOCHANGE	; Object $24 - OBJ_ALBATOSS
	.byte OPTS_NOCHANGE	; Object $25
	.byte OPTS_SETPT5 | $0E	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OPTS_SETPT5 | $0E	; Object $27 - OBJ_OSCILLATING_H
	.byte OPTS_SETPT5 | $0E	; Object $28 - OBJ_OSCILLATING_V
	.byte OPTS_SETPT5 | $0A	; Object $29 - OBJ_SPIKE
	.byte OPTS_SETPT5 | $0A	; Object $2A - OBJ_PATOOIE
	.byte OPTS_SETPT5 | 30	; Object $2B - OBJ_REX
	.byte OPTS_SETPT5 | $0E	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OPTS_SETPT5 | $1A	; Object $2D - OBJ_BIGBERTHA
	.byte OPTS_SETPT6 | $12	; Object $2E - OBJ_INVISIBLELIFT
	.byte OPTS_SETPT5 | $12	; Object $2F - OBJ_BOO
	.byte OPTS_SETPT5 | $12	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OPTS_SETPT5 | $12	; Object $31 - OBJ_GOBLIN
	.byte OPTS_NOCHANGE	; Object $32 - OBJ_BIRDOEGG
	.byte OPTS_SETPT5 | $0A	; Object $33 - OBJ_NIPPER
	.byte OPTS_SETPT5 | $05	; Object $34 - OBJ_TOAD
	.byte OPTS_NOCHANGE	; Object $35 - OBJ_PRINCESS (RAS: Done manually in ObjNorm_Toad)
	.byte OPTS_SETPT5 | $0E	; Object $36 - OBJ_WOODENPLATFORM
	.byte OPTS_SETPT5 | $0E	; Object $37 - OBJ_OSCILLATING_HS
	.byte OPTS_SETPT5 | $0E	; Object $38 - OBJ_OSCILLATING_VS
	.byte OPTS_SETPT5 | $0A	; Object $39 - OBJ_NIPPERHOPPING
	.byte OPTS_SETPT6 | $13	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OPTS_SETPT6 | $4F	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OPTS_SETPT5 | $0E	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OPTS_SETPT5 | $0A	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OPTS_SETPT5 | $1A	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OPTS_SETPT6 | $13	; Object $3F - OBJ_DRYBONES
	.byte OPTS_NOCHANGE	; Object $40 - OBJ_DESERTBONES
	.byte OPTS_NOCHANGE	; Object $41 - OBJ_ENDLEVELCARD
	.byte OPTS_NOCHANGE	; Object $42 - OBJ_REX_PARTLYSQUASHED
	.byte OPTS_SETPT6 | $4F	; Object $43
	.byte OPTS_SETPT5 | $0E	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OPTS_SETPT5 | $12	; Object $45 - OBJ_HOTFOOT
	.byte OPTS_SETPT5 | $0A	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OPTS_NOCHANGE	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) "Kill Action"

	.org ObjectGroup_Attributes4	; <-- help enforce this table *here*
ObjectGroup01_Attributes4:
	.byte OA4_KA_STANDARD	; Object $24 - OBJ_ALBATOSS
	.byte OA4_KA_STANDARD	; Object $25
	.byte OA4_KA_STANDARD	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA4_KA_STANDARD	; Object $27 - OBJ_OSCILLATING_H
	.byte OA4_KA_STANDARD	; Object $28 - OBJ_OSCILLATING_V
	.byte OA4_KA_STANDARD	; Object $29 - OBJ_SPIKE
	.byte OA4_KA_NORMALANDKILLED	; Object $2A - OBJ_PATOOIE
	.byte OA4_KA_JUSTDRAW16X32	; Object $2B - OBJ_REX
	.byte OA4_KA_STANDARD	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA4_KA_NORMALSTATE	; Object $2D - OBJ_BIGBERTHA
	.byte OA4_KA_STANDARD	; Object $2E - OBJ_INVISIBLELIFT
	.byte OA4_KA_STANDARD	; Object $2F - OBJ_BOO
	.byte OA4_KA_POOFDEATH | OA4_POOFFROZEN	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA4_KA_NORMALANDKILLED	; Object $31 - OBJ_GOBLIN
	.byte OA4_KA_STANDARD	; Object $32 - OBJ_BIRDOEGG
	.byte OA4_KA_STANDARD	; Object $33 - OBJ_NIPPER
	.byte OA4_KA_STANDARD	; Object $34 - OBJ_TOAD
	.byte OA4_KA_STANDARD	; Object $35 - OBJ_PRINCESS
	.byte OA4_KA_STANDARD	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA4_KA_STANDARD	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA4_KA_STANDARD	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA4_KA_STANDARD	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA4_KA_STANDARD	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA4_KA_NORMALSTATE	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA4_KA_STANDARD	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA4_KA_STANDARD	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA4_KA_STANDARD	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA4_KA_NORMALANDKILLED	; Object $3F - OBJ_DRYBONES
	.byte OA4_KA_STANDARD	; Object $40 - OBJ_DESERTBONES
	.byte OA4_KA_STANDARD	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA4_KA_STANDARD	; Object $42 - OBJ_REX_PARTLYSQUASHED
	.byte OA4_KA_STANDARD	; Object $43
	.byte OA4_KA_STANDARD	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA4_KA_POOFDEATH | OA4_POOFFROZEN	; Object $45 - OBJ_HOTFOOT
	.byte OA4_KA_NORMALSTATE	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA4_KA_STANDARD	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) pattern index starts
	; These are used for all states except "normal"

OG1_POff .func (\1 - ObjectGroup01_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup01_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG1_POff(ObjP24), OG1_POff(ObjP25), OG1_POff(ObjP26), OG1_POff(ObjP27)
	.byte OG1_POff(ObjP28), OG1_POff(ObjP29), OG1_POff(ObjP2A), OG1_POff(ObjP2B)
	.byte OG1_POff(ObjP2C), OG1_POff(ObjP2D), OG1_POff(ObjP2E), OG1_POff(ObjP2F)
	.byte OG1_POff(ObjP30), OG1_POff(ObjP31), OG1_POff(ObjP32), OG1_POff(ObjP33)
	.byte OG1_POff(ObjP34), OG1_POff(ObjP35), OG1_POff(ObjP36), OG1_POff(ObjP37)
	.byte OG1_POff(ObjP38), OG1_POff(ObjP39), OG1_POff(ObjP3A), OG1_POff(ObjP3B)
	.byte OG1_POff(ObjP3C), OG1_POff(ObjP3D), OG1_POff(ObjP3E), OG1_POff(ObjP3F)
	.byte OG1_POff(ObjP40), OG1_POff(ObjP41), OG1_POff(ObjP42), OG1_POff(ObjP43)
	.byte OG1_POff(ObjP44), OG1_POff(ObjP45), OG1_POff(ObjP46), OG1_POff(ObjP47)


	; Object group $01 (i.e. objects starting at ID $24) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup01_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup01_PatternSets:
	; (End restricted alignment space)

ObjP35:
	.byte $AD, $AF, $B5, $B7
	.byte $81, $83, $85, $87

ObjP25:
ObjP2F:
ObjP47:
	.byte $95, $97, $B9, $BF
ObjP30:
ObjP45:
	.byte $85, $87, $89, $8B, $81, $83
ObjP31:
	.byte $A1, $A3, $A5, $A7, $A1, $A3, $AB, $AD, $A1, $A3, $A5, $A7
ObjP32:
	.byte $B9, $BB, $BD, $BF

ObjP40:
	.byte $89, $8B, $8B, $8B, $8B, $8D
ObjP27:
ObjP28:
ObjP36:
ObjP37:
ObjP38:
ObjP3C:
ObjP3E:
ObjP26:
ObjP44:
	.byte $8F, $9D, $9D, $9D, $9D, $9F
ObjP2B:
	.byte $A9, $AB, $AD, $AF, $A9, $AB, $B1, $B3, $A9, $AB, $AD, $AF

ObjP42:
	.byte $B5, $B7, $B9, $BB, $B5, $B7, $BD, $BF
	
ObjP33:
ObjP39:
	.byte $A1, $A3, $AD, $AF, $A5, $A7, $A9, $AB
ObjP34:
	.byte $B9, $BB, $BD, $BF
ObjP3D:
	.byte $A1, $A3, $A5, $A7, $A9, $AB
ObjP2D:
	.byte $81, $83, $85, $8D, $A1, $8B, $81, $83, $85, $87, $89, $8B, $81, $83, $85, $87, $89, $91, $81, $83, $85, $8D, $A1, $8B, $81, $83, $85, $8D, $A1, $91, $71, $A3, $A5, $71, $71, $71, $71, $99, $9B, $71, $71, $71
ObjP24:
	.byte $A1, $A3, $A5, $A7, $B7, $B7
	.byte $A9, $AB, $AD, $AF, $B7, $B7
	.byte $B1, $B3, $B5, $B7, $B7, $B7
ObjP2C:
	.byte $81, $83, $83, $83, $85, $87
ObjP3F:
	.byte $C1, $C3, $C5, $C7, $C9, $CB, $CD, $CF, $D1, $D3, $D5, $F9, $DD, $DF
	
	; Spike's / Patooie's spike ball patterns are actually here
SpikeBall_Patterns:
	.byte $95, $95, $D9, $DB
ObjP29:
	.byte $81, $83, $85, $87, $89, $8B, $8D, $8F, $97, $99
ObjP2A:
ObjP46:
	.byte $E5, $E5, $E1, $E1, $E1, $E1, $BD, $BF, $E3, $E3
ObjP3B:
ObjP43:
	.byte $E7, $E9, $E7, $EF, $E7, $EF
ObjP3A:
	.byte $71, $E1, $E3, $E1, $E3, $71
ObjP2E:
	.byte $D1, $D3, $D1, $D3
ObjP41:
	.byte $7F, $57

GiantBlockCtl_BlkBump:	.byte CHNGTILE_GIANTBRICKFIX, CHNGTILE_GIANTBLOCKHIT, CHNGTILE_GIANTBLOCKHIT, CHNGTILE_GIANTBRICKBUST
GiantBlockCtl_BlockStarts:	.byte TILE11_BRICK_UL, TILE11_QBLOCKC_UL, TILE11_QBLOCKP_UL
GiantBlockCtl_Frames:	.byte $00, $08, $08

	.byte $00

PRG002_A27B:
	.byte $00, $00, $50, $40, $30, $20, $00, $E0, $D0, $C0, $B0

ObjNorm_GiantBlockCtl:
	LDA Objects_Timer,X
	BNE PRG002_A2CD	 ; If timer not expired, jump to PRG002_A2CD

	LDA Objects_Var2,X
	PHA		 ; Save Var2

	; Clear Var2
	LDA #$00
	STA Objects_Var2,X

	PLA
	STA <Temp_Var11	 ; Restore Var2 -> Temp_Var11
	BNE PRG002_A2A1	 ; If non-zero, jump to PRG002_A2A1

	LDA Player_HitCeiling
	BEQ PRG002_A2CC	 ; If Player did not just hit off ceiling, jump to PRG002_A2CC

	LDA Level_Tile_GndR

PRG002_A2A1:
	STA <Temp_Var1	 ; Var2 or Player detected tile -> Temp_Var1

	LDY #$02	 ; Y = 2
PRG002_A2A5:

	; Determine what kind of giant block was just hit
	LDA <Temp_Var1
	SUB GiantBlockCtl_BlockStarts,Y

	CMP #$04	 
	BGE PRG002_A2C9	 ; If result >= 4 (out of range block type), jump to PRG002_A2C9

	; result < 4 ...

	; Set frame by index
	LDA GiantBlockCtl_Frames,Y
	STA Objects_Frame,X

	TYA		; Y = frame

	BNE PRG002_A2C2	 ; If frame = 0, jump to PRG002_A2C2

	LDA <Temp_Var11
	BNE PRG002_A2C0	 ; If Temp_Var11 (previous Var2) <> 0, jump to PRG002_A2C0

	LDA <Player_Suit
	BEQ PRG002_A2C2	 ; If Player is small, jump to PRG002_A2C2

PRG002_A2C0:
	LDY #$03	 ; Y = 3

PRG002_A2C2:
	TYA		 ; A = frame or 3
	STA Objects_Var1,X	 ; -> Var1

	JMP PRG002_A325	 ; Jump to PRG002_A325

PRG002_A2C9:
	DEY		; Y--
	BPL PRG002_A2A5	; While Y >= 0, loop!

PRG002_A2CC:
	RTS		 ; Return

PRG002_A2CD:

	; Timer not expired...

	CMP #$01
	BNE PRG002_A2DB	 ; If timer is at 1, jump to PRG002_A2DB

	; Timer not expired, > 1

	LDY Objects_Var1,X	 ; Y = Var1

	; Triggers a block bump removal
	LDA GiantBlockCtl_BlkBump,Y
	STA Level_BlkBump+2

	RTS		 ; Return

PRG002_A2DB:
	JSR PRG002_A450

	LDA <Player_HaltGame
	BEQ PRG002_A2E3	 ; If gameplay halted, jump to PRG002_A2E3

	RTS		 ; Return

PRG002_A2E3:
	LDA Objects_Timer,X
	CMP #$0a
	BNE PRG002_A30C	 ; If timer <> $0A, jump to PRG002_A30C

	; Timer = $0A...

	PHA		 ; Save timer value

	; Object Y Hi -> Temp_Var13
	LDA <Objects_YHi,X
	STA <Temp_Var13	

	; Object Y -> Temp_Var14
	LDA <Objects_Y,X
	STA <Temp_Var14	

	; Object X Hi -> Temp_Var15
	LDA <Objects_XHi,X
	STA <Temp_Var15	

	; Object X -> Temp_Var16
	LDA <Objects_X,X
	PHA		 ; Save Object X
	STA <Temp_Var16

	; Clear this tile
	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars

	PLA		 ; Restore 'X'
	ORA #$10	 ; Intended as next tile to the right I think
	STA <Temp_Var16	 ; -> Temp_Var16

	; Clear this tile too
	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars

	PLA		 ; Restore timer

PRG002_A30C:
	TAY		 ; current timer value -> 'Y'
	LDA PRG002_A27B,Y	
	STA <Objects_YVel,X	 ; Applies a staggering Y velocity

	JMP Object_ApplyYVel	 ; Apply Y velocity and don't come back!

GiantBlockCtl_DebrisXOff:	.byte $00, $10, $00, $10
GiantBlockCtl_DebrisYOff:	.byte $00, $00, $10, $10
GiantBlockCtl_DebrisXVel:	.byte -$10, $10, -$10, $10
GiantBlockCtl_DebrisYVel	.byte -$40, -$40, -$28, -$28

PRG002_A325:
	; Set like Player bounced up
	LDA #$01	 
	STA Player_BounceDir

	LDA <Temp_Var11	 ; A = Temp_Var11 (previous Var2)
	BNE PRG002_A35E	 ; If non-zero, jump to PRG002_A35E

	; Play "bump" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	; Set Object Y Hi = Player's Y Hi
	LDA <Player_YHi
	STA <Objects_YHi,X

	LDA <Player_Y

	LDY <Player_Suit
	BEQ PRG002_A347	 ; If Player is small, jump to PRG002_A347

	; Player is NOT small; subtract 16
	SUB #$10
	BCS PRG002_A347
	DEC <Objects_YHi,X	; Apply carry
PRG002_A347:

	AND #$f0	 ; Align to tile grid row
	ORA #$10	 ; Ensures nearest 32
	STA <Objects_Y,X ; -> Object_Y

	; Set Object X Hi = Player's X Hi
	LDA <Player_XHi	
	STA <Objects_XHi,X

	; Use Player X + 8
	LDA <Player_X
	ADD #$08	
	BCC PRG002_A35A	
	INC <Objects_XHi,X	; Apply carry
PRG002_A35A:

	AND #$e0	 ; Aligned to tile grid, left side only
	STA <Objects_X,X ; -> Object_X

PRG002_A35E:

	; Set BlkBump slot 2 coordinates to the object's position

	LDA <Objects_X,X
	STA Level_BlkBump_XLo+2

	LDA <Objects_XHi,X
	STA Level_BlkBump_XHi+2

	LDA <Objects_YHi,X
	STA Level_BlkBump_YHi+2

	LDA <Objects_Y,X
	STA Level_BlkBump_YLo+2

	LDA #CHNGTILE_GIANTBRICKBUST
	STA Level_BlkBump+2

	LDA Objects_Var1,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word GBCtl_BrickBump	; 0: Giant brick bump (small Player hit it)
	.word GBCtl_CoinBlock	; 1: Giant [?] block with coin
	.word GBCtl_LeafBlock	; 2: Giant [?] block with power up
	.word GBCtl_BrickBust	; 3: Giant brick bust

GBCtl_BrickBump:
	JMP PRG002_A420	; Jump to PRG002_A420

GBCtl_CoinBlock:
	INC Coins_Earned	 ; Give a coin

	LDA <Objects_Y,X
	STA <Temp_Var1		; Temp_Var1 = Object's Y

	LDA <Objects_X,X
	ORA #$0e
	STA <Temp_Var2		; Temp_Var2 = Object's X aligned evenly in column

	JSR PRG000_C49B	 ; Init for emerging coin

	JMP PRG002_A420	 ; Jump to PRG000_C49B

GBCtl_LeafBlock:
	LDA <Player_X
	AND #$10
	STA Player_MushFall ; Determine which way a powerup should fall

	LDA #$1e	; A = $1E if Player is not small (Super Leaf)

	LDY <Player_Suit
	BNE PRG002_A3AA	 ; If Player is NOT small, jump to PRG002_A3AA

	LDA #$0d	 ; Otherwise, A = $0D (Mushroom)

PRG002_A3AA:
	LDY #$05	 ; Y = 5 (altering fifth object slot)

	; Make power up appear
	STA Level_ObjectID,Y

	; Set State = 1 (Init)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

	; Set X as +8 from Object X
	LDA <Objects_X,X
	ADD #$08
	STA Objects_X,Y

	; Match other coordinates
	LDA <Objects_XHi,X
	STA Objects_XHi,Y
	LDA <Objects_Y,X
	STA Objects_Y,Y	
	LDA <Objects_YHi,X
	STA Objects_YHi,Y

	JMP PRG002_A420	 ; Jump to PRG002_A420

GBCtl_BrickBust:
	; Crumbling brick noise
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	LDX #$03	 ; X = 3 (looking for up to 4 special objects, the brick debris)
	LDY #$05	 ; Y = 5

PRG002_A3DA:
	LDA SpecialObj_ID,Y
	BEQ PRG002_A3E5	 ; If this special object slot is free, jump to PRG002_A3E5

	DEY		 ; Y--
	BPL PRG002_A3DA	 ; While Y >= 0, loop!

	JMP PRG002_A420	 ; Jump to PRG002_A420

PRG002_A3E5:

	; Found a free slot!

	; Brick debris
	LDA #SOBJ_BRICKDEBRIS
	STA SpecialObj_ID,Y

	; Set brick debris coordinates
	LDA GiantBlockCtl_DebrisXOff,X
	ADD Level_BlkBump_XLo+2	
	STA SpecialObj_XLo,Y	

	LDA GiantBlockCtl_DebrisYOff,X	
	ADD Level_BlkBump_YLo+2
	STA SpecialObj_YLo,Y
	LDA #$00	
	ADC Level_BlkBump_YHi+2		
	STA SpecialObj_YHi,Y	

	; Set brick debris X Velocity
	LDA GiantBlockCtl_DebrisXVel,X	
	STA SpecialObj_XVel,Y	

	; Set brick debris Y Velocity
	LDA GiantBlockCtl_DebrisYVel,X	
	STA SpecialObj_YVel,Y

	; Brick data = 0
	LDA #$00
	STA SpecialObj_Data,Y

PRG002_A417:

	; RAS: Site of ancient bug; see notes in original disassembly!

	DEX		 ; X--
	BPL PRG002_A3DA	 ; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	JMP PRG002_A420	 ; Jump to PRG002_A420

PRG002_A420:
	LDA <Temp_Var11	; A = Temp_Var11 (previous Var2)
	BNE PRG002_A428	 ; If non-zero, jump to PRG002_A428

	; Otherwise, halt Player's vertical movement
	LDA #$00
	STA <Player_YVel

PRG002_A428:

	; Set timer to $0B
	LDA #$0b
	STA Objects_Timer,X

	JMP PRG002_A450	 ; Jump to PRG002_A450

GiantBlockCtl_Pats:	.byte $73, $7B, $7B, $73, $7D, $7F, $7F, $7D, $79, $7B, $7B, $79, $79, $7B, $7B, $79
GiantBlockCtl_Attrs:	.byte $00, $00, SPR_HFLIP, SPR_HFLIP, $00, $00, SPR_HFLIP, SPR_HFLIP, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_VFLIP, SPR_VFLIP, SPR_HFLIP | SPR_VFLIP, SPR_HFLIP | SPR_VFLIP

PRG002_A450:
	LDA Objects_Var1,X
	CMP #$03
	BEQ PRG002_A487	 ; If Var1 = 3, jump to PRG002_A487 (RTS)

	JSR Object_CalcSpriteXY_NoHi

	LDA <Objects_SpriteX,X
	STA <Temp_Var2		 ; Temp_Var2 = Sprite X

	PHA		 ; Save it

	DEC <Objects_SpriteY,X	 ; Sprite Y--

	LDA <Objects_SpriteY,X
	STA <Temp_Var3		 ; Temp_Var3 = Sprite Y

	PHA		 ; Save it

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	LDA Objects_Frame,X
	TAX		 ; X = object's frame
	JSR GiantBlockCtl_Draw
	JSR GiantBlockCtl_Draw

	PLA		 ; Restore Sprite Y
	ADD #16
	STA <Temp_Var3	 ; Temp_Var3 = Sprite Y + 16

	PLA		 ; Restore Sprite X
	STA <Temp_Var2	 ; -> Temp_Var2

	JSR GiantBlockCtl_Draw
	JSR Object_GetRandNearUnusedSpr	 ; Get random nearby unused sprite
	JSR GiantBlockCtl_Draw

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_A487:
	RTS		 ; Return

GiantBlockCtl_Draw:
	LDA Player_AboveTop
	BNE PRG002_A4B7	 ; If Player is way up high, jump to PRG002_A4B7 (RTS)

	LDA #$02
	STA <Temp_Var5	 ; Temp_Var5 = 2
PRG002_A491:
	; Store Sprite Y
	LDA <Temp_Var3
	STA Sprite_RAM+$00,Y

	; Store appropriate pattern
	LDA GiantBlockCtl_Pats,X
	STA Sprite_RAM+$01,Y

	; Set attributes
	LDA #SPR_PAL3	; Palette select 3
	ORA GiantBlockCtl_Attrs,X	; And what he's having
	STA Sprite_RAM+$02,Y

	; Store Sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; X += 8
	ADD #$08
	STA <Temp_Var2

	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)

	INX		 ; X++ (next pattern/attribute)

	DEC <Temp_Var5	 ; Temp_Var5--
	BNE PRG002_A491	 ; While Temp_Var5 > 0, loop!

PRG002_A4B7:
	RTS		 ; Return

	; Carry is set if gameplay not halted and object not dead
CarryClearIfAliveAndNoHalt:
	LDA Objects_State,X	  
	CMP #OBJSTATE_KILLED	; Carry is clear unless state >= OBJSTATE_KILLED
	BEQ PRG002_A4C5	 ; If object state is Dying, jump to PRG002_A4C5

	CLC		 ; Clear carry (if any state other than OBJSTATE_KILLED)

	LDA <Player_HaltGame
	BEQ PRG002_A4C5	 ; If gameplay is not halted, jump to PRG002_A4C5

	SEC		 ; Set carry

PRG002_A4C5:
	RTS		 ; Return

ObjInit_PipewayCtlr:
	; Changes Objects_Y into a grid row position (including the high) rather than a pixel position
	; Used as index (see xcv)
	LSR <Objects_YHi,X
	LDA <Objects_Y,X
	ROR A	; Carries in the high bit, first division
	LSR A
	LSR A
	LSR A	; Completes divide-by-16 (makes grid row position)
	STA <Objects_Y,X

	; Flag we were just in a Pipeway
	INC Map_WasInPipeway

	; Initialize current world for counter
	LDA World_Num
	STA <Objects_Var4,X

	RTS		 ; Return

	; RAS: Merged these tables for ease of use...
	;
	; XHi:
	; Sets the "Map_Entered_XHi" value based on whether you're coming or going
	; That means the Player's X Hi position on the map (not screen scroll position!)
	; Almost the same as PipewayCtlr_MapScrlXHi without the centering bit.
	;
	; X:
	; This contains two values for Map X (*16) whether you're coming or going.
	; That means the Player's X Lo position on the map (not screen scroll position!)
	; The upper nibble ("left") cooresponds to the pipe on the left side
	; The lower nibble ("right") cooresponds to the pipe on the right side
	;
	; Y:
	; This contains two values for Map Y (*16) whether you're coming or going.
	; That means the Player's Y position on the map
	; The upper nibble ("left") cooresponds to the pipe on the left side
	; The lower nibble ("right") cooresponds to the pipe on the right side
	;
	; XSC:
	; This is for the horizontal scroll position of the map.
	; The lower bits of each nibble specify the hard screen position 
	; (i.e. scroll X Hi) and if the highest bit is set means to use
	; the center $80 position instead of the $00 position.
	; The upper nibble ("left") cooresponds to the pipe on the left side
	; The lower nibble ("right") cooresponds to the pipe on the right side	
	;
	; WT:
	; RAS: NEW!  Target WORLD (Left/Top or Right/Bottom)
	;
	; RESV:
	; Reserved...
PipewayCtlr_Dest:
		;     XHi  X    Y    XSC  WT,  RESV
PCDI00	.byte $10, $21, $42, $80, $19, $00	; Pipeway Controller Index 0
PCDI01	.byte $10, $82, $4A, $10, $39, $00	; Pipeway Controller Index 1
PCDI02	.byte $11, $41, $42, $18, $59, $00	; Pipeway Controller Index 2
PCDI03	.byte $01, $E1, $7A, $08, $79, $00	; Pipeway Controller Index 3	FIXME Reserved for W8's zero pipe 
PCDI04	.byte $00, $4C, $35, $08, $66, $00	; Pipeway Controller Index 4
PCDI05	.byte $01, $E8, $55, $81, $66, $00	; Pipeway Controller Index 5

PCDO .func ((\1 - PipewayCtlr_Dest) / 2)	; The offsets 
PipewayCtlr_Dest_Offset:
	.byte PCDO(PCDI00)
	.byte PCDO(PCDI01)
	.byte PCDO(PCDI02)
	.byte PCDO(PCDI03)
	.byte PCDO(PCDI04)
	.byte PCDO(PCDI05)

Pipeway_MusInvert:	.byte $00, $18

ObjNorm_PipewayCtlr:
	JSR PipewyCtl_SetCarryByPPos	 ; Carry = 1 if Player is on lower part of level OR if Player is on right half of screen

	LDA #$00
	ROR A
	STA <Temp_Var1	 ; Temp_Var1 = $00 or $80 based on above

	ROL A
	ROL A
	TAY
	LDA Pipeway_MusInvert,Y
	STA <Temp_Var15		; If we need to set music inversion
	
	; Load default pointer address
	LDA #LOW(PipewayCtlr_Dest)
	STA <Temp_Var3
	LDA #HIGH(PipewayCtlr_Dest)
	STA <Temp_Var4

	; Get offset from based
	LDY Objects_Y,X		; object's Y position (i.e. the index value)
	LDA PipewayCtlr_Dest_Offset,Y	; Get offset
	ASL A		; Needs to be shifted up to be correct (stored shifted right 1)
	ADD <Temp_Var3
	STA <Temp_Var3
	
	BCC PRG002_AF2F		; If carry is NOT set (a >= $80 value indicate "second page"), jump to PRG029_CF2F

	INC <Temp_Var4	 ; Go to second page

PRG002_AF2F:

	LDX Player_Current ; X = Current Player

	; Set Map X Hi
	LDY #0
	LDA [Temp_Var3],Y	; Get appropriate Map X Hi value
	JSR PipewyCtl_GetLowerValue
	STA Map_Entered_XHi,X	 ; Set as Map X High

	; Set Map X
	INY
	LDA [Temp_Var3],Y
	JSR PipewyCtl_GetUpperValue
	STA Map_Entered_X,X

	; Set Map Y
	INY
	LDA [Temp_Var3],Y
	JSR PipewyCtl_GetUpperValue
	STA Map_Entered_Y,X

	; Map X Scroll value -> Temp_Var5
	INY
	LDA [Temp_Var3],Y
	JSR PipewyCtl_GetUpperValue
	STA <Temp_Var5		 ; -> 'Y'

	; Set DESTINATION world
	INY
	LDA [Temp_Var3],Y	; Get target world
	JSR PipewyCtl_GetLowerValue
	STA Map_Previous_World,X	; Set Player's target world
	STA World_Num

	; Set X Offset as appropriate by coordinate (i.e. map at left alignment or halfway-center alignment)
	LDA <Temp_Var5
	AND #$80
	STA Map_Prev_XOff,X

	; Basically takes a 3-bit value packed in the upper nibble
	; and moves it to the bottom; the lower nibble is zeroed
	; out thanks to PipewyCtl_GetUpperValue so it has no effect.
	LDA <Temp_Var5	;   xwyz 0000
	ASL A	; x wyz0 0000
	ASL A	; w yz00 0000
	ROL A	; y z000 000w
	ROL A	; z 0000 00wy 
	ROL A	; 0 0000 0wyz
	STA Map_Prev_XHi,X	 ; Store as Map X Hi

	LDX <SlotIndexBackup		 ; X = object slot index

	; Let's do a neato world transition...
	LDA <Counter_1
	AND #3
	BNE SetWorld_NoChange_Exit
		
	LDA World_Num
	PHA
	CMP <Objects_Var4,X
	BEQ SetWorld_NoChange	; If we're already displaying the right world, jump to SetWorld_NoChange
				
	; Need to change...
	
	; Temp_Var1 has bit 7 set if on the World Zero side
	; So if you're left, count up to current world
	; If you're right, count down to World Zero (which is actually 10, but sssh)
	LDA <Temp_Var1
	BMI SetWorld_OnRight
	
	; On left (current world)
	LDA <Objects_Var4,X
	CMP #9
	BNE SetWorldOnL_NotWZero	; If we're not currently display World Zero, jump to SetWorldOnL_NotWZero
	
	; Set to -1 so the increment takes place...
	LDA #-1
	STA <Objects_Var4,X
	
SetWorldOnL_NotWZero:
	INC <Objects_Var4,X
	
	JMP SetWorld_Update
	
SetWorld_OnRight:
	DEC <Objects_Var4,X
	BPL SetWorld_Update		; If we haven't gone < 0, jump to SetWorld_Update
	
	; Less than zero is World Zero!
	LDA #9
	STA <Objects_Var4,X

SetWorld_Update:
	LDA <Objects_Var4,X
	STA World_Num

	LDA RotatingColor_Cnt
	BNE SetWorl_CycleOK
	
	LDA #$1e
	STA RotatingColor_Cnt

	LDA #SND_LEVELUNK
	STA Sound_QLevel1
	LDA #SND_LEVELAIRSHIP
	STA Sound_QLevel2
	
	LDA <Temp_Var15	 ; Temp_Var1 = $00 or $80 based on above
	STA Music_InvertEn
		
SetWorl_CycleOK:
	TXA
	PHA
	TYA
	PHA
	
	JSR_THUNKA 26, StatusBar_Fill_World
	
	PLA
	TAY
	PLA
	TAX
	
SetWorld_NoChange:
	PLA
	STA World_Num
	
SetWorld_NoChange_Exit:
	RTS


PipewyCtl_SetCarryByPPos:
	LDY <Objects_YHi,X	 
	BNE PRG002_A749	 ; If Player is on lower part of level, jump to PRG002_A749

	; Player is on upper part of level...

	LDA <Player_SpriteX
	ASL A		 ; Set carry by Player's sprite X bit 7 (i.e. Player on right half of screen sets carry = 1)
	RTS		 ; Return

PRG002_A749:

	; Player is on lower part of level...

	LDA <Player_YHi	
	LSR A		 ; Set carry = 1
	RTS		 ; Return


PipewyCtl_GetUpperValue:
	BIT <Temp_Var1
	BPL PRG002_A755	 ; If , jump to PRG002_A755

	; Shift value into upper 4 bits
	ASL A
	ASL A
	ASL A
	ASL A

PRG002_A755:
	AND #%11110000	; Keep only upper 4 bits
	RTS		 ; Return
	
PipewyCtl_GetLowerValue:
	BIT <Temp_Var1
	BMI PRG002_A712	 ; If Temp_Var1 = $80, jump to PRG002_A712

	; Otherwise, shift retrieved value down by 4 bits (get secondary value)
	LSR A	
	LSR A	
	LSR A	
	LSR A	

PRG002_A712:
	AND #%00001111	; Keep only one of the values
	RTS
	
	; Different "entropy" values by the object's slot -- keeps things random looking
Entropy_BySlot:	.byte $13, $D7, $F9, $36, $7F

ObjInit_HotFoot:
	LDA Entropy_BySlot,X
	STA <Objects_Var5,X

ObjInit_HotFootShy:

	; Center Hot Foot
	LDA <Objects_X,X
	ORA #$04
	STA <Objects_X,X

	RTS		 ; Return

ObjNorm_HotfootShy:
	LDA Objects_InWater,X
	BEQ HotFoot_NotInWater
	
	; Use "poof" death
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State,X

	; Set timer to $1F (poof death timer)
	LDA #$1f
	STA Objects_Timer,X

	LDA #SND_PLAYERKICK
	STA Sound_QPlayer
	
HotFoot_NotInWater:
	JSR Object_ApplyYVel	 ; Apply Y Velocity

	; Hotfoot's gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	JSR Object_WorldDetectN1
	LDA <Objects_DetStat,X
	AND #$03
	BNE PRG002_A81B	 ; If Hotfoot hit a wall, jump to PRG002_A81B

	JSR Object_ApplyXVel	 ; Apply X velocity

PRG002_A81B:
	JSR Object_HitFloorAlign	 ; If HotFoot hits the floor, align him to it
	JSR Boo_CheckPlayerSight	 ; Uses Boo's check-facing logic

	LDY #$04	 ; Y = 4

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A846	 ; If Hotfoot has NOT hit floor, jump to PRG002_A846

	LDA #$00	; Don't move (if not chasing Player)

	BCC PRG002_A844	 ; (From Boo_CheckPlayerSight) if not chasing Player, jump to PRG002_A844

	; Hotfoot is chasing Player...

	; Face same way as Player
	LDA <Player_FlipBits
	STA Objects_FlipBits,X

PRG002_A832:
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$02
	TAY		 ; Y = 0 or 2

	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA #$08	; Walk right

	BCS PRG002_A844	; If horizontally flipped, jump to PRG002_A844

	LDA #-$08	; Walk left

PRG002_A844:
	STA <Objects_XVel,X	 ; Set X velocity appropriately

PRG002_A846:
	TYA		 ; A = 0 or 2
	STA Objects_Frame,X	 ; Set frame

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

PRG002_A850:
	LSR Objects_Frame,X	 ; Frame becomes 0 or 1 (to be ROLled back)

	LDA <Counter_1
	LSR A	
	ROL Objects_Frame,X	 ; Frame is now 0/1 or 2/3, depending on counter LSb (flickering effect) 

Bank2_HotFootHaltAction:
	JSR Object_AnySprOffscreen
	BNE PRG002_A888	 ; If any of Hotfoot's sprites are off-screen, jump to PRG002_A888 (RTS)

	JSR Object_CalcSpriteXY_NoHi	; Calculate Hotfoot's sprites
	LDY ObjGroupRel_Idx	 	; Y = Object's group relative index
	LDA ObjectGroup_PatternStarts,Y	; Get Hotfoot's starting pattern index
	ADD Objects_Frame,X	 	; Offset by frame
	TAY		 		; -> 'Y'
	LDA ObjectGroup_PatternSets,Y	; Get appropriate sprite pattern for this frame

	; Store pattern into sprite RAM
	LDY Object_SprRAM,X
	STA Sprite_RAM+$01,Y

	; Store Y coordinate
	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$00,Y

	; Store attributes
	LDA Objects_SprAttr,X
	ORA Objects_FlipBits,X
	STA Sprite_RAM+$02,Y

	; Store X coordinate
	LDA <Objects_SpriteX,X
	STA Sprite_RAM+$03,Y	

PRG002_A888: 
	RTS		 ; Return


ObjNorm_Hotfoot:

	; Mostly reuses the "shy" Hotfoot's code

	JSR CarryClearIfAliveAndNoHalt
	BCS PRG002_A850	 ; If Hotfoot is not alive or gameplay is halted, jump to PRG002_A850

	; Hotfoot alive and gameplay not halted...

	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDY #$04	 ; Y = 4

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A846	 ; If Hotfoot hasn't hit floor, jump to PRG002_A846

	INC <Objects_Var5,X	 ; Var5++
	LDA <Objects_Var5,X	
	AND #$a0
	BEQ PRG002_A844	 ; If Var5 = $A0, jump to PRG002_A844

	ASL A

	LDA <Objects_Var5,X
	TAY		 ; Y = Var5
	AND #%01011111
	BNE PRG002_A8B6	 ; Most of the time, jump to PRG002_A8B6

	BCC PRG002_A8B3	 ; If Var5 bit 7 not set, jump to PRG002_A8B3

	JSR Object_CalcCoarseXDiff
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Store flip towards Player

PRG002_A8B3:
	JSR Object_FlipFace	 ; Turn around

PRG002_A8B6:
	JMP PRG002_A832	 ; Jump to PRG002_A832

Boo_CheckPlayerSight:
	LDY <Objects_Var5,X

	JSR Object_CalcCoarseXDiff
	EOR <Player_FlipBits	 ; Check flip direction against Player; if Player and Boo are facing eachother, result is non-zero
	ASL A		 ; Push up result so it is $00 or $80
	BPL PRG002_A8C5	 ; If Player is not facing Boo, jump to PRG002_A8C5

	LDY #$00	 ; Otherwise, Y = 0

PRG002_A8C5:
	CPY #$14
	BGE PRG002_A8CC	 ; If Var5 >= $14 (Time to start chasing!), jump to PRG002_A8CC

	INY		 ; Y++ (Delaying before starting chase)

	STY <Objects_Var5,X	; Update Var5

PRG002_A8CC:
	RTS		 ; Return

Boo_VelAccel:	.byte $01, -$01
Boo_VelLimit:	.byte $05, -$05

ObjInit_Boo:

	; RAS: NEW -- Boos in the dark will chase you perpetually!
	; Can't shy away if they can't see you!
	; ...
	; So the technical thing is, is a darkness controller present?  
	; If so, alternate behavior time!

	; We'll use Var1 to track darkness; if it is $FF, no darkness controller is active...
	LDA #$FF
	STA Objects_Var1,X
	
	LDY #4
Boo_CheckDarkness_Loop:
	LDA Objects_State,Y
	BEQ BooCDL_NotDarkCtl	; If object is not alive, jump to BooCDL_NotDarkCtl

	LDA Level_ObjectID,Y
	CMP #OBJ_DARKNESSCTL
	BNE BooCDL_NotDarkCtl	; If this is not the darkness controller, jump to BooCDL_NotDarkCtl
	
	; Darkness controller found!  Activate darkness monitoring!
	TYA
	STA Objects_Var1,X

	RTS

BooCDL_NotDarkCtl:
	DEY		; Y--
	BPL Boo_CheckDarkness_Loop	; While Y >= 0, loop!
	
	RTS


ObjNorm_Boo:
	; RAS: NEW!  ALWAYS chase if dark!
	LDY Objects_Var1,X
	BMI Boo_NoDarknessCtl	; If no darkness controller present, abort!
	
	; If brightness controller is in state 1, it's bright, so act normal...
	LDA Objects_Var4,Y
	CMP #1
	BEQ Boo_NoDarknessCtl
	
	; It's dark!  Go nuts!
	BNE PRG002_A8DE

Boo_NoDarknessCtl:
	JSR Boo_CheckPlayerSight
	BCS PRG002_A8DE	 ; If carry set, it's time to start chasing Player!  Jump to PRG002_A8DE

	; Otherwise, Boo just sits still
	LDA #$00
	STA <Objects_XVel,X
	STA <Objects_YVel,X

	BEQ PRG002_A916	 ; Jump (technically always) to PRG002_A916

PRG002_A8DE:
	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP Boo_VelLimit,Y	
	BEQ PRG002_A8EE	 ; If Boo is at his acceleration limit, jump to PRG002_A8EE

	ADD Boo_VelAccel,Y	 ; Boo accelerates!
	STA <Objects_XVel,X	 ; Update Boo's X velocity

PRG002_A8EE:

	; Set flip bit as appropriate
	LDA FacePlayer_FlipBitsStart+1,Y
	STA Objects_FlipBits,X	

	JSR Object_CalcCoarseYDiff

	LDY #$00	 ; Y = 0 (Player is lower, move down!)

	LDA <Temp_Var15
	SUB #$04
	BMI PRG002_A901

	INY		 ; Y = 1 (Player is higher, move up!)

PRG002_A901:
	LDA <Objects_YVel,X
	CMP Boo_VelLimit,Y
	BEQ PRG002_A90E	 ; If Boo is at his acceleration limit, jump to PRG002_A90E

	ADD Boo_VelAccel,Y	 ; Boo accelerates!
	STA <Objects_YVel,X	 ; Update Boo's Y velocity

PRG002_A90E:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	LDA #$01	 ; A = 1 (frame 1, chase!)

PRG002_A916:
	STA Objects_Frame,X	 ; Update Boo's frame

	JSR Object_HitTestRespond	; Do collision test with Player and respond
	JSR Fish_FixedYIfAppro	 	; Fix Boo Y for raster area

Object_DeleteOrDraw:
	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JMP Object_ShakeAndDraw	 	; Draw and don't come back!

Stretch_XVelStart:	.byte -$10, $10
FacePlayer_FlipBitsStart:	.byte $00, SPR_HFLIP, $00	; Boo uses an off-by-1 index here, hence the other $00


Goblin_3rdSprPat:	.byte $B7, $AF	; Bottom right sprite pattern by frame
Goblin_XVel:		.byte -$18, $18
Goblin_SprXOff:		.byte 16, -8	; +16 normally (as right sprite) or -8 if h-flipped (as left sprite)

ObjInit_Goblin:
	INC Objects_IsGiant,X
	RTS

ObjNorm_Goblin:
	LDA <Player_HaltGame
	BNE Goblin_Draw

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE Goblin_Draw		; If Goblin not in normal state (e.g. killed), jump to Goblin_Draw

	JSR Object_HitTestRespond	; Handle object collision
	JSR Object_InteractWithWorld2	; Move, detect, interact with blocks of world
	JSR Object_ToggleFrameBySpd	; Toggle frame 0 or 1 by object's speed

	LDA Objects_DetStat,X
	AND #$03
	BEQ Goblin_NotHitWall	; If Goblin did not hit wall, jump to Goblin_NotHitWall

	; Reverse face!
	LDA Objects_FlipBits,X
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X

Goblin_NotHitWall:
	LDA Objects_DetStat,X
	AND #$04
	BEQ Goblin_NotOnFloor	; If Goblin did not hit floor, jump to Goblin_NotOnFloor

	LDA Objects_Var1,X
	BNE Goblin_Run

	; Searching h-flip back/forth
	LDA <Counter_1
	AND #$10
	ASL A
	ASL A
	STA Objects_FlipBits,X

	; Goblin needs to look for Player

	JSR Object_CalcCoarseXDiff

	LDA <Temp_Var15
	CMP #18
	BGS Goblin_Draw
	CMP #-18
	BLS Goblin_Draw

	; Player is close enough; change to run state
	INC Objects_Var1,X

	; Face Player
	LDA <Temp_Var16
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X

	LDA <Temp_Var16
	ROL A
	ROL A
	TAY
	LDA Goblin_XVel,Y
	STA Objects_XVel,X

Goblin_Run:
	; If Goblin is on floor, do a little bounce (just for fun)
	;LDA #-$18
	;STA Objects_YVel,X

Goblin_NotOnFloor:

	JSR Player_HitEnemy	 ; Do Player to enemy collision

Goblin_Draw:
	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of Goblin's sprites
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of Goblin's sprites

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ Goblin_NoHFlip	; If Goblin is not horizontally flipped, jump to Goblin_NoHFlip

	; To draw flipped, we need to move the "big" part of the Goblin sprite over by 8
	; To make sure it's syncing up with the horizontal vis checks, we'll shift the X
	; over AND rotate the bits over, preserving carry so we can get that back later.
	LDA Objects_X,X
	ADD #8
	STA Objects_X,X

	; Roll and save carry (will use vis checks for sprite column 2 and 3 instead of 1 and 2)
	ROL Objects_SprHVis,X
	PHP	; Save carry

Goblin_NoHFlip:

	JSR Object_Draw16x32Sprite

	; After the initial 16x32
	LDA Object_SprRAM,X
	ADD #16
	TAY

	; By default, make right-most sprites invisible; use $F8 hiding value
	LDA #$F8
	STA Sprite_RAM+$00,Y	; Top Right 
	STA Sprite_RAM+$04,Y	; Bottom Right

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ Goblin_NoHFlip2	; If Goblin is not horizontally flipped, jump to Goblin_NoHFlip

	; Undo the +8 we did earlier, restore the carry which we can use to determine visibility
	LDA Objects_X,X
	SUB #8
	STA Objects_X,X

	PLP	; Restore carry
	BCC Goblin_SprRightOK	; If sprite is not invisible, jump to Goblin_SprRightOK
	BCS Goblin_SprCont	; Otherwise, jump to Goblin_SprCont

Goblin_NoHFlip2:
	LDA Objects_SprHVis,X
	AND #%00100000
	BNE Goblin_SprCont	; If right-most sprite is invisible, jump to Goblin_SprCont

Goblin_SprRightOK:

	; If top sprite is invisible, bottom one is too, so do nothing
	LDA Objects_SprVVis,X
	AND #2
	BNE Goblin_SprCont	; If top sprite is invisible, both are invisible; jump to Goblin_SprCont

	; Set Y (normal)
	LDA Objects_SpriteY,X
	STA Sprite_RAM+$00,Y	; Top Right 

	LDA Objects_SprVVis,X
	AND #1
	BNE Goblin_SprCont	; If bottom sprite is invisible, jump to Goblin_SprCont

	LDA Objects_SpriteY,X
	ADD #16
	STA Sprite_RAM+$04,Y	; Bottom Right

Goblin_SprCont:
	; Pattern
	LDA #$A9
	STA Sprite_RAM+$01,Y

	LDA Objects_Frame,X
	AND #$01	; Compatibility with "killed" state using frame 2
	TAX
	LDA Goblin_3rdSprPat,X
	STA Sprite_RAM+$05,Y

	; Copy attributes
	LDA Sprite_RAM-$06,Y
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	; X = 1 if h-flipped, 0 if not
	AND #SPR_HFLIP
	ROL A
	ROL A
	ROL A
	TAX

	; Set X
	LDA Sprite_RAM-$0D,Y	; Left edge sprite X
	ADD Goblin_SprXOff,X
	STA Sprite_RAM+$03,Y	; top right
	STA Sprite_RAM+$07,Y	; bottom right

	; Pattern offsets

	; -$0F, -$0B, $01
	; -$07, -$03, $05

	LDX <SlotIndexBackup		 ; X = object slot index

	; If Goblin is vertically flipped, need to switch the additional sprites' patterns
	LDA Objects_FlipBits,X
	BPL Goblin_NoVFlip

	LDA Sprite_RAM+$01,Y
	PHA

	LDA Sprite_RAM+$05,Y
	STA Sprite_RAM+$01,Y

	PLA
	STA Sprite_RAM+$05,Y
	
Goblin_NoVFlip:
	JMP Object_DeleteOffScreen	; Delete object if it falls off screen and don't come back


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_InteractWithWorld
;
; Calls Object_Move and handles the object responding to hitting
; the floor/ceiling, or bump blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $A966
Object_InteractWithWorld2:
	JSR Object_Move	; Move and collide with world

	LDA <Objects_DetStat,X

	TAY		 ; Object detection status -> 'Y'
	AND #$04	 
	BEQ PRG002_X973	 ; If object did NOT hit floor, jump to PRG002_X973

	JSR Object_HitGround ; Object hit ground, align

PRG002_X973:
	TYA		 ; Object detection status -> 'A'
	AND #$08
	BEQ PRG002_X97C	 ; If object did NOT hit ceiling, jump to PRG002_X97C

	LDA #$04
	STA <Objects_YVel,X ; Object hit ceiling, use rebound velocity

PRG002_X97C:
	LDA Object_TileFeet2
	CMP #TILEA_BLOCKBUMP_CLEAR
	BNE PRG002_X993	 ; If object did not hit the TILEA_BLOCKBUMP_CLEAR tile, jump to PRG002_X993

	; Hit the blockbump tile... (i.e. this kills an enemy who was unlucky enough to be on a bumped block)

	LDA #-$30
	STA <Objects_YVel,X	 ; Object Y velocity = -$30

	LDA <Objects_X,X
	ASL A	
	ASL A	
	ASL A	
	ASL A			; Shift X left 4 (sort of makes it a 4.4FP)
	EOR <Objects_XVel,X	; Flip against the "whole" part of the X velocity
	AND #$80	 	
	BNE PRG002_X9B1	 	; If object is on the left half of the tile with a right going velocity or vice versa, jump to PRG002_X9B1

PRG002_X993:

	; Object didn't hit the bump tile 

	TYA		 ; Object detection status -> 'A'
	AND #$03
	BEQ PRG002_X9B7	 ; If object did NOT hit a wall, jump to PRG002_X9B7 (RTS)

	CPX #$05
	BNE PRG002_X9B1	 ; If object slot is NOT 5, jump to PRG002_X9B1

	; Object slot 5 only...

	LSR A		 ; Shifts detection bits right 1
 
	LDA <Objects_X,X
	AND #$0f	 ; Tile-relative X

	LDY #$03	 ; Y = 3

	BCS PRG002_X9A7	 ; If object hit wall on the right, jump to PRG002_X9A7

	LDY #$03	 ; Otherwise, Y = 3 (oops?)

PRG002_X9A7:
	STY <Temp_Var1	 ; Temp_Var1 = 3 (because the above does nothing, heh)
	ADD <Temp_Var1	 ; Temp_Var1 = 6
	CMP #$08	 
	BGE PRG002_X9B1	 ; If Temp_Var1 >= 8 (never gonna happen), jump to PRG002_X9B1

	RTS		 ; Return

PRG002_X9B1:

	; Combined, this just reverses the X velocity
	JSR Object_AboutFace
	JSR Object_FlipFace

PRG002_X9B7:
	RTS		 ; Return


ObjInit_InvisibleLift:

	; Object appears 11 pixels below placement
	LDA <Objects_Y,X
	ADD #11
	STA <Objects_Y,X
	BCC PRG002_A9C1	
	INC <Objects_YHi,X
PRG002_A9C1:

	LDA #SPR_VFLIP
	STA Objects_FlipBits,X

	RTS		 ; Return

ObjNorm_InvisibleLift:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR Object_CalcSpriteXY_NoHi	 ; Calculate the Sprite X and Sprite Y

	; RAS: Not invisible anymore!
	JSR InvisiLift_Draw	 ; Draw the lift

	LDA <Objects_Var5,X
	CMP #1
	BEQ PRG002_A9D2	 ; If Var5 = 1 (Lift activated), jump to PRG002_A9D2
	CMP #2
	BEQ IPlat_NoStop	 ; If Var5 = 2 (Lift terminated), jump to IPlat_NoStop

	LDA <Player_HaltGame
	BNE PRG002_A9C1	 ; If gameplay is halted, jump to PRG002_A9C1 (RTS)
	BEQ PRG002_A9F5	 ; Otherwise, jump to PRG002_A9F5

PRG002_A9D2:

	; Lift activated...

	LDA <Player_HaltGame
	BNE PRG002_A9C1	 ; If gameplay is halted, jump to PRG002_A9C1 (RTS)

	; Lift accelerates to -$08 (RAS)
	LDA <Objects_YVel,X
	SUB #$04
	CMP #-$08
	BGE PRG002_A9E4
	LDA #-$08
PRG002_A9E4:
	STA <Objects_YVel,X	 ; Update Y Velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity

PRG002_A9F5:

	JSR Object_WorldDetectN1
	
	LDA <Objects_DetStat,X
	AND #(4 | 8)
	BEQ IPlat_NoStop
	
	INC <Objects_Var5,X
	
	LDA #0
	STA <Objects_YVel,X

IPlat_NoStop:
	; Don't worry about carry since this platform doesn't move horizontally
	LDA #$00
	STA Object_XVelCarry

	JSR PlayerPlatform_Collide
	BCC PRG002_AA03	 ; If Player is not being carried by lift, jump to PRG002_AA03 (RTS)

	LDA <Objects_Var5,X
	BNE PRG002_AA03

	; Otherwise, Var5 = 1 (lift activated)
	INC <Objects_Var5,X

PRG002_AA03:
	RTS		 ; Return


InvisiLift_Draw:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	; Strip any horizontal or vertical flips from flip bits
	LDA <Temp_Var3
	AND #%00111111
	STA <Temp_Var3

	LDA <Counter_1
	LSR A	

	PHP		 ; Save CPU state
	BCC PRG002_AA17	 ; Every other tick, jump to PRG002_AA17

	; Otherwise, use Sprite_RAM offset +8
	TYA
	ADC #$07
	TAY

PRG002_AA17:
	JSR Object_Draw16x16Sprite	; Draw the first half of lift

	LDA <Temp_Var7
	PLP		 ; Restore CPU state
	BCS PRG002_AA21	 ; Every other opposite tick, jump to PRG002_AA21

	; Otherwise, use Sprite_RAM offset +8
	ADC #$08

PRG002_AA21:
	TAY		 ; Sprite_RAM offset -> 'Y'

	; X += 2 (starting sprite tile)
	INX
	INX

	; +16 for second part of lift
	LDA #16
	ADD <Temp_Var2
	STA <Temp_Var2

	; Use latter horizontal visibility bits
	ASL <Temp_Var8
	ASL <Temp_Var8
	JSR Object_Draw16x16Sprite	 ; Draw the second half of lift

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

ObjInit_Albatoss:
	; Set X velocity to -$0A
	LDA #-$0A

PRG002_AA37:
	STA <Objects_XVel,X
	RTS

ObjInit_DesertBones:

	LDA #SPR_BEHINDBG
	STA Objects_FlipBits,X

ObjInit_WoodenPlat:

	; Platform starts one pixel higher than its placement
	LDA <Objects_Y,X
	BNE PRG002_AA3F
	DEC <Objects_YHi,X
PRG002_AA3F:
	DEC <Objects_Y,X

PRG002_AA41:
	RTS		 ; Return


ObjInit_CloudPlatform:
	LDA #-$06	 ; X velocity = -$06
	BNE PRG002_AA37	 ; Jump (technically always) to PRG002_AA37

ObjInit_WoodenPlatform:
	LDA #-$08	 ; X velocity = -$08
	BNE PRG002_AA37	 ; Jump (technically always) to PRG002_AA37

ObjInit_OscillatingShort:
	INC <Objects_Var4,X	; Objects_Var4 = 1 (selects the short timer, less distance)
	BNE ObjInit_WoodenPlat	 ; Jump (technically always) to ObjInit_WoodenPlat

Albatoss_PrepBomb:

	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot if on-screen (or don't come back!)	 

	; Albatoss bomb!
	LDA #SOBJ_ALBABOMB
	STA SpecialObj_ID,Y

	; Clear timer
	LDA #0
	STA SpecialObj_Timer,Y
	STA SpecialObj_Var1,Y

	; Keep index
	TYA
	STA Objects_Var7,X

	; Tell bomb its owner
	TXA
	STA SpecialObj_Data,Y

	RTS

Albatoss_Frames:	.byte  0,  3,  6,  3
Albatoss_YOff:		.byte -8, -8, -4, -8
Albatoss_YOffHi:	.byte $FF,$FF, 0,$FF
ObjNorm_Albatoss:
	; Mostly a platform, but a little animation for fun
	; Set pattern sixth bank to 86
	LDA #86
	STA PatTable_BankSel+4

	; Bomb maybe?
	LDA Objects_Var7,X
	BMI Albatoss_BombDone
	BNE Albatoss_BombUpdate

	; Need to generate a bomb ... maybe ...
	LDA Objects_SprHVis,X
	STA <Temp_Var1		; Keep horizontal visibility flags
	
	AND #%11100000			; Only caring about this much of the sprites
	STA Objects_SprHVis,X
		
	JSR Albatoss_PrepBomb

	LDA <Temp_Var1
	STA Objects_SprHVis,X
	
Albatoss_BombUpdate:
	LDY Objects_Var7,X	; Get bomb index -> 'Y'
	BMI Albatoss_BombDone	; If we just attempted to generate a bomb but came up empty, jump to Albatoss_BombDone
	
	; Set bomb's X
	LDA <Objects_X,X
	ADD #8
	STA SpecialObj_XLo,Y
	LDA <Objects_XHi,X
	ADC #0
	STA SpecialObj_Var3,Y

	; Set bomb's Y
	LDA <Objects_Y,X
	;SUB #14
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	;SBC #$00
	STA SpecialObj_YHi,Y
	
Albatoss_BombDone:
	LDA <Counter_1
	LSR A
	LSR A
	AND #3
	TAY
	LDA Albatoss_Frames,Y
	STA Objects_Frame,X

	LDA <Objects_Y,X
	PHA
	ADD Albatoss_YOff,Y
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	PHA
	ADD Albatoss_YOffHi,Y
	STA <Objects_YHi,X

	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	JSR Object_ShakeAndCalcSprite
	LDX <SlotIndexBackup

	JMP AlbaPlatformCont

ObjNorm_CloudPlat:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

AlbaPlatformCont:
	LDA <Player_HaltGame
	BNE PRG002_AA85	 ; If gameplay halted, jump to PRG002_AA85 (RTS)

	JSR Object_ApplyXVel	 	; Apply object's X velocity
	JSR Object_ApplyYVel	 	; Apply object's Y velocity
	JMP Object_HitTestRespond	; Do hit test and respond, and don't come back!


ObjHit_CloudPlat:
	LDA <Temp_Var12
	LSR A
	BCC PRG002_AA85	 ; If not hit by Player jumping on top, jump to PRG002_AA85 (RTS)

	LDA <Player_YVel
	BMI PRG002_AA85	 ; If Player is moving upward, jump to PRG002_AA85 (RTS)

Player_StandOnPlatform:

	; Set Player to object's Y - 31
	LDA <Objects_Y,X	 
	SUB #31
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	; Flag Player as NOT mid-air
	LDY #$00
	STY <Player_InAir

	LDA Object_XVelCarry
	BPL PRG002_AA7B	

	DEY		 ; Y = -1 (provides a sort of carry if Player's X Velocity caused one)

PRG002_AA7B:
	; Add to Player_X, with carry
	ADD <Player_X
	STA <Player_X
	TYA
	ADC <Player_XHi
	STA <Player_XHi

PRG002_AA85:
	RTS		 ; Return

ObjNorm_WoodenPlatRider:

	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_AAA6	 ; If gameplay is halted, jump to PRG002_AAA6 (RTS)

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR PlayerPlatform_Collide	 ; Collide and ride

	LDA <Objects_XVel,X
	BNE PRG002_AA9A	 ; If platform is moving horizontally, jump to PRG002_AA9A

	; Platform not moving horizontally...
	BCS PRG002_AAA4	 ; If carry-collision occurred with platform, jump to PRG002_AAA4

	RTS		 ; Return


PRG002_AA9A:

	; Platform rider picks up speed until X Vel = $10

	CMP #$06
	BEQ PRG002_AAA6	 ; If Platform's X velocity = $10, jump to PRG002_AAA6 (RTS)

	LDA Level_NoStopCnt
	LSR A	
	BCS PRG002_AAA6	 ; Every other tick, jump to PRG002_AAA6 (RTS)

PRG002_AAA4:
	INC <Objects_XVel,X	 ; Increase platform's speed to the right

PRG002_AAA6:
	RTS		 ; Return


Enemy_CollideWithWorld:
	JSR Object_Move	 ; Do standard object movements

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG002_AAB2	 ; If enemy has NOT hit ceiling, jump to PRG002_AAB2

	; Otherwise, hit off ceiling
	STA <Objects_YVel,X

PRG002_AAB2:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ Object_HitFloorAlign	 ; If enemy has NOT hit walls, jump to Object_HitFloorAlign

	LDA <Objects_XVel,X
	BEQ Object_HitFloorAlign	 ; If object is not moving horizontally, jump to Object_HitFloorAlign

	JSR Object_AboutFace	 ; Otherwise, turn around

Object_HitFloorAlign:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AAA6	 ; If object has NOT hit ground, jump to PRG002_AAA6 (RTS)
	JMP Object_HitGround	 ; Otherwise, align to ground and don't come back!

	; Oscillating platform velocity and limits by direction
OscXVelLimit:	.byte -$10, $10
OscXVel:	.byte -$01, $01

ObjNorm_OscillatingH:
	LDA <Player_HaltGame
	BNE DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	JSR Platform_Oscillate	 ; Do platform oscillation
	JSR Object_ApplyXVel	 ; Apply X velocity
	JMP PlayerPlatform_Collide	 ; Do platform-player collision tests and don't come back!

	; Timers set per direction (long and short, respectively)
OscTimerSets:	.byte $41, $23	; longer timer means longer travel

Platform_Oscillate:
	LDA Objects_Timer,X	 
	BNE DeleteIfOffAndDrawWide	 ; If timer not expired, Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA Level_NoStopCnt
	LSR A
	BCS DeleteIfOffAndDrawWide	 ; Every other tick, Delete if off-screen, otherwise draw wide 48x16 sprite

	LDY <Objects_Var5,X	 ; Y = Objects_Var5 (direction of oscillation)

	; 
	LDA <Objects_XVel,X
	ADC OscXVel,Y
	STA <Objects_XVel,X

	CMP OscXVelLimit,Y
	BNE DeleteIfOffAndDrawWide	 ; If platform not hit the velocity limit, Delete if off-screen, otherwise draw wide 48x16 sprite

	; Change direction!
	TYA
	EOR #$01
	STA <Objects_Var5,X

	LDY <Objects_Var4,X	; Y = Var4 (specifies length)

	; Reset timer
	LDA OscTimerSets,Y
	STA Objects_Timer,X

DeleteIfOffAndDrawWide:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JMP LogPlat_Draw	 ; Jump to LogPlat_Draw

ObjNorm_OscillatingV:
	LDA <Player_HaltGame
	BNE DeleteIfOffAndDrawWide	 ; If gameplay halted, Delete if off-screen, otherwise draw wide 48x16 sprite

	; Vertical oscillating platform reuses the horizontal's code,
	; so the YVel is set equal to the XVel
	LDA <Objects_YVel,X
	STA <Objects_XVel,X

	JSR Platform_Oscillate	 ; Do platform oscillation

	; Same deal, Platform_Oscillate is working with the XVel, 
	; so transfer is into the YVel..
	LDA <Objects_XVel,X
	STA <Objects_YVel,X

	JSR Object_ApplyYVel	 ; Apply Y Velocity

	; Clear X velocity remainders
	LDA #$00
	STA Object_XVelCarry

	JMP PlayerPlatform_Collide	; Do Player-platform collision and don't come back!

ObjInit_FloatWoodenPlat:
	LDA Level_AScrlConfig
	BEQ PRG002_AB35	 ; If no raster, jump to PRG002_AB35 (RTS)

	; If raster active (assuming a level with constant water level)...

	; Set fixed position at water level (vertical scroll +148)
	LDA Level_VertScroll
	ADD #148
	STA <Objects_Y,X
	LDA Level_VertScrollH
	ADC #$00		; Apply carry
	STA <Objects_YHi,X

PRG002_AB35:
	RTS		 ; Return

Float_YVelAdj:	.byte $02, $06, $0A
Float_YAccel:	.byte $02, -$01, -$04

ObjNorm_WoodenPlatFloat:
	JSR Fish_FixedYIfAppro	 	; Fixes 'Y' coordinate for platform that floats in fixed water
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_AB35	 ; If gameplay is halted, jump to PRG002_AB35 (RTS)

	LDY <Objects_Var4,X	 ; Y = Var4

	STA <Objects_Var4,X	 ; Clear Var4

	LDA Float_YVelAdj,Y

	LDY #$00	 ; Y = 0

	SUB <Objects_Var5,X
	BPL PRG002_AB5E	 

	INY		 ; Y = 1

	CMP #-$02	 
	BGE PRG002_AB5E	 

	LDA <Objects_YVel,X
	BMI PRG002_AB5E	 ; If platform is floating upward, jump to PRG002_AB5E

	INY		 ; Y = 2

PRG002_AB5E:
	; Y acceleration of floating platform
	LDA <Objects_YVel,X
	ADD Float_YAccel,Y
	STA <Objects_YVel,X

	JSR Object_ApplyYVel	 ; Apply Y Velocity

	; 
	LDA <Objects_Var5,X
	ADD Object_XVelCarry
	STA <Objects_Var5,X

	; Clear Object_XVelCarry
	LDA #$00
	STA Object_XVelCarry

	JSR PlayerPlatform_Collide	; Do Player-platform collision
	BCC PRG002_AB8F	 		; If Player did not collide with Platform, jump to PRG002_AB8F

	; Player collided with floater

	ROL Player_NoSlopeStick	 	; Set Player_NoSlopeStick

	LDA <Player_YVel
	BEQ PRG002_AB86	 	; If Player is not moving vertically, jump to PRG002_AB86

	LSR A
	LSR A
	STA <Objects_YVel,X	 ; Set floater's Y Velocity to Player's Y velocity / 4

PRG002_AB86:
	LDY <Player_Suit
	BEQ PRG002_AB8C	 ; If Player is small, jump to PRG002_AB8C

	LDY #$01	 ; Y = 1

PRG002_AB8C:
	INY		 ; Y = 1 (if small) or 2 (otherwise)

	STY <Objects_Var4,X	 ; Var4 = 1 or 2

PRG002_AB8F:
	RTS		 ; Return


ObjNorm_DesertBones:
	LDA <Counter_1
	ASL A
	ASL A
	ASL A
	AND #SPR_VFLIP
	ORA #SPR_BEHINDBG
	STA Objects_FlipBits,X

	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_ABAA	 	; If gameplay halted, jump to PRG002_ABAA (RTS)

	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR PlayerPlatform_Collide	 ; Player collision with platform

	; Needs to be in quicksand!
	JSR Object_DetectTile
	CMP #TILE9_QUICKSAND_TOP
	BEQ DesertBones_InSand
	CMP #TILE9_QUICKSAND_MID
	BNE DesertBones_NotInSand

	; Mid sand
DesertBones_FloatUp:
	DEC <Objects_YVel,X
	
	RTS

DesertBones_InSand:
	LDA <Objects_Y,X
	AND #$0F
	CMP #04
	BGE DesertBones_FloatUp

	LDA #0
	STA <Objects_YVel,X

	RTS
	
	
DesertBones_NotInSand:
	LDA <Level_Tile
	
	PHA
	
	ASL A		 
	ROL A		 
	ROL A		 ; Upper 2 bits shift right 6, effectively
	AND #%00000011	 ; Keep these bits, i.e. "tile quadrant"
	TAY		 ; Y = quadrant of last detected tile
	
	PLA
	CMP Tile_AttrTable,Y
	BGE DesertBones_HitFloor

	INC <Objects_YVel,X
	
	RTS

DesertBones_HitFloor:
	JSR Object_HitGround
	
	LDA <Objects_Y,X
	SUB #1
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #0
	STA <Objects_YHi,X
	
	RTS

ObjNorm_WoodenPlatform:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_ABAA	 	; If gameplay halted, jump to PRG002_ABAA (RTS)

	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR PlayerPlatform_Collide	 ; Player collision with platform

	LDA <Objects_YVel,X
	BNE PRG002_ABA8	 ; If Platform is moving vertically, jump to PRG002_ABA8

	BCC PRG002_ABAA	 ; If Player did not collide with platform, jump to PRG002_ABAA (RTS)

	STA <Objects_XVel,X	 ; Otherwise, X Vel = Y Vel

PRG002_ABA8:
	INC <Objects_YVel,X	 ; Platform descends

PRG002_ABAA:
	RTS		 ; Return

ObjInit_WoodenFallingPlat:
	INC <Objects_Var4,X	 ; Var4 = 1

ObjInit_FallingPlatform:

	; Center the platform
	LDA <Objects_X,X
	ORA #$08
	STA <Objects_X,X

	LDA <Objects_Y,X
	ORA #$06
	STA <Objects_Y,X

PRG002_ABB9:
	RTS		 ; Return

	; Index offsets looking for next path element
WoodenPlat_ScanIndices:
	.byte -$06, $06, -$05, $05, -$04, $04, -$03, $03, -$02, $02, -$01, $01, $00
WoodenPlat_ScanIndices_End:


	; All of the following WoodenPlat_* are parallel arrays 

	; Determines which direction the platform should seek for its next path tile
WoodenPlat_NextTileIdx:
	.byte $03, $02, $02, $02
	.byte $02, $00, $00, $00
	.byte $01, $01, $01, $01
	.byte $03, $03, $03, $03

	; The different path tiles the platform may encounter (Typical Set)
WoodenPlat_PathTiles:
	.byte TILEA_PATH_VERT, TILEA_PATH_625B2T_L, TILEA_PATH_625B2T_U, TILEA_PATH_45B2T
	.byte TILEA_PATH_HORZ, TILEA_PATH_45T2B, TILEA_PATH_625T2B_L, TILEA_PATH_625T2B_U
	.byte TILEA_PATH_VERT, TILEA_PATH_625B2T_U, TILEA_PATH_625B2T_L, TILEA_PATH_45B2T
	.byte TILEA_PATH_HORZ, TILEA_PATH_45T2B, TILEA_PATH_625T2B_U, TILEA_PATH_625T2B_L

	; Same setup as WoodenPlat_PathTiles, but for Tileset 2 (Fortress Style)
WoodenPlat_PathTilesAlt:
	.byte TILE2_PATH_VERT, TILE2_PATH_625B2T_L, TILE2_PATH_625B2T_U, TILE2_PATH_45B2T
	.byte TILE2_PATH_HORZ, TILE2_PATH_45T2B, TILE2_PATH_625T2B_L, TILE2_PATH_625T2B_U
	.byte TILE2_PATH_VERT, TILE2_PATH_625B2T_U, TILE2_PATH_625B2T_L, TILE2_PATH_45B2T
	.byte TILE2_PATH_HORZ, TILE2_PATH_45T2B, TILE2_PATH_625T2B_U, TILE2_PATH_625T2B_L

	; Y velocities appropriate to path tile hit
WoodenPlat_YVel:
	.byte -$10, -$10, -$10, -$10	; forward
	.byte  $00,  $10,  $10,  $10
	.byte  $10,  $10,  $10,  $10	; reverse
	.byte  $00, -$10, -$10, -$10
	.byte  $00	; Stop

	; X velocities appropriate to path tile hit
WoodenPlat_XVel:
	.byte  $00,  $08,  $08,  $10	; forward
	.byte  $10,  $10,  $08,  $08
	.byte  $00, -$08, -$08, -$10	; reverse
	.byte -$10, -$10, -$08, -$08
	.byte  $00	; Stop


ObjNorm_PathFollowPlat:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_ABB9	 ; If gameplay is halted, jump to PRG002_ABB9 (RTS)

	LDA <Objects_Var4,X
	BEQ PRG002_AC29	 ; If Var4 = 0, jump to PRG002_AC29

	LSR A
	BEQ PRG002_AC2C	 ; If Var4 < 2, jump to PRG002_AC2C

	; Var4 >= 2...

	INC <Objects_YVel,X	 ; Increase platform's fall rate

PRG002_AC29:
	JMP PRG002_ACAB	 ; Jump to PRG002_ACAB

PRG002_AC2C:

	; Var4 = 1...

	LDA <Objects_YVel,X
	BEQ PRG002_AC3A	 ; If platform is not vertically moving, jump to PRG002_AC3A

	; Platform is vertically moving...

	LDA <Objects_Y,X
	AND #$0f	; Consider platform vertical relative to current grid row only
	CMP #$06
	BNE PRG002_ACAB	 ; If platform is NOT about halfway down this grid row, jump to PRG002_ACAB
	BEQ PRG002_AC42	 ; Otherwise, jump to PRG002_AC42

PRG002_AC3A:

	; Platform is about halfway down current grid row

	LDA <Objects_X,X
	AND #$0f	 ; Consider platform horizontal relative to current grid column only
	CMP #$08	 
	BNE PRG002_ACAB	 ; If platform is NOT about halfway across current grid row, jump to PRG002_ACAB

PRG002_AC42:

	; Platform is about centered

	; Going to detect the four tiles this Platform may be touching	

	LDA #$03
	STA <Temp_Var13		 ; Update Temp_Var13

	LDY ObjGroupRel_Idx	 ; Y = Object's group relative index
	LDA ObjectGroup01_Attributes2,Y	 ; Get attributes set 2
	AND #OA2_TDOGRPMASK		; Mask out the root tile detection group offset
	LSR A		; Upper 4 bits of attributes set 2 shifted right 1 (value * 8)

	STA <Temp_Var1
	LSR A		; Value * 4
	ADD <Temp_Var1	; Value * 12 (RAS: Adding additional reverse gravity offsets)

	TAY		 	; -> 'Y'
PRG002_AC50:
	STY <Temp_Var14		 ; Update Temp_Var14

	JSR Object_DetectTile	 ; Detect tile platform is seeing
	
	LDY <Temp_Var13		 ; Y = Temp_Var13
	STA Temp_Var9,Y	 ; Store detected tile -> Temp_Var[9...12]

	LDY <Temp_Var14		; Y = Temp_Var14

	; Y += 3 (next DetectTile offset triplet)
	INY
	INY
	INY

	DEC <Temp_Var13		 ; Temp_Var13--
	BPL PRG002_AC50	 	; While Temp_Var13 >= 0, loop!

	; Temp_Var13 = 12
	LDA #(WoodenPlat_ScanIndices_End - WoodenPlat_ScanIndices - 1)
	STA <Temp_Var13

	; Temp_Var14 = Var5 (travel direction, offset of 0 or 8)
	LDA <Objects_Var5,X
	STA <Temp_Var14

PRG002_AC6A:
	LDY <Temp_Var13		; Y = Temp_Var13

	LDA WoodenPlat_ScanIndices,Y
	ADD <Temp_Var14		; Travel direction offset
	AND #$0f		; Mod 16
	TAY			; -> 'Y' 

	LDX WoodenPlat_NextTileIdx,Y	 ; X = which of the four tiles that should be checked next

	LDA <Temp_Var9,X	 ; Get this tile
	CMP WoodenPlat_PathTiles,Y	 
	BEQ PRG002_AC9C	 	; If it's one of the path tiles (Typical set), jump to PRG002_AC9C

	CMP WoodenPlat_PathTilesAlt,Y
	BEQ PRG002_AC9C	 	; If it's one of the path tiles (Fortress set), jump to PRG002_AC9C

	CPY <Temp_Var14	
	BNE PRG002_AC92	 ; If Temp_Var14 <> 0, jump to PRG002_AC92 (stop platform)

	CMP #TILE4_PLATFORMPULLER
	BNE PRG002_AC92	 ; If tile is NOT the "Platform Puller" twirly thing, jump to PRG002_AC92 (stop platform)

	; Temp_Var14 = 0 and platform hit a path ending "platform puller" twirly thing

	; Change direction!
	TYA
	EOR #$08
	TAY	

	BPL PRG002_AC9C	 ; Jump (technically always) to PRG002_AC9C

PRG002_AC92:
	DEC <Temp_Var13	 ; Temp_Var13--
	BPL PRG002_AC6A	 ; While Temp_Var13 >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

	INC <Objects_Var4,X	 ; Objects_Var4 = 1 (platform stop)

	LDY #16	; Y = 16 (uses stop velocities)

PRG002_AC9C:

	; Hit a path tile...

	LDX <SlotIndexBackup		 ; X = object slot index

	TYA
	STA <Objects_Var5,X	 ; Store the directional offset (0 or 8)

	; Set Platform X Velocity appropriate for path tile
	LDA WoodenPlat_XVel,Y
	STA <Objects_XVel,X

	; Set Platform Y Velocity appropriate for path tile
	LDA WoodenPlat_YVel,Y
	STA <Objects_YVel,X

PRG002_ACAB:
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_ApplyXVel	 ; Apply X velocity
	
	LDA <Player_YVel
	BMI PRG002_ACBC		; If Player is moving upward, do nothing
	
	JSR PlayerPlatform_Collide	 ; Do Player-to-platform collision
	BCC PRG002_ACBC	 ; If Player did not collide with platform, jump to PRG002_ACBC (RTS)

	; Mark Player standing on platform
	LDA <Objects_Var4,X
	ORA #$01
	STA <Objects_Var4,X

PRG002_ACBC:
	RTS		 ; Return

EnemyEnterFlip:	.byte  $00, SPR_HFLIP
EnemyEnterXVel:	.byte -$08, $08

ObjInit_TowardsPlayer:

	; Get last scroll direction so we know which way to face
	LDY Scroll_LastDir

	; Enemy faces Player relative to which direction he's headed
	LDA EnemyEnterFlip,Y
	STA Objects_FlipBits,X

	; Enemy charges at Player the same
	LDA EnemyEnterXVel,Y
	STA <Objects_XVel,X

	RTS		 ; Return

Spike_Frames:
	.byte $04, $04, $04, $04, $04, $02, $02, $03, $03, $03, $03, $02, $02, $02, $02

Spike_XOff:
	.byte $00
	.byte $02, $03, $02, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

Spike_YOff:
	.byte $00, $F4, $F4
	.byte $F4, $F4, $F4, $F4, $F2, $F0, $EF, $EE, $EE, $EF, $F0, $F2, $F4, $F6, $F9, $FC
	.byte $FF, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00


ObjNorm_Spike:
	LDA Objects_Timer,X
	LSR A
	STA <Objects_Var4,X	 ; Var4 = timer / 2

	ROL A		; Puts bit 0 back
	BEQ PRG002_AD3F	 ; If timer expired, jump to PRG002_AD3F

	LSR A
	BNE PRG002_AD31	 ; If timer > 2, jump to PRG002_AD31

	JSR Spike_TossSpikeBall	 ; Cough up a spike ball!

	LDA <Objects_Var5,X
	BEQ PRG002_AD31	 	; ?? I think this was meant to check that no sprites are off-screen, but most likely you'll make this jump

	INC Objects_Timer,X	 ; Timer++ (delay decrementing it)

PRG002_AD31:
	LDA Objects_Timer,X
	LSR A
	LSR A
	TAY		 ; Y = timer / 4

	; Set Spike's frame
	LDA Spike_Frames,Y
	STA Objects_Frame,X
	BPL PRG002_AD95	 ; If positive, jump to PRG002_AD95

PRG002_AD3F:
	JSR Object_SetXVelByFacingDir	 ; Set Spike's X velocity by his facing direction

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AD80	 ; If Spike has not touched the ground, jump to PRG002_AD80

	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X	 ; Set Spike's frame alternating 0/1 (walking)

	; This keeps Spike interesting
	LDA <Counter_1
	ADC Entropy_BySlot,X	; Add an arbitrary value based on which slot this Spike is in
	BMI PRG002_AD95	 ; If the result has bit 7 set, jump to PRG002_AD95

	JSR Object_CalcCoarseXDiff
	EOR Objects_FlipBits,X
	ASL A
	BPL PRG002_AD6E	 ; If the signs aren't different, Spike doesn't change direction; jump to PRG002_AD6E

	; Spike needs to change direction

	LDA <Counter_1
	AND #$07	
	BNE PRG002_AD80	 ; But only a 1:7 chance, otherwise jump to PRG002_AD80

	JSR Object_FlipFace	 ; Turn around
	JMP PRG002_AD80	 	; Jump to PRG002_AD80

PRG002_AD6E:

	; This gets a little tricky to follow...

	LDA <Temp_Var15	
	ADD #$20
	CMP #$40
	BGE PRG002_AD80	 ; Player out of X range

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15	
	CMP #$08	
	BCC PRG002_AD84	 ; Player out of Y range

PRG002_AD80:
	LDA #$00
	BEQ PRG002_AD88	 

PRG002_AD84:
	LDA <Objects_Var5,X	
	ADC #$10

PRG002_AD88:
	STA <Objects_Var5,X	 
	BPL PRG002_AD95

	; Timer = $3A
	LDA #$3a
	STA Objects_Timer,X

	; Halt Spike's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG002_AD95:
	JSR Enemy_CollideWithWorld	 ; Collide with world
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

Bank2_SpikeHaltAction:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDA <Temp_Var3
	BPL PRG002_ADB4	 ; If Spike is not flipped, jump to PRG002_ADB4

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA <Objects_Var4,X
	TAX		 ; X = Var4

	; Add to Sprite Y by Var4 index
	LDA <Temp_Var1	
	ADD Spike_YOff,X
	STA <Temp_Var1	

	LDX <Temp_Var6		 ; X = object's starting tiles index

PRG002_ADB4:
	JSR Object_Draw16x16Sprite	 ; Draw Spike

	LDX <SlotIndexBackup		 ; X = object slot index

	LDY <Objects_Var4,X	 ; Y = Var4

	LDA <Objects_SpriteY,X
	BIT <Temp_Var3		
	BMI PRG002_ADC5	 ; If Spike is vertically flipped, jump to PRG002_ADC5

	ADD Spike_YOff,Y	 ; Otherwise, add appropriate offset

PRG002_ADC5:
	STA <Temp_Var1		 ; -> Temp_Var1
 
	LDA Spike_XOff,Y

	BIT <Temp_Var3
	BVC PRG002_ADD1	 ; If Spike is NOT horizontally flipped, jump to PRG002_ADD1

	JSR Negate	; Negate the X Offset

PRG002_ADD1:
	ADD <Temp_Var2		 ; Offset by Spike's X
	STA <Temp_Var2		 ; -> Temp_Var2

	LDX #(SpikeBall_Patterns - ObjectGroup01_PatternSets)	 ; Offset to patterns for spike ball

	; Draw Spike's pre-thrown spike ball sprite at +8 to Spike's assigned Sprite_RAM offset
	LDA <Temp_Var7
	ADD #$08	
	TAY		
	JSR Object_Draw16x16Sprite

	; Set Spike's spike ball attributes
	LDA #$02
	STA Sprite_RAM+$02,Y
	ORA #$c0
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Spike_TossSpikeBall:
	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot if on-screen (or don't come back!)	 
	STA <Objects_Var5,X	 ; Objects_Var5 = 0 (because we wouldn't be here otherwise)

	; Spike's spike ball
	LDA #SOBJ_SPIKEBALL	 
	STA SpecialObj_ID,Y

	; Set Spike's ball X
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; Set Spike's ball Y
	LDA <Objects_Y,X
	SUB #14
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	JSR Object_SetXVelByFacingDir	 ; Set Spike's X velocity by his facing direction
	ASL A	
	ASL A		; Multiply result by 4
	STA SpecialObj_XVel,Y	 ; Set as Spike's ball X velocity

	; Spike's ball Y velocity and Data = 0
	LDA #$00
	STA SpecialObj_YVel,Y
	STA SpecialObj_Data,Y

	RTS		 ; Return


	; Sets X velocity by facing flip direction
Object_SetXVelByFacingDir:
	LDA Objects_FlipBits,X
	ASL A
	ASL A	; If HFlip is set, pushed into carry

	LDA #$08
	BCS PRG002_AE28
	LDA #-$08
PRG002_AE28:
	STA <Objects_XVel,X

	RTS		 ; Return

ObjInit_PiranhaSpikeBall:
	; Center piranha
	LDA <Objects_X,X
	ORA #$08
	STA <Objects_X,X

	; Set Objects_Var5 = $10
	LDA #$10
	BNE PRG002_AE3A	 ; Jump (technically always) to PRG002_AE3A

ObjInit_Patooie:
	JSR ObjInit_TowardsPlayer	; Have enemy facing/moving towards Player

	; Set Objects_Var5 = $0C 
	LDA #$0c
PRG002_AE3A:
	STA <Objects_Var5,X

	RTS		 ; Return

ObjNorm_PiranhaSpikeBall:

	; Mostly reuses Patooie's code

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_AE47	 ; If piranha is dead, jump to PRG002_AE47

	JMP PRG002_AEE1	 ; Otherwise, jump to PRG002_AEE1

PRG002_AE47:

	; Use "poof" death
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State,X

	; Set timer to $1F (poof death timer)
	LDA #$1f
	STA Objects_Timer,X

PRG002_AE51:
	INC Objects_HitCount,X	 ; Increase hit count (??)

	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot if on-screen (or don't come back!)

	; Patooie's Spike ball
	LDA #SOBJ_SPIKEBALL
	STA SpecialObj_ID,Y

	; Set Spike ball X
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; Set Spike ball Y -- Objects_Var5 is used as the height of the spiked ball Patooie is blowing
	LDA <Objects_Y,X
	SUB <Objects_Var5,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	; Spike ball data
	LDA #$01
	STA SpecialObj_Data,Y

	LSR A	
	STA SpecialObj_XVel,Y	 ; X Vel = 0

	LDA Objects_Var6,X
	AND #%01111100	; Masking the lower bits not strictly necessary...
	LSR A	
	LSR A	
	TAX	; X = value 0 to 31

	; Set the Patooie ball Y velocity
	LDA Patooie_BallYDelta,X
	JSR Negate
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	STA SpecialObj_YVel,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	JMP PRG002_AF30	 ; Jump to PRG002_AF30

Patooie_BallYDelta:
	.byte $00, -$01, -$02, -$03, -$03, -$03, -$02, -$01, $00,  $01, $02, $03, $03, $03, $02, $01
	.byte $00, -$01, -$01, -$01,  $00,  $01,  $01,  $01

	; Jiggles the spike ball a bit
Patooie_BallXJiggle:
	.byte $00, -$01, $00, $01


ObjNorm_Patooie:
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE PRG002_AEBE	 ; If Patooie's state is not Killed, jump to PRG002_AEBE

	; Patooie is killed...

	LDA Objects_HitCount,X
	BEQ PRG002_AE51	 ; If object hasn't been hit by Player weapon, jump to PRG002_AE51

	JMP PRG002_AF30	 ; Jump to PRG002_AF30

PRG002_AEBE:
	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AEE1	 ; If object did not hit floor, jump to PRG002_AEE1

	LDA <Counter_1
	ADC Entropy_BySlot,X	 ; Add an arbitrary value by this object's slot index
	AND #%10011111
	BNE PRG002_AED7	 	; Semi-randomly jump to PRG002_AED7

	; Sometimes, reverse direction
	LDA <Objects_XVel,X
	JSR Negate	
	STA <Objects_XVel,X

PRG002_AED7:
	; Flip sprite back and forth to simulate walking
	LDA <Counter_1
	ASL A		
	ASL A		
	ASL A		
	AND #SPR_HFLIP
	STA Objects_FlipBits,X

PRG002_AEE1:
	LDA Objects_Var6,X
	BEQ PRG002_AEEF	 ; If Var6 = 0, jump to PRG002_AEEF

	LDA Level_NoStopCnt
	LSR A
	BCC PRG002_AEEF	 ; Every other tick, jump to PRG002_AEEF

	DEC Objects_Var6,X	 ; Otherwise, Var6--

PRG002_AEEF:
	LDY #$00	 ; Y = 0 (Mouth closed)

	LDA Objects_Var6,X
	PHA		 ; Save Var6

	AND #%11000000
	LSR A
	LSR A
	STA <Temp_Var1	 ; Temp_Var1 = $00, $10, $20, or $30

	PLA		 ; Restore Var6

	; Times the mouth animation to be similar to the spike ball's ascend/descend
	ASL A
	EOR Objects_Var6,X
	AND <Temp_Var1	
	BEQ PRG002_AF05

	INY		 ; Y = 1 (Mouth open)

PRG002_AF05:
	TYA
	STA Objects_Frame,X	 ; Set frame 0 or 1

	LDA Objects_Var6,X
	AND #$3f
	BNE PRG002_AF1D	 ; Only continue 1:64 ticks, otherwise jump to PRG002_AF1D

	LDY #$bf	 ; Y = $BF (BIG Blow)

	LDA Level_NoStopCnt
	BPL PRG002_AF19	 ; If the counter is not negative, jump to PRG002_AF19

	LDY #$5f	 ; Otherwise, Y = $5F (SHORT blow)

PRG002_AF19:
	TYA
	STA Objects_Var6,X	 ; Var6 = $5F or $BF

PRG002_AF1D:
	LDA Objects_Var6,X
	AND #%01111100
	LSR A
	LSR A
	TAY		 ; Y = 0 to 31

	; Adjusts height of spike ball
	LDA <Objects_Var5,X
	ADD Patooie_BallYDelta,Y
	STA <Objects_Var5,X

	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

PRG002_AF30:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

Bank2_PiranhaSpikeHaltAction:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X
	CMP #OBJ_PIRANHASPIKEBALL
	BEQ PRG002_AF46	 ; If this is just the piranha with the spike ball rather than a true Patooie, jump to PRG002_AF46

	; Temp_Var1 += 6
	LDA <Temp_Var1
	ADD #$06
	STA <Temp_Var1

PRG002_AF46:
	LDX <Temp_Var6	 ; X = object's starting tiles

	LDA <Temp_Var3
	BPL PRG002_AF4F	 ; If object is not vertically flipped, jump to PRG002_AF4F

	JSR PatooiePiranha_StartTileX	 ; Get correct starting sprite tile

PRG002_AF4F:
	JSR Object_Draw16x16Sprite	 ; Draw sprite

	LSR <Temp_Var5	; Shifting out next vertical visibility bit

	; Sprite Y += 16 for lower half
	LDA <Temp_Var1
	ADD #16
	STA <Temp_Var1

	; 'Y' += 8 (two sprite index over)
	TYA
	ADD #$08
	TAY

	LDX <Temp_Var6	 ; X = starting tiles index

	LDA <Temp_Var3
	BMI PRG002_AF69	 ; If vertically flipped, jump to PRG002_AF69
	JSR PatooiePiranha_StartTileX	 ; Otherwise, get correct starting tile again
PRG002_AF69:
	JSR Object_Draw16x16Sprite	 ; Draw lower half

	LDA <Temp_Var3
	BMI PRG002_AF72	 ; If vertically flipped, jump to PRG002_AF72

	LDY <Temp_Var7		 ; Y = original Sprite_RAM offset

PRG002_AF72:
	; Sets attributes and mirrors piranha sprites
	LDA <Temp_Var3	; Get object attributes
	AND #~(SPR_HFLIP | $03)	 ; Keep everything except the horizontal flip and the palette select
	ORA #SPR_PAL1	 ; Force palette select 1
	STA Sprite_RAM+$02,Y	 ; Set attributes
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y	 ; Set other half of piranha

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X	
	CMP #OBJ_PIRANHASPIKEBALL
	BNE PRG002_AF96	 ; If this is Patooie, jump to PRG002_AF96

	; Piranha needs his body mirrored
	LDA Sprite_RAM+$0A,Y
	AND #~SPR_HFLIP
	STA Sprite_RAM+$0A,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$0E,Y

PRG002_AF96:
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_B01A	 ; If this piranha/Patooie state is Killed, jump to PRG002_B01A

	LDA <Objects_YHi,X
	PHA		 ; Save Y Hi

	LDA <Objects_Y,X
	PHA		 ; Save Y

	; Temporarily using object's Y/HI to calculate the spike ball's position
	SUB <Objects_Var5,X
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X

	LDY #$00	 ; Y = 0 (height of 16)
	JSR Object_DetermineVertVisY	 ; Determine visibility of spike ball sprites
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data for spike ball

	LDA Level_NoStopCnt
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3, based on timer

	; Cause the spike ball to jiggle slightly (Temp_Var2 is X)
	LDA <Temp_Var2
	ADD Patooie_BallXJiggle,X
	STA <Temp_Var2

	; Jump Sprite_RAM offset ahead 16 (four sprites, get passed Patooie/Piranha)
	TYA	
	ADD #16	
	TAY	

	; Draw sprite
	LDX #(SpikeBall_Patterns - ObjectGroup01_PatternSets)	 ; Offset to patterns for spike ball
	JSR Object_Draw16x16Sprite

	; Set spike ball vertical flip periodically
	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP	; Toggled vertical flip
	ORA #SPR_PAL2	; Set palette select 2
	STA Sprite_RAM+$02,Y
	EOR #$c0	; Invert vertical flip and apply horizontal flip
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_B00E	 ; If Patooie/Piranha's state is Killed, jump to PRG002_B00E

	LDA <Player_HaltGame
	BNE PRG002_B00E	 ; If gameplay is halted, jump to PRG002_B00E

	JSR Object_AnySprOffscreen
	BNE PRG002_B00E	 ; If any sprites of the spike ball are off-screen, jump to PRG002_B00E

	LDA Level_ObjectID,X
	PHA		 ; Save piranha/Patooie iID

	; Temporarily switch and masquerade as a OBJ_SPIKE
	; NOTE: This really just needs to be a 16x16 sized object so we
	; can "cheat" and use Object_HitTest on a "special object"
	LDA #OBJ_SPIKE
	STA Level_ObjectID,X

	JSR Object_HitTest
	BCC PRG002_B00A	 ; If Player did NOT hit spike ball, jump to PRG002_B00A

	LDA Player_StarInv
	BNE PRG002_B00A	 ; If Player is Starman invincible, jump to PRG002_B00A

	JSR Object_DoCollision ; Do the collision routine

PRG002_B00A:
	; Restore the object ID
	PLA
	STA Level_ObjectID,X

PRG002_B00E:
	; Restore the Y/Hi
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_YHi,X

	JSR Object_DetermineVertVis	 ; Restore true vertical visibility for this Patooie/piranha
	JSR Object_CalcSpriteXY_NoHi	 ; Calculate the true sprite positions

PRG002_B01A:
	JMP PRG002_B196		; Jump to PRG002_B196 (set pattern bank $4F)

	; Get the correct starting sprite tile based on whether this is
	; a true Patooie or just the piranha pretending to be one
PatooiePiranha_StartTileX:
	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X	 ; Get object ID

	LDX #(ObjP2A - ObjectGroup01_PatternSets + $06)	 ; If Patooie
	CMP #OBJ_PATOOIE
	BEQ PRG002_B02A	 ; If this is Patooie, jump to PRG002_B02A (RTS)
	LDX #(ObjP46 - ObjectGroup01_PatternSets + $08)	 ; If the piranha with spike ball
PRG002_B02A:
	RTS		 ; Return

ObjNorm_Rex:
	LDA <Counter_1
	AND #$08
	LSR A
	LSR A
	LSR A
	STA Objects_Frame,X

	JSR Object_DeleteOffScreen

	JSR Rex_MoveCommon

	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block

	; In ONLY the case of being stomped
	LDA Objects_State,X
	CMP #OBJSTATE_SHELLED
	BNE Rex_Draw

	LDA <Objects_XVel,X
	ASL A
	PHA

	JSR Level_PrepareNewObject
	
	LDA #OBJ_REX_PARTLYSQUASHED
	STA Level_ObjectID,X
		
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X
	
	LDA <Objects_Y,X
	ADD #16
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	ADC #0
	STA <Objects_YHi,X
	
	; If Player is on Yoshi, kill instantly
	LDA Player_Kuribo
	BEQ Rex_StompedNotYoshi
	
	LDA #OBJSTATE_KILLED
	STA Objects_State,X
	
Rex_StompedNotYoshi:
	PLA
	STA <Objects_XVel,X
	
	JMP RexPS_JustDraw
	
Rex_JustDraw:
	JMP Rex_Draw

Rex_Draw:
	JSR Object_Draw16x32Sprite
	LDX <SlotIndexBackup	 ; X = object slot index
	RTS

Rex_MoveCommon:
	LDA Objects_Timer,X
	BEQ Rex_MoveNormal

	; If Rex's timer is set, he's emerging from pipe (W4 challenge)
	; Temporarily cut X velocity and keep him in background

	LDA #SPR_BEHINDBG
	STA Objects_SprAttr,X

Rex_MoveNormal:
	JSR Object_Move	 ; Do general movement code

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG002_ADEE	 ; If object hit ceiling, jump to PRG002_ADEE

	STA <Objects_YVel,X	 ; Otherwise, update Y Velocity

PRG002_ADEE:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ Object_HitGroundAlign ; If object has not hit a wall, jump to Object_HitGroundAlign

	LDA <Objects_XVel,X
	BEQ Object_HitGroundAlign ; If object not moving, jump to Object_HitGroundAlign

	JSR Object_AboutFace	 ; Otherwise, turn around

	; Aligns object that impacts the ground onto the floor
Object_HitGroundAlign:
	LDA <Objects_DetStat,X 
	AND #$04
	BEQ PRG002_ADE2	 ; If object did not hit ground, jump to PRG002_ADE2 (RTS)
 
	JSR Object_HitGround	 ; Otherwise, jump to Object_HitGround

PRG002_ADE2:
	RTS

ObjNorm_RexPartlySquashed:
	LDA <Counter_1
	AND #$08
	LSR A
	LSR A
	LSR A
	STA Objects_Frame,X

	JSR Object_DeleteOffScreen

	JSR Rex_MoveCommon

	JSR Object_HandleBumpUnderneath
	
RexPS_JustDraw:
	JMP Object_ShakeAndDraw

PRG002_B196:
	; Set pattern sixth bank to $4F
	LDA #$4f	  
	STA PatTable_BankSel+5
	RTS		 ; Return

ObjInit_NipperHopping:
	INC <Objects_Var4,X	 ; Var4 = 1
	RTS		 ; Return


ObjNorm_Nipper:
	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$02	 
	TAY		 ; Y = 0 or 2

	JSR Object_CalcCoarseXDiff	 ; Get X difference between Nipper and Player
	STA <Temp_Var14		 ; Store flip direction -> Temp_Var14

	LDA <Temp_Var15	
	ADD #$03
	CMP #$06
	BGE PRG002_B1CD	 ; If Player is horizontally too far away from Nipper, jump to PRG002_B1CD

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	BMI PRG002_B1CD	 ; If Player is below Nipper, jump to PRG002_B1CD

	INY		 ; Y = 1 or 3

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B1CD	 ; If Nipper has not touched ground, jump to PRG002_B1CD

	; Nipper plant don't move horizontally!
	LDA #$00
	STA <Objects_XVel,X

	; Jump little Nipper!
	LDA #-$30
	STA <Objects_YVel,X

PRG002_B1CD:
	TYA	
	STA Objects_Frame,X	 ; Set frame

	JSR Object_DeleteOrDraw	 ; Delete if falls off-screen, otherwise draw
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

	LDA <Objects_Var4,X
	BNE PRG002_B1E1	 ; If Var4 <> 0, jump to PRG002_B1E1

	; Set the flip bits
	LDA <Temp_Var14
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG002_B1E1:
	LDA Objects_Timer,X
	BEQ PRG002_B1EC	 ; If timer expired, jump to PRG002_B1EC

	LSR A
	BNE PRG002_B20F	 ; If timer > 1, jump to PRG002_B20F (RTS)

	JSR Object_FlipFace	 ; Otherwise, turn around

PRG002_B1EC:

	; Timer expired...

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B20F	 ; If Nipper has not touched ground, jump to PRG002_B20F (RTS)

	LDA <Objects_YVel,X
	BMI PRG002_B20F	 ; If Nipper is moving upward, jump to PRG002_B20F (RTS)

	DEC <Objects_Var5,X	; Var5--
	BPL PRG002_B208	 ; If Var5 >= 0, jump to PRG002_B208

	; Reset Var5 = 8
	LDA #$08
	STA <Objects_Var5,X

	; Reset timer to $20
	LDA #$20
	STA Objects_Timer,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

PRG002_B208:
	JSR Object_SetXVelByFacingDir	; Face travel direction 

	; Hop hop hop
	LDA #-$10
	STA <Objects_YVel,X

PRG002_B20F:
	RTS		 ; Return

Princess_Palette:
	; Peach
	.byte $0F, $36, $28, $07
	.byte $0F, $36, $25, $07

	; Rosalina
	.byte $0F, $36, $39, $07
	.byte $0F, $36, $21, $07

Princess_InitYFr_ByWorld:	.byte (0 << 4) | 1, 0, 0, 0, 0, 0, (1 << 4) | 2, 0

ObjInit_Princess:

	; This is the W1 princess (Y = 1) or W7 Rosalina (Y = 2)...
	LDY World_Num
	LDA Princess_InitYFr_ByWorld,Y
	PHA		; Save Y/frame value

	; Upper 4 bits set frame
	LSR A
	LSR A
	LSR A
	LSR A
	STA Objects_Frame,X

	; Set X velocity to non-zero for Rosalina
	ASL A
	ASL A
	ASL A
	ASL A
	NEG
	STA <Objects_XVel,X

	PLA			; Restore Y/frame value
	AND #$0F	; Lower 4 bits will initialize 'Y'
	PHA			; Save Y

	; The colors, Duke, the colors!
	LDA Objects_Frame,X
	ADD #1
	ASL A
	ASL A
	ASL A		; Should now be 8 or 16
	TAY
	DEY			; Y = 7 or 15, last index of palette
	LDX #$1B	; Palette memory offset
	
Princess_SetPal_Loop:

	LDA Princess_Palette,Y
	STA Palette_Buffer,X
	STA Pal_Data,X
	
	DEX
	DEY
	
	TYA
	AND #$07	; Basically looking to see when we've looped below 8 colors...
	CMP #$07	; Lower bits will be exactly 7 in that case
	BNE Princess_SetPal_Loop	; If haven't done 8 colors, loop!

	; Set init Y value
	PLA
	TAY
	
	LDX <SlotIndexBackup
	
	JMP PRG002_B21A	; Jump to PRG002_B21A

ObjInit_Toad:
	LDA <Objects_XHi,X
	BEQ Toad_NotCastle	; If Toad is not far to the right, jump to Toad_NotCastle

	; This is a W1 castle Toad...
 	LDY #3
	BNE PRG002_B21A	; Jump (technically always) to PRG002_B21A

Toad_NotCastle:
	LDY <Objects_YHi,X
	BEQ PRG002_B21A	 ; If Toad is high up, jump to PRG002_B21A

	; If you came via a Map Entry override, we assume it's a white toad house!
	LDA Map_EnterViaID
	BEQ PRG002_B21A		; If not an override, jump to PRG002_B21A

	INY		 ; Otherwise, Y = 1 

PRG002_B21A:
	STY <Objects_Var5,X	 ; -> Objects_Var5 (which message Toad gives)

	; Invalidate the checkpoint for this Player
	JSR_THUNKC 30, Object_InvalidateCP

	; Toad is always on the lower screen space
	LDA #$01
	STA <Objects_YHi,X

	; Stop the timer
	STA Level_TimerEn

	LDA #$00
	STA <Map_UseItem	; Clear item usage flag
	STA Player_Behind	; Player is not behind anything
	STA ToadTalk_CPos	; Clear the Toad character position counter

	; Set the starting VRAM addresses
	LDA #$28
	STA ToadTalk_VH
	LDA #$c8
	STA ToadTalk_VL

	RTS		 ; Return

PRG002_B23D:
	.byte $08, $04, $02, $01

Rosalina_YVelLimit:		.byte $04, -$04
Rosalina_YVelDelta:		.byte $01, -$01

ObjNorm_Toad:

	LDA Level_ObjectID,X
	CMP #OBJ_PRINCESS
	BNE Toad_NotPrincess	; If this is not the princess, jump to Toad_NotPrincess

	; Hack: "PatTableSel" cannot support a bank value over 127, so must do so manually
	LDA #136
	STA PatTable_BankSel+4
	
	LDA <Objects_Var5,X
	CMP #2
	BNE Toad_NotPrincess	; If this is not Rosalina, jump to Toad_NotPrincess
	
	LDA <Counter_1
	AND #$03
	BNE Rosalina_KeepGoing	; Don't accelerate every so many ticks
	
	; Rosalina floats in ... 
	LDY Objects_Var3,X		; Var3 - Rosalina's float direction
	LDA <Objects_YVel,X
	CMP Rosalina_YVelLimit,Y
	BNE Rosalina_FloatYAccel
	
	; Hit limit, reverse
	TYA
	EOR #1
	STA Objects_Var3,X
	
Rosalina_FloatYAccel:
	ADD Rosalina_YVelDelta,Y
	STA <Objects_YVel,X

Rosalina_KeepGoing:
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel
	
	; Jump to PRG002_B272 if not far enough in
	LDA <Objects_XHi,X
	BNE PRG002_B272
	LDA <Objects_X,X
	CMP #$D0
	BGE PRG002_B272
	
	LDA #0
	STA <Objects_XVel,X

Toad_NotPrincess:
	; RAS: Scroll must be aligned before Toad talks
	LDA <Horz_Scroll
	BNE PRG002_B272

	; ... and Toad be visible
	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility
	JSR Object_AnySprOffscreen
	BNE PRG002_B272	 ; If any of Toad's sprites are not visible, jump to PRG002_B272
	
	; Lock scrolling
	LDA #1
	STA LevelJctBQ_Flag

	; Always turn to face Player
	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X

	; Do Toad's dialog message
	JSR Toad_Speak

	LDA Player_HaltTick
	ORA InvFlip_Counter
	BNE PRG002_B261	 ; If Player is still halted or inventory is open, jump to PRG002_B261

	LDA <Pad_Input
	AND #$10
	BEQ PRG002_B261	 ; If Player is NOT pressing START, jump to PRG002_B261

	; Flip open inventory
	LDA #$01
	STA Inventory_Open

	; Start on first inventory item
	LSR A	; A = 0
	STA InvStart_Item

PRG002_B261:
	LDA InvFlip_Counter
	CMP #$04
	BNE PRG002_B272	 ; If Inventory is fully open, jump to PRG002_B272

	LDA <Pad_Input
	AND #%11110011
	BEQ PRG002_B272	 ; If Player is not pressing anything (besides up/down), jump to PRG002_B272

	; Force like Player pressed 'B' (close inventory)
	LDA #$40
	STA <Pad_Input

PRG002_B272:
	JSR Object_Draw16x32Sprite	 ; Draw Toad/Peach's sprite
	
	LDA <Objects_Var5,X
	SUB #1
	CMP #2
	BGE DrawNotPrincess
	
	; Peach/Rosalina uses a dual palette, need to make the first two sprites use PAL1
	LDY Object_SprRAM,X
	
	LDA Sprite_RAM+$02,Y
	AND #~SPR_PAL3
	ORA #SPR_PAL1
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y
	
DrawNotPrincess:
	RTS


Toad_Speak:
	LDA <Objects_Var4,X	 ; Get current dialog state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Toad_HaltPlayer	; RAS
	.word Toad_DrawDiagBox
	.word Toad_DoToadText
	.word Toad_CastleEnder	; RAS: Only do anything if castle Toad (i.e. wait and exit)

TDiagBox_R1:	.byte $94, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $96
TDiagBox_R2:	.byte $92, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $93
TDiagBox_R3:	.byte $95, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $97

TDiagBox_RowOffs:
	.byte (TDiagBox_R1 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1)
	.byte (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R3 - TDiagBox_R1)
TDiagBox_RowOffs_End

Toad_HaltPlayer:
	; Halt the Player
	LDA #$ff
	STA Player_HaltTick

	; Stop clock and animations
	LDA #$81
	STA Level_TimerEn

	; Load Toad text
	LDA #$5e
	STA PatTable_BankSel+1

	INC <Objects_Var4,X	 ; Next dialog state
	RTS

Toad_DrawDiagBox:
	LDX Graphics_BufCnt	 ; X = current graphics buffer counter

	; Store the current VRAM address into the buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,X
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,X

	; Store the next row address (+32 bytes to next row)
	ADD #$20	; 32 bytes to next row
	STA ToadTalk_VL
	BCC PRG002_B2D5
	INC ToadTalk_VH	 ; Apply carry
PRG002_B2D5:

	LDA #(TDiagBox_R2 - TDiagBox_R1)	; run count per row
	STA Graphics_Buffer+2,X
	STA <Temp_Var1		 ; -> Temp_Var1

	LDY ToadTalk_CPos	 ; Y = current dialog box row
	LDA TDiagBox_RowOffs,Y
	TAY		 	; Y = offset to this row index

PRG002_B2E3:
	; Store next pattern in dialog box
	LDA TDiagBox_R1,Y
	STA Graphics_Buffer+3,X

	INY		 ; Y++ (next pattern for dialog box)
	INX		 ; X++ (next index in graphics buffer)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG002_B2E3	 ; While Temp_Var1 > 0, loop!

	; Insert terminator
	LDA #$00
	STA Graphics_Buffer+3,X

	; X += 3
	INX
	INX
	INX
	STX Graphics_BufCnt

	LDX <SlotIndexBackup	 ; X = object slot index

	INC ToadTalk_CPos	 ; Next row

	LDA ToadTalk_CPos
	CMP #(TDiagBox_RowOffs_End - TDiagBox_RowOffs)
	BLT PRG002_B325	 ; If row count < 8, jump to PRG002_B325 (RTS)

	; Dialog box is complete

	LDY <Objects_Var5,X	 ; Y = Objects_Var5

	; Toad's Var1 and Var2 store the current pointer to the text he's reciting
	LDA ToadMsg_Low,Y
	STA Objects_Var1,X
	LDA ToadMsg_High,Y
	STA Objects_Var2,X

	; Reset the VRAM address for the dialog text
	LDA #$28
	STA ToadTalk_VH
	LDA #$e9
	STA ToadTalk_VL

	; Toad's timer = $10
	LDA #$10
	STA Objects_Timer,X

	INC <Objects_Var4,X	 ; Objects_Var4 = 1 (next dialog state)

PRG002_B325:
	RTS		 ; Return

	; English: "Thank you!" / "Peach has at" / "last returned" / "to our fair" / "Mushroom" / "Kingdom!"
ToadMsg_Princess:
	;            T    h    a    n    k         y    o    u    !                        
	.byte $FE, $C3, $D7, $D0, $DD, $DA, $FE, $8C, $DE, $CE, $EA, $FE, $FE, $FE, $FE

	;            P    e    a    c    e         h    a    s         a    t              
	.byte $FE, $BF, $D4, $D0, $D2, $D4, $FE, $D7, $D0, $CC, $FE, $D0, $CD, $FE, $FE

	;            l    a    s    t         r    e    t    u    r    n    e    d         
	.byte $FE, $DB, $D0, $CC, $CD, $FE, $CB, $D4, $CD, $CE, $CB, $DD, $D4, $D3, $FE

	;            t    o         o    u    r         f    a    i    r                   
	.byte $FE, $CD, $DE, $FE, $DE, $CE, $CB, $FE, $D5, $D0, $D8, $CB, $FE, $FE, $FE

	;            M    u    s    h    r    o    o    m                                  
	.byte $FE, $BC, $CE, $CC, $D7, $CB, $DE, $DE, $DC, $FE, $FE, $FE, $FE, $FE, $FE

	;            K    i    n    g    d    o    m    !                                  
	.byte $FE, $BA, $D8, $DD, $D6, $D3, $DE, $DC, $EA, $FE, $FE, $FE, $FE, $FE, $FE


	; English: "One toot on" / "this whistle" / "will send you" / "to a far away" / "land!"
ToadMsg_WarpWhistle:
	;       O    n    e         t    o    o    t         o    n
	.byte $BE, $DD, $D4, $FE, $CD, $DE, $DE, $CD, $FE, $DE, $DD, $FE, $FE, $FE, $FE

	;       t    h    i    s         w    h    i    s    t    l    e
	.byte $CD, $D7, $D8, $CC, $FE, $81, $D7, $D8, $CC, $CD, $DB, $D4, $FE, $FE, $FE

	;       w    i    l    l         s    e    n    d         y    o    u
	.byte $81, $D8, $DB, $DB, $FE, $CC, $D4, $DD, $D3, $FE, $8C, $DE, $CE, $FE, $FE

	;       t    o         a         f    a    r         a    w    a    y
	.byte $CD, $DE, $FE, $D0, $FE, $D5, $D0, $CB, $E5, $D0, $81, $D0, $8C, $FE, $FE

	;       l    a    n    d    !
	.byte $DB, $D0, $DD, $D3, $EA, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE


	; English: "Hello! You" / "found my shop" / "of strange and" / "wonderful" / "things!"
ToadMsg_AnchorPWing:
	;            T    h    e    y         h    a    v    e                             
	.byte $FE, $C3, $D7, $D4, $8C, $FE, $D7, $D0, $CF, $D4, $FE, $FE, $FE, $FE, $FE

	;            t    a    k    e    n         y    o    u    r                        
	.byte $FE, $CD, $D0, $DA, $D4, $DD, $FE, $8C, $DE, $CE, $CB, $FE, $FE, $FE, $FE

	;            s    p    e    c    i    a    l         o    n    e         t    o    
	.byte $FE, $CC, $DF, $D4, $D2, $D8, $D0, $DB, $FE, $DE, $DD, $D4, $FE, $CD, $DE

	;            t    h    e         c    e    n    t    e    r         o    f         
	.byte $FE, $CD, $D7, $D4, $FE, $D2, $D4, $DD, $CD, $D4, $CB, $FE, $DE, $D5, $FE

	;            t    h    e         u    n    i    v    e    r    s    e    !         
	.byte $FE, $CD, $D7, $D4, $FE, $CE, $DD, $D8, $CF, $D4, $CB, $CC, $D4, $EA, $FE

	;            W    e         m    u    s    t         g    o    !                   
	.byte $FE, $C6, $D4, $FE, $DC, $CE, $CC, $CD, $FE, $D6, $DE, $EA, $FE, $FE, $FE



	; English: "Thank you," / "Mario! But" / "our Princess" / "is in another" / "castle!"
ToadMsg_EndW1Castle:
	;            T    h    a    n    k         y    o    u    ,                        
	.byte $FE, $C3, $D7, $D0, $DD, $DA, $FE, $8C, $DE, $CE, $9A, $FE, $FE, $FE, $FE

	;            h    e    r    o    !         B    u    t                        
	.byte $FE, $D7, $D4, $CB, $DE, $EA, $FE, $B1, $CE, $CD, $FE, $FE, $FE, $FE, $FE

	;            o    u    r         P    r    i    n    c    e    s    s              
	.byte $FE, $DE, $CE, $CB, $FE, $BF, $CB, $D8, $DD, $D2, $D4, $CC, $CC, $FE, $FE

	;            i    s         i    n         a    n    o    t    h    e    r         
	.byte $FE, $D8, $CC, $FE, $D8, $DD, $FE, $D0, $DD, $DE, $CD, $D7, $D4, $CB, $FE

	;            c    a    s    t    l    e    !                                       
	.byte $FE, $D2, $D0, $CC, $CD, $DB, $D4, $EA, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	; Pointer table to Toad's messages
	; Warp Whistle
	; Princess (end of W1)
	; Anchor/P-Wing
	; End W1 castle
ToadMsg_Low:	.byte LOW(ToadMsg_WarpWhistle), LOW(ToadMsg_Princess), LOW(ToadMsg_AnchorPWing), LOW(ToadMsg_EndW1Castle)
ToadMsg_High:	.byte HIGH(ToadMsg_WarpWhistle), HIGH(ToadMsg_Princess), HIGH(ToadMsg_AnchorPWing), HIGH(ToadMsg_EndW1Castle)


Toad_DoToadText:
	LDA Objects_Timer,X
	BNE PRG002_B4B1	 ; If timer not expired, jump to PRG002_B4B1

	; Store address of text -> Temp_Var1/2
	LDA Objects_Var1,X
	STA <Temp_Var1
	LDA Objects_Var2,X
	STA <Temp_Var2

	INC Objects_Var1,X	; Next character
	BNE PRG002_B451
	INC Objects_Var2,X	; Apply carry
PRG002_B451:

	LDY #$00	 	; Y = 0
	LDA [Temp_Var1],Y	; Get character here
	TAY		 	; -> 'Y'
	CPY #$FE
	BEQ PRG002_B468	 	; If this is a "space", jump to PRG002_B468

	; Play "blip" sound every other letter
	LDA ToadTalk_VL
	LSR A
	BCC PRG002_B468

	; Play text "blip" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1

PRG002_B468:
	TYA

	LDY Graphics_BufCnt	 ; Y = graphics buffer counter
	STA Graphics_Buffer+3,Y	 ; Store into buffer

	; Insert one character into graphics buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,Y	; address high
	LDA #$01	 
	STA Graphics_Buffer+2,Y	; run length
	LSR A
	STA Graphics_Buffer+4,Y	; terminator
	TYA
	ADD #$04
	STA Graphics_BufCnt	; count
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,Y	; address low

	INC ToadTalk_VL	 ; Next VRAM byte
	AND #$1f	 	; Get current column
	CMP #$17
	BNE PRG002_B4AC	 	; If we're not in column 23, jump to PRG024_A25B

	; Line break!

	LDA ToadTalk_VL
	ADC #$10		; Add enough bytes to get to next row
	STA ToadTalk_VL
	BCC PRG002_B4A1
	INC ToadTalk_VH	; Apply carry
PRG002_B4A1:

	CMP #$a9
	BNE PRG002_B4AC	 ; If we haven't reached the last character, jump to PRG002_B4AC

	INC <Objects_Var4,X	 ; Objects_Var4 = 2 (next dialog state)

	LDA #$00
	STA ToadTalk_CPos

PRG002_B4AC:

	; Set timer to $04
	LDA #$04
	STA Objects_Timer,X

PRG002_B4B1:
	RTS		 ; Return


Toad_CastleEnder:
	LDA <Objects_Var5,X
	CMP #1
	BEQ Princess_EndWorld		; If the Princess, jump to Princess_EndWorld
	CMP #2
	BEQ Princess_EndWorld		; If Rosalina, jump to Princess_EndWorld
	CMP #3
	BNE ToadCastleEnder_DoNothing	; If not a castle-ender Toad, do nothing

Toad_CastleEnder_Do:
	LDA #0
	STA Map_ReturnStatus	; Good return status
	STA Map_WasAltExit	; Not an alternate/secret exit

	; Exit to map
	INC <Level_ExitToMap

ToadCastleEnder_DoNothing:
	RTS

Princess_EndWorld:
	JMP_THUNKC 30, Object_TriggerEndWorld



LogPlat_Draw:
	JSR Object_ShakeAndCalcSprite

	; Do not preserve the H/V flip bits (RAS: Just HFLIP ... ok?)
	LDA <Temp_Var3
	AND #~SPR_HFLIP
	STA <Temp_Var3

	LDA <Counter_1
	LSR A
	PHP		 ; Save CPU state (most importantly the carry flag)
	BCC PRG002_B5BD	 ; Every other tick, jump to PRG002_B5BD

	; Y += (11 + C = 12) -- Every other tick, offset Sprite_RAM
	TYA
	ADC #$0b
	TAY

PRG002_B5BD:
	JSR Object_Draw24x16Sprite	 ; Draw wide sprite

	LDA <Temp_Var7	 ; Get Sprite_RAM offset (as determined by Object_ShakeAndCalcSprite)
	PLP		 ; Restore CPU state
	BCS PRG002_B5C7	 ; Every other opposite tick, jump to PRG002_B5C7

	; Otherwise, add +12 to Sprite_RAM offset
	ADC #$0c

PRG002_B5C7:
	TAY		 ; Sprite_RAM offset -> 'Y'

	INX
	INX
	INX	; X += 3 (starting tiles index)

	; Temp_Var2 (Sprite X) += 24
	LDA #24
	ADD <Temp_Var2
	STA <Temp_Var2

	; Alters horizontal visibility ??
	ASL <Temp_Var8
	ASL <Temp_Var8
	ASL <Temp_Var8

	JSR Object_Draw24x16Sprite	 ; Draw wide sprite

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

ObjNorm_NipperFireBreathe:
	JSR Enemy_CollideWithWorld	; Collide with world
	JSR Object_DeleteOrDraw	 	; Delete if Nipper off-screen or draw it
	JSR Object_HitTestRespond	; Do collision test with Player and respond

	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X	 ; Set flip towards Player
 
	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X	 ; Nipper just smacks his lips

	JSR Object_AnySprOffscreen
	BNE PRG002_B65A	 ; If any of Nipper's sprites are not visible, jump to PRG002_B65A (RTS)

	LDA <Counter_1
	AND #$a0
	BNE PRG002_B65A	; Fire breather only does things in a limited window; otherwise, jump to PRG002_B65A (RTS)

	; Fire breather frame!
	LDA #$02
	STA Objects_Frame,X

	LDA <Counter_1
	AND #$07
	BNE PRG002_B65A	 ; Only do anything 1:8 ticks, otherwise jump to PRG002_B65A (RTS)

	; Set 'Y' to $10 or -$10 based on which side Player is on
	LDA <Temp_Var15
	TAY	
	ADD #$10
	CMP #$20
	BLT PRG002_B61F

	LDY #$10	 ; Y = $10

	LDA <Temp_Var15
	BPL PRG002_B61F

	LDY #-$10	 ; Y = -$10

PRG002_B61F:
	STY <Temp_Var1		 ; Temp_Var1 = $10 or -$10, based on which side Player is on

	JSR Object_CalcCoarseYDiff

	LDA <Temp_Var15
	ADD #$20
	CMP #$40
	BGE PRG002_B65A	 	; If Player is too high above Nipper, jump to PRG002_B65A (RTS)

	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot if on-screen (or don't come back!)

	; Nipper fireball ID
	LDA #SOBJ_NIPPERFIREBALL
	STA SpecialObj_ID,Y

	; Nipper fireball X
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Nipper fireball Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	; Nipper fireball X velocity
	LDA <Temp_Var1
	ASL A		
	JSR Negate	
	STA SpecialObj_XVel,Y

	; Nipper fireball Y velocity
	LDA #-$40
	SUB <Temp_Var15
	STA SpecialObj_YVel,Y

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_B65A:
	RTS		 ; Return

DryBones_XVelConveyor:	.byte $08, $08, $0A	; Dry Bones' X Velocities with conveyor handling 
DryBones_AnimCntrMask:	.byte $04, $08, $08	; These values mask against the counter (Dry Bones animates faster walking against conveyor)

	; While Dry Bones is reassembling, provides frame and timer values
DryBones_ReassembleFrames:	.byte $01, $02, $03, $03, $03, $03, $03, $02
DryBones_ReassembleTimers:	.byte $10, $0A, $06, $06, $06, $06, $FF, $0A
	
ObjNorm_DryBones:
	JSR CarryClearIfAliveAndNoHalt
	BCS DryBones_Draw	 ; If Dry Bones is Dying or gameplay halted, jump to DryBones_Draw

	; Dry Bones is alive and gameplay not halted...

	JSR Enemy_CollideWithWorld	 ; Collide with world
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR DryBones_Draw		 ; Draw Dry Bones
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond
	JSR DryBones_BumpOffOthers	 ; Bump off other objects

	LDA <Objects_Var5,X
	BNE PRG002_B6B2	 ; If Var5 <> 0 (Dry Bones is crumpled), jump to PRG002_B6B2

	JSR Object_HandleConveyorBounceVel	; Sets LRBounce_Vel which way Dry Bones will need to be effected by conveyor
	LDY LRBounce_Vel
	INY		 ; Y++ (index into DryBones_XVelConveyor)

	; Set carry if horizontally flipped
	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA DryBones_XVelConveyor,Y	 ; Get velocity appropriate to Dry Bones' predicament
	BCS PRG002_B69D	 ; If horizontally flipped, jump to PRG002_B69D
	JSR Negate	 ; Otherwise, negate
PRG002_B69D:
	STA <Objects_XVel,X	 ; Set Dry Bones' X velocity

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B6B1	 ; If Dry Bones is NOT on the ground, jump to PRG002_B6B1

	; Toggle Dry Bones' walking frames by counter and whether he's running against a conveyor 
	LDA <Counter_1
	AND DryBones_AnimCntrMask,Y
	BEQ PRG002_B6AE	 
	LDA #$01
PRG002_B6AE:
	STA Objects_Frame,X

PRG002_B6B1:
	RTS		 ; Return

PRG002_B6B2:

	; Crumpled Dry Bones...

	LDA Objects_Timer,X
	BNE PRG002_B6D0	 ; If timer not expired, jump to PRG002_B6D0 (RTS)

	DEC <Objects_Var5,X	 ; Var5--
	BNE PRG002_B6C2	 ; If Var5 <> 0 (still reassembling), jump to PRG002_B6C2

	; Dry Bones gets back up and faces Player!
	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG002_B6C2:

	; Reassembling Dry Bones

	LDY <Objects_Var5,X	; Y = Var5 (0 = fully reassembled, hence -1 used below)

	LDA DryBones_ReassembleFrames-1,Y
	STA Objects_Frame,X

	LDA DryBones_ReassembleTimers-1,Y
	STA Objects_Timer,X

PRG002_B6D0:
	RTS		 ; Return

	; Patterns used when Dry Bones is crumbling
DryBones_CrumblePats:	.byte (ObjP3F - ObjectGroup01_PatternSets + $08), (ObjP3F - ObjectGroup01_PatternSets + $0B)
	; Little head bounce when crumbled
DryBones_HeadYOff:	.byte 0, 0, 0, -1, -2, -1, 0, 0, 0

DryBones_Draw:
	LDA Objects_Frame,X
	CMP #$02
	BGE PRG002_B706	 ; If Dry Bones' frame >= 2 (crumbling), jump to PRG002_B706

	; Frame 0 or 1

	; Save Dry Bones' Y/Hi
	LDA <Objects_YHi,X
	PHA		
	LDA <Objects_Y,X
	PHA		

	; Subtract 16 from Dry Bones' Y position
	SUB #16
	STA <Objects_Y,X
	BCS PRG002_B6F2
	DEC <Objects_YHi,X
PRG002_B6F2:

	; Draw Dry Bones
	LDY #$01	 ; 32 pixels height for Object_DetermineVertVisY
	JSR Object_DetermineVertVisY
	JSR Object_Draw16x32Sprite

	; Restore Dry Bones' Y/Hi
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_YHi,X

	JSR Object_DetermineVertVis
	JMP Object_CalcSpriteXY_NoHi	 ; Calculate sprite X/Y and don't come back!

PRG002_B706:

	; Frame >= 2 (crumbling)...

	LDA Objects_FlipBits,X
	ASL A
	ASL A	; Sets carry if horizontally flipped

	; Save Dry Bones' X/Hi
	LDA <Objects_XHi,X
	PHA
	LDA <Objects_X,X
	PHA

	BCS PRG002_B71C	 ; If Dry Bones is horizontally flipped, jump to PRG002_B71C

	; Subtract 8 from Dry Bones' X position
	SUB #$08
	STA <Objects_X,X
	BCS PRG002_B71C
	DEC <Objects_XHi,X
PRG002_B71C:

	LDY #$02	 ; Select width = 24 for Object_DetermineHorzVisY
	JSR Object_DetermineHorzVisY	 ; Determine horizontal visibility
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite X/Y

	LDX <SlotIndexBackup	 	 ; X = object slot index
	LDY Objects_Frame,X	 	 ; Y = Dry Bones' frame

	LDX DryBones_CrumblePats-2,Y	 ; X = pattern start for this frame of Dry Bones (-2 because we start crumbling at frame 2)
	LDY <Temp_Var7			 ; Y = Sprite_RAM offset
	JSR Object_Draw24x16Sprite	 ; Draw wide sprite (crumbled Dry Bones)

	LDX <SlotIndexBackup		 ; X = object slot index
	BIT <Temp_Var3
	BVC PRG002_B73C	 	; If Dry Bones is not horizontally flipped, jump to PRG002_B73C

	; Otherwise, 'Y' += 8 (two sprites over)
	TYA
	ADD #$08
	TAY

PRG002_B73C:
	LDA <Objects_Var5,X
	TAX		 ; X = Var5 (head bounce index)

	; Apply bounce to his head after crumbling
	LDA Sprite_RAM+$00,Y
	ADD DryBones_HeadYOff,X	
	STA Sprite_RAM+$00,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	; Restore Dry Bones' X/Hi
	PLA
	STA <Objects_X,X
	PLA
	STA <Objects_XHi,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of Dry Bones' sprites
	JMP Object_CalcSpriteXY_NoHi	 ; Calculate Sprite X/Y and don't come back!


ObjHit_DryBones:
	LDA <Objects_Var5,X
	BNE PRG002_B77D	 ; If head bouncing, jump to PRG002_B77D (RTS)

	; Head not bouncing yet

	LDA <Temp_Var12
	LSR A
	BCC PRG002_B77E	 ; If not hit by Player jumping on head, jump to PRG002_B77E (Player_GetHurt)

	; Var5 = 9
	LDA #$09
	STA <Objects_Var5,X

	; Dry Bones stop horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	; Bounce Player
	LDA #-$40
	STA <Player_YVel

	; Crumble sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	; Tally kill
	LDA Kill_Tally
	JSR Score_Get100PlusPts
	INC Kill_Tally

PRG002_B77D:
	RTS		 ; Return

PRG002_B77E:
	JMP Player_GetHurt	 ; Hurt Player and don't come back!


	; Essentially an implementation of Object_BumpOffOthers tailored
	; for Dry Bones, handling one or the other being crumpled
DryBones_BumpOffOthers:
	TXA		  
	ADD <Counter_1
	LSR A		
	BCS PRG002_B789	 ; Semi-randomly jump to PRG002_B789

PRG002_B788:
	RTS		 ; Return

PRG002_B789:
	LDA Objects_SprVVis,X
	BNE PRG002_B77D	 ; If any sprite of Dry Bones is vertically off-screen, jump to PRG002_B77D (RTS)

	LDA Objects_SprHVis,X
	AND #$c0
	CMP #$c0
	BEQ PRG002_B77D	 ; If some of Dry Bones is horizontally off-screen, jump to PRG002_B77D (RTS)

	JSR Object_CalcBoundBox2
	TXA	
	BEQ PRG002_B788	 ; If this Dry Bones is in object slot 0, jump to PRG002_B788

	DEX		 ; X-- (consider the previous object)
PRG002_B79E:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG002_B7A9	 ; If previous object state is Normal, jump to PRG002_B7A9

	CMP #OBJSTATE_SHELLED
	BNE PRG002_B815	 ; If previous object state is not Shelled, jump to PRG002_B815

PRG002_B7A9:
	JSR Object_CalcAttrFlagOff	 ; Y = object's ID

	LDA Object_AttrFlags,Y
	AND #OAT_BOUNCEOFFOTHERS
	BEQ PRG002_B815	 ; If OAT_BOUNCEOFFOTHERS is NOT set, jump to PRG002_B815

	LDA Objects_SprVVis,X
	BNE PRG002_B815	 ; If any sprite is vertically off-screen, jump to PRG002_B815

	LDA Objects_SprHVis,X
	AND #$c0
	CMP #$c0
	BEQ PRG002_B815	 ; If previous object has sprites horizontally off-screen, jump to PRG002_B815

	JSR Object_CalcBoundBox 
	JSR ObjectObject_Intersect 
	BCC PRG002_B815	 ; If object did not intersect with prior object, jump to PRG002_B815

	LDY <SlotIndexBackup	 ; Y = object slot index

	LDA <Objects_X,X
	SUB Objects_X,Y
	PHA		 ; Save the difference between the two objects' Xs

	LDA <Objects_XHi,X
	SBC Objects_XHi,Y
	STA <Temp_Var1	 ; Temp_Var1 = the difference between the two objects' X His

	; Determine which way this object should face relative to its position
	ROL <Temp_Var2
	PLA	
	ADC #$80
	LDA <Temp_Var1
	ADC #$00	
	BNE PRG002_B815	 

	LSR <Temp_Var2	
	LDY #$00	 ; Y = $00 (face one way)
	BCS PRG002_B7EC	

	LDY #SPR_HFLIP	 ; Y = SPR_HFLIP (face the other)

PRG002_B7EC:
	TYA		 
	STA <Temp_Var1	 ; Temp_Var1

	LDY <SlotIndexBackup	 ; Y = The Dry Bones who started this

	LDA Objects_Var5,Y
	BNE PRG002_B7FB	 ; If Var5 <> 0, jump to PRG002_B7FB (crumbled Dry Bones need not turn around)

	; I'm not crumbled, I get to turn...
	LDA <Temp_Var1
	STA Objects_FlipBits,Y

PRG002_B7FB:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG002_B815	 ; If bumped-into object's state is not Normal, jump to PRG002_B815

	LDA Level_ObjectID,X
	CMP #OBJ_DRYBONES
	BNE PRG002_B80E	 ; If Dry Bones bumped into something that's not a Dry Bones, jump to PRG002_B80E

	LDA Objects_Var5,X
	BNE PRG002_B815	 ; If Dry Bones bumped into a crumpled Dry Bones, jump to PRG002_B815

PRG002_B80E:
	; Dry Bones "bumps" into a non-crumpled Dry Bones or something not a Dry Bones, turn around
	LDA <Temp_Var1
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X

PRG002_B815:
	DEX		 ; X--
	BPL PRG002_B79E	 ; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Respawn_XLo:	.byte $40, -$40
Respawn_XHi:	.byte $00, $FF

Fish_Repawn:
	LDY <Scroll_LastDir	 ; Y = last scroll direction value

	; Respawn near Player depending on direction he last moved
	LDA <Player_X
	ADD Respawn_XLo,Y
	STA <Objects_X,X
	LDA <Player_XHi
	ADC Respawn_XHi,Y
	STA <Objects_XHi,X

	TYA
	STA <Objects_Var5,X	 ; Objects_Var5 = entrance direction

ObjInit_ChasingFish:

	; Chasing fish always appear at the current vertical scroll + 160
	LDA Level_VertScroll
	ADD #160
	STA <Objects_Y,X
	LDA Level_VertScrollH
	ADC #$00
	STA <Objects_YHi,X

	; Come in hopping!
	LDA #-$08
	STA <Objects_YVel,X

	; Frame -1??
	LDA #-1
	STA Objects_Frame,X

	RTS		 ; Return

BigBertha_ProxLimit:	.byte $08, -$09	; How close (in coarse units) Big Bertha must be to Player to lunge
BigBertha_XVelLimit:	.byte $30, $50	; Limit on X Velocity (relative, used in addition)
BigBertha_Accel:	.byte -$04, $04	; X Velocity acceleration for each direction
BigBertha_XCoarseLimit:	.byte $10, $70	; How far away Big Bertha can be before turning around
BigBertha_EatLimit:	.byte $01, $03	; In coarse units (relative, used in addition), when Player is close enough to be eaten

ObjNorm_BigBertha:
	JSR Fish_FixedYIfAppro	 ; Fixes 'Y' coordinate for Big Bertha that swims in fixed water
	JSR BigBertha_Draw	 ; Draw Big Bertha

	LDA <Player_HaltGame
	BNE PRG002_B896	 ; If gameplay is halted, jump to PRG002_B896

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE PRG002_B897	 ; If Big Bertha's state is not Dying, jump to PRG002_B897

PRG002_B867:
	; Big Bertha is dying...

	LDA Objects_Timer,X
	BEQ PRG002_B87A	 ; If timer expired, jump to PRG002_B87A

	LSR A	
	BNE PRG002_B896	 ; If timer >= 2, jump to PRG002_B896 (RTS)

	; Timer tick 1...

	; Big Bertha recreates self!
	JSR Level_PrepareNewObject

	; Set back to state 2 (Normal operation)
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X
	JMP Fish_Repawn	 ; Jump to Fish_Repawn

PRG002_B87A:

	; Timer expired on dying Big Bertha...

	; Fix the flip bits
	ASL Objects_FlipBits,X
	SEC
	ROR Objects_FlipBits,X

	LDA Objects_Var7,X
	BEQ PRG002_B889	 ; If Var7 = 0 (Mario not devoured), jump to PRG002_B889
	JMP PRG002_B981	 ; Jump to PRG002_B981

PRG002_B889:
	JSR Object_Move	 ; Do standard object movements

	LDA Objects_SprVVis,X
	BEQ PRG002_B896	 ; If no sprites are vertically off-screen, jump to PRG002_B896

	; Otherwise, set Big Bertha's timer to $FF (time until Big Bertha respawns!)
	LDA #$ff
	STA Objects_Timer,X

PRG002_B896:
	RTS		 ; Return


PRG002_B897:
	LDY Objects_Var7,X
	BEQ PRG002_B8A0	 ; If Mario not devoured, jump to PRG002_B8A0

	INY
	STY Player_HaltTick	; Player is halted until Big Bertha drowns him!

PRG002_B8A0:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

	LDA Objects_Frame,X
	BPL PRG002_B900	 ; If frame = 0, jump to PRG002_B900

	LDA <Objects_SpriteY,X
	CMP #154
	BGE PRG002_B8B8	 ; If Big Bertha's SpriteY >= 154, jump to PRG002_B8B8

	; Otherwise, halt vertical movement
	LDA #$00
	STA <Objects_YVel,X

PRG002_B8B8:
	LDY <Objects_Var5,X	 ; Y = Var5 (current direction)

	LDA <Objects_XVel,X
	ADD BigBertha_XVelLimit,Y
	BMI PRG002_B8CA		; If negative result, jump to PRG002_B8CA

	; Apply acceleration
	LDA <Objects_XVel,X
	ADD BigBertha_Accel,Y
	STA <Objects_XVel,X

PRG002_B8CA:
	LDA <Objects_XVel,X
	LSR A		; Shift right 1
	AND #SPR_HFLIP	; Mask if it was negative
	EOR #SPR_HFLIP	; Flip it
	STA Objects_FlipBits,X	 ; Store horizontal flip bit

	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15		 ; Get coarse X diff
	ADD BigBertha_XCoarseLimit,Y
	BPL PRG002_B8E4	 ; If limit not reached, jump to PRG002_B8E4

	; Turn Big Bertha around
	TYA		
	EOR #$01	
	STA <Objects_Var5,X	 ; Store reversed direction flag

PRG002_B8E4:
	LDA <Temp_Var15		
	CMP BigBertha_ProxLimit,Y
	BNE PRG002_B896	 ; If not hit limit, jump to PRG002_B896 (RTS)

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	CMP #$10
	BGE PRG002_B896	 ; If Big Bertha is vertically too far from Player, jump to PRG002_B896

	; Does ... nothing to X Velocity?
	LDA <Objects_XVel,X
	ASL A			; Bit 7 shifted into carry
	ROR <Objects_XVel,X	; Carry shifted back into Bit 7

	; Big Bertha jumps!
	LDA #-$28
	STA <Objects_YVel,X

	; Gaping mouth
	INC Objects_Frame,X

PRG002_B900:

	; Big Bertha's gravity, Y Vel += 2
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	LDA <Objects_SpriteY,X

	; NOTE: Big Bertha is clearly abusing the purpose of Objects_Frame

	LDY Objects_Frame,X
	CPY #$05
	BGE PRG002_B978	 ; If frame >= 5, jump to PRG002_B978

	CPY #$04
	BLT PRG002_B919	 ; If frame < 4, jump to PRG002_B919

	CMP #148
	BLT PRG002_B896	 ; If SpriteY < 148, jump to PRG002_B896 (RTS)

	LDA #$05
	BNE PRG002_B993	 ; Jump (technically always) to PRG002_B993 (sets Objects_Frame)

PRG002_B919:
	LDA <Counter_1
	AND #$07
	BNE PRG002_B925	 ; Only 1:8 ticks we don't jump to PRG002_B925

	; Reverse frame
	TYA
	EOR #$01
	STA Objects_Frame,X

PRG002_B925:
	CPY #$02
	BGE PRG002_B95C	 ; If frame >= 2, jump to PRG002_B95C

	JSR Object_CalcCoarseXDiff
	LDY <Objects_Var5,X	; get direction flag
	LDA <Temp_Var15
	ADD BigBertha_EatLimit,Y
	CMP #$02
	BGE PRG002_B95C	 ; If Player is horizontally too far away to be eaten, jump to PRG002_B95C

	; Player might get eaten!

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	ADD #$08
	CMP #$0a
	BGE PRG002_B95C	 ; If Player is vertically too far away to be eaten, jump to PRG002_B95C

	LDA Player_StarInv
	ORA <Player_IsDying
	ORA Player_Behind_En
	BNE PRG002_B95C	 ; If Player is invincible by Starman, dying, or "behind the scenes", jump to PRG002_B95C

	; Player gets eaten!

	INC Objects_Var7,X ; Flag Player as devoured

	LDA #$08
	STA <Player_YHi		; Set Player impossibly low
	STA Player_OffScreen	; Flag Player as off-screen

	LDA #0
	STA Player_AboveTop

	LDA #$02
	BNE PRG002_B993	 ; Jump (technically always) to PRG002_B993 (set frame)

PRG002_B95C:
	LDA <Objects_YVel,X
	BMI PRG002_B996	 ; If Big Bertha is moving upward, jump to PRG002_B996 (RTS)

	; Big Bertha is falling...
	
	LDA <Objects_SpriteY,X
	CMP #160
	BLT PRG002_B996	 ; If SpriteY < 160, jump to PRG002_B996 (RTS)

	JSR BigBertha_Splash	 ; Splash!

	; Big Bertha Y -= 24
	LDA <Objects_Y,X
	SUB #24
	STA <Objects_Y,X
	BCS PRG002_B974
	DEC <Objects_YHi,X	 ; Apply carry
PRG002_B974:

	LDA #$04
	BNE PRG002_B993	 ; Jump (technically always) to PRG002_B993 (set frame)

PRG002_B978:
	CMP #160
	BLT PRG002_B996	 ; If Big Bertha's Y < 160, jump to PRG002_B996

	LDA Objects_Var7,X
	BEQ PRG002_B98D	 ; If Player is not devoured, jump to PRG002_B98D

PRG002_B981:
	LDA #$00
	STA Player_HaltTick	; Player not halted
	STA Player_AboveTop	; Player not above top of screen

	; Hold Player really low
	LDA #196
	STA <Player_SpriteY

PRG002_B98D:
	; Big Bertha Y Vel = -$08
	LDA #-$08
	STA <Objects_YVel,X

	; Sprite frame = -1 (??)
	LDA #$ff

PRG002_B993:
	STA Objects_Frame,X

PRG002_B996:
	RTS		 ; Return

PRG002_B997:
	.byte $FE, $02, $05, $FB, $01, $02, $03, $00

BigBertha_Splash:
	LDY #$02	 ; Y = 2 (use splash slot 2)

	LDA Splash_Counter,Y
	BEQ PRG002_B9A7	 ; If this slot is free, jump to PRG002_B9A7

	DEY		 ; Otherwise, try slot 1

PRG002_B9A7:

	; Initialize splash
	LDA #$01
	STA Splash_Counter,Y
	STA Splash_NoScrollY,Y

	; Set Splash Y
	LDA #147
	STA Splash_Y,Y

	; Set Splash X
	LDA <Objects_X,X
	STA Splash_X,Y
	RTS		 ; Return

BigBertha_Draw:
	LDA Objects_Var7,X	 
	BNE PRG002_B9CB	 ; If there's fractional X, jump to PRG002_B9CB

	LDY Objects_State,X
	CPY #OBJSTATE_KILLED
	BNE PRG002_B9CB	 ; If Big Bertha's state is not Killed, jump to PRG002_B9CB

	; Big Bertha's frame set to 1 if Dying
	LDA #$01
	STA Objects_Frame,X

PRG002_B9CB:
	INC Objects_Frame,X	 ; Big Bertha's frame++
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Objects_Frame,X
	DEC Objects_Frame,X	 ; Big Bertha's frame--
	ASL A	
	ASL A			; Multiply by 4
	ADD <Temp_Var6		 ; Add to starting tile
	STA <Temp_Var6		 ; Set as starting tile
	TAX		 ; Starting tile -> 'X'

	LDA <Temp_Var3
	BPL PRG002_B9E8	 ; If Big Bertha is not vertically flipped, jump to PRG002_B9E8

	; Otherwise, starting tile += 3
	INX
	INX
	INX

PRG002_B9E8:
	JSR Object_Draw24x16Sprite ; Draw upper half of Big Bertha

	LSR <Temp_Var5	; Shift the vertical visibility bits

	; Sprite_RAM offset += 12 (3 sprites ahead)
	TYA
	ADD #$0c
	TAY

	LDX <Temp_Var6	 ; X = starting tile

	LDA <Temp_Var3	
	BMI PRG002_B9FB	 ; If Big Bertha is vertically flipped, jump to PRG002_B9FB

	; Otherwise, starting tile += 3
	INX
	INX
	INX

PRG002_B9FB:
	; Sprite Y += 16 (lower half of Big Bertha)
	LDA #16
	ADD <Temp_Var1
	STA <Temp_Var1
	JSR Object_Draw24x16Sprite ; Draw lower half of Big Bertha

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

CheepCheepCharge_ProxLimit:	.byte $06, -$06	; How close (in coarse units) Cheep Cheep must be to Player to lunge
CheepCheepCharge_XVelLimit:	.byte $20, $60	; Limit on X Velocity (relative, used in addition)
CheepCheepCharge_Accel:		.byte -$01, $01	; X Velocity acceleration for each direction
CheepCheepCharge_XCoarseLimit:	.byte $10, $70	; How far away Cheep Cheep can be before turning around


ObjNorm_CharginCheepCheep:
	JSR Fish_FixedYIfAppro	 ; Fixes 'Y' coordinate for Cheep Cheep that swims in fixed water
	JSR Object_ShakeAndDraw	 ; Draw Cheep Cheep

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE PRG002_BA20	 ; If Cheep Cheep's state is not Killed, jump to PRG002_BA20

	JMP PRG002_B867	 ; Jump to PRG002_B867 (use Big Bertha style respawn routine)

PRG002_BA20:

	; Cheep Cheep is not dying...

	; Toggle Cheep Cheep's frame
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block

	LDA <Objects_Var4,X
	BNE PRG002_BA96	 ; If Var4 <> 0 (Cheep Cheep is lunging), jump to PRG002_BA96

	LDA <Objects_SpriteY,X
	CMP #156
	BGE PRG002_BA40	 ; If Cheep Cheep's SpriteY >= 156, jump to PRG002_BA40

	; Stop Cheep Cheep's vertical movement
	LDA #$00
	STA <Objects_YVel,X

PRG002_BA40:
	LDY <Objects_Var5,X	 ; Y = Var5

	LDA <Objects_XVel,X
	ADD CheepCheepCharge_XVelLimit,Y
	BMI PRG002_BA52	 ; If Cheep Cheep has hit velocity limit, jump to PRG002_BA52

	; Cheep Cheep accelerate!
	LDA <Objects_XVel,X
	ADD CheepCheepCharge_Accel,Y
	STA <Objects_XVel,X	

PRG002_BA52:

	LDA <Objects_XVel,X
	LSR A
	AND #SPR_HFLIP
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Store flip bit by X velocity

	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15	
	ADD #$40
	CMP #$80
	BLT PRG002_BA6B		; If Cheep Cheep isn't too far away, jump to PRG002_BA6B

	JMP Fish_Repawn	 	; Cheep Cheep went too far, restart

PRG002_BA6B:
	LDA <Temp_Var15
	ADD CheepCheepCharge_XCoarseLimit,Y
	BPL PRG002_BA78	 ; If Cheep Cheep hasn't gotten too close to Player, jump to PRG002_BA78

	; Reverse direction
	TYA	
	EOR #$01
	STA <Objects_Var5,X

PRG002_BA78:
	LDA <Temp_Var15	
	CMP CheepCheepCharge_ProxLimit,Y
	BNE PRG002_BAA6	 ; If not hit limit, jump to PRG002_BAA6 (RTS)

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15	
	SUB #$05
	CMP #$18
	BGE PRG002_BAA6	 ; If Cheep Cheep is vertically too far from Player, jump to PRG002_BAA6 (RTS)

	; Big Bertha jumps!
	LDA #-$28
	STA <Objects_YVel,X

	; Does ... nothing to X Velocity?
	LDA <Objects_XVel,X
	ASL A			; Bit 7 shifted into carry
	ROR <Objects_XVel,X	; Carry shifted back into Bit 7

	INC <Objects_Var4,X	 ; Var4 = 1 (Cheep Cheep lunge)

PRG002_BA96:

	; Cheep Cheep's gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	LDA <Objects_SpriteY,X
	CMP #168
	BLT PRG002_BAA6	 ; If Cheep Cheep Y < 168, jump to PRG002_BAA6 (RTS)

	; Stop Cheep Cheep from falling too far; bounce back up
	LDA #-$08
	STA <Objects_YVel,X

	DEC <Objects_Var4,X	 ; Var4 = 0 (Cheep Cheep done lunging)

PRG002_BAA6:
	RTS		 ; Return


	; Performs collision tests against platform and enables Player
	; to stand on the platform, hit head off platform, etc.
	; Carry set if carrying collision occurred
PlayerPlatform_Collide:
	JSR Object_HitTest	 ; Test if Player is touching object
	BCC PRG002_BAEE	 	; If not, jump to PRG002_BAEE (RTS)

	; Test if Player is standing on top of platform

	LDA <Player_SpriteY
	ADD #24
	CMP <Objects_SpriteY,X
	BGE PRG002_BABE	 ; If Player's bottom is beneath object's top, jump to PRG002_BABE

	LDA <Player_YVel
	BMI PRG002_BABD	 ; If Player is moving upward, jump to PRG002_BABD

	JSR Player_StandOnPlatform	 ; Stand on platform
	SEC		 ; Set carry (collided)

PRG002_BABD:
	RTS		 ; Return

PRG002_BABE:

	; Check if Player is hitting off bottom of platform

	LDA #-$08	; A = -8 unless small or ducking

	LDY <Player_Suit
	BEQ PRG002_BAC9	 ; If Player is small, jump to PRG002_BAC9

	LDY Player_IsDucking
	BEQ PRG002_BACB	 ; If Player is NOT ducking, jump to PRG002_BACB

PRG002_BAC9:
	LDA #$08	 ; A = 8 if small or ducking

PRG002_BACB:
	ADD <Player_SpriteY
	CMP <Objects_SpriteY,X
	BLT PRG002_BADC	 ; If Player's Sprite top is near object's top, jump to PRG002_BADC

	LDA <Player_YVel
	BPL PRG002_BADA	 ; If Player is falling, jump to PRG002_BADA

	; Player hits head off platform
	LDA #$10
	STA <Player_YVel

PRG002_BADA:
	CLC		 ; Clear carry (no collision)
	RTS		 ; Return

PRG002_BADC:
	LDA <Objects_XVel,X
	BEQ PRG002_BAF4	 ; If platform is not moving horizontally, jump to PRG002_BAF4

	; Platform is moving horizontally...

	LDA <Player_X
	SUB <Objects_X,X	; Difference between Player and Platform X
	EOR <Objects_XVel,X	; Most importantly, check if sign differs from velocity

	CLC		 ; Clear carry (no collision)
	BMI PRG002_BAEF	 ; If signs differ, jump to PRG002_BAEF

	; Otherwise, set Player's X velocity to platform's X velocity
	LDA <Objects_XVel,X
	STA <Player_XVel

PRG002_BAEE:
	RTS		 ; Return


PRG002_BAEF:

	; Halt Player's movement
	LDA #$00
	STA <Player_XVel

	RTS		 ; Return

PRG002_BAF4:

	; Platform is not moving horizontally... 

	JSR Level_ObjCalcXDiffs

	INY		 ; Y = 1 or 2, depending on Player's relative position

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	STA <Temp_Var1	 ; Temp_Var1 is non-zero if Player is pressing left/right

	CPY <Temp_Var1	 ; Check if Player is pressing a direction favorable to his position

	CLC		 ; Clear carry (no collision)

	BNE PRG002_BAEF	 ; If Player is pressing against it, jump to PRG002_BAEF (halt Player's movement)

	; Player pushing with platform
	LDA PlayerPushWithPlatform_XVel-1,Y
	STA <Player_XVel

	RTS		 ; Return

PlayerPushWithPlatform_XVel:	.byte $04, -$04

ObjInit_EndLevelCard:
	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BEQ OIELC_PurpleCometNoGoal	; If Purple Comet active, no normal goal post!
	CMP #MAPOBJ_DAREDEVILCOMET
	BEQ OIELC_DDCometTboxGoal	; If Red Comet active, be a treasure box instead

	; Align to pole
	LDA <Objects_X,X
	SUB #8
	STA <Objects_X,X
	LDA <Objects_XHi,X
	SBC #0
	STA <Objects_XHi,X

OIELC_DDCometNotYet:
	RTS

OIELC_PurpleCometNoGoal:
	JMP Object_Delete
	
OIELC_DDCometTboxGoal:
	LDA #OBJSTATE_INIT
	STA Objects_State,X
	
	; Wait for screen to align
	LDA <Horz_Scroll
	BNE OIELC_DDCometNotYet
		
	INC LevelJctBQ_Flag

	LDX #4
OIELC_PoofEverythingLoop:

	LDA Objects_State,X
	BEQ OIELC_NoNeedPoof	; If object slot not dead/empty, jump to LEC_NoNeedPoof

	CPX <SlotIndexBackup
	BEQ OIELC_NoNeedPoof	; Don't destroy yourself (Rev 1 oops)

	; poof timer
	LDA #$1f
	STA Objects_Timer,X

	LDA #OBJSTATE_POOFDEATH	; A = 8 ("Poof" death the object)
	STA Objects_State,X

OIELC_NoNeedPoof:
	DEX
	BNE OIELC_PoofEverythingLoop

	LDX #7
OIELC_PoofEverythingLoop2:

	LDA SpecialObj_ID,X
	BEQ OIELC_NoNeedPoof2	; If object slot not dead/empty, jump to LEC_NoNeedPoof

	; poof timer
	LDA #$1f
	STA SpecialObj_Data,X

	LDA #SOBJ_POOF	; A = 8 ("Poof" death the object)
	STA SpecialObj_ID,X

OIELC_NoNeedPoof2:
	DEX
	BNE OIELC_PoofEverythingLoop2
	
	; Take the slot safely adjacent to this object
	LDX <SlotIndexBackup
	LDA OIELC_TBoxSpawnSlot,X
	TAX
	
	JSR Level_PrepareNewObject

	LDA #OBJSTATE_INIT
	STA Objects_State,X

	LDA #OBJ_TREASUREBOX
	STA Level_ObjectID,X

	LDY <SlotIndexBackup
	LDA Objects_X,Y
	STA <Objects_X,X
	LDA Objects_XHi,Y
	STA <Objects_XHi,X

	LDA Objects_Y,Y
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	STA <Objects_YHi,X

	LDA #10
	STA Level_TreasureItem
	
	LDX <SlotIndexBackup
	JMP Object_Delete	
	
OIELC_TBoxSpawnSlot:	.byte 1, 2, 3, 4, 0, 1, 2, 3

ObjNorm_EndLevelCard:
	LDA <Objects_DetStat,X	 ; Mis-used as tracking for the current internal state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word EndLevelCard_Untouched		; 0: Initial state before Player touches card

	; Triple card match
	.word $0000	; 1: Halts Player, sets palette, draws card
	.word $0000	; 2: The giant shape in the sky appears
	.word $0000	; 3: Draws the "YOU GOT A CARD" message and inits for extra lives (triple card match)

	; Not Triple card match
	.word EndLevelCard_WaitFlyAway		; 4: Starts Player running off, spins card away until off-screen
	.word EndLevelCard_MsgAndCard		; 5: Draws the messages "COURSE CLEAR!"/"YOU GOT A CARD" and the cards (two places)

	; Extra lives
	.word $0000				; 6 - Give lives until done
	.word EndLevelCard_Exit			; 7: Exit


EndLevelCard_Untouched:
	;LDA <Counter_1		 
	;AND #$07
	;BNE PRG002_BB65	 ; 1:8 ticks continue, otherwise jump to PRG002_BB65

	; Run through frames 0-2
	;INC Objects_Frame,X
	;LDA Objects_Frame,X
	;CMP #$03
	;BLT PRG002_BB65

	; Restart animation loop
	;LDA #$00
	;STA Objects_Frame,X

;PRG002_BB65:

	; RAS: "Card" (now flag) is grabbed by Player going passed it

	; Trigger when close enough X
	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15	
	CMP #$01
	BGE EndFlagNotGrabbed

	LDA Objects_X,X
	STA Player_X
	LDA Objects_XHi,X
	STA Player_XHi
	LDA #0
	STA Player_XVel

	; If Player is above flag, jump to EndFlagNotGrabbed
	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	JSR Negate
	CMP #-$2
	BLS EndFlagNotGrabbed
	CMP #$25
	BGS EndFlagNotGrabbed
	
	; Calculate award score
	LSR A
	LSR A
	ADD #1
	STA <Temp_Var1
	

	LDA #12
	SUB <Temp_Var1
	JSR Score_PopUp


	LDA #PF_HOLDBIG_BASE

	LDY <Player_Suit
	BNE EndFlag_SetFrame

	LDA #PF_HOLDSMALL_BASE

EndFlag_SetFrame:
	STA <Player_Frame


	LDA #$FF
	STA Player_HaltTick

	JSR ObjHit_EndLevelCard

EndFlagNotGrabbed:
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JMP EndLevelCard_Draw	 	; Jump off to draw End Level card


EndLevelCard_WaitFlyAway:
	JSR Object_ApplyYVel	 ; Apply Y Velocity

	LDA <Objects_DetStat,X
	PHA

	LDA <Objects_X,X
	ADD #8
	STA <Objects_X,X
	LDA <Objects_XHi,X
	ADC #0
	STA <Objects_XHi,X

	JSR Object_WorldDetectN1

	LDA <Objects_X,X
	SUB #8
	STA <Objects_X,X
	LDA <Objects_XHi,X
	SBC #0
	STA <Objects_XHi,X

	LDA <Objects_DetStat,X
	AND #$04
	BEQ EndFlag_NotHitFloor		; If flag has not hit ground, jump to EndFlag_NotHitFloor

	; Hit floor; stop moving!
	LDA #0
	STA <Objects_YVel,X


EndFlag_NotHitFloor:
	PLA
	STA <Objects_DetStat,X

	LDA <Objects_YVel,X
	BNE EndFlag_StillMoving		; If flag is still lowering, jump to EndFlag_StillMoving

	; Play "Course Clear" song
	LDA #MUS1_COURSECLEAR
	STA Sound_QMusic1

	; Go to next internal state
	INC <Objects_DetStat,X

	; Set flag's timer to $60
	LDA #$60
	STA Objects_Timer,X

	; Select bank to support "COURSE CLEAR" font
	LDA #$5e
	STA PatTable_BankSel+1

	; Release the Player
	LDA #0
	STA Player_HaltTick

	; A little kick in the right direction
	LDA #1
	STA <Player_InAir

	LDA #$30
	STA <Player_XVel

	LDA #-$40
	STA <Player_YVel

EndFlag_StillMoving:
	JSR EndLevelCard_Draw 	; Draw the card

EndLevelCard_PlayerRunOff:
	JSR EndLevelCard_ClearPlayerIfOff	; Clear Player's sprites as he walks off-screen

	; Always set Player facing correct direction
	LDA #$41
	STA <Player_FlipBits

	; Does the Player's "run off to the right" sequence
	LDY #$ff
	STY Player_EndLevel

	; Technically the Player runs around and loops back left
	LDA <Player_SpriteX
	LSR A		; divide by 2
	CMP #$10	; so really checking if it's around 32 or 33
	BNE PRG002_BCA7	 ; If Player's not there yet, jump to PRG002_BCA7

	STY Player_HaltTick	 ; If Player has run far enough, set halt

PRG002_BCA7:
	RTS		 ; Return

ELC_HighOrLow:	.byte $2C, $2D

EndLevelCard_MsgAndCard:
	JSR EndLevelCard_Draw
	JSR EndLevelCard_PlayerRunOff	 ; Keep checking for Player having run off to the right

	LDA Objects_Timer,X
	CMP #$1e
	BNE PRG002_BCC6	 ; If timer = $1E, jump to PRG002_BCC4

	LDX <Player_YHi
	LDY ELC_HighOrLow,X	 ; Y = $2C/$2D ("COURSE CLEAR")
	LDX <SlotIndexBackup
	STY <Graphics_Queue	 ; Set Graphics_Queue as appropriate

PRG002_BCC6:
	JSR DoTimeBonus	 	; Turn time into score

	;ORA Objects_Timer,X
	BNE PRG002_BD02	 ; If clock not run out or timer not expired, jump to PRG002_BD02

	; All clock converted to score and timer expired...

	LDA <Player_SpriteX
	LSR A		; divide by 2
	CMP #$10	; so really checking if it's around 32 or 33
	BNE PRG002_BD02	 ; If Player's not there yet, jump to PRG002_BD02

	; RAS: No triple card checks

	JSR PRG002_BD35	 ; Prepare for exit

PRG002_BD02:
	RTS		 ; Return

PRG002_BD35:
	; Go to internal state 7
	LDA #$07
	STA <Objects_DetStat,X

	; Set timer to $80
	LDA #$80
	STA Objects_Timer,X

PRG002_BD3E:
	RTS		 ; Return

EndLevelCard_Exit:
	JSR EndLevelCard_Draw 	; Draw the card
	JSR EndLevelCard_ClearPlayerIfOff	; Clear Player's sprites as he walks off-screen

	LDY #0	; RAS: Inventory offset, former 2P specific offsets removed

	LDA Objects_Timer,X
	BNE PRG002_BD6B	 ; If timer not expired, jump to PRG002_BD6B

	; Timer expired, and we're outta here

	; Invalidate the checkpoint for this Player
	JSR_THUNKC 30, Object_InvalidateCP

	LDA #0
	STA Map_ReturnStatus	 ; Return Status = 0 (clear level)
	INC Level_ExitToMap	 ; Flag to exit to map

	RTS		 ; Return

PRG002_BD6B:
	RTS

PRG002_BEA3:
	JSR StatusBar_DrawCardPiece	 ; Redraw the card

Object_ResetXToSlotIndex:
	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return


	; Clears the Player's sprites if they've gone off-screen
EndLevelCard_ClearPlayerIfOff:
	LDY Player_SprOff	 ; Y = Player's sprite offset

	; Temp_Var1 = 5 (all of the Player's potential sprites)
	LDA #$05
	STA <Temp_Var1
PRG002_BEC1:
	LDA Sprite_RAM+$03,Y
	CMP #64
	BGE PRG002_BECD	 ; If Player's Sprite X > 64, jump to PRG002_BECD

	; Otherwise, set Player's Sprite Y to really low (invisible)
	LDA #248
	STA Sprite_RAM+$00,Y

PRG002_BECD:
	INY
	INY
	INY
	INY	; Y += 4 (next sprite)

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG002_BEC1	 ; While Temp_Var1 >= 0, loop!

	RTS		 ; Return

	; Var1 values for Mushroom, Flower, Star
EndLevelCard_Var1:	.byte $24, $25, $26

ObjHit_EndLevelCard:

	; Clear relevant gameplay variables
	LDA #$00
	STA Player_StarInv
	STA Kill_Tally
	STA Level_PSwitchCnt
	STA Level_AScrlConfig
	STA <Player_YVel
	STA PlayerProj_ID	
	STA PlayerProj_ID+1

	; Delete all "Special Objects" in one sweep
	LDY #$09
PRG002_BEF4:
	STA SpecialObj_ID,Y
	DEY
	BPL PRG002_BEF4

	LDX #$04	 ; X = 4
PRG002_BEFC:
	; If this is the flag itself, don't destroy yourself!
	CPX <SlotIndexBackup
	BEQ PRG002_BF4B	 ; If this is the flag itself, jump to PRG002_BF4B

	LDA Objects_State,X
	BEQ PRG002_BF4B	 ; If object slot is dead/empty, jump to PRG002_BF4B

	LDA Level_ObjectID,X
	;CMP #OBJ_WARPHIDE
	;BEQ PRG002_BF46	 ; If this is the World 1-3 Warp Whistle trigger object, jump to  PRG002_BF46
	CMP #OBJ_YOSHI
	BNE GoalHit_NotYoshi

	; "Poofing" Yoshi is mean! Just let him drop off
	LDA #0
	STA <Objects_Var4,X
	STA Player_Kuribo
	BEQ PRG002_BF4B	; Jump (technically always) to PRG002_BF4B

GoalHit_NotYoshi:
	; Determine if object has gone off-screen yet or not
	LDY #$00
	JSR Object_DetermineHorzVisY
	LDY #$00
	JSR Object_DetermineVertVisY
	JSR Object_AnySprOffscreen
	BNE PRG002_BF46	 ; If object is off-screen in any way, jump to PRG002_BF46

	; Object is on-screen -- turn into coin

	; Play coin sound
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1

	; Special object: Emitted coin
	LDA #SOBJ_POPPEDOUTCOIN
	STA SpecialObj_ID,X

	; Set coin where object was
	LDA <Objects_X,X
	STA SpecialObj_XLo,X
	LDA <Objects_Y,X
	STA SpecialObj_YLo,X
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,X

	; Pop out coin Y Velocity
	LDA #-$28
	STA SpecialObj_YVel,X

	; Don't move horizontally
	LDA #$00
	STA SpecialObj_XVel,X

	; Set coin timer to $1F
	LDA #$1f
	STA Objects_Timer,X

	LDA #OBJSTATE_POOFDEATH	; A = 8 ("Poof" death the object)
	BNE PRG002_BF48	 ; Jump (technically always) to PRG002_BF48

PRG002_BF46
	LDA #$00	 ; A = 0 (just delete object)

PRG002_BF48:
	STA Objects_State,X	 ; Set object state

PRG002_BF4B:
	DEX		 ; X--
	BPL PRG002_BEFC	 ; While X >= 0, loop

	LDX <SlotIndexBackup		 ; X = object slot index

	; Stop the level clock and animations
	LDA #$81
	STA Level_TimerEn
	STA EndCard_Flag	 ; Flag end level card as grabbed

	; Card moves down (RAS)
	LDA #$28
	STA <Objects_YVel,X

	LDY Objects_Frame,X	 ; Y = current frame 

	; Set Var1
	LDA EndLevelCard_Var1,Y
	STA Objects_Var1,X

	LDX <SlotIndexBackup		 ; X = object slot index

	; Jump to internal state 4 (Regular get card, no fanfare)
	LDA #$04
	STA <Objects_DetStat,X

	; RAS: No more victory fanfare stuff!

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Play drop sound
	LDA #SND_MAPENTERWORLD
	STA Sound_QMap

PRG002_BF9F:
	RTS		 ; Return

EndLevelCard_Draw:
	;LDA Objects_Frame,X

	;JSR Object_ShakeAndCalcSprite

	;LDA #$05
	;ADD Counter_7to0
	;TAY		 ; Y = 5 to 12

	;LDA SprRamOffsets,Y	 ; Get special "safe" Sprite_RAM offset area
	;ADD #$08
	;TAY		 ; -> 'Y'

	;JSR Object_Draw16x16Sprite	 ; Draw the End Level card

	JSR Object_ShakeAndDraw

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA Objects_Frame,X
	CMP #$0f
	BGE PRG002_BFD3	 ; If frame >= $0F, jump to PRG002_BFD3 (RTS)

	TAX		 ; Frame -> 'X'

	LDA Sprite_RAM+$02,Y
	AND #~(SPR_HFLIP | $03)	 	; Keep all attributes except horizontal flip and palette select
	ORA #SPR_PAL2
	STA Sprite_RAM+$02,Y	 ; Set attributes
	STA Sprite_RAM+$06,Y	 ; Set attributes

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_BFD3:
	RTS		 ; Return

ObjNorm_BirdoEgg:
	; Birdo Egg comes here when held; don't do anything but draw
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ BirdoEgg_Normal

	; Just draw
	JMP Object_ShakeAndDraw	 ; Draw egg 

BirdoEgg_Normal:
	JSR Object_ApplyXVel

	JSR Object_DeleteOffScreen	 ; Delete egg if it falls off-screen

	LDA Objects_Frame,X
	JSR Object_ShakeAndDraw	 ; Draw egg 

	LDA Objects_Frame,X
	BNE BirdoEgg_FireballUpd

	LDA <Player_SpriteY
	ADD #16
	CMP <Objects_SpriteY,X
	BGE BirdoEgg_JustHit	 ; If Player is too far, jump to BirdoEgg_JustHit

	JSR SMB2Object_StandOnCheck2
	BCS Egg_Carry		; If Player is being carried by egg, jump to Egg_Carry (RTS)
	BCC BirdoEgg_JustHit	; Otherwise, jump to BirdoEgg_JustHit

BirdoEgg_FireballUpd:
	LDA Objects_FlipBits,X
	EOR #SPR_VFLIP
	STA Objects_FlipBits,X

BirdoEgg_JustHit:
	; Otherwise, hit Player
	JSR Player_HitEnemy

	RTS

Egg_Carry:
	; Disable tail attack
	INC Player_DisTailAtk

	; Player is standing on SMB2 type object...
	BIT <Pad_Input 
	BVC Egg_CarryNoHold	 ; If Player did not press B button, jump to ShyGuy_NoHold

	; Player grabs SMB2 object!
	LDA #$01
	STA Player_IsHolding

	; Object is grabbed!
	LDA #OBJSTATE_HELD
	STA Objects_State,X

Egg_CarryNoHold:
	RTS


	; Performs collision tests against SMB2-standable object and enables
	; Player to stand on the object.
	; Carry set if carrying collision occurred
	; NOTE: Necessitated duplication in PRG002, so keep in sync!
SMB2Object_StandOnCheck2:
	JSR Object_HitTest	 ; Test if Player is touching object
	BCC SMB2Object_NotStandOn2	 	; If not, jump to SMB2Object_NotStandOn2 (RTS)

	; Test if Player is standing on top of object

	LDA <Player_SpriteY
	ADD #24
	CMP <Objects_SpriteY,X
	BGE SMB2Object_NotStandOn2	 ; If Player's bottom is beneath object's top, jump to SMB2Object_NotStandOn2 (RTS)

	LDA <Player_YVel
	BMI SMB2Object_UpBypass2	 ; If Player is moving upward, jump to SMB2Object_UpBypass2 (RTS)

	JSR Player_StandOnSMB2Obj2	 ; Stand on platform

SMB2Object_UpBypass2:
	SEC		 ; Set carry (collided)
	RTS

SMB2Object_NotStandOn2:
	CLC		; Clear carry (didn't collide)
	RTS		 ; Return


Player_StandOnSMB2Obj2:
	; Set Player to object's Y - 28
	LDA <Objects_Y,X	 
	SUB #28
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	; Flag Player as NOT mid-air
	LDY #$00
	STY <Player_InAir

	LDA <Player_SpriteX
	CMP #16
	BLT Player_SC_LeftEdge2	; If Player is too close to left edge, jump to Player_SC_LeftEdge2

	LDA Object_XVelCarry
	BPL Player_StandCorrect2

	DEY		 ; Y = -1 (provides a sort of carry if Player's X Velocity caused one)

Player_StandCorrect2:
	; Add to Player_X, with carry
	ADD <Player_X
	STA <Player_X
	TYA
	ADC <Player_XHi
	STA <Player_XHi

Player_SC_LeftEdge2:
	RTS		 ; Return
