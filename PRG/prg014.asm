; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg014.bin, File Size: 8193, ORG: $C000
;     -> NES mode enabled
;---------------------------------------------------------------------------
Tile_Layout_TS18:
	; This defines the individual 8x8 blocks used to construct one of the tiles
	; Referenced by Address_Per_Tileset, addressed by Level_Tileset
	; Stored by upper left, then lower left, then upper right, then lower right

	; Remember that palette is determined by the upper 2 bits of a TILE (not the PATTERN)
	; I.e. tiles starting at index $00, $40, $80, $C0 are each on that respective palette

	; Upper left 8x8 pattern per tile
	.byte $FC, $3B, $FF, $CC, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $BC, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DC, $EC, $EC, $EC, $FF, $FF, $FF, $FF, $FF, $29, $28, $2D, $29, $FF, $2B, $2D ; Tiles $40 - $4F
	.byte $00, $14, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $50, $40, $52, $42, $BC, $B0, $BE, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2 ; Tiles $80 - $8F
	.byte $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2 ; Tiles $90 - $9F
	.byte $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $8C, $8E, $8C ; Tiles $A0 - $AF
	.byte $8E, $8C, $8E, $8C, $8E, $52, $52, $50, $40, $42, $AC, $AE, $98, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $18, $02, $02, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Lower left 8x8 pattern per tile
	.byte $FC, $3A, $FF, $CD, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $BD, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DD, $ED, $ED, $ED, $24, $28, $25, $FF, $28, $26, $28, $28, $27, $FF, $28, $28 ; Tiles $40 - $4F
	.byte $10, $15, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $51, $41, $53, $43, $BD, $B1, $BF, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3 ; Tiles $80 - $8F
	.byte $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3 ; Tiles $90 - $9F
	.byte $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $9C, $9E, $9C ; Tiles $A0 - $AF
	.byte $9E, $9C, $9E, $9C, $9E, $53, $53, $51, $41, $43, $AC, $AE, $99, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $18, $12, $12, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Upper right 8x8 pattern per tile	
	.byte $FC, $FC, $FF, $CE, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $BE, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DE, $EE, $EE, $EE, $FF, $FF, $FF, $FF, $FF, $2D, $2D, $2D, $FF, $29, $28, $29 ; Tiles $40 - $4F
	.byte $01, $16, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $70, $40, $72, $42, $E8, $B0, $EA, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2 ; Tiles $80 - $8F
	.byte $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2 ; Tiles $90 - $9F
	.byte $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $8D, $8F, $8D ; Tiles $A0 - $AF
	.byte $8F, $8D, $8F, $8D, $8F, $72, $72, $70, $40, $42, $AD, $AF, $9A, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $19, $03, $03, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Lower right 8x8 pattern per tile
	.byte $FC, $FC, $FF, $CF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $BF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DF, $EF, $EF, $EF, $28, $28, $FF, $24, $25, $28, $28, $28, $FF, $26, $28, $27 ; Tiles $40 - $4F
	.byte $11, $17, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $71, $41, $73, $43, $E9, $B1, $EB, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3 ; Tiles $80 - $8F
	.byte $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3 ; Tiles $90 - $9F
	.byte $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $9D, $9F, $9D ; Tiles $A0 - $AF
	.byte $9F, $9D, $9F, $9D, $9F, $73, $73, $71, $41, $43, $AD, $AF, $9B, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $19, $13, $13, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

Tile_Attributes_TS18:
	.byte $32, $50, $AD, $C1, $32, $50, $AD, $C1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS18
;
; Entry point for loading level layout data for Level_Tileset = 18
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS18:
	; Clear tiles to black
	LDY #$00	 ; Y = 0
PRG014_C40A:
	LDA #TILE18_BLACK
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA

	CPY #$f0
	BNE PRG014_C40A

	; Set the brick foor
	LDY #$d0	 ; Y = $D0
PRG014_C418:
	LDA #TILE18_BRICKFLOOR
	JSR Tile_Mem_ClearA

	CPY #$f0
	BNE PRG014_C418

	JMP LevelLoad	; Begin actual level loading!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Generator_TS18
;
; Based on the values in Temp_Var15 and LL_ShapeDef, chooses an
; appropriate generator function to builds this piece of the
; level.  Tedious, but saves space and is paper-design friendly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG014_C424:
	.byte 0, 15, 30, 45, 60, 75, 90, 105

LoadLevel_Generator_TS18:
	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = upper 3 bits of Temp_Var15 (0-7) (selects a multiple of 15 as the base)

	LDA LL_ShapeDef
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = upper 4 bits of LL_ShapeDef shifted down
	ADD PRG014_C424,X	; Add multiple of 15
	TAX
	DEX
	TXA		 ; A = ((LL_ShapeDef >> 4) + PRG023_A419[X]) - 1

	; PRG014_C424 provides values reserved for expansion...

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_VsBrickTiles	;  0 - Place a run of brick tiles
	.word LoadLevel_VsBounceBlocks	;  1 - Place a run of bounce block tiles
	.word LoadLevel_VsDiamondBlocks	;  2 - Place a run of [UNUSED] SMB1-ish diamond tiles
	.word LoadLevel_VsCoins		;  3 - UNUSED; Places regular SMB3 coins and employs the coin tracking (Level_BlockGrabHitMem)
	.word LoadLevel_VsLadder	;  4 - Place a vertical run of ladder tiles
	.word $0000	;  5 - N/A
	.word $0000	;  6 - N/A
	.word $0000	;  7 - N/A
	.word $0000	;  8 - N/A
	.word $0000	;  9 - N/A
	.word $0000	; 10 - N/A
	.word $0000	; 11 - N/A
	.word $0000	; 12 - N/A
	.word $0000	; 13 - N/A
	.word $0000	; 14 - N/A
	.word $0000	; 15 - N/A
	.word $0000	; 16 - N/A
	.word $0000	; 17 - N/A
	.word $0000	; 18 - N/A
	.word $0000	; 19 - N/A
	.word $0000	; 20 - N/A
	.word $0000	; 21 - N/A
	.word $0000	; 22 - N/A
	.word $0000	; 23 - N/A

	; NOTE: These are stock, I'm not sure which are used or which work correctly.
	; Of course, little 2P Vs Mario/Luigi don't have code to actually use these
	; like the pipes they represent...
	.word LoadLevel_VGroundPipeRun		; 24 - Vertical ground pipe 1 (alt level)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LeveLoad_FixedSizeGen_TS18
;
; Much simpler generators that are fixed-size, commonly used for 
; just single tile placement styles (although a couple relatively 
; complex ones exist in here as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LeveLoad_FixedSizeGen_TS18:
	; It is verified before calling this function that all of
	; the upper 4 bits of LL_ShapeDef are ZERO

	; So the upper 3 bits of Temp_Var15 serve as the most significant bits
	; to a value where LL_ShapeDef provide the 4 least significant bits

	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	ADD LL_ShapeDef	
	TAX		 	; Resultant index is put into 'X'
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_VsLeftPipes	;  0 - Left side of screen pipes that appear in the "typical" levels
	.word LoadLevel_VsRightPipes	;  1 - Right side of screen pipes that appear in the "typical" levels
	.word LoadLevel_VsQBlock	;  2 - [?] block from the ladder climbing game
	.word LoadLevel_VsStatusBar	;  3 - Tiles that make up the status bar

Vs_Battlefields:
	.word Vs_BattlefieldTypical	;  0: Spiny Only
	.word Vs_BattlefieldTypical	;  1: Fighter Fly Only
	.word Vs_BattlefieldTypical	;  2: Spiny and Fighter Fly
	.word Vs_BattlefieldTypical	;  3: Static coins
	.word Vs_BattlefieldTypical	;  4: Spiny and Sidestepper
	.word Vs_BattlefieldTypical	;  5: Fighter Fly and Sidestepper
	.word Vs_BattlefieldTypical	;  6: Sidestepper Only
	.word Vs_BattlefieldFountain	;  7: Coin Fountain
	.word Vs_BattlefieldTypical	;  8: Spiny Only
	.word Vs_BattlefieldTypical	;  9: Fighter Fly Only 
	.word Vs_BattlefieldTypical	; 10: Sidestepper Only
	.word Vs_BattlefieldLadders	; 11: Ladder and [?] blocks


	; Broken into another file for ease of integration in NoDice editor
	.include "PRG/levels/2PVs.asm"

LoadLevel_VsBrickTiles:
	LDX #$00	; X = 0 (place brick tiles)
	JMP PRG014_C580	 ; Jump to PRG014_C580

LoadLevel_VsBounceBlocks:
	LDX #$01	; X = 1 (place bounce block tiles)
	JMP PRG014_C580	 ; Jump to PRG014_C580

PRG014_C57B:
	.byte TILE18_BRICKFLOOR, TILE18_BOUNCEBLOCK, TILE18_DIAMOND

LoadLevel_VsDiamondBlocks:
	LDX #$02	; X = 2 (place SMB1-ish diamond tiles)

PRG014_C580:

	; Temp_Var1 = run length of tiles
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var1

	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_C58A:
	LDA PRG014_C57B,X	 ; Get tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 ; Y++ (next column)

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG014_C58A	 ; While Temp_Var1 >= 0, loop

	RTS		 ; Return


LoadLevel_VsLadder:
	; Run -> 'X'
	LDA LL_ShapeDef
	AND #$0f
	TAX

	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_C59E:
	LDA #TILE18_LADDER
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; +16 bytes to next row
	TYA
	ADD #16
	TAY

	DEX		 ; X--
	BPL PRG014_C59E	 ; While X >= 0, loop

	RTS		 ; Return

LoadLevel_VsLeftPipes:
	LDX #$00	 ; X = 0 (left pipe offset)
	JMP PRG014_C5BA	 ; Jump to PRG014_C5BA

PRG014_C5B0:
	; Left pipe
	.byte $81, $80
	.byte $83, $82

	; Right pipe
	.byte $80, $81
	.byte $82, $83

LoadLevel_VsRightPipes:
	LDX #$04	 ; X = 4 (right pipe offset)

PRG014_C5BA:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_C5BD:
	LDA PRG014_C5B0,X	 ; PRG014_C5BD 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 ; Y++ (next column)
	INX		 ; X++ (next tile)

	TXA
	AND #$01
	BNE PRG014_C5BD	 ; Every other tile, jump to PRG014_C5BD

	LDA TileAddr_Off
	ADD #16		; +16 to next row
	TAY		 ; -> 'Y'

	TXA
	AND #$03
	BNE PRG014_C5BD	 ; If haven't done 4 tiles yet, jump to PRG014_C5BD

	RTS		 ; Return

LoadLevel_VsQBlock:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE18_QBLOCK
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return

Vs_StatusBarTiles:
	.byte TILE18_BLACK, TILE18_MSTATUS_UL, TILE18_STATUS_UM, TILE18_STATUS_UM, TILE18_MSTATUS_UR
	.byte TILE18_BLACK, TILE18_MSTATUS_LL, TILE18_STATUS_LM, TILE18_STATUS_LM, TILE18_MSTATUS_LR
Vs_StatusBarTiles_End

LoadLevel_VsStatusBar:
	LDX #$00		; X = 0

PRG014_C5F4:
	LDY TileAddr_Off	; Y = TileAddr_Off

	; Temp_Var1 = tiles per row - 1
	LDA #(((Vs_StatusBarTiles_End - Vs_StatusBarTiles) / 2) - 1)
	STA <Temp_Var1

PRG014_C5FB:
	LDA Vs_StatusBarTiles,X
	STA [Map_Tile_AddrL],Y

	INY		 ; Y++
	INX		 ; X++

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG014_C5FB	 ; While Temp_Var1 >= 0, loop

	; Go to next row
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off

	CPX #(Vs_StatusBarTiles_End - Vs_StatusBarTiles)
	BNE PRG014_C5F4	 ; If we have another row to do, loop!

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Door1
;
; Puts 2 TILEA_DOOR1 tiles, stacked vertically
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Door1:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA #TILEA_DOOR1	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Move to next row by adding 16 to tile offset
	TYA		 
	ADD #16
	TAY		 
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA #TILEA_DOOR1	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	
LoadLevel_DoNothing:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Door2
;
; Puts 2 TILEA_DOOR2 tiles, stacked vertically
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Door2:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA #TILEA_DOOR2	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Move to next row by adding 16 to tile offset
	TYA		 
	ADD #16
	TAY		 
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA #TILEA_DOOR2	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VGroundPipeRun
;
; Generates a vertical pipe which runs into the ground (i.e. 
; no visible bottom is applied)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_VertPipe:
	.byte TILE1_PIPETB1_L, TILE1_PIPETB1_R	; alt level
	.byte TILE1_PIPETB3_L, TILE1_PIPETB3_R	; Big [?] area
	.byte TILE1_PIPETB2_L, TILE1_PIPETB2_R	; not enterable

LL_VertPipeTransit:
	.byte TILE1_PIPETB4_L, TILE1_PIPETB4_R	; within level transit

LL_VertPipe4:
	.byte TILE3_PIPETB5_L, TILE3_PIPETB5_R	; exits to common end area
	
LoadLevel_VGroundPipeRun:

	; Backup original Map_Tile_AddrL/H to Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	SUB #$90	
	AND #$f0	
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = index to pipe (so relative index * 2 I think)

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of run)

	LDY TileAddr_Off	; Y = TileAddr_Off

	LDA LL_VertPipe,X	 ; Get this pipe tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	LDA LL_VertPipe+1,X	 ; Get pipe's right-hand tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_C688	 	 ; Jump to PRG014_C688

PRG014_C67A:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE1_PIPEVL
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	LDA #TILE1_PIPEVR
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_C688:

	; Restore backup Map_Tile_Addr
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 bytes
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update backup Map_Tile_AddrH

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_C67A	 	 ; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VCeilingPipeRun
;
; Generates a vertical pipe which runs into the ceiling (i.e. 
; no visible top is applied)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VCeilingPipeRun:
	LDA LL_ShapeDef
	PHA		; Save LL_ShapeDef
	SUB #$c0	
	AND #$f0	
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = index to pipe (so relative index * 2 I think)

	PLA		 	; Restore LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (length of run)

PRG014_C6B8:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

PRG014_C6C0:
	LDY TileAddr_Off	; Y = TileAddr_off

	; Store left/right top of pipe into tile mem
	LDA #TILE1_PIPEVL
	STA [Map_Tile_AddrL],Y
	JSR LoadLevel_NextColumn ; Next column
	LDA #TILE1_PIPEVR	 
	STA [Map_Tile_AddrL],Y	 

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Move to next row by adding 16 bytes to Map_Tile_Addr
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	DEC <Temp_Var3		; Temp_Var3--
	BNE PRG014_C6C0	 	; While Temp_Var3 > 0, loop!

	; Bottom of pipe
	LDY TileAddr_Off	
	LDA LL_VertPipe,X	
	STA [Map_Tile_AddrL],Y	
	JSR LoadLevel_NextColumn ; Next column
	LDA LL_VertPipe+1,X	
	STA [Map_Tile_AddrL],Y	

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VTransitPipeRun
;
; Generates a vertical in-level transit style pipe
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VTransitPipeRun:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDX #(LL_VertPipeTransit - LL_VertPipe)	; X is set to index of in-level transit pipe tile

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of run)

	LDY TileAddr_Off	; Y = TileAddr_Off
	LDA [Map_Tile_AddrL],Y	; Get tile here
	CMP LL_VertPipe,X	; Is the in-level transit pipe tile?
	BEQ PRG014_C727	 	; If so, jump to PRG014_C735

	; The current tile is NOT an in-level transit pipe tile
	; ... but it is now!
	LDA LL_VertPipe,X	 
	STA [Map_Tile_AddrL],Y	 
	JSR LoadLevel_NextColumn
	LDA LL_VertPipe+1,X	
	STA [Map_Tile_AddrL],Y	
	JMP PRG014_C735	 	; Jump to PRG014_C735

PRG014_C727:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; Place center column of pipe here
	LDA #TILE1_PIPEVL
	STA [Map_Tile_AddrL],Y
	JSR LoadLevel_NextColumn
	LDA #TILE1_PIPEVR	
	STA [Map_Tile_AddrL],Y	

PRG014_C735:
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to Map_Tile_Addr
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update backup of Map_Tile_AddrH

	DEC <Temp_Var3		; Temp_Var3--
	BNE PRG014_C727	 	; While Temp_Var3 > 0, loop!

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; Store other end of in-level transit vertical pipe here
	LDA LL_VertPipe,X	
	STA [Map_Tile_AddrL],Y	
	JSR LoadLevel_NextColumn
	LDA LL_VertPipe+1,X	
	STA [Map_Tile_AddrL],Y	

	RTS		 ; Return

LoadLevel_VGroundPipe5Run:
	LDX #(LL_VertPipe4 - LL_VertPipe)	; Level_Tileset 3 or 14 (Hills or underground styles) have a fourth pipe

	LDA LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of pipe)
	JMP PRG014_C6B8	 ; Jump to PRG014_C6B8, which continues with the rest of LoadLevel_VCeilingPipeRun


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_HRightWallPipeRun
;
; Generates a horizontal pipe which runs into a righthand wall
; (i.e. no visible right edge is applied)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_HorzPipe:
	.byte TILE1_PIPEH_T, TILE1_PIPEH_T, TILE1_PIPEH_T
	.byte TILE1_PIPEH1_B, TILE1_PIPEH2_B, TILE5_PIPEH3_B

LoadLevel_HRightWallPipeRun:
	LDA LL_ShapeDef
	SUB #$e0	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		; X = relative index by pipe type (0-2)

PRG014_C780:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3	; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	; Y = TileAddr_Off

	; Do top of horizontal pipe
	LDA LL_HorzPipe,X	 ; Get top left edge of pipe
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG014_C79E	 	; Jump to PRG014_C79E

PRG014_C79A:
	LDA #TILE1_PIPEHT	 ; Pipe horizontal middle top
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_C79E:
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3		; Temp_Var3--
	BPL PRG014_C79A	 	; While Temp_Var3 >= 0, loop!

	; Restore Map_Tile_Addr backup
	LDA <Temp_Var1		
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2		; Update Map_Tile_AddrH backup

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	; Do bottom of horizontal pipe
	LDA LL_HorzPipe+3,X	 ; Get bottom left edge of pipe
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_C7D2	 	; Jump to PRG014_C7D2

PRG014_C7CE:
	LDA #TILE1_PIPEHB	 ; Pipe horizontal middle bottom
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_C7D2:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_C7CE	 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_HLeftWallPipeRun
;
; Generates a horizontal pipe which runs into a lefthand wall
; (i.e. no visible left edge is applied)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_HLeftWallPipeRun:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	SUB #$10	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 ; X = relative index by pipe type (0-2)

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3	; Temp_Var3 = lower 4 bits of LL_ShapeDef (length of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG014_C7F7:
	; Do top of horizontal pipe
	LDA #TILE1_PIPEHT	 ; Pipe horizontal middle top
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3		 ; Temp_Var3--
	BNE PRG014_C7F7	 	; While Temp_Var3 > 0, loop!

	LDA LL_HorzPipe,X	 ; Get right top edge of pipe
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1		 
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2		; Update Map_Tile_AddrH backup

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

PRG014_C828:
	; Do bottom of horizontal pipe
	LDA #TILE1_PIPEHB	; Pipe horizontal middle bottom
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BNE PRG014_C828		 ; While Temp_Var3 > 0, loop!

	LDA LL_HorzPipe+3,X	 ; Get right bottom edge of pipe
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_HLeftWallPipeRun3
;
; A bypass that forces horizontal pipe 3 to be used and otherwise
; runs the LoadLevel_HLeftWallPipeRun code...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_HRightWallPipeRun3:	; $C839
	LDX #$02	 ; Force Horizontal Pipe 3
	JMP PRG014_C780	 ; Jump to PRG014_C780


	; UNUSED: 2P Vs doesn't use regular SMB3 coins and certainly doesn't need to track them
	; But, of note, the coins DO display correctly (face forward only) but the "removed"
	; coin tile displays as the base of a Bullet Bill cannon; weird, huh?
LoadLevel_VsCoins:
	; Temp_Var3 = run length
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3

	LDY TileAddr_Off ; Y = TileAddr_Off
PRG014_C848:
	LDX #TILEA_COINREMOVED	 ; X = TILEA_COINREMOVED

	JSR LoadLevel_CheckBGHMem

	CMP #$00
	BNE PRG014_C853	 	; If this coin was grabbed already, jump to PRG014_C853

	LDX #TILEA_COIN	 ; Otherwise, X = TILEA_COIN

PRG014_C853:
	TXA		 ; Coin/removed tile -> 'A'
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INC <Temp_Var16		 ; Temp_Var16++

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG014_C848	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_EndGoal
;
; The end goal!  Takes up a little more than one screen...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FlagPole_Tiles:
FlagPole_Tiles_TS1:	.byte TILE1_FLAGTOP, TILE1_FLAGPOLE, TILE1_DIAMOND
FlagPole_Tiles_TS3:	.byte TILE3_FLAGTOP, TILE3_FLAGPOLE, TILE1_DIAMOND
FlagPole_Tiles_TS4:	.byte TILE4_FLAGTOP, TILE4_FLAGPOLE, TILE4_FLAGBASE
FlagPole_Tiles_TS5:	.byte TILE5_FLAGTOP, TILE5_FLAGPOLE, TILE5_BRICK
FlagPole_Tiles_TS7:	.byte TILE7_FLAGTOP, TILE7_FLAGPOLE, TILE7_GROUND
FlagPole_Tiles_TS9:	.byte TILE9_FLAGTOP, TILE9_FLAGPOLE, TILE1_DIAMOND
FlagPole_Tiles_TS12:	.byte TILE4_FLAGTOP, TILE4_FLAGPOLE, TILE12_ICEBLOCK
FlagPole_Tiles_TS15:	.byte TILE15_FLAGTOP, TILE15_FLAGPOLE, TILE15_DIAMOND

FlagPole_Tilesets:	.byte 1, 3, 4, 5, 7, 9, 12, 14, 15
FlagPole_Tileset_Off:	
	.byte (FlagPole_Tiles_TS1 - FlagPole_Tiles_TS1)		; 1
	.byte (FlagPole_Tiles_TS3 - FlagPole_Tiles_TS1)		; 3
	.byte (FlagPole_Tiles_TS4 - FlagPole_Tiles_TS1)		; 4
	.byte (FlagPole_Tiles_TS5 - FlagPole_Tiles_TS1)		; 5
	.byte (FlagPole_Tiles_TS7 - FlagPole_Tiles_TS1)		; 7
	.byte (FlagPole_Tiles_TS9 - FlagPole_Tiles_TS1)		; 9
	.byte (FlagPole_Tiles_TS12 - FlagPole_Tiles_TS1)	; 12
	.byte (FlagPole_Tiles_TS3 - FlagPole_Tiles_TS1)		; 14
	.byte (FlagPole_Tiles_TS15 - FlagPole_Tiles_TS1)	; 15

LoadLevel_EndGoal:
	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BEQ Goal_NoGoalPurple	; If Purple Comet is active, no goal!
	CMP #MAPOBJ_DAREDEVILCOMET
	BEQ Goal_NoGoalPurple	; If Daredevil Comet is active, no goal!

	; Backup Map_Tile_Addr into Tem_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDY TileAddr_Off ; Y = TileAddr_Off

	; Go through FlagPole_Tilesets to decide which tileset we're on
	LDX #(FlagPole_Tileset_Off - FlagPole_Tilesets - 1)
LoadLevel_EndGoal_TSDetectLoop:
	LDA FlagPole_Tilesets,X
	CMP Level_Tileset
	BEQ LoadLevel_EndGoal_TSFound

	; Not this one... next!
	DEX	; X--
	BPL LoadLevel_EndGoal_TSDetectLoop	; While X >= 0, loop!

LoadLevel_EndGoal_TSFound:
	; Found the tileset... now need proper offset into tiles
	LDA FlagPole_Tileset_Off,X
	TAX	; -> 'X'

	; Set top of flag pole
	LDA FlagPole_Tiles,X	 	; Get proper goal tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_TileMemNextRow	; Next row
	INX				; X++

	; Now do the 7 pole tiles
	LDA #7
	STA <Temp_Var3
LoadLevel_EndGoal_PoleLoop:
	LDA FlagPole_Tiles,X	 ; Get proper goal tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_TileMemNextRow	; Next row

	DEC <Temp_Var3
	BNE LoadLevel_EndGoal_PoleLoop		; While Temp_Var3 > 0, loop!

LoadLevel_EndGoal_PoleLoop_End:

	INX				; X++

	; Set top of flag pole
	LDA FlagPole_Tiles,X	 	; Get proper pole mount tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Something else here
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; Restore Map_Tile_Addr backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

Goal_NoGoalPurple:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PowerBlock
;
; Adds one of many types of "power" blocks -- different containers
; for power ups, P-Switches, vines, and the muncher plant (?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_PowerBlocks:
	.byte TILEA_QBLOCKFLOWER, TILEA_QBLOCKLEAF, TILEA_QBLOCKSTAR, TILEA_QBLOCKCOINSTAR ; 0 - 3
	.byte TILEA_QBLOCKCOIN2, TILEA_MUNCHER, TILEA_BRICKFLOWER, TILEA_BRICKLEAF ; 4 - 7
	.byte TILEA_BRICKSTAR, TILEA_BRICKCOINSTAR, TILEA_BRICK10COIN, TILEA_BRICK1UP ; 8 - 11
	.byte TILEA_BRICKVINE, TILEA_BRICKPSWITCH, TILEA_INVISCOIN, TILEA_INVIS1UP ; 12 - 15
	.byte TILEA_NOTEINVIS, TILEA_NOTEFLOWER, TILEA_NOTELEAF, TILEA_NOTESTAR ; 16 - 19
	.byte TILEA_WOODBLOCKFLOWER, TILEA_WOODBLOCKLEAF, TILEA_WOODBLOCKSTAR, TILEA_NOTECOINHEAVEN ; 20 - 23
	.byte TILEA_PSWITCH ; 24

	; Alternates for when a Daredevil Comet is in effect!
LL_PowerBlocks_DDComet:
	.byte TILEA_QBLOCKCOIN2, TILEA_QBLOCKCOIN2, TILEA_QBLOCKCOIN2, TILEA_QBLOCKCOIN2 ; 0 - 3
	.byte TILEA_QBLOCKCOIN2, TILEA_MUNCHER, TILEA_BRICKCOIN, TILEA_BRICKCOIN ; 4 - 7
	.byte TILEA_BRICKCOIN, TILEA_BRICKCOIN, TILEA_BRICK10COIN, TILEA_BRICK1UP ; 8 - 11
	.byte TILEA_BRICKVINE, TILEA_BRICKPSWITCH, TILEA_INVISCOIN, TILEA_INVIS1UP ; 12 - 15
	.byte TILEA_NOTEINVIS, TILEA_NOTE, TILEA_NOTE, TILEA_NOTE ; 16 - 19
	.byte TILEA_QBLOCKCOIN2, TILEA_QBLOCKCOIN2, TILEA_QBLOCKCOIN2, TILEA_NOTECOINHEAVEN ; 20 - 23
	.byte TILEA_PSWITCH ; 24

	; SB: New ones accessed via entry points
LL_XtraBlocks:
	.byte TILEA_EXSWITCH

LoadLevel_ActionSwitch:
	LDX #(LL_XtraBlocks - LL_PowerBlocks)
	BNE LLPB_Forced

LoadLevel_PowerBlock:
	; The index we came in on is in 'X', which starts at 16
	TXA	
	SUB #16
	TAX		 ; Now 'X' is relative index, 0 - 24

	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BNE LLPB_Forced

	; Daredevil comet: Use alternate table
	TXA
	ADD #(LL_PowerBlocks_DDComet - LL_PowerBlocks)
	TAX

LLPB_Forced:
	LDY TileAddr_Off ; Y = TileAddr_Off

	CPX #11	 
	BEQ PRG014_CAED	 ; If this is a brick with a 1-up, jump to PRG014_CAED

	CPX #15	 
	BNE PRG014_CAFD	 ; If this is NOT a brick with an invisible 1-up, jump to PRG014_CAFD

PRG014_CAED:
	JSR LoadLevel_CheckBGHMem

	CMP #$00	 
	BEQ PRG014_CAFD	 	; If check OK, jump to PRG014_CAFD

	; Otherwise, stamp it out as an empty!  (Prevent 1-up from reappearing)
	LDA #TILEA_BLOCKEMPTY

	CPX #11	 
	BEQ PRG014_CB00	 ; Technically jump always to PRG014_CB00 (because we only get to this code if X = 11 in the first place!)

	; Unreachable?
	JMP PRG014_CB15	 ; Jump to PRG014_CB15 (RTS)

PRG014_CAFD:
	CPX #13
	BEQ LLPB_PSwitchBrick		; If this is a P-Switch brick, jump to LLPB_PSwitchBrick

	CPX #23
	BNE LLPB_NotOrangeBlock		; If this is not an invisible orange note block,jump to LLPB_NotOrangeBlock


LLPB_PSwitchBrick:
	
	; Disable coin heaven and P-Switch blocks when Purple Comet active
	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BEQ PRG014_CB15

LLPB_NotOrangeBlock:

	LDA LL_PowerBlocks,X	 ; Get the correct power block

PRG014_CB00:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	CMP #TILEA_BRICKPSWITCH
	BNE PRG014_CB15	 ; If this is not a brick with a P-Switch inside of it, jump to PRG014_CB15

	; Y -= 16 (go to previous row)
	TYA
	SUB #16
	TAY
	LDA <Map_Tile_AddrH
	SBC #$00
	STA <Map_Tile_AddrH

	; On reload, blank out the used up P-Switch
	LDA #TILEA_PSWITCH_BLANK
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_CB15:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_StarCoin
;
; Adds a star coin to the world (if not in inventory)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_StarCoin3:
	LDX #2
	BNE LoadLevel_StarCoin

LoadLevel_StarCoin2:
	LDX #1
	BNE LoadLevel_StarCoin

LoadLevel_StarCoin1:
	LDX #0

LoadLevel_StarCoin:
	LDA Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BEQ LLSC_Comet
	CMP #MAPOBJ_PURPLECOMET
	BEQ LLSC_Comet

	LDA Inventory_Cards,X
	BEQ LLStarCoin_OK

LLSC_Comet:
	; Otherwise, stamp it out as an empty!  (Prevent star coin from reappearing)
	LDA #TILEA_COINREMOVED
	BNE LLStarCoin_Store	; Jump (technically always) to LLStarCoin_Store

LLStarCoin_OK:
	TXA
	STA <Temp_Var1	; Temp_Var1 = 0 to 2

	LDY Level_Tileset
	LDA Level_StarCoinByTileset,Y	; Get starter star coin for this tileset
	ADD <Temp_Var1			; Offset to specific star coin

LLStarCoin_Store:
	LDY TileAddr_Off ; Y = TileAddr_Off
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem


	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PurpleCoins
;
; Puts down 1-16 purple coins
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_PurpleCoins:
	LDA Reset_Latch
	BEQ LLPC_EditorHack	; Hack for NoDice editor
	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BNE PurpleCoins_NoCometMode

LLPC_EditorHack:
	; Add to running total
	LDA LL_ShapeDef	
	AND #$0f	
	ADD #1	; +1 because "0" is the base for 1 tile
	JSR PurpleCoins_AddToTotal

	LDX #$08	 
	JMP PRG014_CB2A	 ; Jump to PRG014_CB2A

PurpleCoins_AddToTotal:
	ADD Level_PCometCoins
	STA Level_PCometCoins
	LDA Level_PCometCoins+1
	ADC #0
	STA Level_PCometCoins+1
	
PurpleCoins_NoCometMode:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BlockRun
;
; Puts down 1-16 of one of the blocks from LoadLevel_Blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Blocks:
	.byte TILEA_BRICK, TILEA_QBLOCKCOIN, TILEA_BRICKCOIN, TILEA_WOODBLOCK
	.byte TILEA_GNOTE, TILEA_NOTE, TILEA_WOODBLOCKBOUNCE, TILEA_COIN
	.byte TILEA_PURPLECOIN

LoadLevel_BlockRun:
	LDA LL_ShapeDef
	SUB #16
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 ; X = relative index we were called in on

PRG014_CB2A:
	LDA LL_ShapeDef	
	AND #$0f	
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off ; Y = TileAddr_Off

PRG014_CB34:
	CPX #$07	
	BNE PRG014_CB3F	 ; If X <> 7 (coins), jump to PRG014_CB3F

	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BEQ PRG014_CB44		; If Purple Comet is active, no regular coins!

	; Only coins need to do this check...
	JSR LoadLevel_CheckBGHMem	 ; Check if this coin was collected already
	CMP #$00
	BNE PRG014_CB44	 	; If coin was collected already, jump to PRG014_CB44 (skip putting a coin here)

PRG014_CB3F:
	CPX #6
	BNE LLBR_NotRabbit	; If this is not the Rabbit QBlock, jump to LLBR_NotRabbit
	
	; Daredevil comet should prevent rabbit
	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BNE LLBR_NotRabbit

	; Use a coin block instead!
	LDX #1

LLBR_NotRabbit:
	LDA LoadLevel_Blocks,X	 ; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_CB44:
	JSR LoadLevel_NextColumn ; Next column...
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CB34	 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_(Small/Mid/Big)Bush
;
; Inserts 1 of 3 pre-fab large green bush designs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Each bush design is as wide as LL_Bush_Width defines it to be!
LL_Bush1:
	.byte TILE1_SKY,      TILE1_BUSH_UL,  TILE1_BUSH_UR,  TILE1_SKY,      TILE1_SKY
	.byte TILE1_BUSH_UL,  TILE1_BUSH_FUR, TILE1_BUSH_BR,  TILE1_BUSH_UL,  TILE1_BUSH_UR
	.byte TILE1_BUSH_BL,  TILE1_BUSH_FUL, TILE1_BUSH_FUR, TILE1_BUSH_MID, TILE1_BUSH_BR
	.byte TILE1_BUSH_BL,  TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_BR
	.byte $FF	; Terminator

LL_Bush2:
	.byte TILE1_SKY,      TILE1_BUSH_UL,  TILE1_BUSH_UR,  TILE1_SKY
	.byte TILE1_SKY,      TILE1_BUSH_BL,  TILE1_BUSH_FUL, TILE1_BUSH_UR
	.byte TILE1_BUSH_UL,  TILE1_BUSH_FUR, TILE1_BUSH_MID, TILE1_BUSH_BR
	.byte $FF	; Terminator

LL_Bush3:
	.byte TILE1_SKY,      TILE1_SKY,      TILE1_BUSH_UL,  TILE1_BUSH_UR,  TILE1_SKY,      TILE1_SKY
	.byte TILE1_SKY,      TILE1_SKY,      TILE1_BUSH_BL,  TILE1_BUSH_FUL, TILE1_BUSH_UR,  TILE1_SKY
	.byte TILE1_SKY,      TILE1_SKY,      TILE1_BUSH_BL,  TILE1_BUSH_MID, TILE1_BUSH_BR,  TILE1_SKY
	.byte TILE1_SKY,      TILE1_BUSH_UL,  TILE1_BUSH_FUR, TILE1_BUSH_MID, TILE1_BUSH_BR,  TILE1_SKY
	.byte TILE1_BUSH_UL,  TILE1_BUSH_FUR, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_BR,  TILE1_SKY
	.byte TILE1_BUSH_BL,  TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_BR,  TILE1_SKY
	.byte TILE1_BUSH_BL,  TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_FUL, TILE1_BUSH_UR
	.byte TILE1_BUSH_BL,  TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_BR
	.byte $FF	; Terminator


	; Width of each bush; because of "from X to 0" type loops,
	; these are one less than the actual tile width of the bush!
LL_Bush_Width:
	.byte 4, 3, 5

LoadLevel_MidSizeBush:
	LDX #0				; Starting index from LL_Bush1
	LDY #0		 		; Bush width index
	JMP PRG014_CBB9	 		; Jump to PRG014_CBB9

LoadLevel_SmallSizeBush:
	LDX #(LL_Bush2 - LL_Bush1)	; Starting index from LL_Bush1
	LDY #1		 		; Bush width index
	JMP PRG014_CBB9	 		; Jump to PRG014_CBB9

LoadLevel_BigSizeBush:
	LDX #(LL_Bush3 - LL_Bush1)	; Starting index in LL_Bush1
	LDY #2		 		; Bush width index

PRG014_CBB9:

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	STY <Temp_Var13		; Temp_Var13 = 0, 1, or 2

PRG014_CBC3:
	LDY <Temp_Var13		; Y = Temp_Var13
	LDA LL_Bush_Width,Y	
	STA <Temp_Var3		; Temp_Var3 = LL_Bush_Width[Y]

	LDY TileAddr_Off	; Y = TileAddr_Off

PRG014_CBCD:
	LDA LL_Bush1,X		; Get this tile from the bush layout
	CMP #TILE1_SKY
	BEQ PRG014_CC04	 	; If tile = TILE1_SKY, jump to PRG014_CC04 (skip placing it)

	STA <Temp_Var4		; Temp_Var4 = bush tile

	; If this tile belongs in the front of another bush, jump to PRG014_CC00 (place the bush tile)
	CMP #TILE1_BUSH_FUL
	BEQ PRG014_CC00
	CMP #TILE1_BUSH_FUR	 
	BEQ PRG014_CC00	


	LDA [Map_Tile_AddrL],Y	; Get the tile here

	; If tile < TILE1_BUSH_UL or tile >= TILE1_BUSH_SBR (out of bush range), jump to PRG014_CC00 (place the bush tile)
	CMP #TILE1_BUSH_UL	
	BLT PRG014_CC00
	CMP #TILE1_BUSH_SBR	
	BGE PRG014_CC00	

	; Tile we grabbed is in bush range...

	CMP <Temp_Var4	
	BEQ PRG014_CC04		; If the tile we grabbed is the same as the tile we were going to place, jump to PRG014_CC04 (don't place the bush tile)

	LDA <Temp_Var4		; Get tile we were going to place
	CMP #TILE1_BUSH_BL
	BGE PRG014_CBFC	 	; If tile is >= TILE1_BUSH_BL (i.e. not top of a bush), jump to PRG014_CBFC (change to generic middle-of-bush tile)

	; Otherwise, Temp_Var4 += 2 (changes bush tops to "front" tops, or changes "front" tops to the lower part?)
	LDA <Temp_Var4	
	ADD #$02	
	STA <Temp_Var4	

	JMP PRG014_CC00	 	; Jump to PRG014_CC00 (place the bush tile)

PRG014_CBFC:
	LDA #TILE1_BUSH_MID
	STA <Temp_Var4		 ; Temp_Var4 = TILE1_BUSH_MID

PRG014_CC00:
	LDA <Temp_Var4		 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_CC04:
	JSR LoadLevel_NextColumn	; Next column
	INX		 		; X++ (next tile of bush layout)
	DEC <Temp_Var3		 	; Temp_Var3--
	BPL PRG014_CBCD	 		; If Temp_Var3 >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1		 
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	; Go to next row by adding 16 to address
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	LDA LL_Bush1,X
	CMP #$ff	 	
	BNE PRG014_CBC3	 	; If next byte from bush is NOT $FF, loop around again...

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PathHorizontal
;
; Adds a run of 1-16 horizontal moving platform path tiles
; Automatically moves RIGHT with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_PathHorz:
	.byte TILEA_PATH_HORZ, TILE2_PATH_HORZ

LoadLevel_PathHorizontal:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)
PRG014_CC32:
	LDA LL_PathHorz,X	 ; Get appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CC32	 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return

	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PathVertical
;
; Adds a run of 1-16 vertical moving platform path tiles
; Automatically moves DOWN with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_PathVert:
	.byte TILEA_PATH_VERT, TILE2_PATH_VERT

LoadLevel_PathVertical:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)
PRG014_CC44:
	LDA LL_PathVert,X	 ; Get appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Next row by adding 16
	TYA		 
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CC44	 	; While Temp_Var3 >= 0, loop
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Path45T2B
;
; Adds a run of 1-16 45 degree top-to-bottom moving platform path
; tiles.  Automatically moves DOWN and RIGHT with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Path45T2B:
	.byte TILEA_PATH_45T2B, TILE2_PATH_45T2B

LoadLevel_Path45T2B:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)
PRG014_CC5E:
	LDA LL_Path45T2B,X	 ; Get appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Next row by adding 16, to the right 1 via LoadLevel_NextColumn
	TYA
	ADD #16
	TAY	
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	JSR LoadLevel_NextColumn

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CC5E	 	; While Temp_Var3 >= 0, loop
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Path45B2T
;
; Adds a run of 1-16 45 degree bottom-to-top moving platform path
; tiles.  Automatically moves UP and RIGHT with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Path45B2T:
	.byte TILEA_PATH_45B2T, TILE2_PATH_45B2T

LoadLevel_Path45B2T:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)
PRG014_CC7E:
	LDA LL_Path45B2T,X	 ; Load appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Move up and to the right
	TYA
	SUB #16
	TAY	
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	SBC #$00	 
	STA <Map_Tile_AddrH
	JSR LoadLevel_NextColumn

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CC7E	 	; While Temp_Var3 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Path625T2B
;
; Adds a run of 1-16 62.5 degree top-to-bottom moving platform path
; tiles.  Automatically moves DOWN TWICE and RIGHT with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Path625T2B:
	.byte TILEA_PATH_625T2B_U, TILE2_PATH_625T2B_U
	.byte TILEA_PATH_625T2B_L, TILE2_PATH_625T2B_L

LoadLevel_Path625T2B:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)

PRG014_CCA0:
	LDA LL_Path625T2B,X	 ; Get appropriate tile (upper 62.5)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Down one row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA LL_Path625T2B+2,X	 ; Get appropriate tile (lower 62.5)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Down one row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CCA0	 	 ; While Temp_Var3 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Path625T2B
;
; Adds a run of 1-16 62.5 degree top-to-bottom moving platform path
; tiles.  Automatically moves DOWN TWICE and LEFT with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Path625B2T:
	.byte TILEA_PATH_625B2T_U, TILE2_PATH_625B2T_U
	.byte TILEA_PATH_625B2T_L, TILE2_PATH_625B2T_L

LoadLevel_Path625B2T:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)
PRG014_CCD2:
	LDA LL_Path625B2T,X	 	; Get appropriate tile (upper 62.5)
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Down one row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA LL_Path625B2T+2,X	 	; Get appropriate tile (lower 62.5)
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Down one row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	DEY		 ; Y--
	TYA	
	AND #$0f
	CMP #$0f
	BNE PRG014_CD0E		; If we haven't left the left edge of this screen, jump to PRG014_CD0E

	; Move back one screen by subtracting $1B0 from Map_Tile_Addr
	LDA <Map_Tile_AddrL
	SUB #$b0	 
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	SBC #$01	 
	STA <Map_Tile_AddrH

	; Transfer 'Y' to the other side
	INY	
	TYA	
	AND #$f0
	ORA #$0f
	TAY	

PRG014_CD0E:
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CCD2	 	; While Temp_Var3 >= 0, loop!
	RTS		 ; Return


	; Setup for the path routines
LL_PathInit:
	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; X = 0 UNLESS Level_Tileset = 2 (Fortress style), in which case X = 1
	LDX #$00
	LDA Level_Tileset
	CMP #$02	 
	BNE PRG014_CD28	 
	LDX #$01	 

PRG014_CD28:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Lava
;
; Puts down a 1-256 width stretch of lava!  Puts the bubbly on
; top and the red beneath it (i.e. 2 rows)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Lava:
	.byte TILE2_LAVATOP, TILE2_LAVABOTTOM

LL_PurpleGoo:
	.byte TILE3_LAVATOP, TILE3_LAVABOTTOM

LL_Lava15:
	.byte TILE15_LAVATOP, TILE15_LAVABOTTOM

LoadLevel_Lava15:
	LDX #$04
	BNE LLLava_Common
	
LoadLevel_PurpleGoo:
	LDX #$02
	BNE LLLava_Common

LoadLevel_Lava:
	LDX #$00	 	; X = 0 (top of lava first)

LLLava_Common:
	LDY #$00	 ; Y = 0

	LDA [Level_LayPtr_AddrL],Y	 ; Get another byte from layout
	STA <Temp_Var3			 ; Store it into Temp_Var3

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01	
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var4	 ; Temp_Var4 = lower 4 bits of LL_ShapeDef

PRG014_CD4F:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3		 
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3 (restore width)
 
PRG014_CD56:
	LDA LL_Lava,X	 	 ; Get appropriate lava tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	LDA <Temp_Var5		 
	CMP #$ff	 
	BNE PRG014_CD56	 	; While Temp_Var5 >= 0, loop!


	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	TXA
	ORA #1	 	; X = 1 (bottom of lava)
	TAX
	
	DEC <Temp_Var4		; Temp_Var4--
	BPL PRG014_CD4F	 ; While Temp_Var4 >= 0, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Pillar
;
; Puts down 1-16 pillars, which are created downward from their
; starting position for as long as the appropriate BGBRICK tile
; continues downward.  Also generates the shadow, which follows
; the same pattern.  So, word of warning: Don't have a pillar
; generate over top of anything except those tiles!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Pillar:
	LDX #$00	 ; X = 0 (foreground pillar)
	BEQ PRG014_CD98	 ; (Technically always) jump to PRG014_CD98

LL_Pillar:
	.byte TILE2_PILLARSHADOW_T, TILE2_PILLAR_T	; Top
	.byte TILE2_PILLARSHADOW_M, TILE2_PILLAR_M	; Middle
	.byte TILE2_PILLARSHADOW_B, TILE2_PILLAR_B	; Bottom

	; These are the shadow tiles which appear to the right of the pillar
LL_PillarShadow:
	.byte TILE2_BGBRICK_ULDSHADOW, TILE2_BGBRICK_SHADOW	; Top
	.byte TILE2_BGBRICK_LDSHADOW, TILE2_BGBRICK_LSHADOW	; Middle/bottom

	; BGBRICK tile check for different pillar types
	; The pillar will build downward as long as it sees this tile
LL_PillarBrickChk:
	.byte TILE2_BGBRICK_SHADOW2, TILE2_BGBRICK_NOSHADOW
	
LoadLevel_Pillar_BG:
	LDX #$01	 ; X = 1 (background pillar)

PRG014_CD98:
	STX <Temp_Var3		; Temp_Var3 = X

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	 
	AND #$0f	 
	STA <Temp_Var4	 	; Temp_Var4 = lower 4 bits of LL_ShapeDef (number of pillars)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG014_CDAC:
	LDX <Temp_Var3		 ; X = Temp_Var3

	LDA LL_Pillar,X	 	; Get top pillar tile
	STA [Map_Tile_AddrL],Y	; Store into tile mem

	; Loop builds pillar while it hits a TILE2_BGBRICK_SHADOW2 tile 
	; (shadowed pillar) or a TILE2_BGBRICK_NOSHADOW tile (nonshadowed)
PRG014_CDB3:
	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA [Map_Tile_AddrL],Y	; Get tile here
	CMP LL_PillarBrickChk,X	 
	BNE PRG014_CDCD	 	; If NOT the appropriate shadow tile, jump to PRG014_CDCD

	; Otherwise, replace tile with shadowing tile
	LDA LL_Pillar+2,X	 ; Get middle pillar tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_CDB3	 	; Jump to PRG014_CDB3


PRG014_CDCD:

	; Back up one row by subtracting 16 (because we're sitting on
	; the non BGBRICK tile that we hit!)
	TYA	
	SUB #16
	TAY	
	LDA <Map_Tile_AddrH
	SBC #$00	 
	STA <Map_Tile_AddrH

	LDA LL_Pillar+4,X	 ; Get bottom of pillar tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDY TileAddr_Off	 ; Y = TileAddr_Off


	; The following (down to PRG014_CE05) is ALMOST the same as LoadLevel_NextColumn,
	; except it also backs up the new address (kind of pointless, but sure...)

	INY		 ; Y++
	TYA		 ; A = Y
	AND #$0f	 ; Check column
	BNE PRG014_CE05	 ; If on column 1-15, jump to PRG014_CE05

	; Otherwise, need to move over to the next screen (+$1B0)
	LDA <Map_Tile_AddrL
	ADD #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var1		 ; Update Map_Tile_AddrL backup
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	; Get TileAddr_Off and only keep the row, but clear 'Y' lower bits since
	; we're going to column 0 on the same row, new screen...
	LDA TileAddr_Off
	AND #$f0
	TAY	
PRG014_CE05:


	STY TileAddr_Off	 ; Tile_Addr_Off = Y

	; We moved over one column from the top of the pillar...

	LDA LL_PillarShadow,X	 ; Get the appropriate ceiling shadow for this pillar
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Loop builds pillar shadow while it hits a TILE2_BGBRICK_SHADOW2 tile 
	; (shadowed pillar) or a TILE2_BGBRICK_NOSHADOW tile (nonshadowed)
PRG014_CE0D:
	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA [Map_Tile_AddrL],Y	 ; Check for the BGBRICK like before...
	CMP LL_PillarBrickChk,X	 
	BNE PRG014_CE27	 	; If NOT the appropriate shadow tile, jump to PRG014_CE27

	LDA LL_PillarShadow+2,X	 ; Get pillar shadow tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_CE0D	 	; Loop back around...

PRG014_CE27:
	DEC <Temp_Var4		; Temp_Var4--
	BMI PRG014_CE5E	 	; If Temp_Var4 < 0, jump to PRG014_CE5E

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1		 
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	LDX #$02	 ; X = 2
	LDY TileAddr_Off ; Y = TileAddr_Off

PRG014_CE38:
	; The following (down to PRG014_CE05) is ALMOST the same as LoadLevel_NextColumn,
	; except it also backs up the new address (kind of pointless, but sure...)
	INY		 ; Y++
	TYA		 ; A = Y
	AND #$0f	 ; Check column
	BNE PRG014_CE55	 ; If on column 1-15, jump to PRG014_CE05

	; Otherwise, need to move over to the next screen (+$1B0)
	LDA <Map_Tile_AddrL
	ADD #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var1		 ; Update Map_Tile_AddrL backup
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	; Get TileAddr_Off and only keep the row, but clear 'Y' lower bits since
	; we're going to column 0 on the same row, new screen...
	LDA TileAddr_Off
	AND #$f0
	TAY	
PRG014_CE55:

	DEX		 ; X--
	BPL PRG014_CE38	 ; While PRG014_CE38 >= 0, loop!

	STY TileAddr_Off ; TileAddr_Off = Y
	JMP PRG014_CDAC	 ; Loop back around...

PRG014_CE5E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BrickAndShadow
;
; Puts down 1-16 solid brick blocks with automatically added
; shadow background brickwork blocks beneath it
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BrickAndShadow:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_ShapeDef
	AND #$0f	
	TAX		 	; X = lower 4 bits of LL_ShapeDef

PRG014_CE70:
	LDA #TILE2_SOLIDBRICK		; Solid brick pattern
	STA [Map_Tile_AddrL],Y		; Store into tile mem
	JSR LoadLevel_NextColumn	; Go to next column
	DEX		 		; X--
	BPL PRG014_CE70	 		; While X >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA LL_ShapeDef
	AND #$0f	
	TAX		 	; X = lower 4 bits of LL_ShapeDef

	LDA #TILE2_BGBRICK_UNDBRICK 	; BGBRICK as appears under the solid brick edge
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JMP PRG014_CEA3	 		; Jump to PRG014_CEA3

PRG014_CE9F:
	LDA #TILE2_BGBRICK_TOPSHADOW	; Rest of bricks get shadow BGBRICK under it...
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

PRG014_CEA3:
	JSR LoadLevel_NextColumn	 ; Next column
	DEX		 ; X--
	BPL PRG014_CE9F	 ; While X >= 0, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Cannon
;
; Generates a Bullet Bill cannon.  The specified height includes
; the very top of the cannon (height = 0), the mount beneath
; (height = 1), and then the body extending downward (height > 1)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Cannon:
	LDA LL_ShapeDef	 
	AND #$0f	 
	TAX		 	; X = lower 4 bits of LL_ShapeDef (height of cannon)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE1_CANNONTOP1	 ; Top of cannon
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH

	DEX		 ; X-- (height decrement)
	BMI PRG014_CEE9	 ; If X < 0, jump to PRG014_CEE9 (RTS)

	LDA #TILE1_CANNONTOP2	 ; Top beneath cannon
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH

	DEX		 ; X-- (height decrement)
	BMI PRG014_CEE9	 ; If X < 0, jump to PRG014_CEE9 (RTS)

PRG014_CED7:
	LDA #TILE1_CANNONMID	 ; Middle part of cannon and continued
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH

	DEX		 ; X-- (height decrement)
	BPL PRG014_CED7	 ; While X >= 0, loop!

PRG014_CEE9:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_CCBridge
;
; Generates a Cheep-cheep style 'oo' bridge, with fence
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Bridge:
	.byte TILE1_LITTLEFENCE, TILEA_PSWITCHCOIN, TILE1_CCBRIDGE, TILE1_BLOCK_SHUL ; <-- TILE1_BLOCK_SHUL is used as early terminator!

LoadLevel_CCBridge:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	SUB #$40
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	PLA		 ; Restore LL_ShapeDef
	AND #$0f
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)
	STA <Temp_Var4	 ; Temp_Var4 = Temp_Var3 (save original width)

	LDY TileAddr_Off	; Y = TileAddr_Off

	; Top of bridge
PRG014_CF0C:
	LDA LL_Bridge,X	 	; Get fence tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BPL PRG014_CF0C	 	; While Temp_Var4 >= 0, loop!

	; Restore the backup of Map_Tile_Addr
	LDA <Temp_Var1		 
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	; Go to next offset row by adding 16, carry to Map_Tile_AddrH if needed...
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		; Update the backup Temp_Var2

	LDA <Temp_Var3	
	STA <Temp_Var4		; Temp_Var4 = Temp_Var3 (restore original width)

PRG014_CF36:
	LDA LL_Bridge+2,X	; Get bridge tile
	CMP #TILE1_BLOCK_SHUL	
	BEQ PRG014_CF46	 	; If the tile is TILE1_BLOCK_SHUL, jump to PRG014_CF46 (RTS)

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BPL PRG014_CF36	 	; While Temp_Var4 >= 0, loop!

PRG014_CF46:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_TopDecoBlocks
;
; Generates a rectangle (width 1-256 / height 1-16) of "top 
; decorated" blocks, like a block of water with waves at the top,
; or sandy ground with its special "top" sandy floor, etc.
;
; In this case, the lower 4 bits of LL_ShapeDef specify the 
; HEIGHT of the following blocks, while a byte pulled from the
; level data stream contains the WIDTH (so large 1-256 widths
; are supported by this routine.)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_TopBlock:
	.byte TILE1_WFALLTOP,     TILE1_WATERWAVEL, TILE1_WATERWAVE, TILE1_WATERWAVER
	.byte TILE1_WATERBUMPS1,  TILE1_DIAMOND,    TILE1_SANDTOP,   TILE4_CAVEFILLER1
	.byte TILE1_HAUNTBGBRICK1,	TILE1_HAUNTBGBRICK2, TILE3_QUICKSAND_TOP, TILE9_QUICKSAND_TOP	; SB
	.byte TILE15_DIAMOND, TILEA_PURPLECOIN

	; This array specifies what blocks will follow
LL_FollowBlock:
	.byte TILE1_WFALLMID,     TILE1_WATER,      TILE1_WATER,     TILE1_WATER
	.byte TILE1_WATERBUMPSSH, TILE1_DIAMOND,    TILE1_SANDMID,   TILE4_CAVEFILLER2
	.byte TILE1_HAUNTBGBRICK1,	TILE1_HAUNTBGBRICK2, TILE3_QUICKSAND_MID, TILE9_QUICKSAND_MID	; SB
	.byte TILE15_DIAMOND, TILEA_PURPLECOIN

LLPCR_PURPLECOIN_X = (LL_FollowBlock - LL_TopBlock - 1)
LoadLevel_PurpleCoinR:
	LDX #LLPCR_PURPLECOIN_X
	BNE LoadLevel_TopDecoBlocksX

LoadLevel_TopDecoBlocks:
	LDA LL_ShapeDef	 
	SUB #$60
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		; X = relative index

LoadLevel_TopDecoBlocksX:
	LDY #$00	 		; Y = 0
	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	STA <Temp_Var3		 	; Store into Temp_Var3

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01	 
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	; Prevent purple coins when comet not active; skip for not coins, skip for editor
	CPX #LLPCR_PURPLECOIN_X
	BNE LLPR_EditorHack
	LDA Reset_Latch
	BEQ LLPR_EditorHack	; Hack for NoDice editor
	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BNE PRG014_CF46

LLPR_EditorHack:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	 
	AND #$0f	
	STA <Temp_Var4	; Temp_Var4 = lower 4 bits of LL_ShapeDef (height of the run)

	LDA <Temp_Var3	
	STA <Temp_Var5	; Temp_Var5 = Temp_Var3 (the value we pulled in)

	CPX #LLPCR_PURPLECOIN_X
	BNE LLTDB_NotPCoins

	; Purple coins only: Add to running total
	; Little bit ugly because of rectangular multiplication
	LDA <Temp_Var4
	STA <Temp_Var6	; height
LLTDB_PCoinAddLoop:

	; Add width + 1 to total each iteration
	LDA <Temp_Var5
	ADD #1	; +1 because "0" is the base for 1 tile
	JSR PurpleCoins_AddToTotal

	DEC <Temp_Var6
	BPL LLTDB_PCoinAddLoop

LLTDB_NotPCoins:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG014_CF8A:
	LDA LL_TopBlock,X	 ; Get block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5--
	LDA <Temp_Var5
	CMP #-1
	BNE PRG014_CF8A	 	; While Temp_Var5 <> -1, loop!

	; After loop...

PRG014_CF9A:
	DEC <Temp_Var4		; Temp_Var4--
	BPL PRG014_CF9F	 	; While Temp_Var4 >= 0, jump to PRG014_CF9F

	RTS		 ; Return


PRG014_CF9F:
	; Restore from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next offset row by adding 16, carry to Map_Tile_AddrH if needed...
	LDA TileAddr_Off	
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		; Update backup of Map_Tile_AddrH

	LDA <Temp_Var3		
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 (reload starting width)

PRG014_CFBD:
	LDA LL_FollowBlock,X	; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5--
	LDA <Temp_Var5
	CMP #-1
	BNE PRG014_CFBD	 	; While Temp_Var5 <> -1, loop!

	JMP PRG014_CF9A	 ; Jump to PRG014_CF9A


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LittleCloudRun and LoadLevel_LittleCloudSolidRun
;
; Puts down 1-16 of those little smiling Judgem's like clouds
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LittleCloudSolidRun:
	LDX #$01	 	; X = 1 (use TILE1_JCLOUDSOLID)

	BNE PRG014_CFD8		; SB: Bug fixed

PRG014_CFD4:
	.byte TILE1_JCLOUD, TILE1_JCLOUDSOLID

LoadLevel_LittleCloudRun:
	LDX #$00	 ; X = 0 (use TILE1_JCLOUD)

PRG014_CFD8:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_CFE2:
	LDA PRG014_CFD4,X	 ; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Go to next column
	DEC <Temp_Var3		; Temp_Var3--
	BPL PRG014_CFE2	 	; If Temp_Var3 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Jelectro
;
; Puts down 1-16 Jelectros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Jelectro:
	LDX #$02	 ; X = 2 (use TILE4_JELECTRO)
	LDA LL_ShapeDef	 
	JMP PRG014_D007	 ; PRG014_D007

LL_Conveyor:
	.byte TILE2_CONVEYORL, TILE2_CONVEYORR, TILE4_JELECTRO

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Conveyor
;
; Puts down 1-16 left/right conveyor tiles
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Conveyor:
	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef

	SUB #$50	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	TAX		 ; X = relative index

	PLA		 ; Restore LL_ShapeDef

PRG014_D007:
	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_D00E:
	LDA LL_Conveyor,X	 ; Get appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3-- (width decrement)
	BPL PRG014_D00E	 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PutLittleBGCloud
;
; Places a single little BG cloud tile
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_PutLittleBGCloud:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE1_LILBGCLOUD	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DonutLifts
;
; Places 1-16 donut lifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_DonutLifts:
	LDA LL_ShapeDef	 
	AND #$0f	 
	TAX		 ; X = lower 4 bits of LL_ShapeDef (with of run)
	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_D02C:
	LDA #TILE2_DONUTLIFT	; Donut lift
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column
	DEX		 ; X--
	BPL PRG014_D02C	 ; While X >= 0, loop!
	RTS		 ; Return


	; Defines the tile lookup to construct the "big blocks" seen in 
	; Plains style levels, top/middle/bottom, in each of the 4 colors.
LL_BigBlock_Top:
	; Top
	.byte TILE1_WBLOCKUL, TILE1_WBLOCKTH, TILE1_WBLOCKUR
	.byte TILE1_OBLOCKUL, TILE1_OBLOCKTH, TILE1_OBLOCKUR 
	.byte TILE1_GBLOCKUL, TILE1_GBLOCKTH, TILE1_GBLOCKUR
	.byte TILE1_BBLOCKUL, TILE1_BBLOCKTH, TILE1_BBLOCKUR

LL_BigBlock_Mid:
	; Middle
	.byte TILE1_WBLOCKLV, TILE1_WBLOCKM,  TILE1_WBLOCKRV
	.byte TILE1_OBLOCKLV, TILE1_OBLOCKM,  TILE1_OBLOCKRV
	.byte TILE1_GBLOCKLV, TILE1_GBLOCKM,  TILE1_GBLOCKRV
	.byte TILE1_BBLOCKLV, TILE1_BBLOCKM,  TILE1_BBLOCKRV

LL_BigBlock_Bot:
	; Bottom
	.byte TILE1_WBLOCKLL, TILE1_WBLOCKBH, TILE1_WBLOCKLR
	.byte TILE1_OBLOCKLL, TILE1_OBLOCKBH, TILE1_OBLOCKLR
	.byte TILE1_GBLOCKLL, TILE1_GBLOCKBH, TILE1_GBLOCKLR
	.byte TILE1_BBLOCKLL, TILE1_BBLOCKBH, TILE1_BBLOCKLR

	; Array of values used for determining an index of an appropriate shadow;
	; that is, for each of these, they are paired with a result in the same
	; sized LL_BigBlock_ApprShadow array to provide a shadow tile...
LL_BigBlock_ShadowChks:
	; |*	Defines "big block" in just lower-left corner blocks
	; L-	<-- like this
	.byte TILE1_WBLOCKLV, TILE1_WBLOCKM, TILE1_WBLOCKBH, TILE1_WBLOCKLL
	.byte TILE1_OBLOCKLV, TILE1_OBLOCKM, TILE1_OBLOCKBH, TILE1_OBLOCKLL
	.byte TILE1_GBLOCKLV, TILE1_GBLOCKM, TILE1_GBLOCKBH, TILE1_GBLOCKLL
	.byte TILE1_BBLOCKLV, TILE1_BBLOCKM, TILE1_BBLOCKBH, TILE1_BBLOCKLL

	; Big green bush pieces
	.byte TILE1_BUSH_UL,  TILE1_BUSH_BL,  TILE1_BUSH_UR,  TILE1_BUSH_BR
	.byte TILE1_BUSH_FUL, TILE1_BUSH_FBL, TILE1_BUSH_FUR, TILE1_BUSH_FBR

	.byte TILE1_BUSH_MID
LL_BigBlock_EndShadowChks


	; Array of values (matching array above) for correct shadow
LL_BigBlock_ApprShadow:
	; Shadowed middle and bottom of big blocks
	.byte TILE1_WBLOCKSM, TILE1_WBLOCKSM, TILE1_WBLOCKSB, TILE1_WBLOCKSB
	.byte TILE1_OBLOCKSM, TILE1_OBLOCKSM, TILE1_OBLOCKSB, TILE1_OBLOCKSB
	.byte TILE1_GBLOCKSM, TILE1_GBLOCKSM, TILE1_GBLOCKSB, TILE1_GBLOCKSB
	.byte TILE1_BBLOCKSM, TILE1_BBLOCKSM, TILE1_BBLOCKSB, TILE1_BBLOCKSB

	; Shadowed big green bush
	.byte TILE1_BUSH_SUL,  TILE1_BUSH_SBL, TILE1_BUSH_SUR,  TILE1_BUSH_SBR
	.byte TILE1_BUSH_SFUL, TILE1_BUSH_SBL, TILE1_BUSH_SFUR, TILE1_BUSH_SBL	; Did they perhaps mean for TILE1_BUSH_SBR at the end there?

	.byte TILE1_BUSH_SBL

	;;;;;;;;;;;;;;;;;;

	.byte $00, $40, $80, $C0


	; This selects an offset to a particular color of block from LL_BigBlock_Top
LL_BigBlock_Top_ColorOff:	.byte 0, 3, 6, 9	; White, Orange, Green, Blue


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GenerateBigBlock
;
; This rather elaborate function is responsible for the 
; generation of the "big block" blocks seen in a Plains style
; level.  At the current 'cursor' position, and with a given
; width, it automatically generates the block down to the floor
; (so note that there must be a floor there!) and even adds
; an appropriate shadow, shading against the sky, bushes, or
; other big blocks.  Very clever and elaborate, but why not just
; store a tile grid instead of complex generator functions? :P
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_GenerateBigBlock:
	; From level loader function:
	; * Temp_Var15, Temp_Var16, and LL_ShapeDef are three bytes read from the data
	; * Map_Tile_AddrL/H points to starting block of Tile_Mem_Addr(V)
	; * Temp_Var5 = Map_Tile_AddrH + 0/1 (if not vertical, otherwise unassigned)
	; * Temp_Var6 = Map_Tile_AddrH
	; * TileAddr_Off = (Temp_Var15 << 4) | (Temp_Var16 & $f), offset within screen

	; Function is also input 'X', which is the index this arrived via, which in
	; this case is a value of 0 - 3

	STX <Temp_Var12		; Temp_Var12 = X

	; Backup the current Map_Tile_AddrL/H values into Temp_Var3/4
	LDA <Map_Tile_AddrL
	STA <Temp_Var3		; Temp_Var3 = Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	STA <Temp_Var4		; Temp_Var4 = Map_Tile_AddrH

	; Lower 4 bits of LL_ShapeDef specify the "width" of the block
	LDA LL_ShapeDef
	AND #%00001111
	STA <Temp_Var1		; Temp_Var1 = lower 4 bits of LL_ShapeDef

	LDX #$00		; X = 0 (left edge to start)
PRG014_D0A8:
	TXA		 	; A = X (0, 1, 2 for left, middle, right)

	; Temp_Var12: 0-3 (entrance index), selects a root color offset from LL_BigBlock_Top_ColorOff
	; Temp_Var13: Gets root color, so we get 0, 3, 6, 9
	LDX <Temp_Var12	 		
	ADD LL_BigBlock_Top_ColorOff,X	; Offset to specified color
	STA <Temp_Var13			; Temp_Var13 = LL_BigBlock_Top_ColorOff[X] --> 0, 3, 6, 9
	TAX		 		; X = Temp_Var13 

	LDA LL_ShapeDef
	AND #%11000000	 
	STA <Temp_Var2			; Temp_Var2 = just the upper 2 bits of LL_ShapeDef ($00, $40, $80, $C0)

	LDY TileAddr_Off		; Y = TileAddr_Off

	; This applies the top of a big block
	LDA LL_BigBlock_Top,X		; Get tile for this 'X' (X = 0, 4, 8, 12)
	STA [Map_Tile_AddrL],Y		; Store into the level

	; This loops middle blocks until it hits ground
PRG014_D0C1:
	JSR LoadLevel_TileMemNextRow	; Go to next row of tiles, directly beneath this one
	LDA [Map_Tile_AddrL],Y		; Get this tile from existing memory

	; If grabbed tile is TILE1_GROUNDTM (ground top middle) or TILE1_GROUNDTL (ground top left), jump to PRG014_D0D8
	CMP #TILE1_GROUNDTM
	BEQ PRG014_D0D8
	CMP #TILE1_GROUNDTL	
	BEQ PRG014_D0D8

	; Otherwise, there's no ground here; get middle block
	LDX <Temp_Var13		 	; X = Temp_Var13 (0, 3, 6, 9)
	LDA LL_BigBlock_Mid,X	 	; Get appropriate middle block
	STA [Map_Tile_AddrL],Y	 	; Store into TileMem
	JMP PRG014_D0C1	 		; Loop for more ground

PRG014_D0D8:

	; Move back one row of tiles
	; Subtracts 16 from 'Y', updating Map_Tile_AddrH if needed
	TYA	
	SUB #16	
	TAY	
	LDA <Map_Tile_AddrH
	SBC #$00	 
	STA <Map_Tile_AddrH

	; And put the bottom here!
	LDX <Temp_Var13		 
	LDA LL_BigBlock_Bot,X	 
	STA [Map_Tile_AddrL],Y	 

	; Restore the original Map_Tile_AddrL/H values
	LDA <Temp_Var3		 
	STA <Map_Tile_AddrL
	LDA <Temp_Var4		
	STA <Map_Tile_AddrH	

	LDY TileAddr_Off	; Y = TileAddr_Off
	INY		 	; Y++ (next column over)
	TYA		 	; A = Y
	AND #$0f	 	; Keep just the lower 4 bits (specific column)
	BNE PRG014_D11C	 	; If column 1-15, jump to PRG014_D11C

	; Otherwise, we've just crossed over into the next screen...
	LDA TileAddr_Off	
	AND #$f0	 
	TAY		 	; Y = TileAddr_Off & $F0 -- the specific "row" of tiles on this screen

	; Add $1B0 to address (go to next screen) and update Temp_Var3/4 backup
	LDA <Map_Tile_AddrL
	ADD #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var3	
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var4	

	STA <Temp_Var5		; Temp_Var5 = Map_Tile_AddrH

	LDA <Temp_Var15
	AND #$10	
	BNE PRG014_D11C		; If bit 4 of Temp_Var15 is set, jump to PRG014_D11C

	INC <Temp_Var5		; Otherwise, Temp_Var5 = Map_Tile_AddrH + 1

PRG014_D11C:
	STY TileAddr_Off	; Update TileAddr_Off

	DEC <Temp_Var1		; Temp_Var1-- (the width value)

	LDX #$01		; X = 1 (middle blocks)

	LDA <Temp_Var1
	CMP #$01	
	BGS PRG014_D12E	 	; If Temp_Var1 >= 1, jump to PRG014_D12E

	; Otherwise...
	INX			; X = 2 (right-edge blocks)

	; 6502 assembler-ism: we used a BGS (signed) comparison above, so
	; don't think we get here only when Temp_Var1 is 0; we also get
	; here when Temp_Var1 has fallen below zero, which makes it
	; "not zero" (it'd be clearer as a BMI, but whatever)
	CMP #$00	 
	BNE PRG014_D133	 	; If Temp_Var1 <> 0, jump to PRG014_D133

PRG014_D12E:
	STX <Temp_Var13		; Update Temp_Var13 with new edge value
	JMP PRG014_D0A8	 	; Loop around...


	; We're done forming the block!  Left/right/middle, top to bottom!  Whew!


	; Now the shadow...


	; ** Determine proper upper-right corner shadow!

PRG014_D133:
	LDA [Map_Tile_AddrL],Y	; Get tile at our current location

	CMP #TILE1_SKY
	BNE PRG014_D13E	 ; If tile is not sky, jump to PRG014_D13E

	; If there's sky here, plant the corner shadow
	LDA #TILE1_BLOCK_SHUR
	JMP PRG014_D14F	 ; Jump to PRG014_D14F

PRG014_D13E:
	; If not a bush tile, jump to PRG014_D14B
	CMP #TILE1_BUSH_UL
	BLT PRG014_D14B
	CMP #TILE1_BUSH_SBR
	BGE PRG014_D14B	 

	; Otherwise, put shadow on bush
	LDA #TILE1_BUSH_SHUR
	JMP PRG014_D14F	 ; Jump to PRG014_D14F

PRG014_D14B:
	; Not sky, not bush; assume we're shadowing another big block
	AND #$c0	 ; Keep color quadrant
	ORA #$0b	 ; Set to the shaded block tile

PRG014_D14F:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem


	; ** Generate right side shadow...

PRG014_D151:
	JSR LoadLevel_TileMemNextRow	; Go to next row

	LDA [Map_Tile_AddrL],Y	 ; Check this tile

	CMP #TILE1_GROUNDTM
	BEQ PRG014_D15E	 	; If tile is top-middle ground, jump to PRG014_D15E (RTS)

	CMP #TILE1_GROUNDTR
	BNE PRG014_D15F	 	; If tile is NOT top-right ground, jump to PRG014_D15F

PRG014_D15E:
	RTS		 ; Return


PRG014_D15F:
	LDX #(LL_BigBlock_EndShadowChks-LL_BigBlock_ShadowChks-1)

	; Searching for block corners to terminate shadow
	LDA [Map_Tile_AddrL],Y	 	; Get this tile
PRG014_D163:
	CMP LL_BigBlock_ShadowChks,X
	BEQ PRG014_D170	 		; If this tile equals a shadow stopper, jump to PRG014_D170
	DEX		 	; X--
	BPL PRG014_D163		; While X >= 0, loop!

	LDA #TILE1_BLOCK_SHADOW
	JMP PRG014_D173	

PRG014_D170:
	LDA LL_BigBlock_ApprShadow,X	; Get appropriate shading tile

PRG014_D173:
	STA [Map_Tile_AddrL],Y	 	; Store this shadow tile!
	JMP PRG014_D151	 		; Loop!

	; The LL_BigBlockSky arrays define, per color, the large
	; colored blocks that float in the sky, with predetermined
	; shadow effects and whatnot...

LL_BigBlockSky_Left:
	.byte TILE1_WBLOCKUL, TILE1_WBLOCKLL, TILE1_BLOCK_SHLL
	.byte TILE1_OBLOCKUL, TILE1_OBLOCKLL, TILE1_BLOCK_SHLL
	.byte TILE1_GBLOCKUL, TILE1_GBLOCKLL, TILE1_BLOCK_SHLL
	.byte TILE1_BBLOCKUL, TILE1_BBLOCKLL, TILE1_BLOCK_SHLL

LL_BigBlockSky_Middle:
	.byte TILE1_WBLOCKTH, TILE1_WBLOCKBH, TILE1_BLOCK_SHADOWB
	.byte TILE1_OBLOCKTH, TILE1_OBLOCKBH, TILE1_BLOCK_SHADOWB
	.byte TILE1_GBLOCKTH, TILE1_GBLOCKBH, TILE1_BLOCK_SHADOWB
	.byte TILE1_BBLOCKTH, TILE1_BBLOCKBH, TILE1_BLOCK_SHADOWB

LL_BigBlockSky_Right:
	.byte TILE1_WBLOCKUR, TILE1_WBLOCKLR, TILE1_BLOCK_SHADOWB
	.byte TILE1_OBLOCKUR, TILE1_OBLOCKLR, TILE1_BLOCK_SHADOWB
	.byte TILE1_GBLOCKUR, TILE1_GBLOCKLR, TILE1_BLOCK_SHADOWB
	.byte TILE1_BBLOCKUR, TILE1_BBLOCKLR, TILE1_BLOCK_SHADOWB

LL_BigBlockSky_Shadow:
	.byte TILE1_BLOCK_SHUR, TILE1_BLOCK_SHADOW, TILE1_BLOCK_SHLR
	.byte TILE1_BLOCK_SHUR, TILE1_BLOCK_SHADOW, TILE1_BLOCK_SHLR
	.byte TILE1_BLOCK_SHUR, TILE1_BLOCK_SHADOW, TILE1_BLOCK_SHLR
	.byte TILE1_BLOCK_SHUR, TILE1_BLOCK_SHADOW, TILE1_BLOCK_SHLR


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_FloatingBigBlock
;
; Not nearly as elaborate as its "big brother" above, this
; function generates a simple rectangular block that floats
; and has a shadow.  Still generated, though...
;
; Always of a constant height (2 x W) with shadow, no clever 
; shadow detection code.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_FloatingBigBlock:
	; From level loader function:
	; * Temp_Var15, Temp_Var16, and LL_ShapeDef are three bytes read from the data
	; * Map_Tile_AddrL/H points to starting block of Tile_Mem_Addr(V)
	; * TileAddr_Off = (Temp_Var15 << 4) | (Temp_Var16 & $f), offset within screen

	; Back up current Map_Tile_Addr into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	; LL_ShapeDef actually determines the color of the block... a slightly
	; uglier way to do this than just take the index we came in with,
	; like the "big brother" generator function did!
	LDA LL_ShapeDef
	SUB #$50
	PHA		; Push LL_ShapeDef - $50
	
	AND #$f0
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	STA <Temp_Var3	; Store upper 4 bits of result, shifted down by 4, into Temp_Var3

	; Temp_Var3 is now a value like the following, depending on what range 
	; LL_ShapeDef started at (the left number):
	; 00 = $B, 10 = $C, 20 = $D, 30 = $E, 40 = $F, 50 = $0, 60 = $1, 70 = $2,
	; 80 = $3, 90 = $4, A0 = $5, B0 = $6, C0 = $7, D0 = $8, E0 = $9, F0 = $A

	PLA		; Restore LL_ShapeDef - $50

	AND #$0f	; Previous subtraction makes no difference here; keeps the lower 4 bits of LL_ShapeDef
	STA <Temp_Var4	; ... into Temp_Var4 (stores original width)
	STA <Temp_Var6	; ... and Temp_Var6 (active decrementing width counter)

	LDA #$00	
	STA <Temp_Var5	; Temp_Var5 = 0 (loop counter)
PRG014_D1CA:
	LDX <Temp_Var3	; X = Temp_Var3

	; Offset loop counter with color value
	LDA <Temp_Var5	
	ADD LL_BigBlock_Top_ColorOff,X

	TAX		 	; X = A (colorized block)

	LDY TileAddr_Off		; Y = TileAddr_Off
	LDA LL_BigBlockSky_Left,X	; Get this block
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	; Move to next column

	DEC <Temp_Var6		 	; Temp_Var6--

PRG014_D1E0:
	LDA LL_BigBlockSky_Middle,X	; Get this block
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	; Move to next column

	DEC <Temp_Var6		 	; Temp_Var6--
	LDA <Temp_Var6		 
	CMP #$01
	BNE PRG014_D1E0	 		; If Temp_Var6 <> 1, loop!

	LDA LL_BigBlockSky_Right,X	; Get this block
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	; Move to next column

	LDA LL_BigBlockSky_Shadow,X	; Get this shadow block
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Restore original Map_Tile_AddrL/H
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go down to next row (+16 to TileAddr_Off with carry to Map_Tile_AddrH, if needed)
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	LDA <Temp_Var4
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var4 (restore original width value)

	INC <Temp_Var5		 ; Temp_Var5++
	LDA <Temp_Var5		 
	CMP #$03	 
	BNE PRG014_D1CA	 	 ; If Temp_Var5 <> 3, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_RandomPUpClouds
;
; Generates 60 random "power up" clouds in Plains style levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_PUPClouds:
	.byte TILE1_PUPCLOUD_M, TILE1_PUPCLOUD_F, TILE1_PUPCLOUD_S

LoadLevel_RandomPUpClouds:
	LDA #59
	STA Misc_Counter ; Generate 60 random power up clouds!

PRG014_D22B:
	JSR Randomize	 ; Seed the randomizer
	LDA RandomN	 ; Get a random number
	AND #$0f	 
	CMP #10 
	BLT PRG014_D23A	 ; If random number < 10, jump to PRG014_D23A (mod 9 essentially)

	SUB #9	 	; If random number was 10, subtract 9 

PRG014_D23A:
	STA <Temp_Var15	 ; Random number 0-9

	LDA RandomN+1	 ; Get another random number
	TAX		 ; -> 'X'

	AND #$f0
	CMP #$f0
	BNE PRG014_D24B	 ; If the upper 4 bits are not all set, jump to PRG014_D24B

	; Otherwise, X += $20 (random 0 to $EF)
	TXA
	ADD #$20
	TAX	

PRG014_D24B:
	STX <Temp_Var16	 ; Temp_Var16 = 'X'

	TXA		 
	AND #$03	 
	CMP #$03	 
	BNE PRG014_D257	 ; If this random value is not 3, jump to PRG014_D257 (mod 3 essentially)

	; Otherwise, if 3, subtract 2 (make 0)
	SUB #2

PRG014_D257:
	PHA		 ; Save 'A' (Random value of 0-2)
	JSR LoadLevel_Set_TileMemAddr	 ; Set tile address
	PLA		 ; Restore 'A'

	TAX		 ; Get random 0-2 value

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_PUPClouds,X	 ; Get random power up cloud!
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	DEC Misc_Counter	 ; Misc_Counter--
	BPL PRG014_D22B	 	; While Misc_Counter >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VineToGround
;
; Constructs a vine from its starting point continuing downward
; until it hits any "not sky" tile
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VineToGround:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG014_D26E:
	LDA [Map_Tile_AddrL],Y	; Grab this tile
	CMP #TILE1_SKY	
	BEQ PRG014_D278	 	; If this is a sky tile jump to PRG014_D278

	; SB: Support vine-to-ground in Underwater
	LDX Level_Tileset
	CPX #6
	BNE LLV2G_NotWater		; If tileset <> 6 (Underwater), jump to LLV2G_NotWater

	CMP #TILE6_SKY
	BEQ PRG014_D278		; If this is a Underwater-world sky tile, jump to PRG014_D278
	
LLV2G_NotWater:
	; SB: Support vine-to-ground in Sky world
	LDX Level_Tileset
	CPX #13
	BNE PRG014_D282		; If tileset <> 13 (Sky), jump to PRG014_D282 (RTS)

	; Sky could have a couple other valid tiles...
	CMP #TILE13_CLOUD	; General white cloud filler
	BEQ PRG014_D278	 	; If this is a cloud tile jump to PRG014_D278

	CMP #TILE13_SKY
	BNE PRG014_D282		; If not a Sky-world sky tile, jump to PRG014_D282 (RTS)

PRG014_D278:
	LDA #TILE1_VINE	 
	STA [Map_Tile_AddrL],Y		; Put a vine tile here
	JSR LoadLevel_TileMemNextRow	; Go to next row
	JMP PRG014_D26E	 ; Jump to PRG014_D26E

PRG014_D282:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LittleBushRun
;
; Puts down 1-16 of those cute little bushes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LittleBushRun:
	LDA LL_ShapeDef
	AND #$0f	 
	TAX		 ; X = lower 4 bits of LL_ShapeDef
	LDY TileAddr_Off ; Y = TileAddr_Off

PRG014_D28C:
	LDA #TILE1_LITTLE_BUSH
	STA [Map_Tile_AddrL],Y	 	; Put the little bush here
	JSR LoadLevel_NextColumn	; Next column
	DEX		 		; X--
	BPL PRG014_D28C	 		; While X >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Pitfall / LoadLevel_PitfallW
;
; Generates a pitfall along the ground, automatically adding
; the appropriate edge tiles on each side...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Pitfall:
	LDX #$00	 ; X = 0 (above ground tiles)
	BEQ PRG014_D2A9	 ; Jump (technically always) to PRG014_D2A9

LL_RightEdge:
	.byte TILE1_GROUNDTR,  TILE1_GROUNDMR	; Top and middle of ground, right edge
	.byte TILE1_WGROUNDTR, TILE1_WGROUNDMR	; Top and middle of underwater ground, right edge

LL_PitTile:
	.byte TILE1_SKY,       TILE1_SKY	; Associated pit tile for the ground (sky)
	.byte TILE1_WATER,     TILE1_WATER	; Associated pit tile for the underwater ground (water)

LL_LeftEdge:
	.byte TILE1_GROUNDTL,  TILE1_GROUNDML	; Top and middle of ground, left edge
	.byte TILE1_WGROUNDTL, TILE1_WGROUNDML	; Top and middle of underwater ground, left edge

LoadLevel_PitfallW:
	LDX #$02		; X = 2 (underwater tiles instead)

PRG014_D2A9:

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = the lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	; Y = TileAddr_Off

PRG014_D2BB:
	LDA <Temp_Var3
	STA <Temp_Var4		; Temp_Var4 = Temp_Var3 (store original width)

	; Right edge of the ground, beginning of pitfall
	LDA LL_RightEdge,X	; Get this tile
	STA [Map_Tile_AddrL],Y	; Store in tile mem
	JMP PRG014_D2CC		; Jump to PRG014_D2CC

	; Process run of tiles appropriate to the surface (sky or water)
PRG014_D2C7:
	LDA LL_PitTile,X	; Get this pit tile
	STA [Map_Tile_AddrL],Y	; Store in tile mem

PRG014_D2CC:
	JSR LoadLevel_NextColumn ; Go to next column
	DEC <Temp_Var4		 ; Temp_Var4-- (active width counter
	BNE PRG014_D2C7	 	 ; If Temp_Var4 <> 0, loop!

	; Left edge of ground, end of pitfall
	LDA LL_LeftEdge,X	 
	STA [Map_Tile_AddrL],Y	 

	; Restore Map_Tile_AddrL/H from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next offset row by adding 16, carry to Map_Tile_AddrH if needed...
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		; Update the backup Temp_Var2

	INX		 ; X++ (next do mid-ground)

	CPY #$b0	 
	BLT PRG014_D2BB	 ; If Y < $B0, loop!  ($B0 would be the beyond end of screen)

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GroundRun
;
; Puts down 1-255 tiles worth of ground.  Unlike other run
; functions, this does not use the limited lower 4 bits of
; LL_ShapeDef (in fact, does not use it at all), but instead
; grabs another byte from the layout stream and uses that as
; the width value, so this can stretch pretty far!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Ground top left/middle/right or underwater ground left/middle/right
LL_RunGroundTop:	
	.byte TILE1_GROUNDTL,  TILE1_GROUNDTM,  TILE1_GROUNDTR
	.byte TILE1_WGROUNDTL, TILE1_WGROUNDTM, TILE1_WGROUNDTR

	; Ground middle left/middle/right or underwater ground middle left/middle/right
LL_RunGroundMid:
	.byte TILE1_GROUNDML,  TILE1_GROUNDMM,  TILE1_GROUNDMR
	.byte TILE1_WGROUNDML, TILE1_WGROUNDMM, TILE1_WGROUNDMR

LL_RunGround_Offset:
	.byte 0, 3	; Solid ground, solid underwater ground

LoadLevel_GroundRun:
	LDY #$00	 ; Y = 0

	LDA [Level_LayPtr_AddrL],Y
	STA <Temp_Var3		 ; Get next byte from layout -> Temp_Var3 (width of run)

	; Level_LayPtr_Addr += 1
	LDA <Level_LayPtr_AddrL
	ADD #$01	 
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	 
	PHA		 ; Push LL_ShapeDef

	; In short, Y = 0 or 1, depending on whether we were called by index 11 or 12
	SUB #$c0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAY		

	LDX LL_RunGround_Offset,Y	; X = 0 or 3 (solid or underwater solid)
	PLA		 	; Restore LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var4		; Temp_Var4 = lower 4 bits of LL_ShapeDef (width of run)

	LDA <Temp_Var3		; Byte retrieved from stream 
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 (save original width)

	LDY TileAddr_Off	; Y = TileAddr_Off

	; Left edge of ground
	LDA LL_RunGroundTop,X	; Get next ground tile
	STA [Map_Tile_AddrL],Y	; Store into tile mem

	JSR LoadLevel_NextColumn ; Go to next column

	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BEQ PRG014_D354	 	 ; If Temp_Var5 = 0, jump to PRG014_D354

	; Middle ground
PRG014_D348:
	LDA LL_RunGroundTop+1,X	 ; Get middle of ground
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Go to next column

	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG014_D348	 	 ; While Temp_Var5 <> 0, loop!

PRG014_D354:

	; Right edge of ground
	LDA LL_RunGroundTop+2,X	 ; Get right edge
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

LL_GroundRun_Loop:
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 and updating Map_Tile_AddrH if carried
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	LDA <Temp_Var4		 ; Temp_Var4--
	BEQ PRG014_D398	 	 ; If Temp_Var4 < 0, jump to PRG014_D398 (RTS)

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3 (restore original width)

	; Left middle edge
	LDA LL_RunGroundMid,X	 ; Get left edge
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Go to next column
	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BEQ PRG014_D393	 	; If Temp_Var5 = 0, jump to PRG014_D393

PRG014_D387:
	; Middle middle 
	LDA LL_RunGroundMid+1,X	 ; Get middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Go to next column
	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BNE PRG014_D387	 	; While Temp_Var5 <> 0, loop!

PRG014_D393:
	; Right middle edge
	LDA LL_RunGroundMid+2,X	 ; Get right edge
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_D398:
	DEC <Temp_Var4		 ; Temp_Var4--
	BPL LL_GroundRun_Loop	 	 ; While Temp_Var4 >= 0, LL_GroundRun_Loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_CloudRun
;
; Puts down a run of the big clouds, repeating the middle for
; the run in a strange fashion...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Cloud:
	.byte TILE1_CLOUD_UL, TILE1_CLOUD_LL, TILE1_CLOUD_UM, TILE1_CLOUD_LM, TILE1_CLOUD_UR, TILE1_CLOUD_LR

LoadLevel_CloudRun:

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	; Y = TileAddr_Off
	LDX #$00	 	; X = 0

PRG014_D3B3:
	LDA <Temp_Var3
	STA <Temp_Var4		; Temp_Var4 = Temp_Var3 (backup original width)

	LDA LL_Cloud,X	 	; Get left edge of cloud
	JMP PRG014_D3C0	 	; Jump to PRG014_D3C0

PRG014_D3BD:
	LDA LL_Cloud+2,X	; Get middle of cloud

PRG014_D3C0:
	STA [Map_Tile_AddrL],Y	; Store this into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4--
	BNE PRG014_D3BD	 	; If Temp_Var4 <> 0, loop!

	LDA LL_Cloud+4,X	 ; Get right edge of cloud
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Next row by adding 16 and updating Map_Tile_AddrH if carry
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2	 ; Update Map_Tile_AddrH backup

	INX		 ; X++
	CPX #$02	 
	BNE PRG014_D3B3	 ; If X <> 2, loop!

	RTS		 ; Return


LoadLevel_TileMemNextRow:
	; Y = TileAddr_Off

	TYA	
	ADD #16
	TAY		 ; Y += 16

	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Corner
;
; Places a single corner tile in sloped levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_Corners:
	.byte TILE14_ABOVE_CORNER_UL, TILE3_ULCORNERGROUND, TILE3_WCORNER_UL	; Upper left
	.byte TILE14_ABOVE_CORNER_UR, TILE3_URCORNERGROUND, TILE3_WCORNER_UR	; Upper right
	.byte TILE14_ABOVE_CORNER_LL, TILE3_LLCORNERGROUND, TILE3_WCORNER_LL	; Lower left (not avail AG) 
	.byte TILE14_ABOVE_CORNER_LR, TILE3_LRCORNERGROUND, TILE3_WCORNER_LR	; Lower right (not avail AG) 

LoadLevel_Corner:
	LDX LL_ShapeDef	 	; LL_ShapeDef is limited 0-15 because of fixed size gen mode, so it's perfect! 
	LDY TileAddr_Off	; Y = TileAddr_Off
	LDA LL_Corners,X	 ; Get corner tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope45T2B
;
; Adds a 1-16 length 45 degree top-to-bottom slope.  With each
; iteration, it adds one more "midground" tile to the left of the
; slope.  So it looks like this:
; \
; M\
; MM\
; MMM\  ... and so on
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_SlopeMidGround:	.byte TILE14_ABOVE_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND		; Middle ground
LL_45SlopesT2B:		.byte TILE14_ABOVE_SLOPE45T2B, TILE3_SLOPE45T2B,  TILE3_WSLOPE45T2B	; 45 degree ground slopes top-to-bottom
LL_45SlopesB2T:		.byte TILE14_ABOVE_SLOPE45B2T, TILE3_SLOPE45B2T,  TILE3_WSLOPE45B2T	; 45 degree ground slopes bottom-to-top
LL_45SlopesT2BCeiling:	.byte TILE14_ABOVE_S45T2B_CEIL, TILE14_SLOPE45T2B_CEIL, TILE14_WSLOPE45T2B_CEIL		; 45 degree ceiling slopes top-to-bottom (not avail Above Ground)
LL_45SlopesB2TCeiling:	.byte TILE14_ABOVE_S45B2T_CEIL, TILE14_SLOPE45B2T_CEIL, TILE14_WSLOPE45B2T_CEIL		; 45 degree ceiling sloeps bottom-to-top (not avail Above Ground)


LoadLevel_Slope45T2B:	
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$00
	STA <Temp_Var3	; Temp_Var3 = 0 (each additional slope tile we add is followed by +1 midground tiles behind it)

	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef	

	AND #$0f	 
	STA <Temp_Var4	 ; Temp_Var4 = lower 4 bits of LL_ShapeDef (diagonal length of slope)

	PLA		 ; Restore LL_ShapeDef
	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = Relative index 

PRG014_D482:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 
	BEQ PRG014_D497	 	; If Temp_Var3 is zero, we skip the middle ground addition

PRG014_D48B:
	LDA LL_SlopeMidGround,X	 ; Get middle ground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG014_D48B	 	 ; While Temp_Var5 > 0, loop! 

PRG014_D497:
	LDA LL_45SlopesT2B,X	 ; Get the 45 degree slope
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	INC <Temp_Var3		 ; Temp_Var3++ (one more midground behind the slope)
	DEC <Temp_Var4		 ; Temp_Var4-- (diagonal length decrement)
	BPL PRG014_D482	 	; While Temp_Var4 >= 0, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope45B2T
;
; Adds a 1-16 length 45 degree bottom-to-top slope.  With each
; iteration, it adds one more "midground" tile to the right of
; the slope.  So it looks like this:
;    /
;   /M
;  /MM
; /MMM  ... and so on
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Slope45B2T:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$00
	STA <Temp_Var3	; Temp_Var3 = 0 (each additional slope tile we add is followed by +1 midground tiles behind it)

	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef	

	AND #$0f	 
	STA <Temp_Var4	 ; Temp_Var4 = lower 4 bits of LL_ShapeDef (diagonal length of slope)

	PLA		 ; Restore LL_ShapeDef
	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = Relative index 

PRG014_D4DB:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 

	LDA LL_45SlopesB2T,X	 ; Get slope tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_D4EF	 	; Jump to PRG014_D4EF

PRG014_D4EA:
	LDA LL_SlopeMidGround,X	 ; Get mid-ground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_D4EF:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5--
	BPL PRG014_D4EA	 	 ; While Temp_Var5 >= 0, loop!

	INC <Temp_Var3		 ; Temp_Var3++ (one more midground behind the slope)


	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 15 to tile offset (we're always one column too far..)
	LDA TileAddr_Off
	ADD #15
	TAY		 
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	TYA
	AND #$0f
	CMP #$0f	
	BNE PRG014_D534	 	; If we haven't wrapped the screen, jump to PRG014_D534

	; Move back one screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0	
	STA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	SBC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	; Jump to the right side
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

PRG014_D534:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	DEC <Temp_Var4		 ; Temp_Var4-- (diagonal length decrement)
	BPL PRG014_D4DB	 	; While Temp_Var4 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope45T2BCeiling
;
; Adds a 1-16 length 45 degree bottom-to-top slope along the 
; ceiling.  Each row packs midground tiles along the length.
; So it looks like this:
; \MMM
;  \MM
;   \M
;    \
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Slope45T2BCeiling:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	


	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef	

	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (diagonal length of slope)

	PLA		 ; Restore LL_ShapeDef
	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = Relative index 

PRG014_D557:
	LDY TileAddr_Off	 	; Y = TileAddr_Off
	LDA <Temp_Var3		 	
	STA <Temp_Var5		 	; Temp_Var3 = Temp_Var5 (next padding length)

	LDA LL_45SlopesT2BCeiling,X	; Get ceiling slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JMP PRG014_D56B	 		; Jump to PRG014_D56B

PRG014_D566:
	LDA LL_SlopeMidGround,X	 	; Get midground tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

PRG014_D56B:
	JSR LoadLevel_NextColumn	; Next column
	DEC <Temp_Var5		 	; Temp_Var5--
	BPL PRG014_D566	 		; While Temp_Var5 >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH


	INY
	TYA
	AND #$0f
	BNE PRG014_D5A5	 	; If we haven't wrapped the screen, jump to PRG014_D534

	; Move forward one screen by adding $1B0
	LDA <Map_Tile_AddrL
	ADD #$b0	
	STA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	DEY
	TYA
	AND #$f0
	TAY	

PRG014_D5A5:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	DEC <Temp_Var3		 ; Temp_Var3-- (diagonal length decrement, decreasing padding)
	BPL PRG014_D557	 	; While Temp_Var3 >= 0, loop!
	RTS		 ; Return




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope45B2TCeiling
;
; Adds a 1-16 length 45 degree bottom-to-top slope along the 
; ceiling.  Each row packs midground tiles along the length.
; So it looks like this:
; MMM/
; MM/ 
; M/  
; /   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Slope45B2TCeiling:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	


	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef	

	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (diagonal length of slope)

	PLA		 ; Restore LL_ShapeDef
	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = Relative index 

PRG014_D5C8:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA <Temp_Var3
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 
	BEQ PRG014_D5DD	 	; If Temp_Var3 is zero, we skip the middle ground addition

PRG041_D5D1:
	LDA LL_SlopeMidGround,X	 ; Get midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG041_D5D1	 	; While Temp_Var5 > 0, loop!

PRG014_D5DD:
	LDA LL_45SlopesB2TCeiling,X	; Get ceiling slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup
	DEC <Temp_Var3		 ; Temp_Var3-- (diagonal length decrement)
	BPL PRG014_D5C8	 	; While Temp_Var3 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope225T2B
;
; Adds a 1-16 length 22.5 degree top-to-bottom slope.  With each
; iteration, it adds two more "midground" tile to the left of the
; slope.  So it looks like this:
; --
; MM--
; MMMM--
; MMMMMM--
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_225SlopesT2B_Upper:	.byte TILE14_ABOVE_SLOPE225T2B_U, TILE3_SLOPE225T2B_U, TILE3_WSLOPE225T2B_U
LL_225SlopesT2B_Lower:	.byte TILE14_ABOVE_SLOPE225T2B_L, TILE3_SLOPE225T2B_L, TILE3_WSLOPE225T2B_L

LoadLevel_Slope225T2B:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$00
	STA <Temp_Var3		; Temp_Var3 = 0

	LDA LL_ShapeDef	 
	PHA		 	; Save LL_ShapeDef

	AND #$0f	 
	STA <Temp_Var4		; Temp_Var4 = lower 4 bits of LL_ShapeDef (diagonal length of run)

	PLA		 	; Restore LL_ShapeDef

	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = relative index

PRG014_D625:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3
	BEQ PRG014_D642	 	; If Temp_Var3 is currently zero, skip the midground tiles

	; Midground tiles behind slope
PRG014_D62E:
	LDA LL_SlopeMidGround,X	 ; Get midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	LDA LL_SlopeMidGround,X	 ; Get midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG014_D62E	 	; While Temp_Var5

PRG014_D642:
	LDA LL_225SlopesT2B_Upper,X 	; Get proper slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	; Next column

	LDA LL_225SlopesT2B_Lower,X	; Get proper slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	INC <Temp_Var3		 ; Temp_Var3++ (midground tile increment)
	DEC <Temp_Var4		 ; Temp_Var4-- (diagonal length decrement)
	BPL PRG014_D625	 	; While Temp_Var4 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope225B2T
;
; Adds a 1-16 length 22.5 degree top-to-bottom slope.  With each
; iteration, it adds two more "midground" tile to the right of the
; slope.  So it looks like this:
;       --
;     --MM
;   --MMMM
; --MMMMMM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_225SlopesB2T_Upper:	.byte TILE14_ABOVE_SLOPE225B2T_L, TILE3_SLOPE225B2T_L, TILE3_WSLOPE225B2T_L
LL_225SlopesB2T_Lower:	.byte TILE14_ABOVE_SLOPE225B2T_U, TILE3_SLOPE225B2T_U, TILE3_WSLOPE225B2T_U

LoadLevel_Slope225B2T:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$00
	STA <Temp_Var3		; Temp_Var3 = 0

	LDA LL_ShapeDef	 
	PHA		 	; Save LL_ShapeDef

	AND #$0f	 
	STA <Temp_Var4		; Temp_Var4 = lower 4 bits of LL_ShapeDef (diagonal length of run)

	PLA		 	; Restore LL_ShapeDef

	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = relative index

PRG014_D694:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3

	LDA LL_225SlopesB2T_Upper,X	; Get slope tile
	STA [Map_Tile_AddrL],Y		; Store into tile mem
	JSR LoadLevel_NextColumn	; Next column
	LDA LL_225SlopesB2T_Lower,X	; Get slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JMP PRG014_D6B8	 		; Jump to PRG014_D6B8

PRG014_D6AB:
	LDA LL_SlopeMidGround,X	 	; Get midground tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	; Next column
	LDA LL_SlopeMidGround,X	 	; Get midground tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

PRG014_D6B8:
	JSR LoadLevel_NextColumn	; Next column
	DEC <Temp_Var5		 	; Temp_Var5--
	BPL PRG014_D6AB	 		; While Temp_Var5 >= 0, loop!


	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 14 to tile offset (always over by 2)
	LDA TileAddr_Off
	ADD #14
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	TYA		
	AND #$0f	
	CMP #14
	BLT PRG014_D6F9	 	; If we haven't crossed the screen, jump to PRG014_D6F9

	; Move back one screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	SBC #$01	
	STA <Map_Tile_AddrH

	; Jump to the right side
	TYA	
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2	

PRG014_D6F9:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	INC <Temp_Var3		 ; Temp_Var3++ (midground padding increment)
	DEC <Temp_Var4		 ; Temp_Var4-- (diagonal length decrement)
	BPL PRG014_D694	 	; While Temp_Var4 >= 0, loop!
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope225T2BCeiling
;
; Adds a 1-16 length 22.5 degree top-to-bottom slope along the 
; ceiling.  Each row packs midground tiles along the length.
; So it looks like this:
; --MMMMMM
;   --MMMM
;     --MM
;       --
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
	; This ceiling is not available Above Ground
LL_225SlopesT2B_LowerCeiling:	.byte TILE14_ABOVE_S225T2B_L_CEIL, TILE14_SLOPE225T2B_L_CEIL, TILE14_WSLOPE225T2B_L_CEIL
LL_225SlopesT2B_UpperCeiling:	.byte TILE14_ABOVE_S225T2B_U_CEIL, TILE14_SLOPE225T2B_U_CEIL, TILE14_WSLOPE225T2B_U_CEIL

LoadLevel_Slope225T2BCeiling:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	 
	PHA		 	; Save LL_ShapeDef

	AND #$0f	 
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (diagonal length of run)

	PLA		 	; Restore LL_ShapeDef

	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = relative index


PRG014_D724:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3

	LDA LL_225SlopesT2B_LowerCeiling,X	; Get slope tile
	STA [Map_Tile_AddrL],Y		; Store into tile mem
	JSR LoadLevel_NextColumn	; Next column
	LDA LL_225SlopesT2B_UpperCeiling,X	; Get slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JMP PRG014_D748	 		; Jump to PRG014_D748

PRG014_D73B:
	LDA LL_SlopeMidGround,X	 ; Get proper midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	LDA LL_SlopeMidGround,X	 ; Get proper midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_D748:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5--
	BPL PRG014_D73B	 ; While Temp_Var5 >= 0, loop

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDA TileAddr_Off

	; Go to next row
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	INY		 
	INY		 
	TYA		 
	AND #$0f	 
	CMP #$02	 
	BGE PRG014_D786	 ; If not crossing screen edge, jump to PRG014_D786

	; Go to next screen by adding $1B0 
	LDA <Map_Tile_AddrL
	ADD #$b0
	STA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	ADC #$01
	STA <Map_Tile_AddrH
	STA <Temp_Var2	

	DEY	
	DEY	
	TYA	
	AND #$f1
	TAY	

PRG014_D786:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_D724	 	; While Temp_Var3 >= 0, loop
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope225B2TCeiling
;
; Adds a 1-16 length 22.5 degree bottom-to-top slope along the 
; ceiling.  Each row packs midground tiles along the length.
; So it looks like this:
; MMMMMM--
; MMMM--
; MM--
; --
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_225SlopesB2T_UpperCeiling:	.byte TILE14_ABOVE_S225B2T_U_CEIL, TILE14_SLOPE225B2T_U_CEIL, TILE14_WSLOPE225B2T_U_CEIL
LL_225SlopesB2T_LowerCeiling:	.byte TILE14_ABOVE_S225B2T_L_CEIL, TILE14_SLOPE225B2T_L_CEIL, TILE14_WSLOPE225B2T_L_CEIL

LoadLevel_Slope225B2TCeiling:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	 
	PHA		 	; Save LL_ShapeDef

	AND #$0f	 
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (diagonal length of run)

	PLA		 	; Restore LL_ShapeDef

	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = relative index

PRG014_D7AF:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3
	BEQ PRG014_D7CC	 ; If Temp_Var3 = 0, jump to  PRG014_D7CC

PRG014_D7B8:
	LDA LL_SlopeMidGround,X	 ; Get proper midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	LDA LL_SlopeMidGround,X	 ; Get proper midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG014_D7B8	 	; While Temp_Var5 >= 0, loop!

PRG014_D7CC:
	LDA LL_225SlopesB2T_UpperCeiling,X	; Get ceiling slope tile
	STA [Map_Tile_AddrL],Y	 		; Store into tile mem
	JSR LoadLevel_NextColumn 		; Next column
	LDA LL_225SlopesB2T_LowerCeiling,X	; Get ceiling slope tile
	STA [Map_Tile_AddrL],Y	 		; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_D7AF	 	; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VertGroundL
;
; Adds a vertical 1-16 run of left vertical edge tiles for sloped levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_VertGroundL:	.byte TILE14_ABOVE_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL
LL_VertGroundR:	.byte TILE14_ABOVE_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR

LoadLevel_VertGroundL:
	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var1	 ; Temp_Var1 = lower 4 bits of LL_ShapeDef

	PLA		 ; Restore LL_ShapeDef

	SUB #$d0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	LDY TileAddr_Off 	; Y = TileAddr_Off
PRG014_D811:
	LDA LL_VertGroundL,X	; Get vertical ground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	DEC <Temp_Var1		 ; Temp_Var1--
	BPL PRG014_D811	 	; While Temp_Var1 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VertGroundR
;
; Adds a vertical 1-16 run of right vertical edge tiles for sloped levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VertGroundR:
	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var1	 ; Temp_Var1 = lower 4 bits of LL_ShapeDef

	PLA		 ; Restore LL_ShapeDef

	SUB #$d0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ADD #3		; switches to the left edge tiles
	TAX		 ; X = relative index
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	JMP PRG014_D811	 ; Jump to PRG014_D811


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DecoGround
;
; Adds a rectangle (width 1-256 / height 1-16) of "deocrated
; ground" (in sloped levels) which can be the horizontal top
; applied with middle ground beneath it, or it's all just 
; middle ground (depending on index supplied)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_DecoGroundTop:
	.byte TILE14_ABOVE_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND		; All midground
	.byte TILE14_ABOVE_HORZGROUND, TILE3_HORZGROUND, TILE3_WHORZGROUND	; Topped by horizontal ground

LL_DecoGroundMid:
	.byte TILE14_ABOVE_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND		; All midground
	.byte TILE14_ABOVE_MIDGROUND, TILE3_MIDGROUND, TILE3_WMIDGROUND		; Topped by horizontal ground

LoadLevel_DecoGround:
	LDY #$00	 ; Y = 0
	LDA [Level_LayPtr_AddrL],Y	 ; Get another byte from the layout stream
	STA <Temp_Var3		 	; Store into Temp_Var3 (width of rectangle)

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	AND #$0f
	STA <Temp_Var5	; Temp_Var5 = lower 4 bits of LL_ShapeDef (height of rectangle)

	PLA		 ; Restore LL_ShapeDef

	SUB #$40
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

PRG014_D87F:
	LDA LL_DecoGroundTop,X	 ; Get top ground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	LDA <Temp_Var4		 
	CMP #$ff	 
	BNE PRG014_D87F	 	; While Temp_Var4 >= 0, loop

	JMP PRG014_D8A2	 	; Jump to PRG014_D8A2

PRG014_D892:
	LDA LL_DecoGroundMid,X	 ; Get midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	LDA <Temp_Var4	
	CMP #$ff
	BNE PRG014_D892	 	; While Temp_Var4 >= 0, loop!

PRG014_D8A2:

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	LDA <Temp_Var3		 
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

	DEC <Temp_Var5		 ; Temp_Var5-- (height decrement)
	BPL PRG014_D892	 	; While Temp_Var5 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DecoCeiling
;
; Adds a rectangle (width 1-256 / height 1-16) of "deocrated
; ceiling" (in sloped levels) which is the ceiling
; applied with middle ground above it
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_DecoCeilingMid:	.byte TILE14_ABOVE_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
LL_DecoCeiling:		.byte TILE14_ABOVE_CEILING, TILE3_CEILING, TILE3_WCEILING

LoadLevel_DecoCeiling:
	LDY #$00	 		; Y = 0
	LDA [Level_LayPtr_AddrL],Y	; Get byte from layout stream
	STA <Temp_Var3		 	; Store it into Temp_Var3 (width of rectangle)

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef	
	SUB #$a0	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 ; X = relative index

	LDA LL_ShapeDef	 
	AND #$0f	 
	STA <Temp_Var5		; Temp_Var5 = lower 4 bits of LL_ShapeDef (height of rectangle)

PRG014_D8F8:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA <Temp_Var5
	BEQ PRG014_D937	 	; If Temp_Var5 = 0, jump to PRG014_D937 (skip the middle ground portion)

PRG014_D903:
	LDA LL_DecoCeilingMid,X	 ; Get the midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	LDA <Temp_Var4		 
	CMP #$ff	
	BNE PRG014_D903	 	; While Temp_Var4 >= 0, loop!

	; Restore Map_Tile_Addr from backup 
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Move ahead one row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	DEC <Temp_Var5		; Temp_Var5-- (height decrement)
	BNE PRG014_D8F8	 	; While Temp_Var5 >= 0, loop

	LDA <Temp_Var3
	STA <Temp_Var4		; Temp_Var4 = Temp_Var3 (width copy)
	LDY TileAddr_Off	; Y = TileAddr_Off

PRG014_D937:
	LDA LL_DecoCeiling,X	 ; Get ceiling tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	LDA <Temp_Var4
	CMP #$ff	
	BNE PRG014_D937	 	; While Temp_Var4 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGOrWater
;
; SB: I was wrong about this originally, it doesn't work "upside
; down", but I made it work upside down because I have use for
; Galaxy World that way...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Column order is Above Ground (this one's OK in non-UG), Underground/Hills normal, Underwater
LL_BGTop:	.byte TILE3_SKY, TILE3_UNDERGROUND, TILE3_WATER, TILE3_UD_WATER
LL_BGMid:	.byte TILE3_SKY, TILE3_UNDERGROUND, TILE3_WATER, TILE3_WATER

LoadLevel_UD_Water:
	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	LDX #3	; Upside-down water

	BNE LL_BGOrWaterForceEntry

LoadLevel_BGOrWater:
	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	SUB #$10	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 ; Relative index

LL_BGOrWaterForceEntry:
	LDY #$00	 ; Y = 0
	LDA [Level_LayPtr_AddrL],Y	 ; Get another byte from the layout stream
	STA <Temp_Var3		 	; Store into Temp_Var3 (width of rectangle)

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	PLA		 ; Restore LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var4	 ; Temp_Var4 = lower 4 bits of LL_ShapeDef (height of rectangle)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3	
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3 (width copy)

	LDA <Temp_Var4		
	BEQ PRG014_D985	 	; If Temp_Var4 (height) = 0, jump to PRG014_D99F (ONLY use "Top" tile)

PRG014_D99F:
	LDA LL_BGMid,X	 	; Get mid tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5-- (height decrement)
	BPL PRG014_D99F	 	; While Temp_Var5 >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	DEC <Temp_Var4		 ; Temp_Var4-- (height decrement)
	BNE PRG014_D99F	 	; While Temp_Var4 >= 0, loop!

PRG014_D985:
	LDA LL_BGTop,X	 	; Get top tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	LDA <Temp_Var5		
	CMP #$ff
	BNE PRG014_D985	 	; While Temp_Var5 >= 0, loop!

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Nothing
;
; Fixed size generator in sloped level that does ... nothing!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Nothing:

	; SB: In case I hit this trap because I'm a moron, play music...
	LDA #MUS2A_BONUSGAME
	STA Sound_QMusic2
.fixme: JMP .fixme

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_FillBackground
;
; Fills a large area of the background with sky, underground
; speckle and (FIXME? TILE3_UNK), e.g. used in 1-5
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG014_D9CA:
	.byte TILE15_SKY, TILE3_SKY, TILE3_UNDERGROUND, TILE14_BLACKBG

LLFB_IceBlack:
	.byte TILE12_BGBLACK

LoadLevel_FillIceBGBlack:
	LDX #(LLFB_IceBlack - PRG014_D9CA)
	BNE LLFB_IceEntry

LoadLevel_FillBackground:
	LDA LL_ShapeDef	 
	SUB #$0c	 
	TAX		 ; X = relative index

LLFB_IceEntry:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; The lower 5 bits of Temp_Var15 are whatever in fixed size gen...

	LDA <Temp_Var15	 
	AND #$10	 
	BNE PRG014_D9E1	 ; If bit 4 of Temp_Var15 is set, jump to PRG014_D9E1

	; Otherwise...
	CPY #$c0	  
	BLT PRG014_D9E9	 ; If Y < $C0 (end of screen), jump to PRG014_D9E9

PRG014_D9E1:
	TYA	
	SUB #$c0
	TAY	
	JMP PRG014_D9F3	 ; Jump to PRG014_D9F3

PRG014_D9E9:
	LDA PRG014_D9CA,X
	JSR Tile_Mem_ClearA
	CPY #$00	 
	BNE PRG014_D9E9	 

PRG014_D9F3:
	LDA PRG014_D9CA,X
	JSR Tile_Mem_ClearB
	INY		 
	CPY #$f0	 
	BNE PRG014_D9F3	 

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGBush
;
; Adds a 1-16 run of the little "background bushes" (left, run in
; the middle, right edge)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BGBush:
	LDA LL_ShapeDef	 
	AND #$0f	 
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA #TILE3_BGBUSH_L	 ; Left edge of background bush
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_DA8A	 	; Jump to PRG014_DA8A

PRG014_DA86:
	LDA #TILE3_BGBUSH_M	 ; Middle bush
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_DA8A:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BNE PRG014_DA86	 	 ; While Temp_Var3 >= 0, loop!

	LDA #TILE3_BGBUSH_R	 ; Right edge of bush
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Tunnel
;
; Adds a 1-16 run of the "tunnel" tiles that appear beneath some
; grassy hills in a Hills style level.
;
; Note: Apparently at one time, the alternate diamond block seen
; in some W3 levels was to be an option, but for some reason they
; explicitly disabled it... wonder why?
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Tunnel:
	.byte TILE3_TUNNEL
	.byte TILE3_ALTDIAMOND	; listed but not actually usable!

LoadLevel_Tunnel:
	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef

	SUB #$10
	AND #$f0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index
	BNE PRG014_DB13	 ; If X <> 0 (the alt diamond block), jump to PRG014_DB13 (RTS; I guess they didn't want to use it here?)

	PLA		 ; Restore LL_ShapeDef
	AND #$0f
	STA <Temp_Var4	 ; Temp_Var4

	LDY TileAddr_Off 	 ; Y = TileAddr_Off
PRG014_DB07:
	LDA LL_Tunnel,X	 	 ; Get tunnel tile (would've been also the diamond block, phooey)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var4		 ; Temp_Var4--
	BPL PRG014_DB07	 	; While Temp_Var4 >= 0, loop!

PRG014_DB13:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_MiscBG
;
; Miscellaneous background tile insert
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_MiscBG:
	.byte TILE3_LILCLOUD, TILE3_UNK2, TILE3_UNK3

LoadLevel_MiscBG:
	LDX LL_ShapeDef	 	; X = LL_ShapeDef (0-15)
	LDY TileAddr_Off	; Y = TileAddr_Off
	LDA LL_MiscBG,X	 	; Get misc BG tile
	STA [Map_Tile_AddrL],Y	; Store into tile mem
	RTS		 	; Return
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PrefabBlock
;
; Produces large, pre-defined 8x7 blocks.  I'm guessing this was
; just for the sake of pre-fabricating certain types of geometry
; that the typical generators were just not efficient for, but it
; really seems like an inconsistent waste!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PRG014_DB23:	.byte TILE14_ABOVE_CORNER_UR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB29:	.byte TILE3_SKY
PRG014_DB2A:	.byte TILE3_UNDERGROUND
PRG014_DB2B:	.byte TILE3_UNDERGROUND
PRG014_DB2C:	.byte TILE3_UNDERGROUND
PRG014_DB2D:	.byte TILE3_SLOPE45T2B
PRG014_DB2E:	.byte TILE3_MIDGROUND
PRG014_DB2F:	.byte TILE14_SLOPE45T2B_CEIL
PRG014_DB30:	.byte TILE3_SKY
PRG014_DB31:	.byte TILE3_UNDERGROUND
PRG014_DB32:	.byte TILE3_UNDERGROUND
PRG014_DB33:	.byte TILE3_UNDERGROUND
PRG014_DB34:	.byte TILE3_UNDERGROUND
PRG014_DB35:	.byte TILE3_UNDERGROUND
PRG014_DB36:	.byte TILE3_URCORNERGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB3C:	.byte TILE14_ABOVE_CORNER_UL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE14_SLOPE45T2B_CEIL
PRG014_DB40: 	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_HORZGROUND, TILE3_CEILING
PRG014_DB44:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_ULCORNERGROUND, TILE3_LLCORNERGROUND
PRG014_DB48:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_URCORNERGROUND, TILE3_LRCORNERGROUND, TILE3_UNDERGROUND
PRG014_DB4D:	.byte TILE3_UNDERGROUND, TILE3_SLOPE225B2T_L, TILE3_VERTGROUNDL, TILE3_WVERTGROUND_L, TILE3_WVERTGROUND_L, TILE3_MIDGROUND
PRG014_DB53:	.byte TILE3_SKY, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE45T2B
PRG014_DB59:	.byte TILE14_ABOVE_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE14_SLOPE45T2B_CEIL
PRG014_DB5E:	.byte TILE3_UNDERGROUND, TILE3_SLOPE225B2T_U, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB64:	.byte TILE14_ABOVE_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE14_SLOPE45T2B_CEIL
PRG014_DB6A:	.byte TILE14_ABOVE_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB70:	.byte TILE14_ABOVE_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE14_SLOPE45B2T_CEIL
PRG014_DB76:	.byte TILE14_ABOVE_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE14_SLOPE45B2T_CEIL
PRG014_DB7B:	.byte TILE3_UNDERGROUND, TILE3_SLOPE225T2B_U, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB81:	.byte TILE14_ABOVE_CORNER_UR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE14_SLOPE45B2T_CEIL, TILE3_UNDERGROUND
PRG014_DB86:	.byte TILE3_UNDERGROUND, TILE3_SLOPE225T2B_L, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB8C:	.byte TILE3_SKY, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE45B2T
PRG014_DB92:	.byte TILE14_ABOVE_CORNER_UL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB98:	.byte TILE3_SKY
PRG014_DB99:	.byte TILE3_UNDERGROUND
PRG014_DB9A:	.byte TILE3_UNDERGROUND
PRG014_DB9B:	.byte TILE3_UNDERGROUND
PRG014_DB9C:	.byte TILE3_SLOPE45B2T
PRG014_DB9D:	.byte TILE3_MIDGROUND
PRG014_DB9E:	.byte TILE14_SLOPE45B2T_CEIL
PRG014_DB9F:	.byte TILE3_UNDERGROUND
PRG014_DBA0:	.byte TILE3_UNDERGROUND
PRG014_DBA1:	.byte TILE3_UNDERGROUND
PRG014_DBA2:	.byte TILE3_UNDERGROUND
PRG014_DBA3:	.byte TILE3_UNDERGROUND
PRG014_DBA4:	.byte TILE3_UNDERGROUND
PRG014_DBA5:	.byte TILE3_ULCORNERGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DBAB:	.byte TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL
PRG014_DBB1:	.byte TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR
PRG014_DBB7:	.byte TILE3_UNDERGROUND
PRG014_DBB8:	.byte TILE3_UNDERGROUND
PRG014_DBB9:	.byte TILE3_UNDERGROUND
PRG014_DBBA:	.byte TILE3_SLOPE225B2T_L, TILE3_MIDGROUND, TILE14_SLOPE225B2T_U_CEIL
PRG014_DBBD:	.byte TILE3_UNDERGROUND
PRG014_DBBE:	.byte TILE3_UNDERGROUND
PRG014_DBBF:	.byte TILE3_UNDERGROUND
PRG014_DBC0:	.byte TILE3_SLOPE225B2T_U, TILE3_MIDGROUND, TILE14_SLOPE225B2T_L_CEIL
PRG014_DBC3:	.byte TILE3_UNDERGROUND
PRG014_DBC4:	.byte TILE3_UNDERGROUND
PRG014_DBC5:	.byte TILE3_UNDERGROUND
PRG014_DBC6:	.byte TILE3_SLOPE225T2B_L, TILE3_MIDGROUND, TILE14_SLOPE225T2B_U_CEIL
PRG014_DBC9:	.byte TILE3_UNDERGROUND
PRG014_DBCA:	.byte TILE3_UNDERGROUND
PRG014_DBCB:	.byte TILE3_UNDERGROUND
PRG014_DBCC:	.byte TILE3_SLOPE225T2B_U, TILE3_MIDGROUND, TILE14_SLOPE225T2B_L_CEIL
PRG014_DBCF:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND
PRG014_DBD2:	.byte TILE3_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DBD8:	.byte TILE3_ULCORNERGROUND, TILE14_SLOPE225T2B_L_CEIL
PRG014_DBDA:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225B2T_L, TILE3_LLCORNERGROUND
PRG014_DBE0:	.byte TILE3_HORZGROUND, TILE14_SLOPE225T2B_U_CEIL
PRG014_DBE2:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225B2T_U, TILE3_CEILING
PRG014_DBE8:	.byte TILE3_HORZGROUND, TILE3_MIDGROUND, TILE14_SLOPE225T2B_L_CEIL
PRG014_DBEB:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225B2T_L, TILE3_MIDGROUND, TILE3_CEILING
PRG014_DBF1:	.byte TILE3_HORZGROUND, TILE3_MIDGROUND, TILE14_SLOPE225T2B_U_CEIL
PRG014_DBF4:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225B2T_U, TILE3_MIDGROUND, TILE3_CEILING
PRG014_DBFA:	.byte TILE3_HORZGROUND, TILE3_MIDGROUND, TILE14_SLOPE225B2T_U_CEIL
PRG014_DBFD:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225T2B_U, TILE3_MIDGROUND, TILE3_CEILING
PRG014_DC03: 	.byte TILE3_HORZGROUND, TILE3_MIDGROUND, TILE14_SLOPE225B2T_L_CEIL
PRG014_DC06:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225T2B_L, TILE3_MIDGROUND, TILE3_CEILING
PRG014_DC0C:	.byte TILE3_HORZGROUND, TILE14_SLOPE225B2T_U_CEIL
PRG014_DC0E:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225T2B_U, TILE3_CEILING
PRG014_DC14:	.byte TILE3_URCORNERGROUND, TILE14_SLOPE225B2T_L_CEIL
PRG014_DC16:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225T2B_L, TILE3_LRCORNERGROUND
PRG014_DC1C:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND
PRG014_DC1E:	.byte TILE3_UNDERGROUND, TILE3_WCORNER_UR, TILE3_WVERTGROUND_R, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DC24:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND
PRG014_DC26:	.byte TILE3_UNDERGROUND, TILE3_WATERTOP, TILE3_WATER, TILE3_WHORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DC2C:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND
PRG014_DC2E:	.byte TILE3_UNDERGROUND, TILE3_WCORNER_UL, TILE3_WVERTGROUND_L, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DC34:	.byte TILE3_ULCORNERGROUND, TILE3_WVERTGROUND_L, TILE3_WVERTGROUND_L, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DC3A:	.byte TILE3_URCORNERGROUND, TILE3_WVERTGROUND_R, TILE3_WVERTGROUND_R, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND


PRG014_DC40:
	; Each row defines one of the "entry indexes" -- from where that point, we pull 7 tiles
	; Each address in one row is the next column, pointing to the next 7 tiles to pull
	.word PRG014_DB23, PRG014_DB29, PRG014_DB53, PRG014_DB30, PRG014_DB3C, PRG014_DB59, PRG014_DB64, PRG014_DB6A	; Entry 0
	.word PRG014_DB6A, PRG014_DB70, PRG014_DB76, PRG014_DB81, PRG014_DB30, PRG014_DB8C, PRG014_DB98, PRG014_DB92	; Entry 1
	.word PRG014_DB99, PRG014_DB9A, PRG014_DB9B, PRG014_DB9C, PRG014_DB9D, PRG014_DB9E, PRG014_DB9F, PRG014_DB9F	; Entry 2
	.word PRG014_DB9F, PRG014_DB9F, PRG014_DB2F, PRG014_DB2E, PRG014_DB2D, PRG014_DB2C, PRG014_DB2B, PRG014_DB2A	; Entry 3
	.word PRG014_DB40, PRG014_DB40, PRG014_DB40, PRG014_DB40, PRG014_DB40, PRG014_DB40, PRG014_DB40, PRG014_DB40	; Entry 4
	.word PRG014_DB9F, PRG014_DB9F, PRG014_DB9F, PRG014_DBAB, PRG014_DBB1, PRG014_DB9F, PRG014_DB9F, PRG014_DB9F	; Entry 5
	.word PRG014_DBB7, PRG014_DBBD, PRG014_DBB8, PRG014_DBBE, PRG014_DBB9, PRG014_DBBF, PRG014_DBBA, PRG014_DBC0	; Entry 6
	.word PRG014_DBCC, PRG014_DBC6, PRG014_DBCB, PRG014_DBC5, PRG014_DBCA, PRG014_DBC4, PRG014_DBC9, PRG014_DBC3	; Entry 7
	.word PRG014_DBD8, PRG014_DBE0, PRG014_DBE8, PRG014_DBF1, PRG014_DBFA, PRG014_DC03, PRG014_DC0C, PRG014_DC14	; Entry 8
	.word PRG014_DBDA, PRG014_DBE2, PRG014_DBEB, PRG014_DBF4, PRG014_DBFD, PRG014_DC06, PRG014_DC0E, PRG014_DC16	; Entry 9
	.word PRG014_DB9F, PRG014_DBA0, PRG014_DBA1, PRG014_DBA2, PRG014_DBA3, PRG014_DBA4, PRG014_DBA5, PRG014_DBD2	; Entry 10
	.word PRG014_DBD2, PRG014_DB36, PRG014_DB35, PRG014_DB34, PRG014_DB33, PRG014_DB32, PRG014_DB31, PRG014_DB9F	; Entry 11
	.word PRG014_DB9F, PRG014_DB9F, PRG014_DB9F, PRG014_DB44, PRG014_DB48, PRG014_DB9F, PRG014_DB9F, PRG014_DB9F	; Entry 12
	.word PRG014_DC1C, PRG014_DC24, PRG014_DC2C, PRG014_DBCF, PRG014_DC1C, PRG014_DC24, PRG014_DC2C, PRG014_DBCF	; Entry 13
	.word PRG014_DC1C, PRG014_DC24, PRG014_DB4D, PRG014_DB5E, PRG014_DC1E, PRG014_DC26, PRG014_DC34, PRG014_DBD2	; Entry 14
	.word PRG014_DC3A, PRG014_DC26, PRG014_DC2E, PRG014_DB7B, PRG014_DB86, PRG014_DC24, PRG014_DC2C, PRG014_DBCF	; Entry 15

LoadLevel_PrefabBlock:
	; Backup Map_Tile_Addr into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	; LL_ShapeDef is a value 0 - 15 in fixed size gens
	ASL A		
	ASL A	
	ASL A	
	STA <Temp_Var5	 ; Temp_Var5 = 0, 8, 16, 24, ...

	; This loops for 8 columns
PRG014_DD50:
	LDA TileAddr_Off
	STA <Temp_Var6	 ; Temp_Var6 = TileAddr_Off

	LDA #$00
	STA <Temp_Var7	 ; Temp_Var7 = 0

	LDA <Temp_Var5
	ASL A		 
	TAX		 ; X = Temp_Var5 << 1 (0, 16, 32, 48, ...)

	; Get address from one row of PRG014_DC40 array above, store into Temp_Var3/4
	LDA PRG014_DC40,X
	STA <Temp_Var3	
	LDA PRG014_DC40+1,X
	STA <Temp_Var4	

	; This copies in 7 tiles vertically
PRG014_DD67:
	LDY <Temp_Var7		 ; Y = Temp_Var7 (row offset into pointer)
	LDA [Temp_Var3],Y	 ; Get byte from pointer for this row

	LDY <Temp_Var6		 ; Y = Temp_Var6 (row offset into tile memory)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset and also the TileAddr_Off
	TYA	
	ADD #16
	STA <Temp_Var6
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	INC <Temp_Var7		 ; Temp_Var7++ (row increment)

	LDA <Temp_Var7	
	CMP #$06	 
	BNE PRG014_DD67	 	; If Temp_Var6 <> 6, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	JSR LoadLevel_NextColumn ; Next column

	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	
	; Update backup
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	INC <Temp_Var5		 ; Temp_Var5++ (column increment, get next address in same row)
	LDA <Temp_Var5
	AND #$07	
	BNE PRG014_DD50	 	; If Temp_Var5 < 8, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ThroneRoom
;
; Builds the end-of-world Throne Room (completely prefabricated!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; The end world castle throne room
LL_ThroneRoom:
; The princess's letter is actually here (at Vert_Scroll = 0)
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02
	.byte $02, $02, $47, $5C, $5C, $5C, $5C, $5C, $5C, $5C, $5C, $5C, $5C, $5D, $02, $02
	.byte $02, $02, $5E, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $5E, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $5E, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $5E, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $5E, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $5E, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $5E, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4F, $02, $02
	.byte $02, $02, $4D, $4E, $4E, $4E, $4E, $4E, $4E, $4E, $4E, $4E, $50, $51, $02, $02
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02

; You only see from here though... (at Vert_Scroll = $EF)
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	.byte $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $FD
	
	.byte $FF	; Terminator

LoadLevel_ThroneRoom:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; Temp_Var1/2 point to LL_ThroneRoom
	LDA #(LL_ThroneRoom & $FF)
	STA <Temp_Var1		
	LDA #(LL_ThroneRoom >> 8)
	STA <Temp_Var2		

PRG014_DF41:
	LDA [Temp_Var1],Y	 ; Get next tile
	CMP #$ff	 
	BEQ PRG014_DF60	 	; If we hit the terminator, jump to PRG014_DF60

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	INY		 	; Y++ next tile
	CPY #$00	 	; Check if we overflowed
	BNE PRG014_DF5C	 	; If not, jump to PRG014_DF5C

	; Map_Tile_AddrH++
	LDA <Map_Tile_AddrH
	ADD #$01	 
	STA <Map_Tile_AddrH

	; Temp_Var2++ (move ahead 256 bytes)
	LDA <Temp_Var2
	ADD #$01	
	STA <Temp_Var2	

PRG014_DF5C:
	INX		 ; X++	; um, actually I don't think this serves a purpose!  Old version of loop idea I guess?
	JMP PRG014_DF41	; Jump to PRG014_DF41

PRG014_DF60:
	RTS		 ; Return



LBGHM_BitMasks:
	.byte $80, $40, $20, $10, $08, $04, $02, $01

	; Prevents collected coins or discovered hidden power ups from
	; reappearing if you switch areas
	; Returns non-zero if this coin was grabbed or 1-up was found already
LoadLevel_CheckBGHMem:

	; Backup X and Y
	STX <Temp_Var12
	STY <Temp_Var13

	LDA <Temp_Var15		; A = Temp_Var15 (first byte read from layout)
	AND #$10	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA <Temp_Var14		; Temp_Var14 = 0/1, depending on if Temp_Var15's bit 4 was set

	LDY <Temp_Var16		; Y = Temp_Var16 (second byte read from layout)

	LDA LL_ShapeDef	 	; A = LL_ShapeDef
	AND #$f0	 
	BEQ PRG014_DF8C	 	; If upper 4 bits of LL_ShapeDef are not set, jump to PRG014_DF8C

	; Otherwise...
	LDA LL_ShapeDef
	AND #$0f		; Take lower 4 bits of ShapeDef (the original width)
	SUB <Temp_Var3		; Subtract Temp_Var3 (the remaining width)
	ADD <Temp_Var16		; Add in the second value read
	TAY			; Y = original width - remaining width + Temp_Var16

PRG014_DF8C
	TYA		 	; A = Y
	AND #%11111000
	LSR A		 
	LSR A		 	; A = upper 5 bits of 'Y', shifted down twice (has a trailing zero bit)
	ORA <Temp_Var14		; 'Or' the 0/1 determined by Temp_Var15's bit 4
	STA <Temp_Var14		; Temp_Var14 holds the result

	LDA Level_JctFlag	 
	BEQ PRG014_DFA1	 	; If Level_JctFlag = 0 (no junction occurring), jump to PRG014_DFA1

	; Otherwise, Temp_Var14 += $40 (use second set for "alternate" level)
	LDA <Temp_Var14
	ADD #$40	 
	STA <Temp_Var14

PRG014_DFA1:
	LDA <Temp_Var13		; A = Temp_Var13 (the tile offset we came in with)
	AND #$07	 	; Keeping only the first 3 bits (0-7)
	TAX		 	; X = A (0-3)

	LDY <Temp_Var14			; Y = Temp_Var14 from above
	LDA Level_BlockGrabHitMem,Y	; Pull data from Level_BlockGrabHitMem

	; This sets the result of the check
	AND LBGHM_BitMasks,X	; Check if appropriate bit is set (means this coin was grabbed or hidden block hit or whatever)

	; Restore X/Y
	LDX <Temp_Var12
	LDY <Temp_Var13
	RTS		 	; Return

LoadLevel_NextColumn:
	INY		 ; Y++
	TYA		 ; A = Y
	AND #$0f	 ; Check column
	BNE PRG014_DFCC	 ; If on column 1-15, jump to PRG014_DFCC (RTS)

	; Otherwise, need to move over to the next screen (+$1B0)
	LDA <Map_Tile_AddrL
	ADD #$b0	 
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH

	; Get TileAddr_Off and only keep the row, but clear 'Y' lower bits since
	; we're going to column 0 on the same row, new screen...
	LDA TileAddr_Off
	AND #$f0
	TAY	

PRG014_DFCC:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_StoreJctStart
;
; Temp_Var16 and LL_ShapeDef become bytes that fill in Level_JctYLHStart 
; and Level_JctXLHStart arrays, based on lower 4-bits of Temp_Var15
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_StoreJctStart:
	; Temp_Var15, Temp_Var16, and LL_ShapeDef are 3 input bytes from the loader routine

	; Lower 4 bits of Temp_Var15 define the index into Level_JctY/XLHStart
	LDA <Temp_Var15
	AND #$0f	
	TAY		; Y = Temp_Var15 & $f

	LDA <Temp_Var16	
	STA Level_JctYLHStart,Y		; Temp_Var16 is stored at Level_JctYLHStart[Y]

	LDA LL_ShapeDef	 
	STA Level_JctXLHStart,Y		; LL_ShapeDef is stored at Level_JctXLHStart[Y]

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PipeRaiseHelper[1-4]
;
; Adds a 2x2 square of tiles in place of where a risen pipe would
; be or is the pipe itself if it is already known to be risen.
; Meant to assist the OBJ_PIPERAISE[1-4] objects.
; Realistically the simplest way to commit tiles without having
; the pipe re-raise every time the Player re-enters a level.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LoadLevel_PipeRaiseHelper1:
	LDX #0
	BEQ LL_PRH_Enter

LoadLevel_PipeRaiseHelper2:
	LDX #1
	BNE LL_PRH_Enter

LoadLevel_PipeRaiseHelper3:
	LDX #2
	BNE LL_PRH_Enter

LoadLevel_PipeRaiseHelper4:
	LDX #3
	BNE LL_PRH_Enter

LL_PRH_Tiles:	
	.byte TILE1_SKY, TILE1_SKY, TILE1_SKY, TILE1_SKY	; Pipe not risen
	.byte TILE6_SKY, TILE6_SKY, TILE6_SKY, TILE6_SKY	; Underwater area compatible alternate
	.byte TILE1_PIPETB1_L, TILE1_PIPETB1_R, TILE1_PIPEVL, TILE1_PIPEVR	; Pipe already risen

LL_PRH_Enter:

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	
	; Special alternate use: If an action switch is detected here, just modify that!
	LDA [Map_Tile_AddrL],Y
	CMP #TILEA_EXSWITCH
	BNE LL_PRH_NotActSw		; If not an action switch, jump to LL_PRH_NotActSw
	
	; Action switch alternate!
	LDA Level_PipeRaiseData
	AND PipeRaise_NeedRaiseBits,X
	PHP
	
	LDA #TILEA_EXSWITCH
	
	PLP
	BEQ LL_PRH_CommitNoPress	; If switch has never been pressed, jump to LL_PRH_CommitNoPress
	
	; Otherwise, switch was pressed
	LDA #TILEA_PSWITCH_PRESSED
	
LL_PRH_CommitNoPress:
	; Set Action Switch as appropriate
	STA [Map_Tile_AddrL],Y
	RTS


LL_PRH_NotActSw:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDY #0	; Using pipe-not-risen tiles unless we determine it is already risen
	
	LDA Level_Tileset
	CMP #6
	BNE LLPRHNAW_NotUnderwater	; If Level_Tileset <> 6 (Underwater), jump to LLPRHNAW_NotUnderwater
	
	; Underwater uses different sky
	LDY #4
	
LLPRHNAW_NotUnderwater:
	LDA Level_PipeRaiseData
	AND PipeRaise_AlreadyRaisedBits,X
	BEQ LL_PRH_NotAlreadyRisen	; If pipe raise is not already risen, jump to LL_PRH_NotAlreadyRisen

	LDY #8	; Using already risen tiles!

LL_PRH_NotAlreadyRisen:
	TYA
	TAX		; X = 0 or 4

	LDY TileAddr_Off	 ; Y = TileAddr_Off	

LL_PRH_TileLoop:
	LDA LL_PRH_Tiles,X
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	; Next column
	INX		 		; X++ (next tile)
	
	TXA
	AND #1
	BNE LL_PRH_OddCol	; If we're on the "odd" column, jump to LL_PRH_OddCol
	
	; Otherwise, new line...

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1		 
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	; Go to next row by adding 16 to address
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

LL_PRH_OddCol:
	TXA
	AND #3
	BNE LL_PRH_TileLoop	; While X is not 4 or 8, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_UnderRectangle
;
; Rectangle of underground blocks / SMW-esque climable fence 
; with cross-section detection
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LLUR_Tiles:
	; 		Bottom				Middle				Top
	.byte TILE3_LLCORNERGROUND,	TILE3_VERTGROUNDL,	TILE3_ULCORNERGROUND	; Left
	.byte TILE3_CEILING,		TILE3_MIDGROUND,	TILE3_HORZGROUND		; Middle
	.byte TILE3_LRCORNERGROUND,	TILE3_VERTGROUNDR,	TILE3_URCORNERGROUND	; Right

	; 		Bottom				Middle				Top
	.byte TILE2_FENCE_LL,	TILE2_FENCE_ML,		TILE2_FENCE_UL	; Left
	.byte TILE2_FENCE_LM,	TILE2_FENCE_MM,		TILE2_FENCE_UM	; Middle
	.byte TILE2_FENCE_LR,	TILE2_FENCE_MR,		TILE2_FENCE_UR	; Right

	; 		Bottom				Middle				Top
	.byte TILE14_ABOVE_CORNER_LL,	TILE14_ABOVE_VERTGROUNDL,	TILE14_ABOVE_CORNER_UL	; Left
	.byte TILE14_ABOVE_CEILING,		TILE14_ABOVE_MIDGROUND,		TILE14_ABOVE_HORZGROUND		; Middle
	.byte TILE14_ABOVE_CORNER_LR,	TILE14_ABOVE_VERTGROUNDR,	TILE14_ABOVE_CORNER_UR	; Right

LoadLevel_UnderRectangle2:
	LDX #20
	BNE LLURect_2

LoadLevel_UnderRectangle:
	LDA Level_Tileset
	CMP #2
	BNE LLURect_NotFort

	; Fortress tileset uses this generator for fences
	LDX #11		; Top row tiles (fence)
	BNE LLURect_2

LLURect_NotFort:
	LDX #2		; Top row tiles (underground)

LLURect_2:
	LDY #$00	 		; Y = 0
	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	STA <Temp_Var3		 	; Store into Temp_Var3 (width)

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01	 
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

LLURect_RowLoop:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; By default there's only one "row" of the top/bottom
	LDA #1

	CPX #10
	BEQ LLURect_FenceMiddle	; If doing the middle fence tiles, keep the row count of 1
	CPX #19
	BEQ LLURect_FenceMiddle	; If doing the middle above-underground tiles, keep the row count of 1
	CPX #1
	BNE LLURect_TopBot	; If not doing the middle underground tiles, keep the row count of 1

LLURect_FenceMiddle:
	; The "middle" rows are set by parameter...
	LDA LL_ShapeDef	 
	AND #$0f	

LLURect_TopBot:
	STA <Temp_Var4	; Set rows for inner loop


LLURect_InnerLoop:
	LDA <Temp_Var4
	BEQ LLURect_InnerLoop_End	; Using "0" as loop termination so allow for no middle rows

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	; Reset width counter
	LDA <Temp_Var3	
	STA <Temp_Var5	; Temp_Var5 = Temp_Var3 (width)

	; Left tile
	LDA LLUR_Tiles,X	 	 ; Get block
	JSR LLURect_PlaceTile	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

LLURect_ColLoop:
	LDA <Temp_Var5
	BEQ LLURect_ColLoop_End		; Using "0" as loop termination so allow for no middle columns

	LDA LLUR_Tiles+3,X	 ; Get block
	JSR LLURect_PlaceTile	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5
	JMP LLURect_ColLoop	 	; Loop around...

LLURect_ColLoop_End:
	; Right tile
	LDA LLUR_Tiles+6,X	 	 ; Get block
	JSR LLURect_PlaceTile	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1		 
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	
	
	; Go to next row by adding 16 to address
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup
	
	DEC <Temp_Var4
	JMP LLURect_InnerLoop	; Loop around...


LLURect_InnerLoop_End:
	; After loop...

	CPX #18
	BEQ LLURect_EndFence	; Under-above ends if we get here at X=18
	CPX #9
	BEQ LLURect_EndFence	; Fence ends if we get here at X=9
	DEX
	BPL LLURect_RowLoop	 	; While X >= 0 (didn't yet do bottom row), loop!

LLURect_EndFence:
	RTS		 ; Return



LLURect_PlaceTile:
	PHA	; Save tile

	CMP [Map_Tile_AddrL],Y
	BEQ LLURect_PlaceTile_Normal	; If placing the same tile, just stick with it
	
	LDA Level_Tileset
	CMP #2
	BNE LLURect_NotFort_TileCheck
	
	; Fortress tile check...
	; If covering up an existing fence tile, use the "mid fence"
	; TILE2_FENCE_UL >= x >= TILE2_FENCE_LR
	LDA [Map_Tile_AddrL],Y
	CMP #TILE2_FENCE_UL
	BLT LLURect_PlaceTile_Normal
	CMP #TILE2_FENCE_LR+1
	BGE LLURect_PlaceTile_Normal
	
	; Overlap!
	PLA		; Reject old tile
	LDA #TILE2_FENCE_MM
	PHA		; Replace tile
	BNE LLURect_PlaceTile_Normal	; Jump (technically always) to LLURect_PlaceTile_Normal
	
LLURect_NotFort_TileCheck:
	; If covering up an existing "underground" tile, use the "mid ground"
	; This probably could be more intelligent, but this will be good enough
	; TILE3_SLOPE45B2T >= x >= TILE3_LRCORNERGROUND
	LDA [Map_Tile_AddrL],Y
	CMP #TILE3_SLOPE45B2T
	BLT LLURect_PlaceTile_Chk2
	CMP #TILE3_LRCORNERGROUND+1
	BGE LLURect_PlaceTile_Chk2
	
	; Overlap!
	PLA		; Reject old tile
	LDA #TILE3_MIDGROUND
	PHA		; Replace tile
	BNE LLURect_PlaceTile_Normal	; Jump (technically always) to LLURect_PlaceTile_Normal

LLURect_PlaceTile_Chk2:
	; If covering up an existing "above underground" tile, use the "mid ground"
	; This probably could be more intelligent, but this will be good enough
	; TILE14_SLOPE45B2T >= x >= TILE14_LRCORNERGROUND
	LDA [Map_Tile_AddrL],Y
	CMP #TILE14_ABOVE_CORNER_LL
	BLT LLURect_PlaceTile_Normal
	CMP #TILE14_ABOVE_MIDGROUND+1
	BGE LLURect_PlaceTile_Normal
	
	; Overlap!
	PLA		; Reject old tile
	LDA #TILE14_ABOVE_MIDGROUND
	PHA		; Replace tile

LLURect_PlaceTile_Normal:


	PLA
	STA [Map_Tile_AddrL],Y	; Store tile

	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Vine
;
; Puts down 1-16 vine tiles
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LLFortVine_Tile:	.byte TILE1_VINE, TILE2_HANGGLOBE_CABLE

LoadLevel_Vine:
	LDX #0

	LDY TileAddr_Off	 ; Y = TileAddr_Off

LLGlobeManual_Enter:	
	LDA LL_ShapeDef	 
	AND #$0f	 
	STA <Temp_Var4		 ; Temp_Var4 = lower 4 bits of LL_ShapeDef (width of run)

LLFortVine_Loop:
	LDA LLFortVine_Tile,X	; Get appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_TileMemNextRow

	DEC <Temp_Var4		 ; Temp_Var4--
	BPL LLFortVine_Loop	 	; While Temp_Var4 >= 0, loop!
	
	RTS		 	; Return...



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_RandomStarStuff
;
; Background for the space worlds
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_StarTiles:
	.byte TILE3_STARMASS6, TILE3_STARMASS2, TILE3_STARMASS3
	.byte TILE3_STARMASS4, TILE3_STARMASS5, TILE3_STARMASS1
	.byte TILE3_STARMASS5, TILE3_STARMASS2

	.byte TILE3_STARMASS6, TILE3_STARMASS2, TILE3_STARMASS3
	.byte TILE3_STARMASS4, TILE3_STARMASS5, TILE3_STARMASS3
	.byte TILE3_STARMASS5, TILE3_STARMASS2

LoadLevel_RandomStarStuff:
	LDA #255
	STA Misc_Counter ; Lots of random
	
	LDA #4
	STA <Temp_Var14

LLRSS_D22B:
	JSR Randomize	 ; Seed the randomizer
	LDA RandomN	 ; Get a random number
	AND #31
	CMP #24 
	BLT LLRSS_D23A	 ; If random number < 24, jump to LLRSS_D23A (mod 9 essentially)

	SUB #23	 	; If random number was 24, subtract 23

LLRSS_D23A:
	STA <Temp_Var15	 ; Random number 0-23

	LDA RandomN+1	 ; Get another random number
	TAX		 ; -> 'X'

	AND #$f0
	CMP #$f0
	BNE LLRSS_D24B	 ; If the upper 4 bits are not all set, jump to LLRSS_D24B

	; Otherwise, X += $20 (random 0 to $EF)
	TXA
	ADD #$20
	TAX	

LLRSS_D24B:
	STX <Temp_Var16	 ; Temp_Var16 = 'X'

	TXA
	ADD <Temp_Var14
	AND #$0F	; Tile randomizer

	PHA		 ; Save 'A' (Random value of 0-7)
	JSR LoadLevel_Set_TileMemAddr	 ; Set tile address
	PLA		 ; Restore 'A'

	TAX		 ; Get random 0-7 value

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_StarTiles,X	 ; Get random starry tile!
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	DEC Misc_Counter	 ; Misc_Counter--
	BNE LLRSS_D22B	 	; While Misc_Counter > 0, loop!
	
	DEC Temp_Var14
	BNE LLRSS_D22B	 	; While Temp_Var14 > 0, loop!

	RTS		 ; Return
	
