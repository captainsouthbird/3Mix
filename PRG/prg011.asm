; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg011.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------
PRG011_A000:
	.byte $00, $01, $02, $03, $04, $05, $06, $07

Map_Unused7EEA_Vals:
	; LUT indexed by world number with no apparent use?
	.byte $02, $04, $03, $FF, $03, $04, $03, $05

	; This sets up the world map objects
Map_List_Object_Ys:
	; List of Y values for objects on this world
	.word W1_Obj_Ys, W2_Obj_Ys, W3_Obj_Ys, W4_Obj_Ys, W5_Obj_Ys, W6_Obj_Ys, W7_Obj_Ys, W8_Obj_Ys, $0000, W10_Obj_Ys

Map_List_Object_XHis:
	.word W1_Obj_XHis, W2_Obj_XHis, W3_Obj_XHis, W4_Obj_XHis, W5_Obj_XHis, W6_Obj_XHis, W7_Obj_XHis, W8_Obj_XHis, $0000, W10_Obj_XHis

Map_List_Object_XLos:
	; List of X values for objects on this world
	.word W1_Obj_XLos, W2_Obj_XLos, W3_Obj_XLos, W4_Obj_XLos, W5_Obj_XLos, W6_Obj_XLos, W7_Obj_XLos, W8_Obj_XLos, $0000, W10_Obj_XLos

Map_List_Object_IDs:
	; Object ID list for objects on this world
	.word W1_Obj_IDs, W2_Obj_IDs, W3_Obj_IDs, W4_Obj_IDs, W5_Obj_IDs, W6_Obj_IDs, W7_Obj_IDs, W8_Obj_IDs, $0000, W10_Obj_IDs

Map_List_Object_Items:
	.word W1_Obj_Items, W2_Obj_Items, W3_Obj_Items, W4_Obj_Items, W5_Obj_Items, W6_Obj_Items, W7_Obj_Items, W8_Obj_Items, $0000, W10_Obj_Items

; The 'Y' position of each map object
W1_Obj_Ys:	.include "PRG/maps/World1OY"
W2_Obj_Ys:	.include "PRG/maps/World2OY"
W3_Obj_Ys:	.include "PRG/maps/World3OY"
W4_Obj_Ys:	.include "PRG/maps/World4OY"
W5_Obj_Ys:	.include "PRG/maps/World5OY"
W6_Obj_Ys:	.include "PRG/maps/World6OY"
W7_Obj_Ys:	.include "PRG/maps/World7OY"
W8_Obj_Ys:	.include "PRG/maps/World8OY"
W10_Obj_Ys:	.include "PRG/maps/World10OY"

; The hi and low (respective) X coordinates of the map objects
W1_Obj_XHis:	.include "PRG/maps/World1OH"
W2_Obj_XHis:	.include "PRG/maps/World2OH"
W3_Obj_XHis:	.include "PRG/maps/World3OH"
W4_Obj_XHis:	.include "PRG/maps/World4OH"
W5_Obj_XHis:	.include "PRG/maps/World5OH"
W6_Obj_XHis:	.include "PRG/maps/World6OH"
W7_Obj_XHis:	.include "PRG/maps/World7OH"
W8_Obj_XHis:	.include "PRG/maps/World8OH"
W10_Obj_XHis:	.include "PRG/maps/World10OH"
W1_Obj_XLos:	.include "PRG/maps/World1OX"
W2_Obj_XLos:	.include "PRG/maps/World2OX"
W3_Obj_XLos:	.include "PRG/maps/World3OX"
W4_Obj_XLos:	.include "PRG/maps/World4OX"
W5_Obj_XLos:	.include "PRG/maps/World5OX"
W6_Obj_XLos:	.include "PRG/maps/World6OX"
W7_Obj_XLos:	.include "PRG/maps/World7OX"
W8_Obj_XLos:	.include "PRG/maps/World8OX"
W10_Obj_XLos:	.include "PRG/maps/World10OX"

; The IDs of the map objects
; NOTE: The second index is considered reserved for the Airship, which will
; always and only occupy that slot; do not use it for regular maps!
; (World 8 would probably be okay though?)
W1_Obj_IDs:	.include "PRG/maps/World1O"
W2_Obj_IDs:	.include "PRG/maps/World2O"
W3_Obj_IDs:	.include "PRG/maps/World3O"
W4_Obj_IDs:	.include "PRG/maps/World4O"
W5_Obj_IDs:	.include "PRG/maps/World5O"
W6_Obj_IDs:	.include "PRG/maps/World6O"
W7_Obj_IDs:	.include "PRG/maps/World7O"
W8_Obj_IDs:	.include "PRG/maps/World8O"
W10_Obj_IDs:	.include "PRG/maps/World10O"

; The item that this "event" gives you (for hammer brothers only I think)
; 1 - Super, 2 - Fire, 3 - Leaf, 4 - Penguin, 5 - Rabbit, 6 - Hammer, 7 - Judgems, 8 - Pwing, 9 - Star
; A - Anchor, B - Hammer, C - Warp Whistle, D - Music Box
W1_Obj_Items:	.include "PRG/maps/World1OI"
W2_Obj_Items:	.include "PRG/maps/World2OI"
W3_Obj_Items:	.include "PRG/maps/World3OI"
W4_Obj_Items:	.include "PRG/maps/World4OI"
W5_Obj_Items:	.include "PRG/maps/World5OI"
W6_Obj_Items:	.include "PRG/maps/World6OI"
W7_Obj_Items:	.include "PRG/maps/World7OI"
W8_Obj_Items:	.include "PRG/maps/World8OI"
W10_Obj_Items:	.include "PRG/maps/World10OI"


PRG011_A1C8:
	.byte $03, $04, $05, $01, $03, $05, $01, $01
	.byte $00, $00, $00, $00, $00, $00, $00, $00

Map_LoadObjects:
	LDA World_Num
	ASL A
	TAX		; X = World_Num << 1

	; Set address of object Y list for this world
	LDA Map_List_Object_Ys,X
	STA <Temp_Var11	
	LDA Map_List_Object_Ys+1,X
	STA <Temp_Var12	

	; Set address of object X (hi byte) list for this world
	LDA Map_List_Object_XHis,X
	STA <Temp_Var13	
	LDA Map_List_Object_XHis+1,X
	STA <Temp_Var14	

	; Set address of object X (lo byte) list for this world
	LDA Map_List_Object_XLos,X
	STA <Temp_Var15	
	LDA Map_List_Object_XLos+1,X
	STA <Temp_Var16	

	; Set address of object ID list for this world
	LDA Map_List_Object_IDs,X
	STA <Temp_Var9
	LDA Map_List_Object_IDs+1,X
	STA <Temp_Var10

	; Set address of object item list for this world
	LDA Map_List_Object_Items,X
	STA <Temp_Var7
	LDA Map_List_Object_Items+1,X
	STA <Temp_Var8

	; Loop MAPOBJ_TOTALINIT times for all defined map objects
	LDY #MAPOBJ_TOTALINIT
	LDX World_Num
PRG011_A21B:

	; Copy in the data relevant to this map object
	LDA [Temp_Var11],Y
	STA Map_Objects_Y,Y	; Y
	LDA [Temp_Var13],Y
	STA Map_Objects_XHi,Y	; XHi
	LDA [Temp_Var15],Y	
	STA Map_Objects_XLo,Y	; XLo
	LDA [Temp_Var9],Y	
	STA Map_Objects_IDs,Y	; ID
	LDA [Temp_Var7],Y	
	STA Map_Objects_Itm,Y	; Item

	; No "complete" check on index > 7
	CPY #8
	BGE MapSpawn_NotComplete

	LDA Map_Objects_IDs,Y
	CMP #MAPOBJ_LAUNCHSTAR
	BEQ MapSpawn_ObjOK	; Launch Stars always need to spawn

	; If object has been "completed", erase it!
	LDA Map_ObjCompletions,X
	AND MapObj_CompleteBit,Y
	BNE MapSpawn_EraseObj	; If object has been marked "completed", jump to MapSpawn_EraseObj
	
MapSpawn_NotComplete:

	; HACK FOR NODICE
	LDA Reset_Latch
	BEQ MapSpawn_ObjOK	
	; HACK FOR NODICE
	
	LDA Map_Objects_IDs,Y
	CMP #MAPOBJ_MAGIBLOT
	BEQ MapSpawn_ObjOK	; Since Magiblots will only be featured in comet mode, force spawn if not defeated
	
	SUB #MAPOBJ_DAREDEVILCOMET
	CMP #2
	BGE MapSpawn_NotAComet

	; This is a comet... if we're not in "Comet Mode"...
	LDA Map_CometMode
	BEQ MapSpawn_EraseObj	; ... erase it!
	BNE MapSpawn_ObjOK		; ... otherwise, keep it.

MapSpawn_NotAComet:

	; This is a NOT comet... if we're NOT in "Comet Mode"...
	LDA Map_CometMode
	BEQ MapSpawn_ObjOK		; ... keep it!
	
MapSpawn_EraseObj:
	LDA #MAPOBJ_EMPTY
	STA Map_Objects_IDs,Y

MapSpawn_ObjOK:
	DEY		 ; Y--
	BPL PRG011_A21B	 ; While Y >= 0, go around again...

	RTS

Map_Init:
	JSR Map_Airship_Pick_Travel	; Based on world number and a bit of random, selects which set of destinations the airship will use (referred to as A, B, or C)
	LDX World_Num	 		; X = World_Num

	; Unknown lookup val stored to an unused variable
	LDA Map_Unused7EEA_Vals,X	; LUT based on world number for?
	STA Map_Unused7EEA		; Stored into Map_Unused7EEA

	;JSR Map_LoadObjects

	LDA Map_SetBothPlayers
	BNE Map_InitPlayerPos	; If we need to initialize BOTH Players (start of new game ONLY!!), jump to Map_InitPlayerPos

	LDY World_Num

	; Otherwise, we only set the start position for the ACTIVE Player
	LDX Player_Current
	JSR Map_InitAPlayer
		
	; If we just came from World 9 (Star Road) do NOT init both Players!
	LDX #$FF	; For upcoming set
	BNE Map_SkipInitPlayerPos	; Jump (technically always) to Map_SkipInitPlayerPos

Map_InitPlayerPos:
	LDY World_Num	 	; Y = World_Num
	LDX Total_Players	; X = Total players (1 for 1P, 2 for 2P)
	DEX		 	; X--
	
	; Initialization for players...
PRG011_A23E:
	; X is the player index, 1 = Luigi, 0 = Mario
	; Y is World_Num
	JSR Map_InitAPlayer

	DEX		 ; X--
	BPL PRG011_A23E	 ; As long as we have another player to init, loop!

Map_SkipInitPlayerPos:
	STX Map_2PVsGame ; Map_2PVsGame = $FF (since game increments at start, this will play game style 0)

	; Clear the following
	LDA #0
	STA Map_WhiteHouse
	STA Map_CoinShip

	RTS		 ; Return

Map_InitAPlayer:

	; Set starting Y position
	LDA Map_Y_Starts,Y
	STA Map_Entered_Y,X
	STA Map_Previous_Y,X

	; Set starting X position (forced to $20!)
	LDA #$20	 
	STA Map_Entered_X,X
	STA Map_Previous_X,X

	; Set Player's previous movement direction
	LDA #$01
	STA Map_Previous_Dir,X

	;LDA World_Num
	;STA Map_Previous_World,X

	LDA #$00
	STA Map_Entered_XHi,X
	STA Map_Previous_XHi,X
	STA Map_Unused7984,X	; Cleared here, but never used
	STA Map_Prev_XOff2,X
	STA Map_Prev_XHi2,X
	STA Map_Unused798A,X	; Cleared here, but never used
	STA Map_Prev_XOff,X
	STA Map_Prev_XHi,X
		
	RTS

Map_Airship_Travel_BaseIdx:
	; Base index value, per-world
	;      W1   W2   W3   W4   W5   W6   W7   W8
	.byte $00, $03, $06, $09, $0C, $0F, $12, $15

Map_Airship_Travel_Random:
	; Randomly selected offsets
	.byte $00, $01, $02, $00, $01, $02, $00, $01, $02, $00, $01, $02, $00, $01, $02, $00


	; At the beginning of the world, this randomly selects a set of travel destinations the airship will take, six defined per set.
Map_Airship_Pick_Travel:
	LDY World_Num		; Y = World_Num
	LDA RandomN		; A = random
	AND #$0f		; Capped 0-15
	TAX			; X = random number 0-15
	LDA Map_Airship_Travel_Random,X		; Get initial random offset value (essentially amounts to a random value of 0 to 2)
	ADD Map_Airship_Travel_BaseIdx,Y	; Apply base index (Adds 3x World_Num)
	STA Map_Airship_Trav	; Store as the Map_Airship_Trav value
	RTS		 	; Return


Map_WW_StartX:	.byte 0, 240	; Map warp wind starting X position, depending which direction it comes from
Map_WW_DeltaX:	.byte 2, -2	; Position change depending on the direction of travel
Map_WW_TargetX:	.byte 240, 0	; The ending position, depending on direction of travel

	; Starting Y position depending on what world you came from
Map_WW_IslandY:
	.byte $50, $70, $70	; World 1 - 3
	.byte $70, $70, $70	; World 4 - 6
	.byte $90, $90, $90	; World 7 - 9

	; Unused?  Guessing this was possible X Hi init values,
	; though always zero (maybe there would've been multiple
	; islands?  Per group of worlds?)
	.byte $00, $00, $00	; World 1 - 3
	.byte $00, $00, $00	; World 4 - 6
	.byte $00, $00, $00	; World 7 - 9

	; Starting X position depending on what world you came from
Map_WW_IslandX:
	.byte $40, $40, $40	; World 1 - 3
	.byte $40, $40, $40	; World 4 - 6
	.byte $80, $80, $80  	; World 7 - 9


Map_DoMap_WarpWind_FX:

	; Note: In original Japanese version, you could warp from a canoe and then
	; sail yourself off the warp island (but never get back on!)  This fixes 
	; that bug with a vengeance, since it will be called several times :)
	LDA #$00	 	
	STA Map_InCanoe_Flag	; Map_InCanoe_Flag = 0 (not in canoe)

	; NOTE: If Map_WarpWind_FX = 0,  Map_DoMap_WarpWind_FX is never called,
	; so state 0 is technically never used... that's okay, it actually
	; contains a "bug", which might just be unmaintained legacy code..

	; Dynamic jump based on current map special effect occurring..
	LDA <Map_WarpWind_FX
	AND #$7F	; Bit 7 specifies World Zero unlock sequence
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word $0000
	.word WWFX_Menu				; 1 - Map menu
	.word WWFX_PlayerAscend		; 2 - Player ascends upward
	.word WWFX_ClearMapObjs		; 3 - Map objects cleared
	.word WWFX_WarpIslandInit	; 4 - Initialize stuff for the warp island, including setting proper Player X/Y position
	.word WWFX_WarpLanding		; 5 - Player lands on Star Road
	.word WWFX_WZeroUnlockPoof	; 6 - World Zero Unlock Poof 1
	.word WWFX_WZeroUnlockPoof	; 7 - World Zero Unlock Poof 2
	.word WWFX_WZeroUnlockPoof	; 8 - World Zero Unlock Poof 3
	.word WWFX_WZeroUnlockPoof	; 9 - World Zero Unlock Poof 4
	.word WWFX_WZeroUnlockDone	; 10 - World Zero Unlock complete!

WWFX_Menu:
	JSR_THUNKC 30, Game_DoPause30
	RTS

WarpWhistle_Flash:
	LDA <Map_WWOrHT_Cnt
	BNE PRG011_A333	 	; If Map_WWOrHT_Cnt <> 0, jump to PRG011_A333

	LDA #$20	 
	STA <Map_WWOrHT_Cnt	; Otherwise, Map_WWOrHT_Cnt = $20


PRG011_A333:

	; Basically here's what does the white flashing effect
	LDY #%00011000		; Show BG + Sprites
	DEC <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt--
	AND #$04	 
	BEQ PRG011_A33D	 	; Every 4 ticks, toggle mono effect
	LDY #%00011001		; Show BG + Sprites + Mono

PRG011_A33D:
	STY <PPU_CTL2_Copy	; Update
	RTS		 	; Return...


WWFX_PlayerAscend:
	LDX Player_Current	; X = Player_Current

	LDA <World_Map_Y,X
	SUB #4
	STA <World_Map_Y,X

	CMP #$F0
	BLT PRG011_A396	 		; If Player is not off the map yet, jump to PRG011_A396

	INC <Map_WarpWind_FX		; Otherwise, next state!

PRG011_A396:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


WWFX_ClearMapObjs:
	LDA World_Num	 	
	STA Map_Warp_PrevWorld	 	; Map_Warp_PrevWorld = World_Num (where you're coming FROM)

	; Clears out map objects 
	LDY #(MAPOBJ_TOTAL-1) ; Y = (MAPOBJ_TOTAL-1)
	LDA #MAPOBJ_EMPTY ; A = MAPOBJ_EMPTY
PRG011_A3D0:
	STA Map_Objects_IDs,Y
	DEY		 ; Y--
	BPL PRG011_A3D0	 ; If Y >= 0, loop..

	LDA #$08	 
	STA World_Num	 		; World_Num = 8 (World 9)

	LDA #0
	STA Map_Prev_XOff,X
	STA Map_Prev_XHi,X

	INC <Map_WarpWind_FX		; Next state...

	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


	; Map landing destinations, by world
	;               1    2    3    4    5    6    7    8    9    Z
StarRoad_DestY:	.byte  96,  64,  32,  64,  96, 128, 160, 128,   0,  96
StarRoad_DestX:	.byte  64,  96, 128, 160, 192, 160, 128,  96,   0, 128


WWFX_WarpIslandInit:

	; Set Player's X
	LDY Map_Warp_PrevWorld
	LDX Player_Current	; X = Player_Current

	LDA StarRoad_DestX,Y
	STA <World_Map_X,X

	LDA #0
	STA <World_Map_XHi,X

	; Star Road song
	LDA #MUS2A_SKY
	STA Sound_QMusic2

	; World specific bank
	LDX #145
	STX PatTable_BankSel+4

	; Purge map objects!
	LDX #(MAPOBJ_TOTAL-1)
	LDA #MAPOBJ_EMPTY
WWFXWII_NixMapObjsLoop:
	STA Map_Objects_IDs,X

	DEX
	BPL WWFXWII_NixMapObjsLoop

	INC <Map_WarpWind_FX	; Next state...

	RTS		 ; Return

WWFX_WarpLanding:
	LDA #$00	 
	STA Map_ReturnStatus 	; Map_ReturnStatus = 0 (was just set to 3?)

	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld (reassigned not two instructions later!)
	LDX Player_Current	; X = Player_Current

	LDA <World_Map_Y,X
	ADD #4
	STA <World_Map_Y,X
	CMP StarRoad_DestY,Y
	BNE SRPlayer_NotLanded

	; Stop twirling
	LDA #0
	STA <World_Map_Twirl

	LDA <Map_WarpWind_FX
	BPL WWFX_NotWZeroUnlock		; If not World Zero unlock, jump to WWFX_NotWZeroUnlock
	
	; World Zero unlock has more to go...
	INC <Map_WarpWind_FX
	BNE SRPlayer_NotLanded	; Jump (technically always) to SRPlayer_NotLanded

WWFX_NotWZeroUnlock:
	; Otherwise, shut it down!
	LDA #$00	 
	STA <Map_WWOrHT_Cnt
	STA <Map_WarpWind_FX

SRPlayer_NotLanded:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back



MO_HandTrap:
	LDA Map_HandState
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word HT_Init
	.word HT_Flash
	.word HT_GrabPlayer

HT_Init:
	LDX Player_Current
	LDA <World_Map_Y,X
	STA Map_PlyrSprOvrY	; Reset Map_PlyrSprOvrY to the Player's current Y

	ADD #16
	STA <Map_WWOrHT_Y	; Start 16 pixels beneath Player

	; Match Player's X
	LDA <World_Map_XHi,X	 
	STA <Map_HandTrap_XHi	
	LDA <World_Map_X,X
	STA <Map_WWOrHT_X

	INC Map_HandState		; Next state...
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back

HT_Flash:
	JSR WarpWhistle_Flash	 	; Reused flashing effect

	LDA <Map_WWOrHT_Cnt
	BNE PRG011_A494	 		; If Map_WWOrHT_Cnt <> 0, the effect is not over, jump to PRG011_A494

	INC Map_HandState	 	; Next state...

	LDA #SND_LEVELRISE	 
	STA Sound_QLevel1		; "Rising" sound

PRG011_A494:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


HT_GrabPlayer:
	LDA #$01
	STA <Temp_Var1			; Temp_Var1 = 1

	JSR HT_DoRaiseAndFall	 	; Raise hand, take Player down with it

	LDA <Map_WWOrHT_Cnt
	CMP #32 
	BNE PRG011_A4B8	 		; If Map_WWOrHT_Cnt <> 32, jump to PRG011_A4B8

	LDA #$10
	STA Map_Operation	 	; Map_Operation = $10 (enter level)

	LDX Player_Current
	LDA #$00	 
	STA Map_Player_SkidBack,X	; Map_Player_SkidBack = 0
	STA World_EnterState		; World_EnterState = 0
	STA Map_HandState	 	; The multipurpose state variable is reset
	RTS		 		; Return...


PRG011_A4B8:
	JSR WorldMap_UpdateAndDraw	; Do WorldMap_UpdateAndDraw

	LDX Player_Current
	LDA <World_Map_Y,X
	ADD #16
	STA <Temp_Var1		 	; Temp_Var1 = Player's map Y + 16

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	STA <Temp_Var2		 	; Temp_Var2 = Player's map X - Horz_Scroll

	LDA #$00
	STA <Temp_Var3		 	; Temp_Var3 = 0
	JMP PRG011_A503	 		; Jump to PRG011_A503

	; Hand Trap raises for 16 ticks (-1), then falls (1)
HT_RaiseFall:	.byte -1, 1

HT_DoRaiseAndFall:
	LDA <Counter_1
	AND #$01	
	BNE PRG011_A4FC	 	; Every other tic, jump to PRG011_A4FC

	; More specifically, 16 tics for the hand to come up, 16
	; tics for the hand to go down...
	LDA <Map_WWOrHT_Cnt
	AND #$10	 	; Every 16 counter tics...
	LSR A	
	LSR A	
	LSR A	
	LSR A		 	; Amounts to 0/1 every 16 tics
	TAY		 	; Y = 0 or 1
	LDX Player_Current	; X = Player_Current

	LDA <Map_WWOrHT_Y
	ADD HT_RaiseFall,Y
	STA <Map_WWOrHT_Y	; Hand trap's Y += HT_RaiseFall[Y]

	INC <Map_WWOrHT_Cnt
	LDA <Map_WWOrHT_Cnt
	AND #$10
	BEQ PRG011_A4FC	 	; If hand is still raising (pre 16 ticks), jump to PRG011_A4FC

	; As hand falls, it takes Player down with it!
	LDA <Map_WWOrHT_Y	
	STA Map_PlyrSprOvrY	

PRG011_A4FC:
	RTS		 	; Return...

	; NOTE: These values are shared with the HAND TRAP of World 8
Map_WW_Pal:	.byte $01, $03	; The former is a BROWN color (hand trap), the latter is its white color
Map_WW_Pattern:
	.byte $15, $FF	; Frame 0 (Hand, Wind)
	.byte $19, $FF	; Frame 1 (Hand, Wind)

PRG011_A503:

	; This masks the bottom of the hand by deliberately drawing 8 junk sprites
	; 16 pixels beneath it to force the hardware to stop drawing at that 
	; scanline; it's dirty, but effective -- so long as no other sprites
	; are on that scanline to be noticeably effected :)
	LDX #$07	 ; X = 7
PRG011_A505:
	TXA		 
	ASL A		 
	ASL A		 
	TAY		 	; Y = X << 2 (* 4, or for 7 sprites...)

	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y	; Store Y

	LDA #$27	 
	STA Sprite_RAM+$01,Y	; Pattern

	LDA #%00100011
	STA Sprite_RAM+$02,Y	; Place sprite behind BG, flipped horizontally and vertically

	LDA #$00	 
	STA Sprite_RAM+$03,Y	; X = 0

	DEX		 	; X--
	BPL PRG011_A505	 	; While X >= 0, loop!

WarpWindHandTrap_Draw:
	LDX <Temp_Var3		; X = Temp_Var3 (warp wind palette)

	; The warp wind sprite Y
	LDA <Map_WWOrHT_Y	; A = Map_WWOrHT_Y
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64

	LDA <Temp_Var3		; A = Temp_Var3
	BEQ PRG011_A544	 	; If Temp_Var3 = 0, jump to PRG011_A544 (AFAIK, this is never the case)

	LDA Map_PlyrSprOvrY
	CMP #$f8
	BNE PRG011_A56B	 	; If Map_PlyrSprOvrY <> $f8, jump to PRG011_A56B

	; Disable Player map sprite!
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88
	STA Sprite_RAM+$8C
	STA Sprite_RAM+$90

	JMP PRG011_A56B	 	; Jump to PRG011_A56B...

PRG011_A544:
	; Otherwise, not disabling Player map sprite...

	LDA <Map_WWOrHT_Cnt
	AND #$10
	BEQ PRG011_A56B

	; Restore Player's map sprite Y
	LDA Map_PlyrSprOvrY
	STA Sprite_RAM+$8C
	STA Sprite_RAM+$90
	SUB #16
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88

	LDA Sprite_RAM+$85
	CMP #$27	 
	BNE PRG011_A56B	 	; If the pattern in use is not $27, jump to PRG011_A56B

	; Otherwise, disable half the sprite
	LDA #$f8	 
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88

PRG011_A56B:
	; Set the warp wind's attributes (white palette)
	LDA Map_WW_Pal,X
	STA Sprite_RAM+$62
	STA Sprite_RAM+$66

	; Set the warp wind's X
	LDA <Temp_Var2		; Map_WWOrHT_X
	STA Sprite_RAM+$63
	ADD #$08	 
	STA Sprite_RAM+$67	; Map_WWOrHT_X + 8

	LDY Map_WW_Pattern,X	; Get the pattern for the wind/hand

	LDA <Map_WWOrHT_Cnt
	AND #$10	 
	BEQ PRG011_A58B	 
	LDY Map_WW_Pattern+2,X	; Every 16 tics, use the second frame

PRG011_A58B:
	; Store the pattern for the first sprite
	STY Sprite_RAM+$61

	INY	
	INY			; Pattern += 2
	STY Sprite_RAM+$65	; Store the pattern for the second sprite

	LDA <Map_WWOrHT_Dir
	BEQ PRG011_A5AA	 	; If Map_WWOrHT_Dir = 0, jump to PRG011_A5AA

	; Flip the wind patterns!
	STY Sprite_RAM+$61
	DEY		
	DEY		
	STY Sprite_RAM+$65

	; Set the flip attribute
	LDA Sprite_RAM+$62	; Get old attributes
	ORA #$40	 	; H-Flip attr
	STA Sprite_RAM+$62	
	STA Sprite_RAM+$66	

PRG011_A5AA:

	; This draw a couple high-priority sprites at the border's edge 
	; using border patterns to clip the warp wind sprite!

	; Sprite set to Y
	LDA <Map_WWOrHT_Y
	STA Sprite_RAM+$00
	STA Sprite_RAM+$04

	; Pattern 1
	LDA #$01	 
	STA Sprite_RAM+$01

	; Pattern $B
	LDA #$0b	 
	STA Sprite_RAM+$05

	; Attributes
	LDA #$01	 
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06

	; And X = 1
	STA Sprite_RAM+$07

	; And X = 8
	LDA #$08	 
	STA Sprite_RAM+$03

	LDA <Temp_Var2	 ; MapWWOrHT_X
	AND #$80	 
	BEQ PRG011_A5DC	 ; If MapWWOrHT_X is not in the right half of the screen, jump to PRG011_A5DC (RTS)

	; Otherwise, put the border patch on the RIGHT side!
	LDA #$f0	
	STA Sprite_RAM+$03
	LDA #$f8	 
	STA Sprite_RAM+$07

PRG011_A5DC:
	RTS		 ; Return


GameOver_TwirlToStart:
	LDX Player_Current	 

	LDA <Map_SkidBack
	BNE PRG011_A63D	 ; If Map_SkidBack is set, jump to PRG011_A63D

	LDY World_Num	 ; Y = World_Num

	LDA <World_Map_Y,X
	SUB Map_Y_Starts,Y
	STA <Map_Skid_DeltaY

	LDA <World_Map_X,X
	SUB #$20
	STA <Map_Skid_DeltaX

	LDA #$00
	STA <Map_Skid_TravDirs
	STA <Map_Skid_DeltaFracX
	STA <Map_Skid_DeltaFracY

	LDA <World_Map_X,X
	CMP #32
	BGE PRG011_A610	 ; If Player's Map X >= 32 (the common start X of all maps), jump to PRG011_A610

	; Player's Map X < 32...

	; Set bit 0 on Map_Skid_TravDirs (travel right instead of left)
	LDA #$01
	STA <Map_Skid_TravDirs

	; Negate Map_Skid_DeltaX
	LDA #$ff
	EOR <Map_Skid_DeltaX
	TAY
	INY
	STY <Map_Skid_DeltaX

PRG011_A610:
	LDY World_Num	 ; Y = World_Num

	LDA <World_Map_Y,X
	CMP Map_Y_Starts,Y
	BGE PRG011_A628	 ; If Player's Map Y >= the starting Y of the map, jump to PRG011_A628

	; Player's Map Y < the starting Y of the map...

	; Negate Map_Skid_DeltaY
	LDA #$ff
	EOR <Map_Skid_DeltaY
	TAY
	INY
	STY <Map_Skid_DeltaY

	; Set bit 1 on Map_Skid_TravDirs (travel down instead of up)
	LDA <Map_Skid_TravDirs
	ORA #$02
	STA <Map_Skid_TravDirs

PRG011_A628:

	; Lowest 4 bits of Map_Skid_DeltaY/X -> Upper 4 bits of Map_Skid_DeltaFracY/X
	LDY #$04	 ; Y = 4
PRG011_A62A:
	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaY		; Bit 0 of Map_Skid_DeltaY -> carry
	ROR <Map_Skid_DeltaFracY		; Set as bit 7 of Map_Skid_DeltaFracY

	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaX		; Bit 0 of Map_Skid_DeltaX -> carry
	ROR <Map_Skid_DeltaFracX		; Set as bit 7 of Map_Skid_DeltaFracX

	DEY			; Y--
	BPL PRG011_A62A		; While Y >= 0, loop!

	; Map_Skid_Counter = $20
	LDA #$20
	STA <Map_Skid_Counter

	INC <Map_SkidBack		 ; Set Map_SkidBack

PRG011_A63D:

	; Skid sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A65E	 ; If Player is traveling left, jump to PRG011_A65E

	; Traveling to the right...

	; Map_Skid_FracX += Map_Skid_DeltaFracX
	LDA <Map_Skid_FracX
	ADD <Map_Skid_DeltaFracX
	STA <Map_Skid_FracX

	; Add and carry into the full X
	LDA <World_Map_X,X
	ADC <Map_Skid_DeltaX
	STA <World_Map_X,X

	; Any additional carry into Map XHi
	LDA <World_Map_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	JMP PRG011_A671	 ; Jump to PRG011_A671

PRG011_A65E:

	; Traveling to the left

	; Map_Skid_FracX -= Map_Skid_DeltaFracX
	LDA <Map_Skid_FracX
	SUB <Map_Skid_DeltaFracX
	STA <Map_Skid_FracX

	; Subtract and carry into the full X
	LDA <World_Map_X,X
	SBC <Map_Skid_DeltaX
	STA <World_Map_X,X

	; Any additional carry into Map XHi
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

PRG011_A671:
	LDA <Map_Skid_TravDirs
	AND #$02
	BEQ PRG011_A687	 ; If Player is traveling up, jump to PRG011_A65E

	; Traveling downward

	; Map_Skid_FracY += Map_Skid_DeltaFracY
	LDA <Map_Skid_FracY
	ADD <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	; Add and carry into the full Y
	LDA <World_Map_Y,X
	ADC <Map_Skid_DeltaY
	STA <World_Map_Y,X

	JMP PRG011_A694	 ; Jump to PRG011_A694

PRG011_A687:

	; Traveling downward

	; Map_Skid_FracY -= Map_Skid_DeltaFracY
	LDA <Map_Skid_FracY
	SUB <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	; Subtract and carry into the full Y
	LDA <World_Map_Y,X
	SBC <Map_Skid_DeltaY
	STA <World_Map_Y,X

PRG011_A694:
	DEC <Map_Skid_Counter	; Map_Skid_Counter--
	BNE PRG011_A6BC	 ; If Map_Skid_Counter <> 0, jump to PRG011_A6BC

PRG011_A698:
	; GameOver_State = 8 (we've landed, we're done)
	LDA #$08
	STA GameOver_State

	LDX Player_Current	 ; X = Player_Current

	LDA #$00
	STA <Map_SkidBack
	STA World_Map_Twirl,X	 ; Twirling is done
	STA Map_Prev_XOff2,X
	STA Map_Prev_XHi2,X

	; Set the previous values at the twirl landing spot

	; Map_Previous_Y = World_Map_Y
	LDA <World_Map_Y,X
	STA Map_Previous_Y,X

	; Map_Previous_X/Hi = Map_Previous_X/Hi
	LDA <World_Map_XHi,X
	STA Map_Previous_XHi,X
	LDA <World_Map_X,X
	STA Map_Previous_X,X

PRG011_A6BC:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


GameOver_TwirlFromAfar:
	LDX Player_Current	 ; X = Player_Current

	; Map X -= 2 (Player flying from way off goes directly left)
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	BNE PRG011_A6E4	 ; If Player Map X <> Horz_Scroll, jump to PRG011_A6E4

	LDA #$00
	STA Map_Prev_XOff,X
	STA Map_Prev_XHi,X
	STA Map_Entered_XHi,X

	INC GameOver_State	 ; GameOver_State++

PRG011_A6E4:

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	JSR Map_DrawBorderForPlayer	 ; Draw border sprites to cover twirling Player

	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


Map_DrawBorderForPlayer:
	LDX Player_Current	; X = Player_Current

	; Set Map Border Sprite Y
	LDA <World_Map_Y,X
	STA Sprite_RAM+$00
	STA Sprite_RAM+$04

	; Set Map Border Sprite left Pattern
	LDA #$01
	STA Sprite_RAM+$01

	; Set Map Border Sprite right Pattern
	LDA #$0b
	STA Sprite_RAM+$05

	; Set Map Border Sprite attributes
	LDA #SPR_PAL0
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06

	; Set Map Border left Sprite X
	STA Sprite_RAM+$07

	; Set Map Border right Sprite X
	LDA #$08
	STA Sprite_RAM+$03

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	AND #$80
	BEQ PRG011_A727	 ; If difference is positive, jump to PRG011_A727 (RTS)

	; Set Map Border Sprite X
	LDA #240
	STA Sprite_RAM+$03
	LDA #248
	STA Sprite_RAM+$07

PRG011_A727:
	RTS		 ; Return


GameOver_AlignToStartY
	LDX Player_Current	 ; X = Player_Current

	; Enter from right side
	LDA #240
	STA <World_Map_X,X

	LDY World_Num		 ; Y = World_Num
	LDA Map_Y_Starts,Y	 ; Get start Y
	STA <World_Map_Y,X	 ; Set Player at start Y

	INC GameOver_State	 ; GameOver_State++
	JMP PRG011_A6E4	 	; Jump to PRG011_A6E4

GameOver_ReturnToStartX:
	LDX Player_Current	 ; X = Player_Current

	; Player's Map X -= 2 (skidding towards Start panel)
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X

	CMP #$20
	BNE PRG011_A74E	 ; If Player is not at $20 (fixed start point X), jump to PRG011_A74E

	JMP PRG011_A698	 ; Jump to PRG011_A698

PRG011_A74E:

	; Play skidding sound (actually pointless from where it jumps)
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	JMP PRG011_A6E4	 ; Jump to PRG011_A6E4

MO_SkidToPrev:
	LDX Player_Current	 ; X = Player_Current

	LDA <Map_SkidBack
	BEQ PRG011_A760	 ; If Map_SkidBack is not set, jump to PRG011_A760

	JMP PRG011_A834	 ; Jump to PRG011_A834

PRG011_A760:

	; Checks all map objects to see if Player has died while in a map object

	LDY #(MAPOBJ_TOTAL-1)	; Y = (MAPOBJ_TOTAL-1)
PRG011_A762:
	LDA Map_Objects_IDs,Y
	BNE PRG011_A76D	 ; If this map object slot is not empty, jump to PRG011_A76D

PRG011_A767:
	DEY		 ; Y--
	BPL PRG011_A762	 ; While Y >= 0, loop!
	JMP PRG011_A79D	 ; Jump to PRG011_A79D

PRG011_A76D:

	; If Player is not on top of the airship, jump to PRG011_A767
	LDA <World_Map_Y,X
	CMP Map_Objects_Y,Y
	BNE PRG011_A767

	LDA <World_Map_XHi,X
	CMP Map_Objects_XHi,Y
	BNE PRG011_A767

	LDA <World_Map_X,X
	CMP Map_Objects_XLo,Y
	BNE PRG011_A767

	;LDA Map_Objects_IDs,Y
	;CMP #MAPOBJ_COINSHIP
	;BNE PRG011_A767	 ; If this is NOT a Coin Ship, jump to PRG011_A767

	; Player was on top of a coin ship and DIED!!, return to Hammer Bro!
	;LDA #MAPOBJ_HAMMERBRO
	;STA Map_Objects_IDs,Y

	JMP PRG011_A767	 ; Jump to PRG011_A767

PRG011_A79D:

	; Player died on top of something not an Airship or a Coin ship...

	LDA Map_Previous_Y,X
	SUB <World_Map_Y,X
	STA <Map_Skid_DeltaY

	LDA Map_Previous_XHi,X
	CMP <World_Map_XHi,X
	BEQ PRG011_A7B0	 ; If Player is on the same map screen as he was before, jump to PRG011_A7B0
	BGE PRG011_A7B7	 ; If Player is on a map screen to the right, jump to PRG011_A7B7
	BLT PRG011_A7CB	 ; If Player is on a map screen to the left, jump to PRG011_A7CB

PRG011_A7B0:

	; Player is on the same map screen he was previously...

	LDA Map_Previous_X,X
	CMP <World_Map_X,X
	BLT PRG011_A7CB	 ; If Player is to the left from where he was, jump to PRG011_A7CB

PRG011_A7B7:

	; Player is to the right from where he was...

	; Map_Skid_DeltaFracX starts as straight difference in X, to be corrected
	LDA Map_Previous_X,X
	SUB <World_Map_X,X
	STA <Map_Skid_DeltaFracX

	; Map_Skid_DeltaX starts as straight difference in X Hi
	LDA Map_Previous_XHi,X
	SBC <World_Map_XHi,X	
	STA <Map_Skid_DeltaX

	; Do not set bit 0 on Map_Skid_TravDirs (travel left instead of right)
	LDY #$00	 ; Y = 0

	JMP PRG011_A7DC	 ; Jump to PRG011_A7DC

PRG011_A7CB:

	; Player is to the left from where he was

	; Map_Skid_DeltaFracX starts as straight difference in X, to be corrected
	LDA <World_Map_X,X
	SUB Map_Previous_X,X
	STA <Map_Skid_DeltaFracX

	; Map_Skid_DeltaX starts as straight difference in X Hi
	LDA <World_Map_XHi,X
	SBC Map_Previous_XHi,X
	STA <Map_Skid_DeltaX

	; Set bit 0 on Map_Skid_TravDirs (travel right instead of left)
	LDY #$01	 ; Y = 1

PRG011_A7DC:
	STY <Map_Skid_TravDirs	 ; Set Map_Skid_TravDirs

	LDA #$00
	STA <Map_Skid_FracX
	STA <Map_Skid_DeltaFracY

	LDA Map_Previous_Y,X
	CMP <World_Map_Y,X
	BGE PRG011_A7F9	 ; If Player is lower than he was before, jump to PRG011_A7F9

	; Player was higher than before... negate Map_Skid_DeltaY
	LDA #$ff
	EOR <Map_Skid_DeltaY
	TAY
	INY
	STY <Map_Skid_DeltaY

	; Set bit 1 on Map_Skid_TravDirs (travel down instead of up)
	LDA <Map_Skid_TravDirs
	ORA #$02
	STA <Map_Skid_TravDirs

PRG011_A7F9:
	LDA <Map_Skid_DeltaX
	BNE PRG011_A817	 ; If Player is left/right of where he was before, jump to PRG011_A817

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	TAY

	LDA <Map_Skid_TravDirs
	AND #$01
	BNE PRG011_A811	 ; If Player is traveling right, jump to PRG011_A811

	TYA
	ADD <Map_Skid_DeltaFracX
	BCC PRG011_A81D	 ; If no carry, jump to PRG011_A81D
	BCS PRG011_A817	 ; Otherwise, jump to PRG011_A817

PRG011_A811:
	TYA
	SUB <Map_Skid_DeltaFracX
	BCS PRG011_A81D	 ; If carry set, jump to PRG011_A81D

PRG011_A817:
	INC Map_Operation	 ; Map_Operation++ (go to the "twirl from afar" state)
	JMP MO_SkidToPrevAfar	 ; Jump to MO_SkidToPrevAfar

PRG011_A81D:

	; Lowest 4 bits of Map_Skid_DeltaY/X -> Upper 4 bits of Map_Skid_DeltaFracY/X
	LDY #$04	 ; Y = 4
PRG011_A81F:
	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaY		; Bit 0 of Map_Skid_DeltaY -> carry
	ROR <Map_Skid_DeltaFracY	; Set as bit 7 of Map_Skid_DeltaFracY

	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaX		; Bit 0 of Map_Skid_DeltaX -> carry
	ROR <Map_Skid_DeltaFracX	; Set as bit 7 of Map_Skid_DeltaFracX; Bit 0 -> Carry
	ROR <Map_Skid_FracX		; Set as bit 7 of <Map_Skid_FracX

	DEY			; Y--
	BPL PRG011_A81F		; While Y >= 0, loop!

	; Map_Skid_Counter = $20
	LDA #$20
	STA <Map_Skid_Counter

	INC <Map_SkidBack		 ; Set Map_SkidBack

PRG011_A834:
	LDA <Map_Skid_Counter
	BEQ PRG011_A891	 ; If Map_Skid_Counter = 0, jump to PRG011_A891

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	LDA <Map_Skid_TravDirs
	AND #$01
	BNE PRG011_A859	 ; If Player is traveling right, jump to PRG011_A859

	LDA <Map_Skid_FracCarry
	ADD <Map_Skid_FracX
	STA <Map_Skid_FracCarry

	LDA <World_Map_X,X
	ADC <Map_Skid_DeltaFracX
	STA <World_Map_X,X

	LDA <World_Map_XHi,X
	ADC <Map_Skid_DeltaX
	STA <World_Map_XHi,X

	JMP PRG011_A86C	 ; Jump to PRG011_A86C

PRG011_A859:
	LDA <Map_Skid_FracCarry
	SUB <Map_Skid_FracX
	STA <Map_Skid_FracCarry

	LDA <World_Map_X,X
	SBC <Map_Skid_DeltaFracX
	STA <World_Map_X,X

	LDA <World_Map_XHi,X
	SBC <Map_Skid_DeltaX
	STA <World_Map_XHi,X

PRG011_A86C:
	LDA <Map_Skid_TravDirs
	AND #$02
	BNE PRG011_A882	 ; If Player is traveling down, jump to PRG011_A882

	LDA <Map_Skid_FracY
	ADD <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	LDA <World_Map_Y,X
	ADC <Map_Skid_DeltaY
	STA <World_Map_Y,X

	JMP PRG011_A88F	 ; Jump to PRG011_A88F

PRG011_A882:
	LDA <Map_Skid_FracY
	SUB <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	LDA <World_Map_Y,X
	SBC <Map_Skid_DeltaY
	STA <World_Map_Y,X

PRG011_A88F:
	DEC <Map_Skid_Counter		 ; Map_Skid_Counter--

PRG011_A891:
	JSR WorldMap_UpdateAndDraw	 ; Update and draw map

	LDA <Map_Skid_Counter
	ORA Map_March_Count+1	; <--- Airship's movement counter
	ORA Map_Pan_Count
	BNE PRG011_A8C8	 ; If skidding, the airship is moving, or the map is panning, jump to PRG011_A8C8 (RTS)

	; Map_Operation = $0B (Hammer bros march around)
	LDA #$0b
	STA Map_Operation

	LDX Player_Current	 ; X = Player_Current

	; Ensure Player is precisely at his previous position
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X
	STA Map_Entered_X,X

	LDA Map_Prev_XOff2,X
	STA Map_Prev_XOff,X

	LDA Map_Prev_XHi2,X
	STA Map_Prev_XHi,X

	; Clear skid vars
	LDA #$00
	STA <Map_SkidBack
	STA Map_Player_SkidBack,X

PRG011_A8C8:
	RTS		 ; Return

MO_SkidToPrevAfar:
	LDX Player_Current	 ; X = Player_Current

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A8E9	 ; If Player is traveling left, jump to PRG011_A8E9

	; Far away Player skidding directly to the left; Map X -= 2
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	BEQ PRG011_A8FF	 ; If Player hit left edge, jump to PRG011_A8FF

	JMP PRG011_A90E	 ; Jump to PRG011_A90E

PRG011_A8E9:

	; Far away Player skidding directly to the right; Map X += 2
	LDA <World_Map_X,X
	ADD #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	CMP #240
	BNE PRG011_A90E	 ; If Player has not hit right edge, jump to PRG011_A90E

PRG011_A8FF:

	; Player hit edge of the screen

	LDA Map_Prev_XOff2,X
	STA Map_Prev_XOff,X

	LDA Map_Prev_XHi2,X
	STA Map_Prev_XHi,X

	INC Map_Operation	 ; Map_Operation++

PRG011_A90E:

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	JSR Map_DrawBorderForPlayer	 ; Draw border to block Player sprite

	JMP WorldMap_UpdateAndDraw	 ; Update and draw map and don't come back!

MO_SkidAfarPrep:
	LDX Player_Current	 ; X = Player_Current

	; Set Player's Y and XHi to their previous values
	LDA Map_Previous_Y,X
	STA <World_Map_Y,X
	LDA Map_Previous_XHi,X
	STA <World_Map_XHi,X

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A946	 ; If Player is traveling left, jump to PRG011_A946

	; Traveling rightward

	LDY #240	 ; Y = 240

	LDA <Horz_Scroll
	BEQ PRG011_A941		; If horizontal scroll = 0, jump to PRG011_A941

	LDA Map_Previous_X,X
	ADD <Horz_Scroll
	LDA Map_Previous_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	LDY #112	 ; Y = 112

PRG011_A941:
	STY <World_Map_X,X ; Set proper World Map X to begin skidding from

	JMP PRG011_A95B	 ; Jump to PRG011_A95B

PRG011_A946:

	; Traveling leftward

	LDA <Horz_Scroll
	BEQ PRG011_A957	 ; If Horz_Scroll = 0, jump to PRG011_A957

	LDA Map_Previous_X,X
	SUB <Horz_Scroll
	LDA Map_Previous_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

PRG011_A957:
	LDA <Horz_Scroll
	STA <World_Map_X,X

PRG011_A95B:

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	INC Map_Operation	 ; Map_Operation++

	JMP PRG011_A90E	 ; Jump to PRG011_A90E

MO_SkidAfarFinish:
	LDX Player_Current	 ; X = Player_Current

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A986	 ; If Player is traveling left, jump to PRG011_A946

	; Player traveling left

	; Map X -= 2
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	CMP Map_Previous_X,X
	BEQ PRG011_A99A	 ; If Player Map X is at his previous X, jump to PRG011_A99A

	JMP PRG011_A9B5	 ; Otherwise, jump to PRG011_A9B5 (indirect to PRG011_A90E)

PRG011_A986:

	; Player traveling right

	; Map X += 2
	LDA <World_Map_X,X
	ADD #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	CMP Map_Previous_X,X
	BNE PRG011_A9B5	 ; If Player Map X is not at his previous X, jump to PRG011_A9B5 (indirect to PRG011_A90E)

PRG011_A99A:

	; Player has finally arrived at his "previous" position, completing the skid back from afar

	; Map_Operation = $0B (Hammer bros march around)
	LDA #$0b
	STA Map_Operation

	; Ensure Player is precisely at his previous position
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X
	STA Map_Entered_X,X

	LDA #$00
	STA <Map_SkidBack
	STA Map_Player_SkidBack,X

PRG011_A9B5:
	JMP PRG011_A90E	 ; Jump to PRG011_A90E

	; Indexed by Map_ClearLevelFXCnt * 2
Map_ClearLevelFXPatterns:

	; "Poof" effect
	.byte $2B, $3D
	.byte $2B, $39
	.byte $2B, $35
	.byte $2B, $31
	.byte $2D, $2F
	.byte $2D, $2F

	; "Flip" effect
	.byte $25, $25	; 6
	.byte $27, $27	; 7
	.byte $25, $25	; 8

	; This just forces "poof" completion on the following tiles (in quadrant zero, since all other
	; quadrants always "poof" except fortress tiles)
Map_ForcePoofTiles:
	.byte TILE_TOADHOUSE, TILE_HANDTRAP, TILE_DANCINGFLOWER, TILE_ALTTOADHOUSE
Map_ForcePoofTiles_End

	; These are the select few tiles that "completing" their associated area
	; will not cause the Player to end their turn (in a 2P game)
Map_NoLoseTurnTiles:
	.byte TILE_TOADHOUSE, TILE_ALTTOADHOUSE, TILE_PIPE, TILE_QBLOCK
Map_NoLoseTurnTiles_End


	; SB: Special tiles which "complete" from tiles in this table to matched tile in the next table
	; Keep in sync with PRG012 Map_Removable_Tiles / Map_RemoveTo_Tiles
Map_SpecComp_Tiles:	
	.byte TILE_FORT				; 0
	.byte TILE_ALTFORT			; 1
	.byte TILE_LARGEFORT		; 2
	.byte TILE_GHOSTHOUSE		; 3
	.byte TILE_TOADHOUSE		; 4
	.byte TILE_QBLOCK			; 5
	.byte TILE_AIRSHIP			; 6
	.byte TILE_HANDTRAP			; 7
	.byte TILE_PYRAMID			; 8
	.byte TILE_BOWSERCASTLELR	; 9
Map_SpecComp_Tiles_End
Map_SpecComp_TilesComp:	
	.byte TILE_FORTRUBBLE		; 0
	.byte TILE_ALTRUBBLE		; 1
	.byte TILE_LARGEFORT_RUBBLE	; 2
	.byte TILE_GHOSTHOUSE_COMP	; 3
	.byte TILE_BONUS_COMP		; 4
	.byte TILE_BONUS_COMP		; 5
	.byte TILE_AIRSHIP_COMP		; 6
	.byte TILE_HANDTRAP_COMP	; 7
	.byte TILE_PYRAMID_COMP		; 8
	.byte TILE_BOWSERCASTLELRC	; 9

MO_DoLevelClear:
	; SB: Forcing pipeways even without pipe tiles
	LDA Map_WasInPipeway
	BEQ MDLC_WasNotInPipeway
	
	INC Map_NoLoseTurn	 ; Set Map_NoLoseTurn
	BNE PRG011_AA26
	
MDLC_WasNotInPipeway:

	; Check if this one of the tiles that does not cause a Player to lose their turn
	JSR Map_GetTile	 	; Get current tile Player is standing on

	LDX #(Map_NoLoseTurnTiles_End - Map_NoLoseTurnTiles - 1)
PRG011_A9F0:
	CMP Map_NoLoseTurnTiles,X
	BEQ PRG011_A9FB	 ; If this tile matches one of the "don't lose a turn" tiles, jump to PRG011_A9FB

	DEX		 ; X--
	BPL PRG011_A9F0	 ; While X >= 0, loop

	JMP PRG011_A9FE	 ; Jump to PRG011_A9FE

PRG011_A9FB:
	INC Map_NoLoseTurn	 ; Set Map_NoLoseTurn

PRG011_A9FE:
	JSR Map_GetTile	 	; Get current tile Player is standing on

	AND #$c0	 	; Only keeping the upper 2 bits of it
	CLC		 
	ROL A		 
	ROL A		 
	ROL A		 
	TAY		 	; Y = upper 2 bits of map tile shifted down; the "tile quadrant"

	LDX #(Map_ForcePoofTiles_End - Map_ForcePoofTiles - 1)
	LDA <World_Map_Tile
PRG011_AA0C:
	CMP Map_ForcePoofTiles,X
	BEQ PRG011_AA19	 ; If this tile matches, jump to PRG011_AA19

	DEX		 ; X--
	BPL PRG011_AA0C	 ; While X >= 0, loop

	; This tile is not in the Map_ForcePoofTiles set...

	CMP Tile_AttrTable+4,Y
	BLT PRG011_AA26	 ; If this tile is not possibly an "enterable" tile, jump to PRG011_AA26

	; This is one of the Map_ForcePoofTiles tiles, or at least a (potentially) enterable one

PRG011_AA19:
	LDA <Map_ClearLevelFXCnt
	BEQ PRG011_AA29	 ; If "map poof" is not currently in use, jump to PRG011_AA29

	LDA <Counter_1
	AND #$03
	BEQ PRG011_AA4C	 ; 1:4 ticks jump to PRG011_AA4C

PRG011_AA23:
	JMP PRG011_AB1B	 ; Otherwise, jump to PRG011_AB1B

PRG011_AA26:
	JMP PRG011_AB61	 ; Jump to PRG011_AB61

PRG011_AA29:

	; Map poof is not in use...

	;CPY #$00
	;BNE PRG011_AA39	 ; If tile is NOT quadrant 0 ($00-$3F), jump to PRG011_AA39

	; Quadrant 0 tiles only...

	; Map_ClearLevelFXCnt = 7 (begin panel flipover effect)
	LDA #$07
	STA <Map_ClearLevelFXCnt

	; Play "flip over" sound
	LDA #SND_MAPINVENTORYFLIP
	STA Sound_QMap

	JMP PRG011_AA23	 ; Jump to PRG011_AA23 (PRG011_AB1B)



	; "Poof" effect starts Map_ClearLevelFXCnt at 1, which it will be shortly...

PRG011_AA4C:

	; Updating whatever effect we're performing

	INC <Map_ClearLevelFXCnt	 ; Map_ClearLevelFXCnt++

	; Remember these compares are immediately following the INC...
	LDA <Map_ClearLevelFXCnt
	CMP #$07
	BEQ MapClear_PoofOver

	CMP #$0a
	BNE PRG011_AA23	 ; If Map_ClearLevelFXCnt <> $0A (end of completed level panel flip), jump to PRG011_AA23 (PRG011_AB1B)

PRG011_AA58:

	; Map_ClearLevelFXCnt = 0 (effect over)
	LDA #$00
	STA <Map_ClearLevelFXCnt

MapClear_PoofOver:
	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_XHi,X
	ASL A		 ; 2 byte index
	TAY		 ; -> Y
	LDA Tile_Mem_Addr,Y	; Get tile address low for this map screen
	ADD #$f0	 	; Base map offset
	STA <Map_Tile_AddrL	; -> Map_Tile_AddrL

	LDA Tile_Mem_Addr+1,Y	; Get tile address high for this map screen
	ADC #$00	 	; Apply carry
	STA <Map_Tile_AddrH	; -> Map_Tile_AddrH

	; Calculate a row/column offset
	LDA <World_Map_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <World_Map_Y,X
	TAY		 ; -> 'Y'

	LDA [Map_Tile_AddrL],Y	 ; Get the tile here
	PHA		 ; Save tile value

	AND #%11000000
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAX		 ; X = tile quadrant * 2 (0, 2, 4, 6)

	LDA Player_Current
	BEQ PRG011_AA8C	 ; If Player is Mario, jump to PRG011_AA8C

	INX		 ; Otherwise, X++

PRG011_AA8C:
	PLA	; Restore tile value
	PHA	; Save tile

	; SB: If tile is $0/1x, it is a "primary level", which we have new "check mark" standard tiles for
	AND #$F0
	CMP #$20
	BGE Complete_NotPrimaryLevel	; If not a $0/1x tile, jump to Complete_NotPrimaryLevel

	; Primary level!  Restore tile...
	PLA

	; 'OR' to next row!
	ORA #$10
	BNE Complete_PrimaryLevel	; Jump (technically always) to Complete_PrimaryLevel

Complete_NotPrimaryLevel:
	PLA	; Discard saved tile

	; Other tile type replacements here...
	LDX #(Map_SpecComp_Tiles_End - Map_SpecComp_Tiles - 1)
Complete_OtherTile_Loop:
	CMP Map_SpecComp_Tiles,X
	BNE Complete_OtherTile_NotMatch ; If this tile isn't a match, jump to Complete_OtherTile_NotMatch

	; Matched tile!
	LDA Map_SpecComp_TilesComp,X
	BNE Complete_PrimaryLevel	; Jump (technically always) to Complete_PrimaryLevel

Complete_OtherTile_NotMatch:
	DEX	; X--
	BPL Complete_OtherTile_Loop	; While X >= 0, loop!

Complete_PrimaryLevel:
	STA [Map_Tile_AddrL],Y	; Set it in memory
	STA <World_Map_Tile	; ... as well as the tile detected

	; Backup 'Y', the tile offset
	TYA
	PHA

	JSR Map_MarkLevelComplete	 ; Mark this level as complete!

	; Keep Complete/secret bits as appropriate -> Temp_VarNP0 for MapCompletion_FixAdjPaths
	LDA Level_IsComplete
	AND #(MCOMP_COMPLETE | MCOMP_SECRET)
	STA Temp_VarNP0

	LDY Player_Current	 ; Y = Player_Current
	LDX <World_Map_X,Y	 ; X = Player Map X
	LDA World_Map_Y,Y	 ; A = Player Map Y

	; Commit tile change
	JSR Map_DrawTileChange

	; Restore 'Y'
	PLA
	TAY

	; Fix surrounding path tiles that have now been opened
	; (Temp_VarNP0 set above after Map_MarkLevelComplete)
	JSR MapCompletion_FixAdjPaths

	JMP PRG011_AB61	 ; Jump to PRG011_AB61

PRG011_AB1B:
	LDX Player_Current	 ; X = Player_Current

	; Copy Player's Map Y/X -> Temp_Var1/2
	LDA <World_Map_Y,X
	STA <Temp_Var1
	LDA <World_Map_X,X
	STA <Temp_Var2

	LDY <Map_ClearLevelFXCnt
	CPY #$07
	BLT PRG011_AB5B	 ; If Map_ClearLevelFXCnt < 7 (doing Fortress poof rather than panel flip), jump to PRG011_AB5B

	; Set "flip" sprite Y
	LDA <Temp_Var1
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64

	DEY		 ; Y--

	; Y *= 2 (two patterns per count)
	TYA
	ASL A
	TAY

	; Set the two patterns for the panel flip sprites
	LDA Map_ClearLevelFXPatterns,Y
	STA Sprite_RAM+$61
	STA Sprite_RAM+$65

	; Set left panel flip sprite attribute
	LDA #SPR_PAL3
	STA Sprite_RAM+$62

	; Set right panel flip sprite attribute
	LDA #(SPR_PAL3 | SPR_HFLIP)
	STA Sprite_RAM+$66

	; Set left panel flip sprite X
	LDA <Temp_Var2
	SUB <Horz_Scroll
	STA Sprite_RAM+$63

	; Set right panel flip sprite X
	ORA #$08
	STA Sprite_RAM+$67

PRG011_AB58:
	JMP PRG011_ABBE	 ; Jump to PRG011_ABBE

PRG011_AB5B:
	JSR Map_DrawClearLevelPoof	 ; Draw the "poof"
	JMP PRG011_ABCC	 ; Jump to PRG011_ABCC (MapObjects_UpdateDrawEnter)


PRG011_AB61:
	LDA Map_WasInPipeway
	BNE PRG011_AB58	 ; If we were just in a pipe, jump to PRG011_AB58 (PRG011_ABBE) (do short cycle because we didn't do anything)

	; Here we check if Player was on top of a map object, thus assumed to be the cause of level entry, thus needs to be "completed."

	LDY #(MAPOBJ_TOTAL - 1)	 ; Y = (MAPOBJ_TOTAL - 1) (For all map objects)
	LDX Player_Current	 ; X = Player_Current
PRG011_AB6B:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_AB89	 	; If this map object slot is empty, jump to PRG011_AB89

	LDA Map_Objects_Y,Y
	STA <Temp_Var1		; Temp_Var1 = this map object's Y
	CMP <World_Map_Y,X
	BNE PRG011_AB89	 	; If Player is not on this map object vertically, jump to PRG011_AB89

	LDA Map_Objects_XHi,Y
	CMP <World_Map_XHi,X
	BNE PRG011_AB89	 	; If Player is not on the same screen as this map object, jump to PRG011_AB89

	LDA Map_Objects_XLo,Y
	STA <Temp_Var2		; Temp_Var2 = this map object's X

	CMP <World_Map_X,X
	BEQ PRG011_AB8F 	; If Player is definitely on top of this map object, jump to PRG011_AB8F

PRG011_AB89:
	DEY		 	; Y--
	BPL PRG011_AB6B		; While Y >= 0, loop

	JMP PRG011_ABBE	 ; Jump to PRG011_ABBE

PRG011_AB8F:
	STY <Map_HideObj	; Index of map object Player is standing on -> Map_HideObj (hide this object and can't re-enter it)

	LDA <Map_ClearLevelFXCnt
	BNE PRG011_ABA7	 ; If Map_ClearLevelFXCnt <> 0, jump to  PRG011_ABA7

	; "Poof" sound
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

PRG011_ABA7:
	LDA <Counter_1
	AND #$03
	BNE PRG011_AB5B	 ; 1:4 ticks proceed, otherwise jump to PRG011_AB5B

	INC <Map_ClearLevelFXCnt	; Map_ClearLevelFXCnt++

	LDA <Map_ClearLevelFXCnt
	CMP #$08
	BNE PRG011_AB5B	 ; If Map_ClearLevelFXCnt = 7 (end of "poof" effect), jump to  PRG011_AB5B

	; Record defeat, so long as not too large (shouldn't happen)
	CPY #8
	BGE MObj_NoDefeat

	
	LDX World_Num
	;CPX #8
	;BGE MObj_NoDefeat
	
	; Mark defeated
	LDA Map_ObjCompletions,X
	ORA MapObj_CompleteBit,Y
	STA Map_ObjCompletions,X

	; If this was a comet, increment Map_StarCoin_Got
	LDA Map_Objects_IDs,Y
	CMP #MAPOBJ_DAREDEVILCOMET
	BEQ MObj_DefeatComet
	CMP #MAPOBJ_PURPLECOMET
	BNE MObj_NoDefeat
	
MObj_DefeatComet:
	INC Map_StarCoin_Got
	
MObj_NoDefeat:
	; Map object will now disappear!
	LDA #MAPOBJ_EMPTY
	STA Map_Objects_IDs,Y		; Empty the slot
	STA <Map_ClearLevelFXCnt	; Stop the clear effect (poof)
	STA <Map_HideObj		; Clear the hidden object index

PRG011_ABBE:
	LDA <Map_ClearLevelFXCnt
	BNE PRG011_ABCC	 ; If Map_ClearLevelFXCnt <> 0, jump to PRG011_ABCC

	; Level clearing effect is over...

	LDA #$00
	STA Map_WasInPipeway

	; Map_Operation = 8
	LDA #$08
	STA Map_Operation

PRG011_ABCC:
	JMP MapObjects_UpdateDrawEnter	 ; Jump to MapObjects_UpdateDrawEnter


	; SB: Made into subroutine for reuse
	; X = X coordinate on map (e.g. MapPoof_X)
	; A = Y coordinate on map (e.g. MapPoof_Y)
Map_DrawTileChange:
	JSR Map_Calc_NT2Addr_By_XY	 ; Nametable 2 Offset -> Temp_Var15

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	; Set high byte of video address
	LDA <Temp_Var15
	STA Graphics_Buffer+$00,X
	STA Graphics_Buffer+$05,X

	; Set low byte of video address for first row of level panel change
	LDA <Temp_Var16
	STA Graphics_Buffer+$01,X

	; Set low byte of video address for second row of level panel change
	ADD #32		; +32 for next row
	STA Graphics_Buffer+$06,X

	; Run length of 2 for both
	LDA #$02
	STA Graphics_Buffer+$02,X
	STA Graphics_Buffer+$07,X

	; SB: New: Just get patterns as appropriate instead of hardcoding them PLEASE!
	JSR MapTile_GetPats

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	; Add in the four replacement patterns to cover over the completed level
	LDA <Temp_Var1
	STA Graphics_Buffer+$03,X
	LDA <Temp_Var2
	STA Graphics_Buffer+$08,X
	LDA <Temp_Var3
	STA Graphics_Buffer+$04,X
	LDA <Temp_Var4
	STA Graphics_Buffer+$09,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$0A,X

	; Graphics_BufCnt += 10
	LDA Graphics_BufCnt
	ADD #10
	STA Graphics_BufCnt

	RTS


	; Draws the "Poof" effect that occurs after a Fortress is completed
Map_DrawClearLevelPoof:
	; Temp_Var1 = Y
	; Temp_Var2 = X

	; Set poof top Y 8 pixels above (centered over point)
	LDA <Temp_Var1
	SUB #$08	
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64
	STA Sprite_RAM+$68
	STA Sprite_RAM+$6C

	; Set poof bottom Y 8 pixels below (centered over point)
	ADD #16
	STA Sprite_RAM+$70
	STA Sprite_RAM+$74
	STA Sprite_RAM+$78
	STA Sprite_RAM+$7C

	LDY #$00	 ; Y = 0
	LDA <Temp_Var2	 
	SUB <Horz_Scroll 
	SUB #$08	 ; Set X coordinate relative to screen scroll - 8
PRG011_ABF9:
	; Set poof X coordinates
	STA Sprite_RAM+$63,Y	; Top
	STA Sprite_RAM+$73,Y	; Bottom

	ADD #$08	 ; X += 8

	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)

	CPY #$10	 
	BNE PRG011_ABF9	 ; If 'Y' <> $10, jump to PRG011_ABF9

	; Palette select 3 
	LDA #$03
	STA Sprite_RAM+$62
	STA Sprite_RAM+$66

	; Palette select 3 and horizontal flip
	LDA #$43
	STA Sprite_RAM+$6A
	STA Sprite_RAM+$6E

	; Palette select 3 and vertical flip
	LDA #$83
	STA Sprite_RAM+$72
	STA Sprite_RAM+$76

	; Palette select 3 and both flip
	LDA #$c3
	STA Sprite_RAM+$7A
	STA Sprite_RAM+$7E

	LDX <Map_ClearLevelFXCnt	 ; X = Map_ClearLevelFXCnt
	DEX		 ; X-- (off by 1)
	TXA
	ASL A
	TAX		 ; X *= 2

	; SB: Stupid fixes for an unknown problem
	BPL Map_PoofIndexNotNeg

	LDX #0
	BEQ Map_PoofIndexOK

Map_PoofIndexNotNeg:
	CPX #12
	BLT Map_PoofIndexOK
	
	LDX #10

Map_PoofIndexOK:
	; Set pattern
	LDA Map_ClearLevelFXPatterns,X
	STA Sprite_RAM+$61
	STA Sprite_RAM+$6D
	STA Sprite_RAM+$71
	STA Sprite_RAM+$7D

	; Set pattern
	LDA Map_ClearLevelFXPatterns+1,X
	STA Sprite_RAM+$65
	STA Sprite_RAM+$69
	STA Sprite_RAM+$75
	STA Sprite_RAM+$79

	RTS		 ; Return



MO_CheckWZUnlock:
	LDA Map_WarpWind_FX
	BNE MCWZU_RTS

	; If there's already a "secret" marker in the W9 completions,
	; we've already done WZero's unlock event, so do nothing...
	LDY MapCompletions_Starts+8
	LDA Map_Completions,Y
	AND #MCOMP_SECRET
	BNE MCWZU_Nothing

	; Back up Map_StarCoin_Got/Map_StarCoin_Total so we don't screw up the status bar later
	LDA Map_StarCoin_Got
	PHA
	LDA Map_StarCoin_Total
	PHA

	LDA Map_CometMode
	BEQ MCWZU_NoCometMode	; If not in Comet Mode, can't possibly unlock, jump to MCWZU_NoCometMode
	
	; Count all star coins and see if we're there yet...
	JSR_THUNKA 12, Map_CountAllStarCoinsToW8
	
	LDA Temp_VarNP0
	BEQ MCWZU_NoCometMode	; If you don't have the greater of 256 star coins yet, jump to MCWZU_NoCometMode
	
	LDA Map_StarCoin_Got
	CMP Map_StarCoin_Total
	BNE MCWZU_NoCometMode	; If you otherwise don't match the got vs. total amount, jump to MCWZU_NoCometMode
	
	; Start World Zero sequence!
	LDA #$82
	STA Map_WarpWind_FX

	LDA #SND_LEVELVINE
	STA Sound_QLevel1

	; Can't lose turn otherwise it crashes, heh
	INC Map_NoLoseTurn

MCWZU_NoCometMode:

	; Restore Map_StarCoin_Got/Map_StarCoin_Total
	PLA
	STA Map_StarCoin_Total
	PLA
	STA Map_StarCoin_Got

MCWZU_Nothing:
	INC Map_Operation	 ; Map_Operation++
	
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back

MCWZU_RTS:
	JSR Map_DoMap_WarpWind_FX
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back

WWFX_WZeroUnlockPoof:
	; MO_DoLevelClear

	;JSR PRG011_A9FE
	
	LDA Map_Operation
	CMP #$0D
	BEQ WWFXP_StartFFX
	CMP #$09
	BEQ WWFXP_StartFFX
	BNE WWFXP_Done
	
WWFXP_StartFFX:
	LDA #0
	STA <Map_ClearLevelFXCnt
	
	LDA #1
	
	LDY <Map_WarpWind_FX
	CPY #$86
	BNE WWFXP_SkipMonoFlash
	
	LDA #SND_LEVELAIRSHIP
	STA Sound_QLevel2
	
	LDA #0	; Mono flash only on first one
		
WWFXP_SkipMonoFlash:
	STA Map_Intro_Tick

	LDA <Map_WarpWind_FX
	AND #$7F	; Bit 7 specifies World Zero unlock sequence
	SUB #5
	STA Map_DoFortressFX

	LDA #8
	STA Map_Operation
	
	INC <Map_WarpWind_FX
	
WWFXP_Done:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


WWFX_WZeroUnlockDone:
	LDA #12
	STA Map_Operation

	; Mark all W9 completions as "MCOMP_SECRET"
	LDY MapCompletions_Starts+8
WZUD_MarkSecretCompLoop:
	LDA Map_Completions,Y
	ORA #MCOMP_SECRET
	STA Map_Completions,Y

	INY
	CPY MapCompletions_Starts+9
	BNE WZUD_MarkSecretCompLoop

	JMP WWFX_NotWZeroUnlock
	
	; This looks for an empty map object slot and returns the index in 'Y'
	; Assumes that the first two slots are always occupied...
	; NOTE: Dangerous!  If all slots are filled, this could loop for eternity
	; or return a bad index!  There's just an assumption of a free slot!
	;
	; A better implemention per what the rest of the engine would do is make
	; sure we don't loop beyond the last object ((MAPOBJ_TOTAL-1)) and in failure
	; "Do Not Return to Caller" (double PLA instruction), but oh well...
Map_FindEmptyObjectSlot:
	LDY #$02	 ; Y = 2
PRG011_AD9F:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_ADA8	 ; If this map object slot is empty, jump to PRG011_ADA8 (RTS)

	INY		 ; Y++
	JMP PRG011_AD9F	 ; Loop

PRG011_ADA8:
	RTS		 ; Return

Map_March_InitValues:
	; Initializes Map_March_Count values per Map_Object_ID
	; Generally the value is $20 (Marching time amount) and $00 (Don't march)
	; There's some restriction on these values because of internal ANDings.

	; Also, an object won't actually march unless it is tied into the march
	; function (check function pointer list @ PRG011_AE0B), but if it uses 
	; the Map_Object_Stationary function, it will briefly animate slightly
	; faster (as does a Hammer Brother marching around) due to a jump it
	; makes; this is used to make the World 7 Plant look ferocious (I suppose)
	; and would happen with World 8 stuff too, but they use $00 values so
	; the net effect is absolutely nothing.
	.byte $00	; None
	.byte $00	; Boo
	.byte $00	; Airship
	.byte $00	; Daredevil Comet
	.byte $00	; Purple Comet
	.byte $20	; Cheep Cheep
	.byte $20	; Shy Guy
	.byte $20	; Rex
	.byte $20	; Gao
	.byte $20	; Fazzy Crab
	.byte $00	; Octo Goomba
	.byte $20	; Magiblot
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Object_Do_All
;
; Runs update code on all map objects, e.g. what makes a 
; Hammer Brother march, an airship fly, etc.  Does NOT have
; anything to do with the interaction of the object, except
; for the canoe, which simply sets the "In Canoe" flag if
; the Player is standing in it.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Object_Do_All:
	LDA Map_NoLoseTurn
	BNE PRG011_ADF4	 ; If Map_NoLoseTurn is set, jump to PRG011_ADF4 (RTS)

	LDY #(MAPOBJ_TOTAL-1) 	; Total map objects which may exist on the map (only 8 are defined at start)
	STY <Temp_Var13		; Temp_Var13 = $0D

	LDA Map_Operation
	CMP #$0b
	BNE PRG011_ADE6	 	; If Map_Operation <> $0B (Hammer Bro marching around), jump to PRG011_ADE6

	LDA Map_MarchInit
	BNE PRG011_ADE6	 	; If Map_MarchInit is set, jump to PRG011_ADE6

PRG011_ADD2:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_ADDE	 	; If the object ID is zero, nothing to do, jump to PRG011_ADDE
	TAX		 	; X = A

	; Initialize all the map march values
	LDA Map_March_InitValues,X	; For this object's ID, get the init value
	STA Map_March_Count,Y	 	; Store it in this object's slot

PRG011_ADDE:
	DEY		 ; Y--
	BPL PRG011_ADD2	 ; While Y <> 1, loop!


	INC Map_MarchInit	 ; Set Map_MarchInit (March initialization complete!)

PRG011_ADE6:
	LDX <Temp_Var13		; X = Temp_Var13
	LDA Map_Objects_IDs,X
	BEQ PRG011_ADF0	 	; If the object ID is zero, nothing to do, jump to PRG011_ADF0
	JSR Map_Object_Do 	; Process this map object!

PRG011_ADF0:
	DEC <Temp_Var13		; Temp_Var13--
	BPL PRG011_ADE6	 	; While Temp_Var13 >= 0, loop!

PRG011_ADF4:
	RTS		 ; Return


Map_Object_Do:
	; Map object to do...
	JSR Map_Object_CheckVisibility	 ; Check and store if this object is visible

	;LDA Map_Objects_IDs,X	; Get the ID
	;CMP #MAPOBJ_CANOE
	;BGE PRG011_AE0B	 	; If object ID >= $10 (Canoe), jump to PRG011_AE0B

	LDY Map_Operation	; Y = Map_Operation
	CPY #$0B
	BNE PRG011_AE0B	 	; If Map_Operation <> $0B, jump to PRG011_AE0B

	LDY Map_March_Count,X
	BEQ PRG011_ADF4	 ; If march count = 0, jump to PRG011_ADF4

PRG011_AE0B:
	; Based on the ID, jump to proper routine for how it should act on the map
	LDA Map_Objects_IDs,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_ADF4		; None (Just RTS)
	.word PRG011_ADF4		; Boo (Just RTS)
	.word PRG011_ADF4	; Launch Star (Just RTS)
	.word PRG011_ADF4	; Daredevil Comet (Just RTS)
	.word PRG011_ADF4	; Purple Comet (Just RTS)
	.word Map_Object_March		; Cheep Cheep
	.word Map_Object_March		; Shy Guy
	.word Map_Object_March		; Rex
	.word Map_Object_March		; Gao
	.word Map_Object_March		; Fazzy Crab
	.word Map_Object_March		; Octo Goomba
	.word Map_Object_March		; Magiblot

	; Based on march travel direction, these are the movements
Map_Object_Travel_Y:	.byte 0, 0, 1, -1
Map_Object_Travel_X:	.byte 1, -1, 0, 0
Map_Object_Travel_XHi:	.byte 0, -1, 0, 0

Map_Object_March_Offset:
	; For a 32 position march, offset to the object's X coordinate
	.byte -8, -7, -6, -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7
	.byte  8,  7,  6,  5,  4,  3,  2,  1,  0, -1, -2, -3, -4, -5, -6, -7

Map_Object_March_OffsetXHi:
	; For a 32 position march, offset to the object's X Hi coordinate
	.byte -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0
	.byte  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1

Map_Object_March:
	; For all map objects which "march" back and forth (includes Hammer/etc. Brothers, and bonuses...)
	LDA Map_Operation
	CMP #$0d	 	
	BNE Map_Object_March_NonNormal	 	; If Map_Operation <> $0D (Normal operation), jump to Map_Object_March_NonNormal

	; Normal operation, objects just "marching" around...
	LDA Map_Objects_IDs,X	; A = object's ID
	;CMP #MAPOBJ_NSPADE
	;BLT Map_Object_MusicBoxCheck ; If object ID < MAPOBJ_NSPADE (includes hammer brother types and the world 7 plant), jump to Map_Object_MusicBoxCheck

	;CMP #MAPOBJ_BATTLESHIP
	;BLT PRG011_AE93	 	; If object ID < MAPOBJ_BATTLESHIP (includes bonus items), jump to PRG011_AE93 (they don't "sleep")

;Map_Object_MusicBoxCheck:
	;LDA Map_MusicBox_Cnt
	;BNE PRG011_AED1	 	; If music box is active, jump to PRG011_AED1

;PRG011_AE93:
	TXA
	AND #$01
	STA <Temp_Var16	; Temp_Var16 = object's index AND'ed 1 (mixes up the marching a little; left/right swap)

	LDA Map_March_Count
	AND #$10
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = (Map_March_Count & $10) >> 4
	STA Map_Object_Data,X	; Data in the context of a "marcher" is 0/1 depending which direction they're walking (every 16 tics, reverse direction)

	LDA <Temp_Var16	; Get the march flip
	BEQ PRG011_AEAE	 	; If no flip needed, jump to PRG011_AEAE

	; Flip the march direction
	EOR Map_Object_Data,X
	STA Map_Object_Data,X

PRG011_AEAE:
	LDA <Temp_Var16
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var16	; Temp_Var16 <<= 4

	LDA Map_March_Count
	AND #$1f	 	; March count is basically 0-31, flipping at 16
	EOR <Temp_Var16	; Flip the upper bit as appropriate

	TAY		 		; Y = A (the adjusted march)
	LDA Map_Objects_XLo,X		; A = object's X coordinate (low part)
	ADD Map_Object_March_Offset,Y	; Add the proper offset in their march
	STA Map_Object_ActX,X	 	; Store this as their display X

	; X Hi offset as needed
	LDA Map_Object_ActXH,X	
	ADC Map_Object_March_OffsetXHi,Y
	STA Map_Object_ActXH,X	 

PRG011_AED1:
	RTS		 ; Return

Map_Object_March_NonNormal:
	; For marchers when Map_Operation <> $0D ...

	CMP #$0b	 
	BNE PRG011_AED1	 	; If Map_Operation <> $0B (Hammer Brothers march around), jump to PRG011_AED1 (RTS)

	LDA Map_MusicBox_Cnt
	BNE PRG011_AF46	 	; If music box is active, jump to PRG011_AF46

	; Hammer brothers need to march about...
	LDY <Temp_Var13		; Y = Temp_Var13 (current object we're working on)
	LDX #$01	 	; X = 1

	; For both players...
PRG011_AEDF:
	;JMP PRG011_AEFA

	; Check if Player is standing on map object
	LDA <World_Map_Y,X
	CMP Map_Object_ActY,Y
	BNE PRG011_AEFA	 	; If Player's Y is not equal to this map object, jump to PRG011_AEFA (do nothing)

	LDA <World_Map_XHi,X
	CMP Map_Object_ActXH,Y
	BNE PRG011_AEFA	 	; If Player's X Hi is not equal to this map object, jump to PRG011_AEFA (do nothing)

	LDA <World_Map_X,X
	CMP Map_Object_ActX,Y
	BNE PRG011_AEFA	 	; If Player's X Lo is not equal to this map object, jump to PRG011_AEFA (do nothing)

	; SB: This is meant to be "runs into you" code, but since I took
	; away skidding on death, I need to have them march in that
	; situation, otherwise you re-enter immediately on death!
	LDA Map_ReturnStatus
	BEQ Map_MarchRunIntoOK		
	
	; If Player died, don't run into him again right away...
	LDA #$00
	STA Map_ReturnStatus
	BEQ PRG011_AEFA

Map_MarchRunIntoOK:
	LDA #$00
	STA Map_March_Count,Y	; Clear Map_March_Count for this object (why??)
	RTS		 	; Return...

PRG011_AEFA:
	DEX		 ; X--
	BPL PRG011_AEDF	 ; If X >= 0, loop!

	LDA Map_March_Count,Y
	AND #$1f	 	; Cap Map_March_Count to $00-$1F
	BNE PRG011_AF0C	 	; If Map_March_Count value is not zero, jump to PRG011_AF0C

	LDA RandomN,Y	 	; Pulls a random number from the pool (NOTE: This only works for first 7 objects, after that not random)
	AND #$03	 	; Cap value 0-3
	JSR Map_MarchValidateTravel	; Validates traveling in this direction OR does not return here!

PRG011_AF0C:
	LDY <Temp_Var13		; Y = Index of current object we're working with
	LDA Map_Objects_IDs,Y	; Get this object's ID
	BEQ PRG011_AF46	 	; If ID = 0, jump to PRG011_AF46 (shouldn't ever happen??)

	; If object ID is < MAPOBJ_HAMMERBRO or >= MAPOBJ_W7PLANT (not one of the hammer/etc. brothers), jump to PRG011_AF26
	;CMP #MAPOBJ_HAMMERBRO
	;BLT PRG011_AF26
	;CMP #MAPOBJ_W7PLANT	 
	;BGE PRG011_AF26

	LDA <Counter_1
	AND #$0f	 ; Restrict counter to 0-15
	BNE PRG011_AF26	 ; If not zero, jump to PRG011_AF26

	LDA #SND_LEVELMARCH	 	
	STA Sound_QLevel2	; Play Marching sound

PRG011_AF26:
	LDX Map_Object_Data,Y	 ; Get march direction

	; The moment you've all been waiting for:
	; The actual march movement!

	; Travel Y
	LDA Map_Object_ActY,Y
	ADD Map_Object_Travel_Y,X
	STA Map_Object_ActY,Y

	; Travel X
	LDA Map_Object_ActX,Y	
	ADD Map_Object_Travel_X,X
	STA Map_Object_ActX,Y	

	; Travel X Hi byte
	LDA Map_Object_ActXH,Y
	ADC Map_Object_Travel_XHi,X
	STA Map_Object_ActXH,Y	

PRG011_AF46:
	; Jumps here if music box is active
	LDX <Temp_Var13			; X = Temp_Var13
	JSR Map_Object_March_UpdateXs	; Copy updated X's to the map RAM

	DEC Map_March_Count,X	 	; Decrement the march counter
	BNE PRG011_AF84	 		; If not zero, jump to PRG011_AF84 (RTS)

	LDA Map_MusicBox_Cnt
	BNE PRG011_AF84	 		; If music box active, jump to PRG011_AF84

	; This is going to loop through all OTHER objects...
	; Basically to make sure this object didn't land on top of another
	LDY #$0d	 
PRG011_AF57:
	CPY <Temp_Var13
	BEQ PRG011_AF81		; If this is the object we're working with, skip this loop!

	LDA Map_Objects_IDs,Y 	; Get this object ID
	BEQ PRG011_AF81	 	; If 0 (no object here), jump to PRG011_AF81
	;CMP #MAPOBJ_CANOE
	;BGE PRG011_AF81	 	; If ID >= MAPOBJ_CANOE (canoe), jump to PRG011_AF81

	LDA Map_March_Count,Y
	BNE PRG011_AF81

	LDA Map_Object_ActY,Y
	CMP Map_Object_ActY,X
	BNE PRG011_AF81		; Y's are different, OK

	LDA Map_Object_ActXH,Y
	CMP Map_Object_ActXH,X
	BNE PRG011_AF81		; X hi's are different, OK

	LDA Map_Object_ActX,Y
	CMP Map_Object_ActX,X
	BEQ PRG011_AF85		; Gah, everything matched!  I'm standing on something, jump to PRG011_AF85

PRG011_AF81:
	DEY		 ; Y--
	BNE PRG011_AF57	 ; While Y >= 0, loop!

PRG011_AF84:
	RTS		 ; Return

PRG011_AF85:
	; I landed on something, so I gotta re-march
	LDA #$20
	STA Map_March_Count,X	; Redo march

	CPY #$01
	BEQ PRG011_AF93

	LDA #$20	
	STA Map_March_Count,Y

PRG011_AF93:
	RTS		 ; Return


Map_Object_Stationary:
	; For objects like the World 7 plant or World 8 artillery
	; that don't go anywhere ever...

	LDA Map_Operation
	CMP #$0b
	BNE PRG011_AF93	 ; If Map_Operation <> $0B (March Around time), jump to PRG011_AF93 (RTS)
	JMP PRG011_AF46	 ; During the would-be marching period, just animate faster (but no movement)



Map_Object_March_UpdateXs:
	; Copy the object's moved X lo & hi to the stored map versions
	LDA Map_Object_ActX,X
	STA Map_Objects_XLo,X
	LDA Map_Object_ActXH,X
	STA Map_Objects_XHi,X
	RTS		 	; Return


	; Travel directions:
	; 0 = Right, 1 = Left, 2 = Down, 3 = Up
Map_Object_March_YOffByDir:	.byte 0, 0, 16, -16	; Travel direction Y offsets for marching map brother
				.byte 0, 0, 32, -32	; Next tile over; if the first tile is OK, see if the destination is OK too

Map_Object_March_XOffByDir:	.byte 16, -16, 0, 0	; Travel direction X offsets for marching map brother
				.byte 32, -32, 0, 0	; Next tile over; if the first tile is OK, see if the destination is OK too

Map_Object_March_XHiOffByDir:	.byte 0, -1, 0, 0	; Travel direction X Hi offsets for marching map brother
				.byte 0, -1, 0, 0	; Next tile over; if the first tile is OK, see if the destination is OK too

	; Tiles that are forbidden for the marching object to "land" on
Map_Object_Forbid_LandingTiles:
	.byte TILE_MARIOCOMP_O, TILE_LUIGICOMP_O, TILE_MARIOCOMP_P, TILE_LUIGICOMP_P
	.byte TILE_DANCINGPALM, TILE_DANCINGBUSH, TILE_PIPE,        TILE_HANDTRAP_COMP 
	.byte TILE_QBLOCK,      TILE_ALTSPIRAL,   TILE_FORTRUBBLE,  TILE_MARIOCOMP_G
	.byte TILE_LUIGICOMP_G, TILE_MARIOCOMP_R, TILE_LUIGICOMP_R, TILE_ALTRUBBLE
	.byte TILE_START,		TILE_LARGEFORT,	  TILE_GHOSTHOUSE,  TILE_GHOSTHOUSE_COMP
	.byte TILE_AIRSHIP,		TILE_AIRSHIP_COMP
Map_Object_Forbid_LT_End

	; This makes it safe to expand the above
	; There's a mistake in here somewhere, I think Nintendo did their loop/indexing wrong
	; See notes at PRG011_B406
MOV_Landings2Check = (Map_Object_Forbid_LT_End - Map_Object_Forbid_LandingTiles) + 1


	; Extra tiles that a hammer bro is forbidden from stepping on
	; I don't know why these are split from the above?
Map_MarchXtraForbidTiles:
	.byte TILE_TOADHOUSE, TILE_ALTTOADHOUSE, TILE_CASTLEBOTTOM, TILE_PATHANDNUB	; <-- Last one is weird "enterable"!
Map_MarchXtraForbidTiles_End


Map_MarchValidateTravel:
	; A = pseudo-random value, 0-3
	STA <Temp_Var1		; Temp_Var1 = random val 0-3
	LDA #$04
	STA <Temp_Var2		; Temp_Var2 = 4

PRG011_B3A3:
	LDY <Temp_Var13		; Y = Temp_Var13 (Current object we're working on)
	DEC <Temp_Var1		; Temp_Var1--

	LDA RandomN,Y	 	; Get the full random value
	ASL A		 	; A << 1
	BCC PRG011_B3B1	 	; If the bit 7 was not set, carry is clear, and jump to PRG011_B3B1

	INC <Temp_Var1
	INC <Temp_Var1		; Otherwise, Temp_Var1 (the 0-3 input) += 2

PRG011_B3B1:
	LDA <Temp_Var1		; A = Temp_Var1 (0-5 now)
	AND #$03
	STA <Temp_Var1		; Enforcing 0-3 cap on Temp_Var1

	; Temp_Var1 is a value from 0-3 that specifies a travel direction

	EOR Map_Object_Data,Y	; March direction possible invert
	CMP #$01	 
	BEQ PRG011_B3A3	 	; If current result = 1, jump to PRG011_B3A3

	DEC <Temp_Var2		; Temp_Var2--
	BPL PRG011_B3CA	 	; If Temp_Var2 >= 0, jump to PRG011_B3CA

	LDA #$00
	STA Map_March_Count,Y	; Clear Map_March_Count value

	; ******!!!
	; NOTE: Don't actually return to caller; return to caller's caller!
	PLA		 
	PLA
	RTS		 ; Return

LT0B:
PRG011_B3CA:
	BNE PRG011_B3D3	 	; If Temp_Var2 <> 0, jump to PRG011_B3D3

	; When Temp_Var2 = 0...
	LDA Map_Object_Data,Y	; Get march direction
	EOR #$01	 	; Flip it
	STA <Temp_Var1		; Store that to Temp_Var1

PRG011_B3D3:
	LDX <Temp_Var1		; X = Temp_Var1 (0-3)
	JSR Map_Object_March_PickTravel	; Sets Map_Tile_Addr, figures travel destination in Temp_Var3 (upper 4 containing target row, lower 4 containing target column)

	LDA <Temp_Var1		; A = Temp_Var1 (0-3) travel dir
	ASL A		 	; A << 1 (index)
	TAX		 	; X = A

	; Get address Map_Object_Valid_Tiles (on page 10), store into Temp_Var15
	; This lists valid tiles the object may travel over...
	LDA Map_Object_Valid_Tiles,X
	STA <Temp_Var15	
	LDA Map_Object_Valid_Tiles+1,X
	STA <Temp_Var16

	LDY <Temp_Var3		; Y = Temp_Var3 (travel target)
	LDA [Map_Tile_AddrL],Y	; Get tile here

	LDY #(Map_Object_Valid_Tiles2Check-1)	; Check all possible travel-over tiles
PRG011_B3EC:
	CMP [Temp_Var15],Y
	BEQ PRG011_B3F5	 	; If this tile is valid to travel over, jump to PRG011_B3F5
	DEY		 ; Y--
	BPL PRG011_B3EC	 ; While Y >= 0, loop!
	BMI PRG011_B3A3	 ; If we couldn't find a tile valid to travel over, jump to PRG011_B3A3 to choose anew...

PRG011_B3F5:
	; Valid tile in front of us, now check if we can move one more!
	; (Moves are in two tiles, not one; make sure "landing zone" is safe)
	LDY <Temp_Var13	 ; Y = Temp_Var13 (object we're working on)
	LDA <Temp_Var1	 ; A = Temp_Var1
	ADD #$04	 ; Offset the travel dir +4; check next tile over (since moves are made by 2 tiles, not 1)

	TAX		 ; X = A (travel dir)
	JSR Map_Object_March_PickTravel	 ; Get next tile over, "landing zone"

	LDY <Temp_Var3			; Y = Temp_Var3 (travel target)
	LDA [Map_Tile_AddrL],Y		; Get tile here

	LDY #(MOV_Landings2Check-1)
PRG011_B406:
	; NOTE: For some reason, they were checking one byte prior to the actual
	; LUT, but then they won't decrement 'Y' down to zero (so it stays within
	; the LUT); there must have been a mistake here somewhere? :)
	CMP Map_Object_Forbid_LandingTiles-1,Y
	BNE PRG011_B40E	 ; If this is not a forbidden landing tile, jump to PRG011_B40E
	JMP PRG011_B3A3	 ; Otherwise, jump to PRG011_B3A3

PRG011_B40E:
	DEY		 ; Y--
	BNE PRG011_B406	 ; While Y > 0, loop!

	LDX <Temp_Var13		 	; X = Temp_Var13
	LDY #(Map_MarchXtraForbidTiles_End - Map_MarchXtraForbidTiles)	
PRG011_B415:
	; NOTE: Like PRG011_B406, this loop doesn't hit index 0.  Wonder why??
	CMP Map_MarchXtraForbidTiles-1,Y
	BEQ PRG011_B42A	 ; If tile is one of the additional forbidden tiles, jump to PRG011_B42A

	DEY		 ; Y--
	BNE PRG011_B415	 ; While Y <> 0, loop!

	PHA		 ; Save tile

	; Calculate tile quadrant
	ASL A
	ROL A
	ROL A
	AND #$03
	TAY	; -> 'Y'

	PLA		 ; Restore tile

	CMP Tile_AttrTable+4,Y
	BLT PRG011_B435	 ; If this tile is not enterable, jump to PRG011_B435 (safe landing)

PRG011_B42A:

	LDA #$20
	CMP Map_March_Count,X
	BNE PRG011_B435	 ; If March counter <> $20, jump to PRG011_B435

	; More time to march
	ASL A		 ; A = $40
	STA Map_March_Count,X	 ; -> March counter

PRG011_B435:
	; Safe landing!
	LDA <Temp_Var1
	STA Map_Object_Data,X

	RTS		 ; Return

Map_Object_March_PickTravel:
	; Sets Map_Tile_Addr, figures travel destination in Temp_Var3 (upper 4 containing target row, lower 4 containing target column)

	LDA Map_Object_ActY,Y	 ; A = Map object's Y
	ADD Map_Object_March_YOffByDir,X	 ; X = 0-3 travel direction; add indexed value to the Y coordinate
	STA <Temp_Var3		 ; Result into Temp_Var3

	LDA Map_Object_ActX,Y	 ; A = Map object's X
	ADD Map_Object_March_XOffByDir,X	 ; X = 0-3 travel direction; add indexed value to the X coordinate
	STA <Temp_Var4		 ; Result into Temp_Var4

	LDA Map_Object_ActXH,Y	 ; A = Map object's X hi byte
	ADC Map_Object_March_XHiOffByDir,X	 ; X = 0-3 travel direction; add indexed value to the X Hi
	ASL A		 	; Index into Tile_Mem_Addr
	TAX		 	; X = A

	; Get to proper offset for where object stands, +$F0
	LDA Tile_Mem_Addr,X
	ADD #$f0
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	ADC #$00
	STA <Map_Tile_AddrH

	LDA <Temp_Var4	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	ORA <Temp_Var3	; Makes an assumption that the object's Y value is row-aligned (which it generally is)
	STA <Temp_Var3	; Temp_Var3 = (Temp_Var4 >> 4) | Temp_Var3
	RTS		; Return


	; This is a rotated array of Sprite_RAM offsets, helps distribute
	; the map object display so even if there's scanline overflows,
	; there will be at least some visibility of all objects.
Map_SpriteRAM_Offset:
	.byte $08, $60, $10, $58, $18, $50, $20, $48, $28, $40, $30, $38 


MapObjects_UpdateDrawEnter:
	JSR Map_Object_Do_All	 ; Runs update code for all map objects
	JSR FX_World_8_Darkness	 ; Performs / updates the World 8 darkness effect, if active

	; Temp_Var13 = $0D
	LDA #$0D	 	; Total map objects which may exist on the map (only 8 are defined at start)
	STA <Temp_Var13

	; Map_SprRAMOffDistr runs from $00 to $0A, inclusive
	INC Map_SprRAMOffDistr
	LDA Map_SprRAMOffDistr
	CMP #$0b
	BLT PRG011_B554

	LDA #$00
	STA Map_SprRAMOffDistr

PRG011_B554:

	; Temp_Var6 = 0
	LDA #$00
	STA <Temp_Var6

	LDY <Temp_Var13	 ; Y = Temp_Var13 (current map slot index)
	BEQ PRG011_B56E	 ; If Temp_Var13 = 0, jump to PRG011_B56E

	DEY		 ; Y--
	TYA
	ADD Map_SprRAMOffDistr	 ; A = Map_SprRAMOffDistr + Temp_Var13

	CMP #$0b
	BLT PRG011_B568	 ; If value didn't overflow, jump to PRG011_B568

	SBC #$0b	 ; Otherwise, keep it in range of $00 - $0A (modulus)

PRG011_B568:
	TAX		 ; -> 'X'

	LDA Map_SpriteRAM_Offset,X	; Get Sprite_RAM offset
	STA <Temp_Var6		 	; -> Temp_Var6

PRG011_B56E:
	LDX <Temp_Var13		 ; X = Temp_Var13

	LDA Map_Objects_Vis,X
	BEQ PRG011_B578	 ; If this object isn't visible, jump to PRG011_B578

	JSR MapObject_DrawSleepEnter	 ; Draw the map object, put it to sleep (if applicable), and enter it if it should be entered

PRG011_B578:
	DEC <Temp_Var13	 ; Temp_Var13--
	BPL PRG011_B554	 ; While Temp_Var13 >= 0, loop!

PRG011_B57C:
	LDA Map_Operation
	CMP #$0d
	BNE PRG011_B58C	 ; If the map operation <> $0D (normal), jump to PRG011_B58C (RTS)

	LDA <Counter_1
	AND #$03
	BNE PRG011_B58C

	INC Map_March_Count	; Increment Map_March_Count every 4 ticks

PRG011_B58C:
	RTS		 ; Return


	; Draw the map object, put it to sleep (if applicable), and enter it if it should be entered
MapObject_DrawSleepEnter:
	LDA Map_Objects_IDs,X
	BEQ PRG011_B58C

	CPX <Map_HideObj
	BNE PRG011_B599	 ; If this map object slot index <> Map_HideObj, jump to PRG011_B599

	CPX #$00	 
	BEQ PRG011_B599	 ; If this map object slot index = 0, jump to PRG011_B599

	RTS		 ; Return

PRG011_B599:

	; Map object slot 0 (typ. HELP bubble) or any object that is not in the Map_HideObj override slot

	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)

	; Set Y for map object sprite
	LDA Map_Object_ActY,X
	STA Sprite_RAM+$98,Y
	STA Sprite_RAM+$9C,Y

	; Set X for map object sprite
	LDA Map_Object_ActX,X
	SUB <Horz_Scroll
	STA Sprite_RAM+$9B,Y

	; Right half
	ADD #$08
	STA Sprite_RAM+$9F,Y

	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)

	; Map object ID -> Temp_Var8
	LDA Map_Objects_IDs,X
	STA <Temp_Var8

	; Jump by the Map Object ID (this is largely wasted here...)
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_ADF4		; 00=None (RTS)
	.word MapBoo_DrawAndDance	; 01=Dancing Boo
	.word MapObj_DrawLaunchStar	; 02=Launch Star
	.word MapObj_DrawLaunchStar	; 03=Daredevil Comet
	.word MapObj_DrawLaunchStar	; 04=Purple Comet
	.word MapObj_DrawMarcher	; 05=Cheep Cheep
	.word MapObj_DrawMarcher	; 06=Shy Guy
	.word MapObj_DrawMarcher	; 07=Rex
	.word MapObj_DrawMarcher	; 08=Gao
	.word MapObj_DrawMarcher	; 09=Fazzy Crab
	.word MapObj_DrawMarcher	; 10=Octo Goomba
	.word MapObj_DrawMarcher	; 11=Magiblot

MapObj_DrawLaunchStar:
	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)

	LDA <Counter_1
	AND #$03
	BNE MODLS_NoFrameChange

	; Animate frames 0 to 2 (Map_Object_Data)
	INC Map_Object_Data,X
	LDA Map_Object_Data,X
	CMP #3
	BLT MODLS_NoFrameChange

	LDA #0
	STA Map_Object_Data,X
MODLS_NoFrameChange:


	; Set frame
	LDA Map_Object_Data,X
	ASL A
	ASL A		; 0, 4, 8
	ADD #$A1	; $A1, $A5, $A9
	
	LDY Map_Objects_IDs,X
	CPY #MAPOBJ_DAREDEVILCOMET
	BEQ MODLS_Comet
	CPY #MAPOBJ_PURPLECOMET
	BNE MODLS_NotComet
	
MODLS_Comet:
	; Comet only; use $B1 etc.
	ADD #$10

MODLS_NotComet:
	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)

	; Load the patterns of the map object
	STA Sprite_RAM+$99,Y	
	ADD #$02
	STA Sprite_RAM+$9D,Y	

	; Load the attributes of the map object
	LDA #SPR_PAL2	; Launch stars and Purple comets use this

	LDY Map_Objects_IDs,X
	CPY	#MAPOBJ_DAREDEVILCOMET
	BNE MODLS_NotDDComet
	
	; Daredevil comet uses SPR_PAL1
	LDA #SPR_PAL1
	
MODLS_NotDDComet:
	
	
	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)
	STA Sprite_RAM+$9A,Y	
	STA Sprite_RAM+$9E,Y	

	; If Player pushes A, do enter logic, otherwise do nothing
	LDA <Pad_Input
	BPL MODLS_NoAButton

	JSR Map_CheckValidObjEntry
	BCC MODLS_NoAButton

	LDA InvFlip_Counter
	BNE MODLS_NoAButton

	LDA #$0D
	STA Map_Operation

	JMP PRG011_B68B

MODLS_NoAButton:
	RTS

MapBoo_FancyPatOffs:
	; Spin right round
	.byte $08
	.byte $0C
	.byte $11
	.byte $0C | SPR_HFLIP
	.byte $08
	.byte $08

	; Duck
	.byte $00
	.byte $00

	; Spin left round
	.byte $08
	.byte $0C | SPR_HFLIP
	.byte $11
	.byte $0C
	.byte $08
	.byte $08

	; Duck
	.byte $00
	.byte $00

	; Tada
	.byte $05
	
	; Face
	.byte $08
	.byte $08
	.byte $08
	.byte $08
	.byte $08
	.byte $08
	
	; Spin
	.byte $14
	.byte $08 | SPR_VFLIP
	.byte $14 | SPR_HFLIP

	; Face
	.byte $08
	.byte $08
	.byte $08
	.byte $08

MapBoo_DrawAndDance:
	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)

	;INC Map_Object_Data,X
	;LDA Map_Object_Data,X
	;LSR A
	;LSR A
	;LSR A
	;LSR A

	; Hackish; going by Music_NextIndex
	; $0D regular dancing
	; $0E twirl and spin dance

	LDA Music_NextIndex
	CMP #$0E
	BNE Boo_NormalDance

	LDA <Counter_1
	AND #%00001111
	BNE Boo_NoDanceMove

	INC Map_Object_Data,X

Boo_NoDanceMove:
	
	LDY Map_Object_Data,X
	LDA MapBoo_FancyPatOffs,Y	; Get current pattern offset
	PHA		; Save it

	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)
	
	AND #~(SPR_HFLIP | SPR_VFLIP)	; Clear any flip bits
	ORA #$81
	STA Sprite_RAM+$99,Y	
	ADD #2
	STA Sprite_RAM+$9D,Y	

	; Restore it and get flip bits
	PLA
	AND #(SPR_HFLIP | SPR_VFLIP)

	JMP Boo_StoreAttr

Boo_NormalDance:
	LDA #0
	STA Map_Object_Data,X

	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)

	LDA <Counter_1
	AND #%00100000
	LSR A
	LSR A
	LSR A
	ADD #$81
	STA Sprite_RAM+$99,Y	
	ADD #2
	STA Sprite_RAM+$9D,Y	

	LDA <Counter_1
	AND #%01000000
	
Boo_StoreAttr:
	ORA #SPR_PAL1
	STA Sprite_RAM+$9A,Y	
	STA Sprite_RAM+$9E,Y
	
	AND #SPR_HFLIP
	BEQ Boo_NoHFlip
	
	; H-Flip must flip patterns...
	LDA Sprite_RAM+$99,Y
	PHA
	LDA Sprite_RAM+$9D,Y
	STA Sprite_RAM+$99,Y
	PLA
	STA Sprite_RAM+$9D,Y

Boo_NoHFlip:
	JMP PRG011_B68B

	; This table starts from MAPOBJ_CHEEPCHEEP
Marcher_Patterns:
	.byte $99, $9B, $99, $9D
	.byte $AD, $AF, $BD, $BF
	.byte $C1, $C3, $C5, $C7
	.byte $C9, $CB, $CD, $CF
	.byte $D1, $D3, $D5, $D7
	.byte $D9, $DB, $DD, $DF
	.byte $E1, $E3, $E5, $E7
	
Marcher_Attributes:
	.byte SPR_PAL1
	.byte SPR_PAL1
	.byte SPR_PAL1
	.byte SPR_PAL1
	.byte SPR_PAL1
	.byte SPR_PAL1
	.byte SPR_PAL1

MapObj_DrawMarcher:
	
	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)
	LDA Map_Objects_IDs,X
	SUB #MAPOBJ_CHEEPCHEEP
	ASL A
	ASL A
	STA <Temp_Var1


	LDA Map_March_Count,X
	LSR A

	LDY Map_Operation
	CPY #$0D
	BNE MODM_UseSelfCount
	
	LDA Map_March_Count
	
MODM_UseSelfCount:
	AND #$02
	ADD <Temp_Var1
	TAX

	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)

	; Load the patterns of the map object
	LDA Marcher_Patterns,X
	STA Sprite_RAM+$99,Y	
	LDA Marcher_Patterns+1,X
	STA Sprite_RAM+$9D,Y	

	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)
	LDA Map_Objects_IDs,X
	SUB #MAPOBJ_CHEEPCHEEP
	TAX

	; Load the attributes of the map object
	LDA Marcher_Attributes,X
	STA Sprite_RAM+$9A,Y	
	LDA Marcher_Attributes,X
	STA Sprite_RAM+$9E,Y	

	; "Marching" objects come here (map object ID $02-$06/$08)
	; Horizontal flip for "marching" type objects when their Data is non-zero
	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)

	LDA Map_Object_Data,X
	BNE PRG011_B68B		; If data <> 0, jump to PRG011_B68B

	LDA Sprite_RAM+$9D,Y
	CMP Sprite_RAM+$99,Y
	BEQ PRG011_B68B	 ; If the sprite patterns are the same, jump to PRG011_B68B

	; Swaps the pattern and attributes and marks horizontal flip (i.e. mirrors the map object sprite)
	LDX Sprite_RAM+$99,Y
	STA Sprite_RAM+$99,Y
	TXA
	STA Sprite_RAM+$9D,Y
	LDA Sprite_RAM+$9A,Y
	EOR #$40
	STA Sprite_RAM+$9A,Y
	LDA Sprite_RAM+$9E,Y
	EOR #$40
	STA Sprite_RAM+$9E,Y

PRG011_B68B:
	JSR Map_CheckValidObjEntryMO
	BCC PRG011_B6F5

	; Player is going to "enter" this map object...

	LDX Player_Current	 ; X = Player_Current (needless reload?)

	LDA #$00
	STA Map_Player_SkidBack,X
	STA World_EnterState

	; Store the object ID -> Map_EnterViaID
	LDA Map_Objects_IDs,Y
	STA <Map_EnterViaID

	; If this is a N-Spade or White Toad house, jump to PRG011_B6E2
	;CMP #MAPOBJ_NSPADE
	;BEQ PRG011_B6E2
	;CMP #MAPOBJ_WHITETOADHOUSE
	;BNE PRG011_B6E5

;PRG011_B6E2:
	; N-Spade and White Toad House only...
	;INC Map_NoLoseTurn	 ; Set Map_NoLoseTurn

PRG011_B6E5:
	LDA Map_Objects_Itm,Y
	STA Level_TreasureItem

	; Begin level entry
	LDA #$0f
	STA Map_Operation

	; Don't return to caller!
	PLA
	PLA

	JMP PRG011_B57C	; Jump to PRG011_B57C

PRG011_B6F5:
	RTS		 ; Return

Map_CheckValidObjEntryMO:
	LDA Map_Operation
	CMP #$0D
	BNE MCVOE_NotValid	 ; If Map_Operation <> $0D (something is going on), jump to PRG011_B6F5 (RTS)

Map_CheckValidObjEntry:
	LDA <Map_WarpWind_FX
	BNE MCVOE_NotValid	; Don't "warp into" map objects!

	LDY <Temp_Var13		 ; Y = Temp_Var13 (the map object slot index)

	LDA Map_DrawPanState
	BNE MCVOE_NotValid	 ; If some kind of map drawing/panning activity is occurring, jump to PRG011_B6F5 (RTS)

	LDA Map_Pan_Count
	BNE MCVOE_NotValid	 ; If the map is panning, jump to PRG011_B6F5 (RTS)

	LDX Player_Current	 ; X = Player_Current

	; If the Player is not perfectly situated on top of the map object, jump to PRG011_B6F5 (RTS)

	LDA Map_Objects_Y,Y
	CMP <World_Map_Y,X
	BNE MCVOE_NotValid

	LDA Map_Objects_XHi,Y
	CMP <World_Map_XHi,X
	BNE MCVOE_NotValid

	LDA Map_Objects_XLo,Y
	CMP <World_Map_X,X
	BNE MCVOE_NotValid	
	
	; Valid entry, set carry
	SEC
	RTS
	
MCVOE_NotValid:
	; Not valid entry, clear carry
	CLC
	RTS

	; FIXME: Anyone want to claim this?  (Exact same routine appears in PRG010 @ $D228)
; $B6F6 
	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_Dir,X	; Get Player's map direction
	EOR #$03
	CMP #$03
	BNE PRG011_B703	 	; If Player did not travel left or right, jump to PRG011_B703

	EOR #$0f	 ; Otherwise invert all direction bits??

PRG011_B703:
	STA <World_Map_Dir,X	 ; -> World_Map_Dir

	RTS		 ; Return


MapStarsIntro_DoStarFX:
	LDA Map_StarFX_State
	JSR DynJump

	.word MapStarsIntro_Init
	.word WWFX_PlayerAscend	; THIS STATE IS NOT USED (accidentally/on-purpose skipped)
	.word MapStarsIntro_Do

	; Default "radius" values for each star on the world intro
MSI_DefaultRadii:	.byte $14, $10, $0C, $08, $04, $00, $1C, $18

	; Per-radius size values
MSI_RadSize:		.byte 0, 24, 48, 71, 90, 106, 118, 125, 128, 125, 118, 106, 90, 71, 48, 24


	; Patterns used by the "stars" in the intro
MapStarsIntro_Patterns:	.byte $11, $13 

MapStarsIntro_Init:
	LDA #SND_MAPENTERWORLD	
	STA Sound_QMap	; Play the starry entrance sound

	; Preload the default "radius" values for each star
	LDX #$07
PRG011_B799:
	LDA MSI_DefaultRadii,X
	STA <Map_StarsRadius,X
	DEX		 	; X--
	BPL PRG011_B799	 	; While X >= 0, loop!

	LDX <Map_StarsState
	BNE PRG011_B7AD	 	; If Map_StarsState <> 0, jump to PRG011_B7AD

	; Stars emanating from center
	LDA #$80	 
	STA <Map_StarsCenterX	; Map_StarsCenterX = $80
	STA <Map_StarsCenterY	; Map_StarsCenterY = $80
	BNE PRG011_B800	 	; Jump (technically always) to PRG011_B800

PRG011_B7AD:
	CPX #$01	 
	BNE PRG011_B7CC	 	; If Map_StarsState <> 1, jump to PRG011_B7CC

	; Stars emanating from Player start
	LDX Player_Current	; X = Player_Current

	LDA <World_Map_X,X
	ADD <Horz_Scroll
	STA <Map_StarsCenterX	; Map_StarsCenterX = Player's Map X + Horz_Scroll

	LDA <World_Map_Y,X	
	STA <Map_StarsCenterY	; Map_StarsCenterY = Player's Map Y

	LDA #$86
	STA Map_Stars_PRelX	; Map_Stars_PRelX = $86

	LDA #$d0	
	STA Map_Stars_PRelY	; Map_Stars_PRelY = $D0

	JMP PRG011_B7E6	 ; Jump to PRG011_B7E6

PRG011_B7CC:
	; Map_StarsState = 2

	LDA #$88
	STA <Map_StarsCenterX	; Map_StarsCenterX = 136

	LDA #$5c
	STA <Map_StarsCenterY	; Map_StarsCenterY = 92

	LDX Player_Current	; X = Player_Current

	LDA <World_Map_X,X
	ADD <Horz_Scroll
	STA Map_Stars_PRelX	 	; Map_Stars_PRelX = Player's map X coordinate + Horz_Scroll

	LDA <World_Map_Y,X
	STA Map_Stars_PRelY	 	; Map_Stars_PRelY = Player's map Y coordinate

	INC <Map_StarFX_State	; Next state... (NOTE: Incremented again below!)

PRG011_B7E6:

	; Calculate step and deltas
	LDX <Map_StarsCenterX
	LDA Map_Stars_PRelX
	JSR MSI_CalcDeltaAndSteps
	STA <Map_StarsXSteps
	STX Map_StarsDeltaX

	LDX <Map_StarsCenterY
	LDA Map_Stars_PRelY
	JSR MSI_CalcDeltaAndSteps
	STA <Map_StarsYSteps	
	STX Map_StarsDeltaY

PRG011_B800:
	LDA #$00
	STA <Map_StarsFrame	; Map_StarsFrame = 0
	STA <Map_StarsLandRad	; Map_StarsLandRad = 0
	STA <Map_StarsOutRad	; Map_StarsOutRad = 0

	LDA #$11
	STA <Map_StarsPattern

	LDA #$09
	STA <Map_StarsConst9	; Map_StarsConst9 = 9 (forever?)

	INC Map_StarFX_State	; Next state... (technically, +2 before it gets back)

	LDX <Map_StarsState
	CPX #$02	 
	BEQ PRG011_B81C	 	; If Map_StarsState = 2, jump to PRG011_B81C (RTS)

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG011_B81C:
	RTS		 	; Return


	; FIXME: Anyone want to claim this?
; $B81D
	JMP PRG011_B8B1	; Jump to PRG011_B8B1

MapStarsIntro_Do:
	LDA <Map_StarsLandRad
	BNE PRG011_B834	 		; If Map_StarsLandRad <> 0 (we're doing the "landing" now), jump to PRG011_B834

	LDA <Map_StarsOutRad
	ADD #$04	 
	CMP #$5f	 
	BGE PRG011_B830	 	; If Map_StarsOutRad + 4 >= $5F, jump to PRG011_B830 (change direction)

	; Otherwise, jump to PRG011_B8AF
	JMP PRG011_B8AF	

PRG011_B830:
	LDA #$01	 
	STA <Map_StarsLandRad		; Map_StarsLandRad = 1

PRG011_B834:
	; Stars landing

	LDA <Map_StarsState
	BEQ PRG011_B874	 		; If Map_StarsState = 0, jump to PRG011_B874

	LDA <Map_StarsCenterX
	CMP Map_Stars_PRelX
	BGE PRG011_B84B	 		; If Map_StarsCenterX >= Map_Stars_PRelX (Player's landing is to the left), jump to PRG011_B84B

	; Player's landing is to the right...
	ADC Map_StarsDeltaX		; Map_StarsCenterX += Map_StarsDeltaX
	TAX		 		; X = A
	DEC <Map_StarsXSteps		; Map_StarsXSteps--
	BMI PRG011_B854			; If Map_StarsXSteps < 0, jump to PRG011_B854
	INX		 		; X++
	JMP PRG011_B854	 		; Jump to PRG011_B854

PRG011_B84B:
	SBC Map_StarsDeltaX	 	; Map_StarsCenterX -= Map_StarsDeltaX
	TAX		 		; X = A
	DEC <Map_StarsXSteps		; Map_StarsXSteps--
	BMI PRG011_B854	 		; If Map_StarsXSteps < 0, jump to PRG011_B854
	DEX				; X--

PRG011_B854:
	STX <Map_StarsCenterX		; Update Map_StarsCenterX

 
	LDA <Map_StarsCenterY
	CMP Map_Stars_PRelY
	BGE PRG011_B869	 		; If Map_StarsCenterY >= Map_Stars_PRelY (Player's landing is above), jump to PRG011_B869

	; Player's landing is below...
	ADC Map_StarsDeltaY		; Map_StarsCenterY += Map_StarsDeltaY
	TAX		 		; X = A
	DEC <Map_StarsYSteps		; Map_StarsYSteps--
	BMI PRG011_B872	 		; If Map_StarsYSteps < 0, jump to PRG011_B872
	INX		 		; X++
	JMP PRG011_B872	 		; Jump to PRG011_B872

PRG011_B869:
	SBC Map_StarsDeltaY	 	; Map_StarsCenterY -= Map_StarsDeltaY
	TAX		 		; X = A
	DEC <Map_StarsYSteps		; Map_StarsYSteps--
	BMI PRG011_B872	 		; If Map_StarsYSteps < 0, jump to PRG011_B872
	DEX		 		; X--

PRG011_B872:
	STX <Map_StarsCenterY		; Update Map_StarsCenterY

PRG011_B874:
	LDA <Map_StarsOutRad
	SUB #$04	 
	BNE PRG011_B8AF	 		; If Map_StarsOutRad - 4 <> 0, jump to PRG011_B8AF

	LDA #$00	 
	STA Map_StarFX_State	 	; Map_StarFX_State = 0
	STA <Map_StarsLandRad		; Map_StarsLandRad = 0

	LDA <Map_StarsState
	CMP #$02	 
	BEQ PRG011_B8A5			; If Map_StarsState = 2, jump to PRG011_B8A5


PRG011_B8A5:
	LDX <Map_StarsState
	CPX #$02	 
	BEQ PRG011_B8AE	 	; If Map_StarsState = 2, jump to PRG011_B8AE (RTS)

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG011_B8AE:
	RTS		 ; Return

PRG011_B8AF:
	; Stars taking off

	STA <Map_StarsOutRad	; Update Map_StarsOutRad

PRG011_B8B1:
	; This just adds 32 each display frame and toggles the Map_StarsFrame when it overflows
	LDA <Map_StarsAnimCnt
	ADD #32
	STA <Map_StarsAnimCnt	; Map_StarsAnimCnt += 32
	BCC PRG011_B8C6		; If it hasn't overflowed, jump to PRG011_B8C6

	; So Map_StarsFrame toggles every 8 frames
	LDA <Map_StarsFrame	
	EOR #$01	 
	STA <Map_StarsFrame	; Toggle Map_StarsFrame (0/1)

	TAX		 
	LDA MapStarsIntro_Patterns,X	 ; Based on Map_StarsFrame, get the pattern number
	STA <Map_StarsPattern		 ; Store into Map_StarsPattern

PRG011_B8C6:
	LDY #$00	 ; Y = 0

	LDX #$07	 ; X = 7

	; This just adds $70 each display frame and toggles the Map_StarsFrame when it overflows
	LDA <Map_StarsRadCnt
	ADD #$70
	STA <Map_StarsRadCnt	; Map_StarsRadCnt += $70
	BCC PRG011_B8D5	 	; If it hasn't overflowed, jump to PRG011_B8D5

	; So roughly every 2.29 display frames...
	LDY #$01	 	; Y = 1 (+1 to the rotation)

PRG011_B8D5:
	STY <Map_StarsDeltaR	; Map_StarsDeltaR = Y (0 or 1)

PRG011_B8D7:

	; Add to each star's radius 0 or 1, capping the value at 0-31
	LDA <Map_StarsRadius,X	
	ADD <Map_StarsDeltaR	
	AND #$1f	 
	STA <Map_StarsRadius,X	; Map_StarsRadius[X] = (Map_StarsRadius[X] + 1) & $1f

	JSR MSI_CalcStarsXY	; Calculate this star's X and Y (and Temp_Var10 contains the X for the second sprite)
	JSR MSI_DrawStar	; Draw this star!
	DEX		 	; X--
	BPL PRG011_B8D7	 	; If X >= 0, loop!

	LDX <Map_StarsState
	CPX #$02	 
	BEQ PRG011_B8F2		; If Map_StarsState = 2, jump to PRG011_B8F2
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG011_B8F2:
	RTS		 ; Return

; MSI_CalcStarsXY
;
; Calculates the current X and Y position of each star
MSI_CalcStarsXY:
	LDA <Map_StarsRadius,X
	AND #$0f		; Only using values 0-15 of the "radius"	 
	TAY
	LDA MSI_RadSize,Y
	STA <Temp_Var1		; Temp_Var1 = MSI_RadSize[Y] (size for this radius)

	LDA <Map_StarsOutRad	; A = Map_StarsOutRad
	LDY <Map_StarsConst9	; Y = Map_StarsConst9
	JSR MSI_CalcXOffset	; Generates Temp_Var3 X offset value

	LDA <Map_StarsRadius,X	
	AND #$18	 
	CMP #16
	BLT PRG011_B917	 	; If (Map_StarsRadius[X] & $18) < 16, jump to PRG011_B917

	; Otherwise...
	LDA #-1
	STA <Temp_Var1		; Temp_Var1 = -1

	LDA <Map_StarsCenterX
	SBC <Temp_Var3		; A = Map_StarsCenterX - Temp_Var3 (calculated value from MSI_CalcXOffset)
	JMP PRG011_B91F	 	; Jump to PRG011_B91F

PRG011_B917:
	LDA #$01
	STA <Temp_Var1		; Temp_Var1 = 1

	LDA <Map_StarsCenterX
	ADC <Temp_Var3		; A = Map_StarsCenterX + Temp_Var3

PRG011_B91F:
	STA <Map_StarsX,X	; Set this as the star's X position
	STA <Temp_Var7		; Temp_Var7 = star's X position

	LDA <Map_StarsCenterX
	STA <Temp_Var8		; Temp_Var8 = all stars center X

	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

	LDA <Temp_Var6
	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980

	LDA <Map_StarsX,X
	ADD #8
	STA <Temp_Var10		; Temp_Var10 = star's X + 8 (will be second sprite's offset)
	STA <Temp_Var7		; Temp_Var7 = Temp_Var10

	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

	LDA <Temp_Var6		
	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980

	LDA <Map_StarsRadius,X	
	ADD #$08	 
	AND #$0f	 
	TAY		 	; Y = (radius value + 8) & $F
	LDA MSI_RadSize,Y
	STA <Temp_Var1		; Temp_Var1 = MSI_RadSize[Y] (size for this radius)

	LDA <Map_StarsOutRad	; A = Map_StarsOutRad
	LDY <Map_StarsConst9	; Y = Map_StarsConst9
	JSR MSI_CalcXOffset	; Generates Temp_Var3 X offset value

	LDA <Map_StarsRadius,X
	SUB #$08	
	AND #$18
	CMP #16
	BLT PRG011_B968	 	; If ((Map_StarsRadius[X] - 8) & $18) < 16, jump to PRG011_B968

	LDA #-1
	STA <Temp_Var1		; Temp_Var1 = -1

	LDA <Map_StarsCenterY
	SBC <Temp_Var3		; A = Map_StarsCenterX - Temp_Var3 (calculated value from MSI_CalcXOffset)
	JMP PRG011_B970	 	; Jump to PRG011_B970

PRG011_B968:
	LDA #1
	STA <Temp_Var1		; Temp_Var1 = 1

	LDA <Map_StarsCenterY
	ADC <Temp_Var3		

PRG011_B970:
	STA <Map_StarsY,X	; star's Y = Map_StarsCenterY + Temp_Var3
	STA <Temp_Var7		; Temp_Var7 = star's Y

	LDA <Map_StarsCenterY	
	STA <Temp_Var8		; Temp_Var8 = all stars center Y

	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

	LDA <Temp_Var6	
	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980
	RTS		 	; Return

PRG011_B980:
	LDA #$f8
	STA <Map_StarsY,X	; star's Y = $F8 (hides sprite)
	LDA #$00	 
	STA <Map_StarsX,X	; star's X = 0 (we're hiding the sprite)

	STA <Temp_Var10		; Temp_Var10 = star's X (0) (will be second sprite's offset)
	RTS		 	; Return

MSI_CalcXOffset:
	; A = Map_StarsOutRad
	; Y = Map_StarsConst9 (9)

	; MAPOBJ_HAMMERBROFIXME: I don't really understand the algorithm (I think it's some kind of
	; division or fractional multiplication routine?), produces X offset in Temp_Var3

	STA <Temp_Var2	; Temp_Var2 = Map_StarsOutRad

	LDA #$00	
	STA <Temp_Var3	; Temp_Var3 = 0
	STA <Temp_Var4	; Temp_Var4 = 0

PRG011_B993:
	ASL <Temp_Var4
	ROL <Temp_Var3
	ASL <Temp_Var1
	BCC PRG011_B9A6

	LDA <Temp_Var4
	ADD <Temp_Var2
	STA <Temp_Var4

	BCC PRG011_B9A6

	INC <Temp_Var3

PRG011_B9A6:
	DEY		 ; Y--
	BNE PRG011_B993	 ; While Y >= 0, loop

	RTS		 ; Return

; MSI_DrawStar
;
; Generates the hardware sprites for a star
MSI_DrawStar:
	TXA
	ASL A
	ASL A
	ASL A
	TAY		; Y = X << 3

	; Store the Y part of this star's sprites
	LDA <Map_StarsY,X	 
	STA Sprite_RAM+$98,Y	 
	STA Sprite_RAM+$9C,Y	 

	; Store the patterns for this star's sprites
	LDA <Map_StarsPattern	
	STA Sprite_RAM+$99,Y	
	STA Sprite_RAM+$9D,Y	

	; First sprite is palette 3
	LDA #$03	 
	STA Sprite_RAM+$9A,Y

	; Second sprite is same but also HV flipped
	LDA #$c3
	STA Sprite_RAM+$9E,Y

	; Store X coordinate for first sprite
	LDA <Map_StarsX,X
	STA Sprite_RAM+$9B,Y

	; Store X coordinate for second sprite
	LDA <Temp_Var10
	STA Sprite_RAM+$9F,Y

	RTS		 ; Return

PRG011_SUB_B9D4:
	; Temp_Var1 = 1 or -1
	; Temp_Var7 = star's X position
	; Temp_Var8 = all stars center X

	LDA <Temp_Var7
	EOR <Temp_Var8
	AND #$80	 
	BEQ PRG011_B9EA	 	; If Temp_Var7 and Temp_Var8 are oppositely signed, jump to PRG011_B9EA

	LDA <Temp_Var1
	BPL PRG011_B9E6	 	; If Temp_Var1 >= 0, jump to PRG011_B9E6

	LDA <Temp_Var7
	BMI PRG011_B9EF	 	; If Temp_Var7 < 0, jump to PRG011_B9EF
	BPL PRG011_B9EA	 	; Otherwise, jump to PRG011_B9EA

PRG011_B9E6:
	LDA <Temp_Var7
	BPL PRG011_B9EF	 	; If Temp_Var7 >= 0, jump to PRG011_B9EF

PRG011_B9EA:
	LDA #1
	STA <Temp_Var6		; Temp_Var6 = 1
	RTS		 	; Return...

PRG011_B9EF:
	LDA #-1
	STA <Temp_Var6		; Temp_Var6 = -1
	RTS		 	; Return...

MSI_CalcDeltaAndSteps:

	; X = Map_StarsCenterX
	; A = Map_Stars_PRelX

	STX <Temp_Var4	; Temp_Var4 = Map_StarsCenterX
	STA <Temp_Var5	; Temp_Var5 = Map_Stars_PRelX
 
	SUB <Temp_Var4	
	STA <Temp_Var1	; Temp_Var1 = Temp_Var5 (Map_Stars_PRelX) - Temp_Var4 (Map_StarsCenterX)

	LDA <Temp_Var5	
	CMP <Temp_Var4	
	BGE PRG011_BA0B	; If Temp_Var5 >= Temp_Var4, jump to PRG011_BA0B

	; Otherwise, Temp_Var1 is negative; negate it!
	LDA <Temp_Var1
	EOR #$ff	
	ADC #$01	
	STA <Temp_Var1	

	; FIXME: I don't really understand the algorithm (I think it's some kind of
	; division routine?), but it finds the delta X/Y values for the star intro
	; and the number of steps to complete the move
PRG011_BA0B:
	LDA #$00
	STA <Temp_Var3	; Temp_Var3 = 0

	LDY #$07	; Y = 7
PRG011_BA11:
	ASL <Temp_Var3
	ROL <Temp_Var1
	ROL A		
	BCS PRG011_BA1C	

	CMP #$17
	BLT PRG011_BA20	

PRG011_BA1C:
	SBC #$17	
	INC <Temp_Var3	; Temp_Var3++

PRG011_BA20:
	DEY		 ; Y--
	BPL PRG011_BA11	 ; While Y >= 0, loop!

	LDX <Temp_Var3	 ; X = Temp_Var3
	RTS		 ; Return


Map_MarkLevelComplete:
	LDX Player_Current 	 ; X = Player_Current

	LDA Map_Player_SkidBack,X
	BNE PRG011_BA89	 ; If Player skid back, we didn't complete this level, so jump to PRG011_BA89 (RTS)

	JSR Map_FindCompForPlayerPos

	; Take all current star coin bytes and combine into a bitfield
	LDA Inventory_Cards
	ASL A
	ASL A
	STA Temp_Var1

	LDA Inventory_Cards+1
	ASL A
	ORA Temp_Var1
	STA Temp_Var1

	LDA Inventory_Cards+2
	ORA Temp_Var1
	STA Temp_Var1

	; Set the complete or secret/alternate bit!
	; (Depending on whether Map_WasAltExit is set)
	LDX Map_WasAltExit

	; Clear Map_WasAltExit
	LDA #0
	STA Map_WasAltExit

	LDA Map_Completions,Y
	PHA		; We'll need to reference the prior completion bits...
	ORA MarkComplete_NormalAltBit,X	; Set complete bit!
	ORA <Temp_Var1		; Merge star coins
	STA Map_Completions,Y

	; Set Level_IsComplete in case Player re-enters immediately
	STA Level_IsComplete

	; We need to add newly acquired star coins to the total
	; for proper display. However, if there were already
	; star coins from a prior completion, we only want to
	; add the NEW ones, otherwise we'll get the total wrong.
	; (E.g. If we had 1 previously, now have all 3, it will
	; show 4 instead of 3 acquired.)

	; To fix this, we simply filter the star coins that were
	; out of the star coins we have now...
	PLA		; Previous completion bits
	EOR #(MCOMP_SCOIN1 | MCOMP_SCOIN2 | MCOMP_SCOIN3)	; Make a mask
	STA <Temp_Var1	; -> Temp_Var1
	
	; Take what we have now, filter by the mask and newly acquired
	LDA Map_Completions,Y
	AND <Temp_Var1
	AND #(MCOMP_SCOIN1 | MCOMP_SCOIN2 | MCOMP_SCOIN3)
	TAX

	; Add to total star coins!
	LDA Map_StarCoin_Got
	ADD Map_CSC_SCoinBitToVal,X
	STA Map_StarCoin_Got	

PRG011_BA89:
	RTS		 ; Return

MarkComplete_NormalAltBit:	.byte MCOMP_COMPLETE, MCOMP_SECRET


Map_Object_CheckVisibility:
	; For a given object, check if it's visible on the map.  This value is
	; stored into the Map_Objects_Vis array
	; X is the index to the map object we need to work with!
	LDY #$00	 	; Object is not visible until proven visible...

	LDA Map_Objects_XHi,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var2		; Temp_Var2 = object's X Hi byte << 4

	LDA Map_Objects_XLo,X
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	ORA <Temp_Var2		
	STA <Temp_Var2		; OR'ing the low X >> 4; Temp_Var2 now contains a proper "column" position

	LDA <Scroll_ColumnR
	SUB #$02	 	; A = Scroll_ColumnR - 2
	CMP <Temp_Var2
	BLT PRG011_BAB1	 	; If object is less than the right scroll column, jump to PRG011_BAB1

	LDA <Scroll_ColumnL	; A = Scroll_ColumnL
	CMP <Temp_Var2	
	BGE PRG011_BAB1	 	; If object is greater-equal to the left scroll column, jump to PRG011_BAB1

	LDY #$01	 	; Object is visible!
PRG011_BAB1:
	TYA		 	; A = Y
	STA Map_Objects_Vis,X 	; Mark this object as visible or not
	RTS		 	; Return

Map_Object_Canoe:
	LDY Player_Current	; Y = Player_Current
	LDA Map_InCanoe_Flag
	BEQ PRG011_BAD9	 	; If Map_InCanoe_Flag = 0, jump to PRG011_BAD9

	; Otherwise, the Canoe is updated to match the Player's
	; position; this seems to only allow one canoe per map!
	; Though it could probably be fixed somehow...
	LDA World_Map_Y,Y 
	STA Map_Objects_Y,X
	STA Map_Object_ActY,X
	LDA World_Map_X,Y	
	STA Map_Objects_XLo,X	
	STA Map_Object_ActX,X	
	LDA World_Map_XHi,Y	
	STA Map_Objects_XHi,X	
	STA Map_Object_ActXH,X	

PRG011_BAD9:

	; Basically if Player is standing in Canoe, it activates the Map_InCanoe_Flag flag
	LDA World_Map_Move,Y
	ORA Map_Player_SkidBack,Y
	BNE PRG011_BAFE	 

	LDA World_Map_Y,Y
	CMP Map_Object_ActY,X
	BNE PRG011_BAFE

	LDA World_Map_XHi,Y
	CMP Map_Object_ActXH,X
	BNE PRG011_BAFE	 

	LDA World_Map_X,Y
	CMP Map_Object_ActX,X
	BNE PRG011_BAFE	 

	; Map_InCanoe_Flag = 1 (In canoe!)
	LDA #$01
	STA Map_InCanoe_Flag

PRG011_BAFE:
	RTS		 ; Return

W8D_CircSprs:
	.byte $F8, $81, $01, $F0
	.byte $F0, $83, $01, $F8
	.byte $E8, $85, $01, $00
	.byte $E8, $85, $41, $08
	.byte $F0, $83, $41, $10
	.byte $F8, $81, $41, $18
	.byte $08, $81, $81, $F0
	.byte $10, $83, $81, $F8
	.byte $18, $85, $81, $00
	.byte $18, $85, $C1, $08
	.byte $10, $83, $C1, $10
	.byte $08, $81, $C1, $18
	.byte $E8, $0B, $01, $F0
	.byte $E8, $0B, $01, $18
	.byte $18, $0B, $01, $F0
	.byte $18, $0B, $01, $18
	.byte $F0, $0B, $01, $E8
	.byte $00, $0B, $01, $E8
	.byte $10, $0B, $01, $E8
	.byte $F0, $0B, $01, $20
	.byte $00, $0B, $01, $20
W8D_CircSprs_Unaligned

	.byte $10, $0B, $01, $20
	.byte $E0, $87, $01, $F8
	.byte $E0, $87, $01, $10
	.byte $20, $87, $81, $F8
W8D_CircSprs_Aligned

PRG011_BB63:
	.byte $20, $87, $81

PRG011_BB66:
	.byte $10, $E0, $E8, $D8, $F0, $D0, $F8

FX_World_8_Darkness:
	LDY World_8_Dark	; Y = World_8_Dark
	BEQ PRG011_BB7A	 	; If not in the World 8 darkness, jump to PRG011_BB7A (RTS)
	LDX Player_Current	; X = Player_Current
	LDA Map_Player_SkidBack,X
	BEQ PRG011_BB7B	 	; If Player's Map_Player_SkidBack = 0, jump to PRG011_BB7B

PRG011_BB7A:
	RTS		 	; Otherwise, return...

PRG011_BB7B:
	CPY #$07	 
	BGE PRG011_BB9A	 	; If World_8_Dark >= 7 (effect complete), jump to PRG011_BB9A

	LDA #$00	
	STA Map_W8D_Idx	 	; Map_W8D_Idx = 0

	LDA <World_Map_X,X	; Player's X coordinate -> A
	ADD PRG011_BB66,Y	; Add an offset based on World_8_Dark

	LDY <World_Map_Y,X	; Y = Player's Y coordinate
	LDX #$01	 	; X = 1

	JSR Map_W8DarknessUpdate	; Update darkness around Player

	INC World_8_Dark	; World_8_Dark++

	LDA World_8_Dark	 
	LSR A		 	
	BCC FX_World_8_Darkness	; Loops if carry not set by the "LSR A" (so only loops on 2, 4, 6)

PRG011_BB9A:
	LDX Player_Current	; X = Player_Current

	LDY #$00	 ; Y = 0

	LDA <World_Map_Move,X
	AND #$07	; Cap 0-7
	CMP #$06
	BEQ PRG011_BBAC	 ; On "6" of every "0-7" jump to PRG011_BBAC

	CMP #$02
	BNE PRG011_BBBB	 ; If not "2" of every "0-7" jump to PRG011_BBBB

	INY		 ; Otherwise, Y++

PRG011_BBAC:
	STY Map_W8D_Idx	 ; -> Map_W8D_Idx

	LDA <World_Map_X,X
	PHA		 ; Save Player's map X

	LDY <World_Map_Y,X	 ; Y = Player's map Y

	LDA <World_Map_Dir,X
	TAX		 ; X = Player's map direction of travel

	PLA		 ; A = Player's map X

	; Update darkness around Player
	JSR Map_W8DarknessUpdate

PRG011_BBBB:
	LDY #(W8D_CircSprs_Unaligned - W8D_CircSprs)

	LDX Player_Current	 ; X = Player_Current

	; Temp_Var1/2 = Player's Map Y/X
	LDA <World_Map_Y,X
	STA <Temp_Var1
	LDA <World_Map_X,X
	STA <Temp_Var2

	LDX #(W8D_CircSprs_Unaligned - W8D_CircSprs)

	AND #$0f	 ; Get lower 4 bits of X
	BNE PRG011_BBD0	 ; If Player is not perfectly aligned in column, jump to PRG011_BBD0

	LDX #(W8D_CircSprs_Aligned - W8D_CircSprs)

PRG011_BBD0:

	; Set circle sprite Y
	LDA <Temp_Var1
	ADD W8D_CircSprs,X
	STA Sprite_RAM+$08,Y

	; Set circle sprite pattern
	LDA W8D_CircSprs+1,X
	STA Sprite_RAM+$09,Y

	; Set circle sprite attribute
	LDA W8D_CircSprs+2,X
	STA Sprite_RAM+$0A,Y

	; Set circle sprite X
	LDA <Temp_Var2
	ADD W8D_CircSprs+3,X
	STA Sprite_RAM+$0B,Y

	DEY
	DEY
	DEY
	DEY	; Y -= 4 (previous sprite)

	DEX
	DEX
	DEX
	DEX	; X -= 4 (previous circle sprite def)

	BMI PRG011_BC00	 ; If out of sprites, jump to PRG011_BC00

	CPX #(W8D_CircSprs_Unaligned - W8D_CircSprs)
	BNE PRG011_BBD0	 ; If not at end of aligned circle sprites, loop

	LDX #$3c
	BNE PRG011_BBD0	 ; If X <> $3C (?), loop

PRG011_BC00:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DoAnimations
;
; This subroutine takes care of the simplistic animations
; that occur on the world maps.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Map_AnimSpeeds:
	; These define the ticks to wait for each frame of the
	; map animation per world.  Interestingly, this allows
	; for different pauses on each frame, but it appears 
	; that this functionality was left unused,
	.byte $11, $11, $11, $11	; World 1
	.byte $08, $08, $08, $08	; World 2
	.byte $17, $17, $17, $17	; World 3
	.byte $17, $17, $17, $17	; World 4
	.byte $12, $12, $12, $12	; World 5
	.byte $0B, $0B, $0B, $0B	; World 6
	.byte $1D, $1D, $1D, $1D	; World 7
	.byte $0F, $0F, $0F, $0F	; World 8
	.byte $14, $14, $14, $14	; World 9 (Warp Zone)
	.byte $0F, $0F, $0F, $0F	; World Zero

Map_AnimCHRROM:
	; This sets the CHRROM page in use per animation frame (common to all worlds)
	.byte $14, $70, $72, $74

Map_DoAnimations:	; $BC29
	LDX World_Num	; X = World_Num
	CPX #8	; SB: World 9
	BNE PRG011_BC34	; If not on World 9, jump to PRG011_BC34

	; World 9...
	LDY #$00		; Otherwise, Y = 0
	BPL Map_NoAnimUpdate	; (technically always) jump to Map_NoAnimUpdate (World 9 does not animate)

PRG011_BC34:
	; Any world but 9 goes here...
	CPX #7		
	BNE PRG011_BC46	 	; If World is NOT 8, jump to PRG011_BC46

	; World 8
	LDY Player_Current	; Y = Player_Current
	LDA World_Map_XHi,Y	; Get player's hi byte coordinate (what "level" of world 8 we're on...)
	CMP #$03
	BNE PRG011_BC46		; If NOT on the final screen of World 8 (Bowser's castle), jump to PRG011_BC46

	; World 8 Final screen
	LDY #$00	 	; Otherwise, Y = 0
	BEQ Map_NoAnimUpdate	; (technically always) jump to Map_NoAnimUpdate (final screen doesn't animate)

PRG011_BC46:
	LDY World_Map_AnimF	; Get current world map animation frame
	DEC World_Map_AnimT	; World_Map_AnimT--
	BPL Map_NoAnimUpdate 	; If ticks remain, jump to Map_NoAnimUpdate

	INY		 ; Y++ (next frame)
	TYA		 ; A = frame
	;CPX #2
	;BNE PRG011_BC5D	 ; If world is NOT 3, jump to PRG011_BC5D

	; World 3 limits animation to one of two frames, since part
	; of that animation includes the draw bridges.
	;AND #$01	 	; Only allowing one frame through (0 and 1)
	;LDY World3_Bridge	; Get the bridge state
	;BEQ PRG011_BC5D	 	; If World3_Bridge = 0 (bridges are down), jump to PRG011_BC5D
	;ORA #$02	 	; Otherwise, jump the animation higher (between 0 and 3)

;PRG011_BC5D:
	AND #$03	 	; Cap animation to 0-3
	STA World_Map_AnimF	; Store the updated frame

	; Reset the animation clock
	TAY
	TXA
	ASL A
	ASL A
	ORA World_Map_AnimF
	TAX		 
	LDA Map_AnimSpeeds,X	 ; X = World_Num * 4 + World_Map_AnimF (get tick for frame 0-3 in this world)
	STA World_Map_AnimT	 ; Store this new tick

Map_NoAnimUpdate:
	LDA Map_AnimCHRROM,Y	; Get the correct CHRROM page
	STA PatTable_BankSel	  	; Put it to use
	RTS		  ; Return!


Map_CountComets_ByWorld:
	LDA Map_ObjCompletions,X
	STA <Temp_Var3

	TXA
	PHA
	ASL A
	TAX

	LDA Map_List_Object_IDs,X
	STA <Temp_Var1
	LDA Map_List_Object_IDs+1,X
	STA <Temp_Var2
	

	; Counting all trackable map objects
	LDY #7
Map_CCBW_Loop:
	LDA [Temp_Var1],Y
	CMP #MAPOBJ_DAREDEVILCOMET
	BEQ Map_CCBW_CountComet
	CMP #MAPOBJ_PURPLECOMET
	BNE Map_CCBW_NotComet
Map_CCBW_CountComet:

	; Definitely one more towards the total
	INC Map_StarCoin_Total
	
	; If defeated, one more towards the star coins
	LDA <Temp_Var3
	AND MapObj_CompleteBit,Y
	BEQ Map_CCBW_NotComet	; If this comet hasn't been beat yet, jump to Map_CCBW_NotComet
	
	; Completed comet!
	INC Map_StarCoin_Got

Map_CCBW_NotComet:
	DEY
	BPL Map_CCBW_Loop

	PLA
	TAX
	
	RTS
	

Map_BackupObj_SlotOff:	.byte 0, MAPOBJ_TOTAL


	; The slots are marked per world. Given a player, determine
	; what slot is appropriate for them, based on what world
	; they're in...
Map_GetSlotForBackup:
	; Get Player's world
	LDX Player_Current
	LDA Map_Previous_World,X
	STA <Temp_Var1	; We'll need this later

	LDX Total_Players
	CPX #1
	BEQ MGSFB_1P	; If a 1P game, it's easy; just always use slot 0

	; 2P makes a mess, of course...

	LDX #0
	CMP Map_ObjBackup_World,X
	BEQ MGSFB_FoundWorldInSlot	; If found in slot 0, return it!
	INX
	CMP Map_ObjBackup_World,X
	BEQ MGSFB_FoundWorldInSlot	; If found in slot 1, return it!
	
	; Shit! Neither slot has the world the player is in...
	; So we need to find the slot that neither player 
	; is using... we know that this player doesn't have a
	; slot, so we just need to find the one that the other
	; player is using and not use that one!
	LDA Player_Current
	EOR #1	; The OTHER player
	TAX
	LDA Map_Previous_World,X	; Get other player's world

	LDX #0
	CMP Map_ObjBackup_World,X
	BNE MGSFB_FoundWorldInSlot	; If it's not in slot 0, use slot 0!
	
	INX		; Slot 0 is in use, use slot 1

MGSFB_FoundWorldInSlot:
	RTS

MGSFB_1P:
	LDX #0
	RTS

Map_RestoreObjects:
	JSR Map_GetSlotForBackup
	
	; Now that we have the slot, let's check if the world number
	; is correct. If it's NOT, we need to reload objects!
	LDA <Temp_Var1	; Player's world
	CMP Map_ObjBackup_World,X	; Check against slot's world
	BEQ MRO_WorldMatch		; If slot world matches, jump to MRO_WorldMatch
	
	; On a mismatch, that means the world was not in the slots,
	; and we need to actually load the objects...
	
	; This will be the world now!
	STA Map_ObjBackup_World,X
	
	JSR Map_LoadObjects
	
	; After loading, immediatel backup to get backup in sync
	; (Further backups won't happen until end of turn)
	JMP Map_BackupObjects

MRO_WorldMatch:
	LDA Map_BackupObj_SlotOff,X
	TAX
	LDY #0
Map_PSwitch_ReloadObjects:
	LDA Map_ObjBackup_Y,X
	STA Map_Objects_Y,Y
	LDA Map_ObjBackup_XLo,X
	STA Map_Objects_XLo,Y
	LDA Map_ObjBackup_XHi,X
	STA Map_Objects_XHi,Y
	LDA Map_ObjBackup_IDs,X
	STA Map_Objects_IDs,Y
	LDA Map_ObjBackup_Itm,X
	STA Map_Objects_Itm,Y
	
	INX
	INY
	CPY #MAPOBJ_TOTAL
	BLT Map_PSwitch_ReloadObjects

	RTS
	

	; Player's turn has ended, need to back up map object
	; positions into the appropriate slot...
Map_BackupObjects:
	JSR Map_GetSlotForBackup

	LDA Map_BackupObj_SlotOff,X
	TAX
	LDY #0
Map_BackupObjectsLoop:
	LDA Map_Objects_Y,Y
	STA Map_ObjBackup_Y,X
	LDA Map_Objects_XLo,Y
	STA Map_ObjBackup_XLo,X
	LDA Map_Objects_XHi,Y
	STA Map_ObjBackup_XHi,X
	LDA Map_Objects_IDs,Y
	STA Map_ObjBackup_IDs,X
	LDA Map_Objects_Itm,Y
	STA Map_ObjBackup_Itm,X
	
	INX
	INY
	CPY #MAPOBJ_TOTAL
	BLT Map_BackupObjectsLoop
	
	RTS
