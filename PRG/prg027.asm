; Source generated by DCC6502 version v1.4
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg027.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------
CineKing_DoWandReturn:
	LDA CineKing_Timer2
	BEQ PRG027_A008	 ; If CineKing_Timer2 = 0, jump to PRG027_A008

	DEC CineKing_Timer2	 ; CineKing_Timer2--

PRG027_A008:
	JSR Sprite_RAM_Clear
	JMP EndWorldSeq_DoState		; Perform state operation for Toad & King Cinematic

EndWorldSeq_DoState:
	LDA CineKing_State
	JSR DynJump
	
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word EndWorldSeq_Init		; 0: Initialize vars
	.word EndWorldSeq_Victory	; 1: World x Complete!
	.word EndWorldSeq_FadeOut	; 2: Fade out, prepare fade in the letter
	.word EndWorldSeq_WaitForA		; 3: Waits for Player to push A

EndWorldSeq_Init:
	; CineKing_Timer2 = $80
	LDA #$80
	STA CineKing_Timer2

	; Set Player to top of screen
	STA <Player_Y

	; Clear auto scroll variables
	LDY #$14	 ; Y = $14
PRG027_A052:
	STA AScroll_Anchor-1,Y	 ; Clear this auto scroll variable
	DEY		 ; Y--
	BNE PRG027_A052	 ; While Y <> 0, loop!

	; Font
	LDA #146
	STA PatTable_BankSel+1

	; CineKing_Timer2 = $1E
	LDA #$1e
	STA CineKing_Timer2

	INC CineKing_State	 ; CineKing_State = 1

	LDA Player_RescuePrincess
	BNE Ending_SkipWorldMus

	; SB: World Victory!
	LDA #MUS2B_SMB1VICTORY
	STA Sound_QMusic2

Ending_SkipWorldMus:
	RTS		 ; Return

EndWorldSeq_Victory:

	LDA SndCur_Music2
	BNE EndWorldSeq_VictoryMusNotDone

	; Music done!
	
	; CineKing_Timer2 = $1E
	LDA #$1e
	STA CineKing_Timer2

	; Next state
	INC CineKing_State

EndWorldSeq_VictoryMusNotDone:
	LDA Player_RescuePrincess
	BEQ EndWorldSeq_NotEnding

	; Ending only: Hit A or START to reset
	LDA <Pad_Input
	AND #(PAD_A | PAD_START)
	BEQ EndWorldSeq_NotEnding
	
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	JSR_THUNKA 26, Palette_FadeOut	 		; Fade out
	;LDA #0
	;STA Reset_Latch
	INC CineKing_State
	JMP W8BypassJct

EndWorldSeq_NotEnding:
	RTS

Letter_Palette:
	.byte $0F, $0F, $30, $3C, $0F, $10, $35, $30, $0F, $00, $10, $30, $0F, $1B, $2C, $3C
	.byte $0F, $30, $16, $0F, $0F, $16, $25, $30, $0F, $30, $21, $0F, $0F, $30, $27, $0F

EndWorldSeq_FadeOut:
	LDA CineKing_Timer2
	BEQ PRG027_A0A8	 ; If CineKing_Timer2 is expired, jump to PRG027_A0A8

	LSR A
	BNE PRG027_A0CD	 ; Every other tick, jump to PRG027_A0CD (RTS)

	JMP Palette_PrepareFadeOutTK	 ; Otherwise, jump to Palette_PrepareFadeOutTK

PRG027_A0A8:
	JSR Palette_DoFadeOutTK	 ; Fade out (the King's room)

	LDA Fade_Level
	BNE PRG027_A0CD	 ; If not completely faded, jump to PRG027_A0CD

W8BypassJct:
	; Font
	LDA #$5e
	STA PatTable_BankSel+1

	; Load up the letter's palette
	LDY #31		; Y = 31 (all colors)
PRG027_A0B2:
	LDA Letter_Palette,Y
	STA Pal_Data,Y
	DEY		 ; Y--
	BPL PRG027_A0B2	 ; While Y >= 0, loop

	JSR Palette_PrepareFadeInTK	 ; Fade in (the letter)

	; Set scroll up high (the letter is actually level data)
	LDA #$18
	STA <Vert_Scroll

	; Level_VertScrollH = 1
	LDA #$01
	STA Level_VertScrollH

	LDA #MUS2C_STAR
	LDY Player_RescuePrincess
	BEQ EndWorldSeq_PlayStarMusic

	LDA #MUS2B_PRINCESS
	
EndWorldSeq_PlayStarMusic:
	STA Sound_QMusic2

	INC CineKing_State	 ; CineKing_State = 4 

PRG027_A0CD:
	RTS		 ; Return


	; Eyes/Mouth sprite pattern use to animate the Princess "talking"
Princess_FacePatterns:
	.byte $83, $87, $89
	.byte $A3, $A7, $A9

Letter_PrincessSprites:
	.byte $78, $83, $01, $38
	.byte $68, $97, $01, $38
	.byte $78, $81, $01, $30
	.byte $78, $85, $01, $40
	.byte $88, $91, $01, $30
	.byte $88, $93, $01, $38
	.byte $88, $95, $01, $40
Letter_PrincessSprites_End

EndWorldSeq_WaitForA:
	; Load needed graphics
	LDA #$05
	STA PatTable_BankSel+3
	LDA #$7F
	STA PatTable_BankSel+4

	LDA #0
	STA <Temp_Var1

	LDA World_Num
	CMP #6
	BNE Princess_NotW7	; If not world 7, jump to Princess_NotW7

	; World 7 only...
	LDA #$20
	STA <Temp_Var1

Princess_NotW7:

	; Copy in the sprites that make up the Princess in the lower left corner of the letter
	LDY #(Letter_PrincessSprites_End - Letter_PrincessSprites)
PRG027_A148:
	LDA Letter_PrincessSprites-1,Y
	STA Sprite_RAM+$9F,Y
	
	TYA
	AND #$03
	CMP #2
	BNE PrincessCopy_NotW7	; If not the pattern, jump to PrincessCopy_NotW7

	; Add offset to pattern (intended for Rosalina)
	LDA Sprite_RAM+$9F,Y
	ADD <Temp_Var1
	STA Sprite_RAM+$9F,Y

PrincessCopy_NotW7:
	DEY		 ; Y--
	BNE PRG027_A148	 ; While Y <> 0, loop

	JSR Palette_DoFadeInTK	 ; Perform fade in

	LDA Fade_Level
	BNE PRG027_A1A7	 ; If not done fading, jump to PRG027_A1A7 (RTS)

	LDA CineKing_Timer2
	BEQ PRG027_A169	 ; If CineKing_Timer2 is expired, jump to PRG027_A169

	JSR Letter_PaletteKludge	 ; Not sure what this is for; sets up the graphics buffer to patch a single palette color?

PRG027_A169:
	LDA <Pad_Input
	BPL PRG027_A174		; If Player is NOT pressing A, jump to PRG027_A174

	JSR_THUNKC 10, Map_CompleteWorld

	LDY Player_RescuePrincess
	BEQ EndWorldSeq_NoReset

	; On ending letter, reset game
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	JSR_THUNKA 26, Palette_FadeOut	 		; Fade out

	; Reset all Toad Houses
	JSR_THUNKA 12, Map_ResetToadHouses

	LDA #1
	STA Map_CometMode

	JSR Game_SaveData

	LDA #0
	STA Reset_Latch

EndWorldSeq_NoReset:

EndWorldSeq_JumpBack:
	INC <Level_ExitToMap	; Exiting to map!

	; World_EnterState = 0
	LDA #$00
	STA World_EnterState

PRG027_A174:
	LDY #$01	 ; Y = 1

	LDA <Counter_1
	AND #$38
	BEQ PRG027_A181	 ; Periodically jump to PRG027_A181

	LSR A
	LSR A
	AND #$02
	TAY		 ; Y = 0 or 2

PRG027_A181:
	LDA World_Num
	CMP #6
	BNE PrincessMouth_NotW7		; If not World 7, jump to PrincessMouth_NotW7

	; Rosalina must be offset by 3
	INY
	INY
	INY

PrincessMouth_NotW7:
	; Change face sprite pattern
	LDA Princess_FacePatterns,Y
	STA Sprite_RAM+$A1


PRG027_A1A7:
	RTS		 ; Return

Letter_PalKludges:
	.byte $0F, $16

Letter_PaletteKludge:
	LDA CineKing_Timer2
	LSR A
	AND #$01
	TAY		 ; Y = 0 or 1, changing every other tick

	LDA Letter_PalKludges,Y	 ; Load palette value

	LDY Graphics_BufCnt	 ; Y = graphics buffer counter

	STA Graphics_Buffer+$3,Y ; Store into buffer

	; Color at $3F10
	LDA #$3f
	STA Graphics_Buffer,Y
	LDA #$10
	STA Graphics_Buffer+$1,Y

	; Run length of 1
	LDA #$01
	STA Graphics_Buffer+$2,Y

	; Terminator
	LSR A
	STA Graphics_Buffer+$4,Y

	; Y += 4 (bytes into buffer)
	INY
	INY
	INY
	INY

	; Update graphics buffer counter
	STY Graphics_BufCnt

	RTS		 ; Return

PRG027_A1D5:
	.byte $15, $0E, $07, $00


Letter_Bodies:
	.word Letter_World1	; World 1
	.word Letter_World2	; World 2
	.word Letter_World3	; World 3
	.word Letter_World4	; World 4
	.word Letter_World5	; World 5
	.word Letter_World6	; World 6
	.word Letter_World7	; World 7 
	.word Letter_World8	; World 8
	.word Letter_World1	; World 9 (Not used)
	.word Letter_WorldZeroA	; World Zero (Incomplete)
	.word Letter_WorldZeroB	; World Zero (Fully complete)

Letter_World1:
	;       R    e    s    t    i    n    g         a    f    t    e    r         t    h    e    i    r    
	.byte $C1, $D4, $CC, $CD, $D8, $DD, $D6, $FE, $D0, $D5, $CD, $D4, $CB, $FE, $CD, $D7, $D4, $D8, $CB, $00

	;       v    i    c    t    o    r    i    o    u    s         d    e    f    e    a    t         o    f    
	.byte $CF, $D8, $D2, $CD, $DE, $CB, $D8, $DE, $CE, $CC, $FE, $D3, $D4, $D5, $D4, $D0, $CD, $FE, $DE, $D5, $00

	;       B    o    w    s    e    r    ,         o    u    r         h    e    r    o    e    s    
	.byte $B1, $DE, $81, $CC, $D4, $CB, $9A, $FE, $DE, $CE, $CB, $FE, $D7, $D4, $CB, $DE, $D4, $CC, $00

	;       d    r    e    a    m         o    f         a         s    t    a    i    r    w    a    y         
	.byte $D3, $CB, $D4, $D0, $DC, $FE, $DE, $D5, $FE, $D0, $FE, $CC, $CD, $D0, $D8, $CB, $81, $D0, $8C, $FE, $00

	;       l    e    a    d    i    n    g         t    o         a         w    o    r    l    d    .    
	.byte $DB, $D4, $D0, $D3, $D8, $DD, $D6, $FE, $CD, $DE, $FE, $D0, $FE, $81, $DE, $CB, $DB, $D3, $E9, $00

	;       
	.byte $00

	;       U    p    o    n         a    w    a    k    e    n    i    n    g    ,    
	.byte $C4, $DF, $DE, $DD, $FE, $D0, $81, $D0, $DA, $D4, $DD, $D8, $DD, $D6, $9A, $00

	;       t    h    e    y         w    e    n    t         t    o         a         c    a    v    e    
	.byte $CD, $D7, $D4, $8C, $FE, $81, $D4, $DD, $CD, $FE, $CD, $DE, $FE, $D0, $FE, $D2, $D0, $CF, $D4, $00

	;       n    e    a    r    b    y         a    n    d    ,         t    o         t    h    e    i    r    
	.byte $DD, $D4, $D0, $CB, $D1, $8C, $FE, $D0, $DD, $D3, $9A, $FE, $CD, $DE, $FE, $CD, $D7, $D4, $D8, $CB, $00

	;       s    u    r    p    r    i    s    e    ,         s    a    w    
	.byte $CC, $CE, $CB, $DF, $CB, $D8, $CC, $D4, $9A, $FE, $CC, $D0, $81, $00

	;       e    x    a    c    t    l    y         w    h    a    t         t    h    e    y    
	.byte $D4, $88, $D0, $D2, $CD, $DB, $8C, $FE, $81, $D7, $D0, $CD, $FE, $CD, $D7, $D4, $8C, $00

	;       h    a    d         s    e    e    n         i    n         t    h    e    i    r    
	.byte $D7, $D0, $D3, $FE, $CC, $D4, $D4, $DD, $FE, $D8, $DD, $FE, $CD, $D7, $D4, $D8, $CB, $00

	;       d    r    e    a    m    s    .    .    .    
	.byte $D3, $CB, $D4, $D0, $DC, $CC, $E9, $E9, $E9, $00

	; Terminator
	.byte $FF


Letter_World2:
	;       A    f    t    e    r         d    e    f    e    a    t    i    n    g         t    h    e    
	.byte $B0, $D5, $CD, $D4, $CB, $FE, $D3, $D4, $D5, $D4, $D0, $CD, $D8, $DD, $D6, $FE, $CD, $D7, $D4, $00

	;       e    v    i    l         K    i    n    g         W    a    r    t    ,         o    u    r    
	.byte $D4, $CF, $D8, $DB, $FE, $BA, $D8, $DD, $D6, $FE, $C6, $D0, $CB, $CD, $9A, $FE, $DE, $CE, $CB, $00

	;       h    e    r    o    e    s         g    r    o    u    n    d         t    h    e    
	.byte $D7, $D4, $CB, $DE, $D4, $CC, $FE, $D6, $CB, $DE, $CE, $DD, $D3, $FE, $CD, $D7, $D4, $00

	;       a    i    r    s    h    i    p         t    o         f    i    n    d         t    h    e    y    
	.byte $D0, $D8, $CB, $CC, $D7, $D8, $DF, $FE, $CD, $DE, $FE, $D5, $D8, $DD, $D3, $FE, $CD, $D7, $D4, $8C, $00

	;       a    r    e         a    t         t    h    e         f    o    o    t         o    f         a    
	.byte $D0, $CB, $D4, $FE, $D0, $CD, $FE, $CD, $D7, $D4, $FE, $D5, $DE, $DE, $CD, $FE, $DE, $D5, $FE, $D0, $00

	;       d    a    r    k         f    o    r    e    s    t         c    a    l    l    e    d    
	.byte $D3, $D0, $CB, $DA, $FE, $D5, $DE, $CB, $D4, $CC, $CD, $FE, $D2, $D0, $DB, $DB, $D4, $D3, $00

	;       B    o    o    '    s         W    o    o    d    s    .    
	.byte $B1, $DE, $DE, $AB, $CC, $FE, $C6, $DE, $DE, $D3, $CC, $E9, $00

	;       
	.byte $00

	;       H    o    p    e    f    u    l    l    y         o    u    r         h    e    r    o    e    s    
	.byte $B7, $DE, $DF, $D4, $D5, $CE, $DB, $DB, $8C, $FE, $DE, $CE, $CB, $FE, $D7, $D4, $CB, $DE, $D4, $CC, $00

	;       w    i    l    l         r    e    m    e    m    b    e    r    
	.byte $81, $D8, $DB, $DB, $FE, $CB, $D4, $DC, $D4, $DC, $D1, $D4, $CB, $00

	;       t    h    a    t         B    o    o    s         d    o         n    o    t    
	.byte $CD, $D7, $D0, $CD, $FE, $B1, $DE, $DE, $CC, $FE, $D3, $DE, $FE, $DD, $DE, $CD, $00

	;       f    e    a    r         a    n    y    t    h    i    n    g         i    n    
	.byte $D5, $D4, $D0, $CB, $FE, $D0, $DD, $8C, $CD, $D7, $D8, $DD, $D6, $FE, $D8, $DD, $00

	;       t    h    e         d    a    r    k    .    .    .    
	.byte $CD, $D7, $D4, $FE, $D3, $D0, $CB, $DA, $E9, $E9, $E9, $00



	; Terminator
	.byte $FF


Letter_World3:
	;       B    o    w    s    e    r         J    r    .    '    s         B    o    o    m    e    r    
	.byte $B1, $DE, $81, $CC, $D4, $CB, $FE, $B9, $CB, $E9, $AB, $CC, $FE, $B1, $DE, $DE, $DC, $D4, $CB, $00

	;       w    e    a    p    o    n         w    a    s         n    o         m    a    t    c    h    
	.byte $81, $D4, $D0, $DF, $DE, $DD, $FE, $81, $D0, $CC, $FE, $DD, $DE, $FE, $DC, $D0, $CD, $D2, $D7, $00

	;       f    o    r         o    u    r         h    e    r    o    e    s    !         T    h    e    y    
	.byte $D5, $DE, $CB, $FE, $DE, $CE, $CB, $FE, $D7, $D4, $CB, $DE, $D4, $CC, $EA, $FE, $C3, $D7, $D4, $8C, $00

	;       h    a    v    e         n    o    w         l    a    n    d    e    d         i    n         a    
	.byte $D7, $D0, $CF, $D4, $FE, $DD, $DE, $81, $FE, $DB, $D0, $DD, $D3, $D4, $D3, $FE, $D8, $DD, $FE, $D0, $00

	;       l    a    n    d         w    h    e    r    e         d    i    n    o    s    a    u    r    s    
	.byte $DB, $D0, $DD, $D3, $FE, $81, $D7, $D4, $CB, $D4, $FE, $D3, $D8, $DD, $DE, $CC, $D0, $CE, $CB, $CC, $00

	;       s    t    i    l    l         r    o    a    m    .    
	.byte $CC, $CD, $D8, $DB, $DB, $FE, $CB, $DE, $D0, $DC, $E9, $00

	;       
	.byte $00

	;       W    h    i    l    e         m    a    n    y         h    e    r    e         a    r    e    
	.byte $C6, $D7, $D8, $DB, $D4, $FE, $DC, $D0, $DD, $8C, $FE, $D7, $D4, $CB, $D4, $FE, $D0, $CB, $D4, $00

	;       f    o    e    s    ,         o    u    r         h    e    r    o    e    s         m    a    y    
	.byte $D5, $DE, $D4, $CC, $9A, $FE, $DE, $CE, $CB, $FE, $D7, $D4, $CB, $DE, $D4, $CC, $FE, $DC, $D0, $8C, $00

	;       s    e    e    k         t    h    e         a    i    d         o    f    
	.byte $CC, $D4, $D4, $DA, $FE, $CD, $D7, $D4, $FE, $D0, $D8, $D3, $FE, $DE, $D5, $00

	;       o    n    e         d    i    n    o    s    a    u    r    
	.byte $DE, $DD, $D4, $FE, $D3, $D8, $DD, $DE, $CC, $D0, $CE, $CB, $00

	;       n    a    m    e    d         Y    o    s    h    i    !    
	.byte $DD, $D0, $DC, $D4, $D3, $FE, $C8, $DE, $CC, $D7, $D8, $EA, $00



	; Terminator
	.byte $FF

	
Letter_World4:
	;       O    u    r         h    e    r    o    e    s         h    a    v    e         Y    o    s    h    i    
	.byte $BE, $CE, $CB, $FE, $D7, $D4, $CB, $DE, $D4, $CC, $FE, $D7, $D0, $CF, $D4, $FE, $C8, $DE, $CC, $D7, $D8, $00

	;       t    o         t    h    a    n    k         f    o    r         t    h    e         h    e    l    p    
	.byte $CD, $DE, $FE, $CD, $D7, $D0, $DD, $DA, $FE, $D5, $DE, $CB, $FE, $CD, $D7, $D4, $FE, $D7, $D4, $DB, $DF, $00

	;       i    n         f    i    g    h    t    i    n    g         a    g    a    i    n    s    t    
	.byte $D8, $DD, $FE, $D5, $D8, $D6, $D7, $CD, $D8, $DD, $D6, $FE, $D0, $D6, $D0, $D8, $DD, $CC, $CD, $00

	;       B    o    w    s    e    r         J    r    .         B    i    d    d    i    n    g    
	.byte $B1, $DE, $81, $CC, $D4, $CB, $FE, $B9, $CB, $E9, $FE, $B1, $D8, $D3, $D3, $D8, $DD, $D6, $00

	;       f    a    r    e    w    e    l    l         t    o         Y    o    s    h    i    ,    
	.byte $D5, $D0, $CB, $D4, $81, $D4, $DB, $DB, $FE, $CD, $DE, $FE, $C8, $DE, $CC, $D7, $D8, $9A, $00

	;       o    u    r         h    e    r    o    e    s         n    o    w         f    i    n    d    
	.byte $DE, $CE, $CB, $FE, $D7, $D4, $CB, $DE, $D4, $CC, $FE, $DD, $DE, $81, $FE, $D5, $D8, $DD, $D3, $00

	;       t    h    e    m    s    e    l    v    e    s         i    n         a    n         a    r    i    d    
	.byte $CD, $D7, $D4, $DC, $CC, $D4, $DB, $CF, $D4, $CC, $FE, $D8, $DD, $FE, $D0, $DD, $FE, $D0, $CB, $D8, $D3, $00

	;       d    e    s    e    r    t         f    i    l    l    e    d         w    i    t    h    
	.byte $D3, $D4, $CC, $D4, $CB, $CD, $FE, $D5, $D8, $DB, $DB, $D4, $D3, $FE, $81, $D8, $CD, $D7, $00

	;       a    n    c    i    e    n    t         r    u    i    n    s    .    
	.byte $D0, $DD, $D2, $D8, $D4, $DD, $CD, $FE, $CB, $CE, $D8, $DD, $CC, $E9, $00

	;       
	.byte $00

	;       T    h    e    y         m    u    s    t         r    e    m    a    i    n    
	.byte $C3, $D7, $D4, $8C, $FE, $DC, $CE, $CC, $CD, $FE, $CB, $D4, $DC, $D0, $D8, $DD, $00

	;       a    l    e    r    t         f    o    r         d    a    n    g    e    r    
	.byte $D0, $DB, $D4, $CB, $CD, $FE, $D5, $DE, $CB, $FE, $D3, $D0, $DD, $D6, $D4, $CB, $00

	;       f    r    o    m         t    h    e         s    k    y    .    .    
	.byte $D5, $CB, $DE, $DC, $FE, $CD, $D7, $D4, $FE, $CC, $DA, $8C, $E9, $E9, $00


	; Terminator
	.byte $FF

	
Letter_World5:
	;       H    a    v    i    n    g         s    u    c    c    e    s    s    f    u    l    l    y    
	.byte $B7, $D0, $CF, $D8, $DD, $D6, $FE, $CC, $CE, $D2, $D2, $D4, $CC, $CC, $D5, $CE, $DB, $DB, $8C, $00

	;       d    e    f    e    a    t    e    d         g    u    a    r    d    i    a    n    s    
	.byte $D3, $D4, $D5, $D4, $D0, $CD, $D4, $D3, $FE, $D6, $CE, $D0, $CB, $D3, $D8, $D0, $DD, $CC, $00

	;       o    f         t    h    e         d    e    s    e    r    t         K    i    n    g    
	.byte $DE, $D5, $FE, $CD, $D7, $D4, $FE, $D3, $D4, $CC, $D4, $CB, $CD, $FE, $BA, $D8, $DD, $D6, $00

	;       T    o    t    o    m    e    s    u         a    n    d         t    h    e    
	.byte $C3, $DE, $CD, $DE, $DC, $D4, $CC, $CE, $FE, $D0, $DD, $D3, $FE, $CD, $D7, $D4, $00

	;       s    a    n    d         s    e    r    p    e    n    t         C    l    y    d    e    ,    
	.byte $CC, $D0, $DD, $D3, $FE, $CC, $D4, $CB, $DF, $D4, $DD, $CD, $FE, $B2, $DB, $8C, $D3, $D4, $9A, $00

	;       o    u    r         h    e    r    o    e    s         h    a    v    e    
	.byte $DE, $CE, $CB, $FE, $D7, $D4, $CB, $DE, $D4, $CC, $FE, $D7, $D0, $CF, $D4, $00

	;       f    o    l    l    o    w    e    d         B    o    w    s    e    r         J    r    .    
	.byte $D5, $DE, $DB, $DB, $DE, $81, $D4, $D3, $FE, $B1, $DE, $81, $CC, $D4, $CB, $FE, $B9, $CB, $E9, $00

	;       t    o         I    s    l    e         D    e    l    f    i    n    o    .    
	.byte $CD, $DE, $FE, $B8, $CC, $DB, $D4, $FE, $B3, $D4, $DB, $D5, $D8, $DD, $DE, $E9, $00

	;       
	.byte $00

	;       R    u    m    o    r         h    a    s         i    t    ,    
	.byte $C1, $CE, $DC, $DE, $CB, $FE, $D7, $D0, $CC, $FE, $D8, $CD, $9A, $00

	;       B    o    w    s    e    r         J    r    .    
	.byte $B1, $DE, $81, $CC, $D4, $CB, $FE, $B9, $CB, $E9, $00

	;       h    a    s         b    u    i    l    t         a    
	.byte $D7, $D0, $CC, $FE, $D1, $CE, $D8, $DB, $CD, $FE, $D0, $00

	;       r    o    c    k    e    t         h    e    r    e    
	.byte $CB, $DE, $D2, $DA, $D4, $CD, $FE, $D7, $D4, $CB, $D4, $00

	;       s    o    m    e    w    h    e    r    e    .    
	.byte $CC, $DE, $DC, $D4, $81, $D7, $D4, $CB, $D4, $E9, $00




	; Terminator
	.byte $FF


Letter_World6:
	;       O    u    r         h    e    r    o    e    s         d    i    s    c    o    v    e    r    
	.byte $BE, $CE, $CB, $FE, $D7, $D4, $CB, $DE, $D4, $CC, $FE, $D3, $D8, $CC, $D2, $DE, $CF, $D4, $CB, $00

	;       t    h    e    m    s    e    l    v    e    s         o    n         a    
	.byte $CD, $D7, $D4, $DC, $CC, $D4, $DB, $CF, $D4, $CC, $FE, $DE, $DD, $FE, $D0, $00

	;       m    a    s    s    i    v    e         r    o    c    k    e    t         a    b    o    u    t    
	.byte $DC, $D0, $CC, $CC, $D8, $CF, $D4, $FE, $CB, $DE, $D2, $DA, $D4, $CD, $FE, $D0, $D1, $DE, $CE, $CD, $00

	;       t    o         l    a    u    n    c    h    !         W    a    s         t    h    i    s    
	.byte $CD, $DE, $FE, $DB, $D0, $CE, $DD, $D2, $D7, $EA, $FE, $C6, $D0, $CC, $FE, $CD, $D7, $D8, $CC, $00

	;       s    o    m    e         k    i    n    d         o    f         t    r    a    p    ?    !    
	.byte $CC, $DE, $DC, $D4, $FE, $DA, $D8, $DD, $D3, $FE, $DE, $D5, $FE, $CD, $CB, $D0, $DF, $EB, $EA, $00

	;       
	.byte $00

	;       A    f    t    e    r         i    t         r    u    m    b    l    e    s         t    o    
	.byte $B0, $D5, $CD, $D4, $CB, $FE, $D8, $CD, $FE, $CB, $CE, $DC, $D1, $DB, $D4, $CC, $FE, $CD, $DE, $00

	;       l    i    f    e    ,         i    t         c    r    a    s    h    -    l    a    n    d    s    
	.byte $DB, $D8, $D5, $D4, $9A, $FE, $D8, $CD, $FE, $D2, $CB, $D0, $CC, $D7, $FE, $DB, $D0, $DD, $D3, $CC, $00

	;       o    n         a         n    e    a    r    b    y         p    l    a    n    e    t    .    
	.byte $DE, $DD, $FE, $D0, $FE, $DD, $D4, $D0, $CB, $D1, $8C, $FE, $DF, $DB, $D0, $DD, $D4, $CD, $E9, $00

	;       
	.byte $00

	;       O    u    r         h    e    r    o    e    s         a    r    e    
	.byte $BE, $CE, $CB, $FE, $D7, $D4, $CB, $DE, $D4, $CC, $FE, $D0, $CB, $D4, $00

	;       n    o    w         i    n         t    h    e    
	.byte $DD, $DE, $81, $FE, $D8, $DD, $FE, $CD, $D7, $D4, $00

	;       g    r    e    a    t    e    r         g    a    l    a    x    y    .    
	.byte $D6, $CB, $D4, $D0, $CD, $D4, $CB, $FE, $D6, $D0, $DB, $D0, $88, $8C, $E9, $00

	;       
	.byte $00

	; Terminator
	.byte $FF

Letter_World7:
	;       T    h    e    y         k    i    d    n    a    p    p    e    d         y    o    u    r    
	.byte $C3, $D7, $D4, $8C, $FE, $DA, $D8, $D3, $DD, $D0, $DF, $DF, $D4, $D3, $FE, $8C, $DE, $CE, $CB, $00

	;       s    p    e    c    i    a    l         o    n    e         w    h    i    l    e    
	.byte $CC, $DF, $D4, $D2, $D8, $D0, $DB, $FE, $DE, $DD, $D4, $FE, $81, $D7, $D8, $DB, $D4, $00

	;       y    o    u         w    e    r    e         t    r    a    v    e    r    s    i    n    g    
	.byte $8C, $DE, $CE, $FE, $81, $D4, $CB, $D4, $FE, $CD, $CB, $D0, $CF, $D4, $CB, $CC, $D8, $DD, $D6, $00

	;       t    h    e         G    a    l    a    x    i    e    s    .         S    h    e         i    s    
	.byte $CD, $D7, $D4, $FE, $B6, $D0, $DB, $D0, $88, $D8, $D4, $CC, $E9, $FE, $C2, $D7, $D4, $FE, $D8, $CC, $00

	;       a    t         B    o    w    s    e    r    '    s         G    a    l    a    x    y    
	.byte $D0, $CD, $FE, $B1, $DE, $81, $CC, $D4, $CB, $AB, $CC, $FE, $B6, $D0, $DB, $D0, $88, $8C, $00

	;       i    n         t    h    e         c    e    n    t    e    r         o    f         t    h    e    
	.byte $D8, $DD, $FE, $CD, $D7, $D4, $FE, $D2, $D4, $DD, $CD, $D4, $CB, $FE, $DE, $D5, $FE, $CD, $D7, $D4, $00

	;       U    n    i    v    e    r    s    e    !         I         w    i    l    l    
	.byte $C4, $DD, $D8, $CF, $D4, $CB, $CC, $D4, $EA, $FE, $B8, $FE, $81, $D8, $DB, $DB, $00

	;       t    a    k    e         y    o    u         t    h    e    r    e         i    n         m    y    
	.byte $CD, $D0, $DA, $D4, $FE, $8C, $DE, $CE, $FE, $CD, $D7, $D4, $CB, $D4, $FE, $D8, $DD, $FE, $DC, $8C, $00

	;       s    t    a    r         s    h    i    p    .    
	.byte $CC, $CD, $D0, $CB, $FE, $CC, $D7, $D8, $DF, $E9, $00

	;       
	.byte $00

	;       G    o         f    o    r    t    h    ,    
	.byte $B6, $DE, $FE, $D5, $DE, $CB, $CD, $D7, $9A, $00

	;       h    e    r    o    e    s    !    
	.byte $D7, $D4, $CB, $DE, $D4, $CC, $EA, $00

	; Terminator
	.byte $FF


Letter_World8:
	;       C    o    n    g    r    a    t    u    l    a    t    i    o    n    s    ,    
	.byte $B2, $DE, $DD, $D6, $CB, $D0, $CD, $CE, $DB, $D0, $CD, $D8, $DE, $DD, $CC, $9A, $00

	;       h    e    r    o    e    s    !         Y    o    u         h    a    v    e    
	.byte $D7, $D4, $CB, $DE, $D4, $CC, $EA, $FE, $C8, $DE, $CE, $FE, $D7, $D0, $CF, $D4, $00

	;       d    e    f    e    a    t    e    d         B    o    w    s    e    r         a    n    d    
	.byte $D3, $D4, $D5, $D4, $D0, $CD, $D4, $D3, $FE, $B1, $DE, $81, $CC, $D4, $CB, $FE, $D0, $DD, $D3, $00

	;       r    e    s    t    o    r    e    d         p    e    a    c    e         t    o    
	.byte $CB, $D4, $CC, $CD, $DE, $CB, $D4, $D3, $FE, $DF, $D4, $D0, $D2, $D4, $FE, $CD, $DE, $00

	;       t    h    e         K    i    n    g    d    o    m    !    
	.byte $CD, $D7, $D4, $FE, $BA, $D8, $DD, $D6, $D3, $DE, $DC, $EA, $00

	;       
	.byte $00

	;       H    o    w    e    v    e    r    ,         c    o    m    e    t    s    
	.byte $B7, $DE, $81, $D4, $CF, $D4, $CB, $9A, $FE, $D2, $DE, $DC, $D4, $CD, $CC, $00

	;       f    r    o    m         t    h    e         g    r    e    a    t    e    r    
	.byte $D5, $CB, $DE, $DC, $FE, $CD, $D7, $D4, $FE, $D6, $CB, $D4, $D0, $CD, $D4, $CB, $00

	;       G    a    l    a    x    y         h    a    v    e         s    h    o    w    n    
	.byte $B6, $D0, $DB, $D0, $88, $8C, $FE, $D7, $D0, $CF, $D4, $FE, $CC, $D7, $DE, $81, $DD, $00

	;       u    p    ,         c    a    u    s    i    n    g    
	.byte $CE, $DF, $9A, $FE, $D2, $D0, $CE, $CC, $D8, $DD, $D6, $00

	;       s    t    r    a    n    g    e         e    f    f    e    c    t    s    
	.byte $CC, $CD, $CB, $D0, $DD, $D6, $D4, $FE, $D4, $D5, $D5, $D4, $D2, $CD, $CC, $00

	;       i    n         s    o    m    e         a    r    e    a    s    .    .    .    
	.byte $D8, $DD, $FE, $CC, $DE, $DC, $D4, $FE, $D0, $CB, $D4, $D0, $CC, $E9, $E9, $E9, $00

	; Terminator
	.byte $FF


Letter_WorldZeroA:
	;       C    o    n    g    r    a    t    u    l    a    t    i    o    n    s    !    
	.byte $B2, $DE, $DD, $D6, $CB, $D0, $CD, $CE, $DB, $D0, $CD, $D8, $DE, $DD, $CC, $EA, $00

	;       Y    o    u         d    e    f    e    a    t    e    d         C    o    u    n    t    
	.byte $C8, $DE, $CE, $FE, $D3, $D4, $D5, $D4, $D0, $CD, $D4, $D3, $FE, $B2, $DE, $CE, $DD, $CD, $00

	;       B    l    e    c    k         i    n         W    o    r    l    d         Z    e    r    o    !    
	.byte $B1, $DB, $D4, $D2, $DA, $FE, $D8, $DD, $FE, $C6, $DE, $CB, $DB, $D3, $FE, $C9, $D4, $CB, $DE, $EA, $00

	;       
	.byte $00

	;       H    o    w    e    v    e    r    ,         s    e    e    m    s         y    o    u    
	.byte $B7, $DE, $81, $D4, $CF, $D4, $CB, $9A, $FE, $CC, $D4, $D4, $DC, $CC, $FE, $8C, $DE, $CE, $00

	;       m    i    s    s    e    d         a         f    e    w         S    t    a    r    
	.byte $DC, $D8, $CC, $CC, $D4, $D3, $FE, $D0, $FE, $D5, $D4, $81, $FE, $C2, $CD, $D0, $CB, $00

	;       C    o    i    n    s         f    o    r         f    u    l    l    
	.byte $B2, $DE, $D8, $DD, $CC, $FE, $D5, $DE, $CB, $FE, $D5, $CE, $DB, $DB, $00

	;       c    o    m    p    l    e    t    i    o    n    .    .    .    
	.byte $D2, $DE, $DC, $DF, $DB, $D4, $CD, $D8, $DE, $DD, $E9, $E9, $E9, $00


	; Terminator
	.byte $FF
	
	
Letter_WorldZeroB:
	;       C    o    n    g    r    a    t    u    l    a    t    i    o    n    s    !    
	.byte $B2, $DE, $DD, $D6, $CB, $D0, $CD, $CE, $DB, $D0, $CD, $D8, $DE, $DD, $CC, $EA, $00

	;       Y    o    u         d    e    f    e    a    t    e    d         C    o    u    n    t    
	.byte $C8, $DE, $CE, $FE, $D3, $D4, $D5, $D4, $D0, $CD, $D4, $D3, $FE, $B2, $DE, $CE, $DD, $CD, $00

	;       B    l    e    c    k         i    n         W    o    r    l    d         Z    e    r    o    
	.byte $B1, $DB, $D4, $D2, $DA, $FE, $D8, $DD, $FE, $C6, $DE, $CB, $DB, $D3, $FE, $C9, $D4, $CB, $DE, $00

	;       a    n    d         g    o    t         e    v    e    r    y         S    t    a    r    
	.byte $D0, $DD, $D3, $FE, $D6, $DE, $CD, $FE, $D4, $CF, $D4, $CB, $8C, $FE, $C2, $CD, $D0, $CB, $00

	;       C    o    i    n         i    n         t    h    e         g    a    m    e    !    
	.byte $B2, $DE, $D8, $DD, $FE, $D8, $DD, $FE, $CD, $D7, $D4, $FE, $D6, $D0, $DC, $D4, $EA, $00

	;       
	.byte $00

	;       Y    o    u         a    r    e         a         S    u    p    e    r    
	.byte $C8, $DE, $CE, $FE, $D0, $CB, $D4, $FE, $D0, $FE, $C2, $CE, $DF, $D4, $CB, $00

	;       P    l    a    y    e    r    !    
	.byte $BF, $DB, $D0, $8C, $D4, $CB, $EA, $00

	;       
	.byte $00

	; Terminator
	.byte $FF


LetterRow_VRAM_L:	.byte $AA, $8A, $6A, $4A, $2A, $06, $E6, $C6, $A6, $86, $66, $46, $26, $06
LetterRow_VRAM_H:	.byte $22, $22, $22, $22, $22, $22, $21, $21, $21, $21, $21, $21, $21, $21


WorldX_Clear:
	;       W    o    r    l    d         X         C    l    e    a    r    !    
	.byte $C6, $DE, $CB, $DB, $D3, $FE, $F0, $FE, $B2, $DB, $D4, $D0, $CB, $EA, $FF

World8_Clear:
	;       T    H    E         E    N    D    
	.byte $C3, $B7, $B4, $FE, $B4, $BD, $B3, $FF


EndWorldLetter_GenerateText:

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Body

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LDA World_Num
	ASL A
	TAX		 ; X = World_Num * 2

	LDA Player_RescuePrincess
	BNE WES_RescuePrincessCount

	CPX #(9 * 2)
	BNE EWLGT_NotWorldZeroWin	; If not in World Zero, jump to EWLGT_NotWorldZeroWin
	
WES_RescuePrincessCount:
	TXA
	PHA
	
	; Count all star coins collected versus game total
	; Lower 8 bits of result are in Map_StarCoin_Got
	; and Map_StarCoin_Total, plus Temp_VarNP0...
	JSR_THUNKA 12, Map_CountAllStarCoins
	
	PLA
	TAX
	
	; If Temp_VarNP0 is not 1, you didn't get enough
	; star coins (indicates an overflow in the count,
	; and there are more than 255 star coins!)
	LDA Temp_VarNP0
	CMP #1
	BNE EWLGT_NotWorldZeroWin
	
	; Finally, Map_StarCoin_Got must match Map_StarCoin_Total!
	LDA Map_StarCoin_Got
	CMP Map_StarCoin_Total
	BNE EWLGT_NotWorldZeroWin
	
	; If we get here, let's use the alternate letter!
	LDX #20

EWLGT_NotWorldZeroWin:
	; Base address for letter body -> Temp_Var1/2
	LDA Letter_Bodies,X
	STA <Temp_Var1
	LDA Letter_Bodies+1,X
	STA <Temp_Var2	

	LDY #$00	 ; Y = 0 (letter body offset)
	LDX #(LetterRow_VRAM_H - LetterRow_VRAM_L - 1)	 ; init X (letter body line index)
PRG027_ABA9:
	; Temp_Var4 = VRAM low address starting for this line
	LDA LetterRow_VRAM_L,X
	STA <Temp_Var4

PRG027_ABAE:
	LDA PPU_STAT

	; Set VRAM High address starting for this line
	LDA LetterRow_VRAM_H,X
	STA PPU_VRAM_ADDR

	; Set VRAM Low address starting for this line
	LDA <Temp_Var4
	STA PPU_VRAM_ADDR

	LDA [Temp_Var1],Y ; Get next character from letter body

	INY		 ; Y++ (next letter body character)

	CMP #$00
	BEQ PRG027_ABCE	 ; If character = 0 (next line), jump to PRG027_ABCE

	CMP #$ff
	BEQ PRG027_ABD1	 ; If character = $FF (terminator), jump to PRG027_ABD1 (end of body)

	STA PPU_VRAM_DATA	; Store character as pattern

	INC <Temp_Var4	 ; Temp_Var4++
	BNE PRG027_ABAE	 ; Loop (assumes Temp_Var4 never overflows)

PRG027_ABCE:
	DEX		 ; X-- (next line address)
	BPL PRG027_ABA9	 ; While X >= 0, loop (prevents too many lines)

PRG027_ABD1:

	;LDA Player_RescuePrincess
	;BNE WES_RescuePrincessPrint

	LDA World_Num
	CMP #9
	BNE Letter_NotWZeroNoStars		; If not the World Zero letter, no need to print star coin totals

	LDA <Temp_Var1
	CMP (Letter_Bodies + 18)	; Ew
	BNE Letter_NotWZeroNoStars

WES_RescuePrincessPrint:
	; Print star coin totals
	JSR Letter_PrintSCTotals
	
Letter_NotWZeroNoStars:

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; World X Clear

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	LDY #$00	 ; Y = 0 (letter body offset)

	LDA Player_RescuePrincess
	BEQ WorldXClear_NotEnding

	; Base address for letter body -> Temp_Var1/2
	LDA #LOW(World8_Clear)
	STA <Temp_Var1
	LDA #HIGH(World8_Clear+1)
	STA <Temp_Var2	

	; Temp_Var4 = VRAM low address starting for this line
	LDA #$CC
	STA <Temp_Var4

	BNE PRG027_WXBAE

WorldXClear_NotEnding:
	; Base address for letter body -> Temp_Var1/2
	LDA #LOW(WorldX_Clear)
	STA <Temp_Var1
	LDA #HIGH(WorldX_Clear+1)
	STA <Temp_Var2	

	; Temp_Var4 = VRAM low address starting for this line
	LDA #$C9
	STA <Temp_Var4

PRG027_WXBAE:
	LDA PPU_STAT

	; Set VRAM High address starting for this line
	LDA #$29
	STA PPU_VRAM_ADDR

	; Set VRAM Low address starting for this line
	LDA <Temp_Var4
	STA PPU_VRAM_ADDR

	LDA [Temp_Var1],Y ; Get next character from letter body

	INY		 ; Y++ (next letter body character)

	CMP #$F0
	BNE WorldClear_NotWNum	; If character is not $F0 (World number placeholder), jump to WorldClear_NotWNum

	; World number placeholder!
	LDA World_Num
	CMP #9
	BNE WorldClear_SetNotWZero
	
	; World Zero fix
	LDA #$F0
	BNE WorldClear_SetPattern
	
WorldClear_SetNotWZero:
	ADD #$F1
	BNE WorldClear_SetPattern	; Jump (technically always) to WorldClear_SetPattern

WorldClear_NotWNum:
	CMP #$ff
	BEQ PRG027_WXBD1	 ; If character = $FF (terminator), jump to PRG027_WXBD1 (RTS)

WorldClear_SetPattern:
	STA PPU_VRAM_DATA	; Store character as pattern

	INC <Temp_Var4	 ; Temp_Var4++
	BNE PRG027_WXBAE	 ; Loop (assumes Temp_Var4 never overflows)


PRG027_WXBD1:

	RTS		 ; Return


Letter_PrintSCTotals:
	LDX #0

	LDA LetterRow_VRAM_H,X
	STA PPU_VRAM_ADDR
	LDA LetterRow_VRAM_L,X
	STA PPU_VRAM_ADDR
	
	; Little star
	LDA #$7B
	STA PPU_VRAM_DATA
	
	; Space
	LDA #$FE
	STA PPU_VRAM_DATA

	; Retrieved star coins
	LDA Temp_VarNP0
	STA <Temp_Var2
	LDA Map_StarCoin_Got
	STA <Temp_Var1
	
	JSR Letter_Print3Digits

	; Space
	LDA #$FE
	STA PPU_VRAM_DATA
	; Slash
	LDA #$7A
	STA PPU_VRAM_DATA
	; Space
	LDA #$FE
	STA PPU_VRAM_DATA

	; Retrieved star coins
	LDA #1	; Cheating
	STA <Temp_Var2
	LDA Map_StarCoin_Total
	STA <Temp_Var1

	JSR Letter_Print3Digits

	RTS
	
	
PRG027_B166:	.byte $00, $00, $00
PRG027_B16C:	.byte $01, $0A, $64
PRG027_B172:	.byte $0F, $42, $3F 

Letter_Print3Digits:
	; To print 3 digits ... stole it from the status bar code! Just less digits.

	LDX #$02	 ; X = 5	0-5, 6 digits
PRG027_B19A:
	LDA <Temp_Var1	 ; Get LSD -> A

	; I haven't taken time yet to discern this magic yet
	SUB PRG027_B16C,X
	STA <Temp_Var1	
	LDA <Temp_Var2	
	SBC PRG027_B166,X
	STA <Temp_Var2	

	BCC PRG027_B1B8	 	; If the subtraction didn't go negative, jump to PRG027_B1B8

	INC Score_Temp	 ; Score_Temp++

	JMP PRG027_B19A	 ; Jump to PRG027_B19A

PRG027_B1B8:
	LDA <Temp_Var1

	; I haven't taken time yet to discern this magic yet
	ADD PRG027_B16C,X
	STA <Temp_Var1	
	LDA <Temp_Var2	
	ADC PRG027_B166,X
	STA <Temp_Var2	

	LDA Score_Temp	 
	ADD #$70	 	; A = Score_Temp + $F0 (tile to display)
	STA PPU_VRAM_DATA	; Store it as next digit

	LDA #$00	 	; A = 0
	STA Score_Temp	 	; Score_Temp = 0

	INY		 	; Y++
	DEX		 	; X--
	BPL PRG027_B19A	 	; While digits remain, loop!

	RTS		 ; Return


	
	; Palette Data
	; The palette data is pretty much a direct write to the PPU palette RAM.
	; A palette is defined by an entire set of 16 colors, assigned by index.
	; Level_Tileset normally decides which palette to select, and then the
	; RAM variable PalSel_Tile_Colors selects which colors will be assigned
	; the bg (tiles), and after that PalSel_Obj_Colors select the index for
	; the sprites.  There is an override variable, Pal_Force_Set12, which
	; will select a palette set based on its value instead of Level_Tileset,
	; but it does not use the PalSel variables and instead forces the first
	; two palette sets into bg / sprite respectively (too bad, really!)

PalSet_Maps:	
	; Refer to Map_Tile_ColorSets in PRG012 to change these selections
	.byte $0F, $0F, $30, $3C, $0F, $36, $27, $37, $0F, $21, $2A, $37, $0F, $30, $16, $37	; World 1
	.byte $0F, $0F, $30, $3C, $0F, $36, $27, $2A, $0F, $12, $1A, $2A, $0F, $30, $16, $2A	; World 2
	.byte $0F, $0F, $30, $3C, $0F, $36, $27, $21, $0F, $21, $10, $37, $0F, $21, $10, $37	; World 9
	.byte $0F, $0F, $30, $3C, $0F, $36, $27, $3A, $0F, $12, $2A, $3A, $0F, $30, $16, $3A	; World 4
	.byte $0F, $0F, $30, $3C, $0F, $36, $27, $28, $0F, $12, $2A, $28, $0F, $30, $16, $28	; World 5
	.byte $0F, $0F, $30, $3C, $0F, $36, $27, $37, $0F, $21, $2A, $37, $0F, $30, $16, $37	; World 6
	.byte $0F, $0F, $30, $3C, $0F, $36, $19, $2A, $0F, $12, $1A, $2A, $0F, $30, $07, $16	; World 7
	.byte $0F, $0F, $30, $3C, $0F, $36, $27, $17, $0F, $06, $27, $17, $0F, $35, $25, $17	; World 8

	; Refer to Map_Object_ColorSets in PRG012 to change these selections
	.byte $FF, $16, $36, $0F, $FF, $30, $16, $0F, $FF, $17, $27, $0F, $FF, $30, $16, $0F	; Normal palette
	.byte $FF, $16, $36, $0F, $FF, $30, $1A, $0F, $FF, $17, $27, $0F, $FF, $30, $16, $0F	; Map object colors used in World 4 (green for dino)
	.byte $FF, $16, $36, $0F, $FF, $30, $27, $0F, $FF, $17, $27, $0F, $FF, $30, $16, $0F	; Map object colors used in World 5 (orange for Gao)
	.byte $0F, $0F, $30, $3C, $0F, $27, $17, $00, $0F, $02, $27, $00, $0F, $30, $16, $00	; World 3

PalSet_Plains:
	.byte $3C, $0F, $30, $3C, $3C, $0F, $36, $27, $3C, $0F, $2A, $1A, $3C, $0F, $31, $21	; BG Pal 0
	.byte $36, $0F, $30, $3C, $36, $0F, $36, $27, $36, $0F, $2A, $1A, $36, $0F, $31, $12	; BG Pal 1
	.byte $37, $0F, $30, $3C, $37, $0F, $36, $27, $37, $0F, $2A, $1A, $37, $0F, $31, $12	; BG Pal 2
	.byte $3B, $0F, $30, $3C, $3B, $0F, $36, $27, $3B, $0F, $2A, $1A, $3B, $0F, $31, $21	; BG Pal 3
	.byte $21, $0F, $30, $3C, $21, $0F, $36, $27, $21, $0F, $2A, $1A, $21, $0F, $31, $12	; BG Pal 4
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $30, $0F, $0F, $0F, $01, $31, $12	; BG Pal 5
	.byte $0F, $0F, $30, $3C, $0F, $0F, $21, $12, $0F, $0F, $2A, $1A, $0F, $0F, $2C, $1C	; BG Pal 6
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $0B, $2A, $1A, $0F, $0F, $10, $00	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0C, $FF, $0C, $30, $16, $FF, $0C, $30, $2A, $FF, $0C, $36, $27	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0C, $FF, $0C, $30, $06, $FF, $0C, $30, $0A, $FF, $0C, $21, $11	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $1A, $27, $0F, $FF, $30, $36, $0F, $FF, $16, $30, $0F	; SPR Pal 3 (11)

PalSet_Fort:
	.byte $0F, $0F, $30, $3C, $0F, $07, $36, $27, $0F, $00, $30, $10, $0F, $0C, $3C, $2C	; BG Pal 0
	.byte $0F, $0F, $30, $3C, $0F, $07, $36, $27, $0F, $00, $30, $10, $0F, $07, $36, $27	; BG Pal 1
	.byte $0F, $0F, $30, $3C, $0F, $07, $36, $27, $0F, $00, $30, $10, $0F, $1B, $3B, $2B	; BG Pal 2
	.byte $0F, $0F, $30, $3C, $0F, $07, $36, $27, $0F, $0B, $3B, $1B, $0F, $02, $21, $12	; BG Pal 3
	.byte $0F, $0F, $30, $3C, $0F, $07, $36, $27, $0F, $06, $27, $16, $0F, $00, $30, $10	; BG Pal 4
	.byte $0F, $0F, $30, $3C, $0F, $16, $2C, $27, $0F, $00, $10, $30, $0F, $0F, $30, $0F	; BG Pal 5 (Reserved World complete)
	.byte $0F, $0F, $30, $3C, $0F, $07, $30, $27, $0F, $30, $0F, $0F, $0F, $30, $0F, $0F	; BG Pal 6
	.byte $0F, $0F, $30, $3C, $0F, $0F, $06, $07, $0F, $0F, $07, $08, $0F, $0F, $00, $0F	; BG Pal 7

	.byte $FF, $16, $27, $0C, $FF, $06, $30, $16, $FF, $0F, $30, $2C, $FF, $07, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0F, $FF, $07, $30, $16, $FF, $0F, $36, $16, $FF, $1A, $30, $27	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $0F, $36, $16, $FF, $0F, $30, $27, $FF, $0F, $30, $2A	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $0F, $36, $16, $FF, $0F, $36, $10, $FF, $0F, $27, $17	; SPR Pal 3 (11)

PalSet_HillsUnder:
	.byte $3C, $0F, $30, $3C, $3C, $0F, $36, $27, $3C, $0F, $2A, $1A, $3C, $0F, $2A, $12 	; BG Pal 0 (General greens/sky)
	.byte $22, $0F, $30, $3C, $22, $0F, $36, $27, $22, $0F, $27, $17, $22, $0F, $27, $2C 	; BG Pal 1 (General desert/sky)
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $0F, $1A, $0A, $0F, $0F, $24, $14  	; BG Pal 2 (Plant fortress)
	.byte $3C, $0F, $30, $3C, $3C, $0F, $36, $27, $3C, $0F, $27, $17, $3C, $0F, $00, $0F 	; BG Pal 3 (Sandy muck)
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $1C, $3C, $2A, $0F, $1C, $3C, $12 	; BG Pal 4 (Undergroundy cyan ground)
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $06, $27, $16, $0F, $11, $31, $21 	; BG Pal 5 (Nighttime sandy)
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $0F, $2A, $1A, $0F, $0F, $2A, $12 	; BG Pal 6 (Nighttime green)
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $3C, $30, $2A, $0F, $3C, $30, $12 	; BG Pal 7 (Snowy!)

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 0 (8) (Normal)
	.byte $FF, $16, $36, $0F, $FF, $0C, $30, $16, $FF, $0C, $30, $2A, $FF, $0C, $36, $27	; SPR Pal 1 (9) (Underground)
	.byte $FF, $16, $36, $0F, $FF, $0C, $30, $16, $FF, $0C, $39, $11, $FF, $0C, $36, $27	; SPR Pal 2 (10) (Galatic)
	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $16, $29, $30	; SPR Pal 3 (11) (Petey Piranha)

PalSet_HighUp:
	.byte $3C, $0F, $30, $3C, $3C, $0F, $36, $27, $3C, $0F, $2A, $1A, $3C, $0F, $30, $21	; BG Pal 0
	.byte $37, $0F, $30, $3C, $37, $0F, $36, $27, $37, $0F, $2B, $1A, $37, $0F, $30, $21	; BG Pal 1
	.byte $02, $0F, $30, $3C, $02, $0F, $25, $24, $02, $0F, $3A, $24, $02, $0F, $26, $24	; BG Pal 2
	.byte $0F, $0F, $30, $3C, $0F, $30, $0F, $0F, $0F, $30, $0F, $0F, $0F, $30, $0F, $0F	; BG Pal 3
	.byte $0F, $0F, $30, $3C, $0F, $0F, $27, $17, $0F, $29, $19, $0F, $0F, $0F, $31, $21	; BG Pal 4 (SMB2 rebrand dark)
	.byte $02, $0F, $30, $3C, $02, $0F, $23, $30, $02, $0F, $21, $30, $02, $0F, $13, $30	; BG Pal 5
	.byte $21, $0F, $30, $3C, $21, $0F, $27, $17, $21, $29, $19, $0F, $21, $0F, $31, $21	; BG Pal 6 (SMB2 rebrand bright)
	.byte $0F, $0F, $30, $3C, $0F, $0F, $27, $17, $0F, $0F, $27, $17, $0F, $0F, $25, $17	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0F, $FF, $01, $30, $16, $FF, $01, $30, $2A, $F1, $0F, $36, $27	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $1A, $27, $0F, $FF, $30, $36, $0F, $FF, $16, $30, $0F	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $1A, $27, $0F, $FF, $30, $36, $0F, $FF, $16, $30, $0F	; SPR Pal 3 (11)

PalSet_GhostHouse:
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $2A, $1B, $0F, $1C, $2C, $38	; BG Pal 0
	.byte $00, $0F, $30, $3C, $00, $0F, $36, $27, $00, $0F, $2A, $1B, $00, $10, $20, $20	; BG Pal 1
	.byte $08, $0F, $30, $3C, $08, $0F, $36, $27, $08, $0F, $2A, $1B, $08, $18, $28, $38	; BG Pal 2
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $2A, $1B, $0F, $1C, $2C, $38	; BG Pal 3
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $2A, $1B, $0F, $1C, $2C, $38	; BG Pal 4
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $2A, $1B, $0F, $1C, $2C, $38	; BG Pal 5
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $2A, $1B, $0F, $1C, $2C, $38	; BG Pal 6
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $00, $0C, $0F, $0C, $0F, $00	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0F, $FF, $1A, $27, $0F, $FF, $30, $36, $0F, $FF, $16, $30, $0F	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $1A, $27, $0F, $FF, $30, $36, $0F, $FF, $16, $30, $0F	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $06, $19, $28, $FF, $06, $10, $28, $FF, $16, $30, $0F	; SPR Pal 3 (11)

PalSet_Water:
	.byte $12, $0F, $30, $3C, $12, $0F, $36, $27, $12, $0F, $01, $2C, $12, $0F, $25, $10	; BG Pal 0
	.byte $12, $0F, $30, $3C, $12, $0F, $36, $27, $12, $0F, $01, $2C, $12, $0F, $30, $10	; BG Pal 1
	.byte $12, $0F, $30, $3C, $12, $0F, $36, $27, $12, $0F, $01, $00, $12, $0F, $21, $12	; BG Pal 0
	.byte $22, $0F, $30, $3C, $22, $0F, $36, $27, $22, $0F, $30, $37, $22, $0F, $25, $10	; BG Pal 3
	.byte $36, $0F, $30, $3C, $36, $0F, $27, $17, $36, $0F, $2B, $1A, $36, $0F, $3C, $12	; BG Pal 4
	.byte $36, $0F, $30, $3C, $36, $0F, $27, $17, $36, $0F, $2B, $1A, $36, $0F, $3C, $12	; BG Pal 5
	.byte $36, $0F, $30, $3C, $36, $0F, $27, $17, $36, $0F, $2B, $1A, $36, $0F, $3C, $12	; BG Pal 6
	.byte $36, $0F, $30, $3C, $36, $0F, $27, $17, $36, $0F, $2B, $1A, $36, $0F, $3C, $12	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $30, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0F, $FF, $2A, $27, $0F, $FF, $17, $27, $0F, $FF, $16, $30, $0F	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $17, $27, $36, $FF, $2A, $30, $0F, $FF, $0F, $30, $16	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $30, $16, $0F, $FF, $2A, $3B, $0F, $FF, $17, $36, $26	; SPR Pal 3 (11)

PalSet_Delfino:
	.byte $3C, $0F, $30, $3C, $3C, $0F, $36, $27, $3C, $0F, $30, $2A, $3C, $0F, $2A, $12 	; BG Pal 0 (regular bright)
	.byte $22, $0F, $30, $3C, $22, $0F, $36, $27, $22, $0F, $30, $2A, $22, $0F, $38, $28 	; BG Pal 1 (darker sky, sign)
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $12, $02, $0F, $0F, $38, $28  	; BG Pal 2 (casino inner)
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $30, $2A, $0F, $0F, $2A, $12 	; BG Pal 3 (half-pipe levels)
	.byte $00, $0F, $30, $3C, $00, $0F, $36, $27, $00, $0F, $2A, $1A, $00, $0F, $21, $12 	; BG Pal 4 (N&B Blocks)
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $06, $27, $16, $0F, $07, $17, $12 	; BG Pal 5
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $0F, $2A, $1A, $0F, $0F, $2A, $12 	; BG Pal 6
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $3C, $30, $2A, $0F, $3C, $30, $12 	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0F, $FF, $0C, $30, $16, $FF, $0C, $30, $2A, $FF, $0C, $36, $27	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $0C, $30, $16, $FF, $0C, $30, $10, $FF, $0C, $37, $27	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $1A, $27, $0F, $FF, $30, $36, $0F, $FF, $16, $30, $0F	; SPR Pal 3 (11)

PalSet_PipeMaze:
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $0B, $3B, $1B, $0F, $0F, $0C, $0F	; BG Pal 0 (base with dark BG)
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $0B, $3B, $1B, $0F, $0F, $31, $21	; BG Pal 1 (base with light BG)
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $00, $20, $10, $0F, $0F, $0C, $0F	; BG Pal 2 (W7 Fort 2)
	.byte $36, $0F, $30, $3C, $36, $0F, $27, $17, $36, $0F, $2B, $1A, $36, $0F, $3C, $12 	; BG Pal 3
	.byte $36, $0F, $30, $3C, $36, $0F, $27, $17, $36, $0F, $2B, $1A, $36, $0F, $3C, $12	; BG Pal 4
	.byte $36, $0F, $30, $3C, $36, $0F, $27, $17, $36, $0F, $2B, $1A, $36, $0F, $3C, $12	; BG Pal 5 (used in 2-5)
	.byte $36, $0F, $30, $3C, $36, $0F, $27, $17, $36, $0F, $2B, $1A, $36, $0F, $3C, $12	; BG Pal 6
	.byte $36, $0F, $30, $3C, $36, $0F, $27, $17, $36, $0F, $2B, $1A, $36, $0F, $3C, $12	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0C, $30, $16, $FF, $0C, $30, $2A, $FF, $0C, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0F, $FF, $2A, $27, $0F, $FF, $17, $27, $0F, $FF, $16, $30, $0F	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $17, $27, $36, $FF, $2A, $30, $0F, $FF, $0F, $30, $16	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $30, $16, $0F, $FF, $2A, $3B, $0F, $FF, $17, $36, $26	; SPR Pal 3 (11)

PalSet_Desert:
	.byte $22, $0F, $30, $3C, $22, $0F, $36, $27, $22, $0F, $27, $17, $22, $0F, $36, $14	; BG Pal 0
	.byte $36, $0F, $30, $3C, $36, $0F, $36, $27, $36, $0F, $2A, $1A, $36, $0F, $31, $21	; BG Pal 1
	.byte $0F, $0F, $30, $3C, $0F, $0F, $30, $00, $0F, $0F, $1A, $0A, $0F, $0F, $31, $21	; BG Pal 2
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $27, $17, $0F, $0F, $31, $21	; BG Pal 3
	.byte $08, $0F, $30, $3C, $08, $0F, $36, $27, $08, $0F, $27, $17, $08, $0F, $36, $14	; BG Pal 4
	.byte $37, $0F, $30, $3C, $37, $0F, $36, $27, $37, $0F, $27, $17, $37, $0F, $31, $21	; BG Pal 5
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $30, $0F, $0F, $0F, $30, $0F, $0F	; BG Pal 6
	.byte $22, $0F, $30, $3C, $22, $0F, $36, $27, $22, $0F, $2A, $1A, $22, $0F, $31, $12	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $36, $14, $FF, $0F, $36, $27	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $06, $19, $28, $FF, $06, $10, $28, $FF, $16, $30, $0F	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $0C, $30, $16, $FF, $0C, $30, $2C, $FF, $0C, $30, $00	; SPR Pal 3 (11)

PalSet_Airship:
	.byte $3C, $0F, $30, $3C, $3C, $0F, $36, $27, $3C, $0F, $30, $10, $3C, $0F, $27, $17 	; BG Pal 0
	.byte $12, $0F, $30, $3C, $12, $0F, $36, $27, $12, $0F, $30, $10, $12, $0F, $2B, $1B	; BG Pal 1
	.byte $37, $0F, $30, $3C, $37, $0F, $36, $27, $37, $0F, $30, $10, $37, $0F, $2C, $1C 	; BG Pal 2
	.byte $3B, $0F, $30, $3C, $3B, $0F, $36, $27, $3B, $0F, $30, $10, $3B, $0F, $28, $18 	; BG Pal 3
	.byte $31, $0F, $30, $3C, $31, $0F, $36, $27, $31, $0F, $30, $10, $31, $0F, $21, $12	; BG Pal 4
	.byte $0F, $0F, $30, $3C, $0F, $0F, $0C, $0F, $0F, $0F, $30, $10, $0F, $0F, $27, $17	; BG Pal 5
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $30, $10, $0F, $0F, $27, $17	; BG Pal 6
	.byte $0C, $0F, $20, $2C, $0C, $0F, $26, $17, $0C, $0F, $20, $0F, $0C, $0F, $1C, $0C	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $21, $FF, $0F, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0F, $FF, $0C, $30, $31, $FF, $0C, $30, $2A, $FF, $17, $36, $27	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $06, $19, $28, $FF, $06, $10, $28, $FF, $16, $30, $0F	; SPR Pal 3 (11)

PalSet_Giant:
	.byte $3C, $0F, $30, $3C, $3C, $0F, $36, $27, $3C, $0F, $2A, $1A, $3C, $0F, $31, $21	; BG Pal 0
	.byte $36, $0F, $30, $3C, $36, $0F, $36, $27, $36, $0F, $2A, $1A, $36, $0F, $31, $12	; BG Pal 1
	.byte $37, $0F, $30, $3C, $37, $0F, $36, $27, $37, $0F, $2A, $1A, $37, $0F, $31, $12	; BG Pal 2
	.byte $3B, $0F, $30, $3C, $3B, $0F, $36, $27, $3B, $0F, $2A, $1A, $3B, $0F, $31, $21	; BG Pal 3
	.byte $21, $0F, $30, $3C, $21, $0F, $36, $27, $21, $0F, $2A, $1A, $21, $0F, $31, $12	; BG Pal 4
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $30, $0F, $0F, $0F, $01, $31, $12	; BG Pal 5
	.byte $0F, $0F, $30, $3C, $0F, $0F, $21, $12, $0F, $0F, $2A, $1A, $0F, $0F, $2C, $1C	; BG Pal 6
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $0B, $2A, $1A, $0F, $0F, $10, $00	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0C, $FF, $0C, $30, $16, $FF, $0C, $30, $2A, $FF, $0C, $36, $27	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0C, $FF, $0C, $30, $06, $FF, $0C, $30, $0A, $FF, $0C, $21, $11	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $1A, $27, $0F, $FF, $30, $36, $0F, $FF, $16, $30, $0F	; SPR Pal 3 (11)

PalSet_Ice:
	.byte $31, $0F, $30, $3C, $31, $0F, $30, $27, $31, $0F, $30, $2A, $31, $0F, $30, $12	; BG Pal 0
	.byte $0F, $0F, $30, $3C, $0F, $06, $0F, $27, $0F, $0F, $0F, $2A, $0F, $0F, $30, $12	; BG Pal 1
	.byte $0F, $0F, $30, $3C, $0F, $0F, $25, $24, $0F, $0F, $3A, $24, $0F, $0F, $26, $24	; BG Pal 2
	.byte $0F, $0F, $30, $3C, $0F, $0F, $27, $38, $0F, $0F, $2A, $38, $0F, $0F, $26, $38 	; BG Pal 3
	.byte $0F, $0F, $30, $3C, $0F, $0F, $27, $30, $0F, $0F, $2A, $30, $0F, $0F, $12, $30	; BG Pal 4
	.byte $0F, $0F, $30, $3C, $0F, $0F, $23, $30, $0F, $0F, $21, $30, $0F, $0F, $13, $30	; BG Pal 5
	.byte $0F, $0F, $30, $3C, $0F, $0F, $27, $38, $0F, $0F, $2A, $38, $0F, $0F, $26, $38	; BG Pal 6
	.byte $0F, $0F, $30, $3C, $0F, $0F, $27, $17, $0F, $0F, $27, $17, $0F, $0F, $25, $17	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $30, $FF, $0F, $36, $27	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $06, $30, $16, $FF, $00, $30, $2C, $FF, $17, $30, $27	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $0C, $30, $16, $FF, $0C, $39, $11, $FF, $0C, $36, $27	; SPR Pal 3 (11) (Galatic)

PalSet_Sky:
	.byte $30, $0F, $30, $3C, $30, $0F, $36, $27, $30, $0F, $2A, $1A, $30, $0F, $12, $21	; BG Pal 0
	.byte $00, $0F, $30, $3C, $00, $0F, $36, $27, $00, $0F, $2A, $1A, $00, $0F, $0F, $21	; BG Pal 1 (World 8)
	.byte $3C, $0F, $30, $3C, $3C, $0F, $36, $27, $3C, $0F, $2A, $1A, $3C, $0F, $30, $12	; BG Pal 2
	.byte $30, $0F, $30, $3C, $30, $0F, $36, $27, $30, $0F, $37, $01, $30, $0F, $37, $21	; BG Pal 3
	.byte $30, $0F, $30, $3C, $30, $0F, $36, $27, $30, $0F, $12, $21, $30, $0F, $12, $21	; BG Pal 4
	.byte $0F, $0F, $30, $3C, $0F, $0F, $23, $30, $0F, $0F, $21, $30, $0F, $0F, $13, $30	; BG Pal 5
	.byte $0F, $0F, $30, $3C, $0F, $0F, $27, $38, $0F, $0F, $2A, $38, $0F, $0F, $26, $38	; BG Pal 6
	.byte $0F, $0F, $30, $3C, $0F, $0F, $27, $17, $0F, $0F, $27, $17, $0F, $0F, $25, $17	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $12, $FF, $0F, $36, $27	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $1A, $27, $0F, $FF, $30, $36, $0F, $FF, $16, $30, $0F	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $1A, $27, $0F, $FF, $30, $36, $0F, $FF, $16, $30, $0F	; SPR Pal 3 (11)

PalSet_2PVs:
	.byte $0F, $0F, $30, $3C, $0F, $17, $36, $27, $0F, $1A, $3B, $2A, $0F, $12, $31, $21	; BG Pal 0
	.byte $0F, $0F, $30, $3C, $0F, $17, $36, $27, $0F, $12, $31, $21, $0F, $1A, $3A, $2A	; BG Pal 1
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $0F, $2A, $1C, $0F, $0F, $21, $1C	; BG Pal 2
	.byte $37, $0F, $30, $3C, $37, $0F, $30, $27, $37, $0F, $3A, $1A, $37, $0F, $36, $27	; BG Pal 3
	.byte $0F, $0F, $30, $3C, $0F, $10, $30, $3C, $0F, $0B, $1B, $3B, $0F, $00, $10, $30	; BG Pal 4
	.byte $3C, $0F, $30, $3C, $3C, $0F, $30, $3B, $3C, $0F, $37, $27, $3C, $12, $31, $21	; BG Pal 5
	.byte $06, $0F, $30, $3C, $06, $17, $36, $26, $06, $0F, $2B, $1A, $06, $0F, $21, $12	; BG Pal 6
	.byte $07, $0F, $30, $3C, $07, $17, $36, $26, $07, $0F, $2B, $1A, $07, $0F, $21, $12	; BG Pal 7

	.byte $FF, $16, $36, $12, $FF, $1A, $36, $0C, $FF, $12, $31, $21, $FF, $16, $30, $27	; SPR Pal 0 (8)
	.byte $FF, $16, $36, $12, $FF, $30, $36, $1A, $FF, $17, $36, $1A, $FF, $16, $30, $27	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $30, $36, $1A, $FF, $17, $36, $27, $FF, $16, $30, $27	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $12, $FF, $1A, $36, $12, $FF, $16, $30, $27, $FF, $12, $31, $21	; SPR Pal 3 (11)

PalSet_Bonus:
	.byte $0F, $0F, $30, $3C, $0F, $16, $30, $36, $0F, $16, $30, $21, $0F, $17, $30, $27 	; BG Pal 0
	.byte $0F, $0F, $30, $3C, $0F, $30, $21, $36, $0F, $36, $1A, $2A, $0F, $36, $17, $27	; BG Pal 1
	.byte $0F, $0F, $30, $3C, $0F, $17, $27, $36, $0F, $2A, $21, $36, $0F, $16, $30, $36	; BG Pal 2
	.byte $0F, $0F, $30, $3C, $0F, $30, $16, $36, $0F, $30, $16, $21, $0F, $30, $17, $27	; BG Pal 3
	.byte $0F, $0F, $30, $3C, $0F, $30, $16, $36, $0F, $30, $16, $21, $0F, $30, $17, $27	; BG Pal 4
	.byte $0F, $0F, $30, $3C, $0F, $30, $16, $36, $0F, $30, $16, $21, $0F, $30, $17, $27	; BG Pal 5
	.byte $0F, $0F, $30, $3C, $0F, $30, $16, $36, $0F, $30, $16, $21, $0F, $30, $17, $27	; BG Pal 6
	.byte $0F, $0F, $30, $3C, $0F, $30, $16, $36, $0F, $30, $16, $21, $0F, $30, $17, $27	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $17, $27, $36, $FF, $2A, $21, $0F, $FF, $0F, $30, $16	; SPR Pal 0 (8)
	.byte $FF, $16, $30, $0F, $FF, $17, $27, $36, $FF, $2A, $21, $0F, $FF, $0F, $30, $16	; SPR Pal 1 (9)
	.byte $FF, $16, $36, $0F, $FF, $17, $27, $36, $FF, $2A, $21, $0F, $FF, $0F, $30, $16	; SPR Pal 2 (10)
	.byte $FF, $16, $36, $0F, $FF, $17, $27, $36, $FF, $2A, $21, $0F, $FF, $0F, $16, $16	; SPR Pal 3 (11)

PalSet_Ext:
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $00, $20, $10, $0F, $01, $13, $03	; BG Pal 0 (Castle Bleck)
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $00, $20, $10, $0F, $06, $27, $16	; BG Pal 1 (Bowser's Castle)
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $00, $2A, $1A, $0F, $01, $31, $12	; BG Pal 2 (Blue water)
	.byte $00, $0F, $30, $3C, $00, $0F, $0F, $0F, $00, $0F, $0F, $0F, $00, $0F, $0F, $0F	; BG Pal 3 (Game N Watch)
	.byte $21, $0F, $30, $3C, $21, $0F, $36, $27, $21, $0F, $2A, $1A, $21, $0F, $31, $12	; BG Pal 4
	.byte $0F, $0F, $30, $3C, $0F, $0F, $36, $27, $0F, $30, $0F, $0F, $0F, $01, $31, $12	; BG Pal 5
	.byte $0F, $0F, $30, $3C, $0F, $0F, $21, $12, $0F, $0F, $2A, $1A, $0F, $0F, $2C, $1C	; BG Pal 6
	.byte $0F, $0F, $30, $3C, $0F, $06, $36, $27, $0F, $0B, $2A, $1A, $0F, $0F, $10, $00	; BG Pal 7

	.byte $FF, $16, $36, $0F, $FF, $0F, $30, $16, $FF, $0F, $30, $2A, $FF, $0F, $36, $27	; SPR Pal 0 (8) (Light)
	.byte $FF, $16, $36, $0C, $FF, $0C, $30, $16, $FF, $0C, $30, $2A, $FF, $0C, $36, $27	; SPR Pal 1 (9) (Dark)
	.byte $FF, $16, $36, $0C, $FF, $0F, $0F, $0F, $FF, $0F, $0F, $0F, $FF, $0F, $0F, $0F	; SPR Pal 2 (10) (Game N Watch)
	.byte $FF, $16, $36, $0F, $FF, $07, $30, $16, $FF, $0F, $36, $16, $FF, $1A, $30, $27	; SPR Pal 3 (11) (Bowser)


	; Special sprite palette for ending only
Pal_Ending:
	.byte $FF, $17, $36, $0F, $FF, $17, $36, $0F, $FF, $17, $36, $0F, $FF, $17, $36, $0F	; SPR Pal 0 (8)


Palette_By_Tileset:
	; Points to palette data by a given Level_Tileset value
	.word PalSet_Maps	; 0 - Map
	.word PalSet_Plains	; 1 - Plains style
	.word PalSet_Fort	; 2 - Mini fortress style
	.word PalSet_HillsUnder	; 3 - Hills style
	.word PalSet_HighUp	; 4 - High-Up style
	.word PalSet_GhostHouse	; 5 - Ghose House
	.word PalSet_Water	; 6 - Water world
	.word PalSet_Delfino	; 7 - Toad house
	.word PalSet_PipeMaze	; 8 - Vertical pipe maze
	.word PalSet_Desert	; 9 - desert level
	.word PalSet_Airship	; 10 - airship
	.word PalSet_Giant	; 11 - Giant world
	.word PalSet_Ice	; 12 - ice level
	.word PalSet_Sky	; 13 - coin heaven / sky level
	.word PalSet_HillsUnder	; 14 - underground
	.word PalSet_Ext	; 15 - ext
	.word PalSet_Bonus	; 16 - spade game sliders
	.word PalSet_Bonus	; 17 - N-spade
	.word PalSet_2PVs	; 18 - 2P Vs
	.word PalSet_Bonus	; 19 - bonus game intro and N-Spade

BonusGame_PlayerPal:
	; Player palettes for the bonus game
	.byte $0F, $16, $30, $36, $0F, $16, $30, $21	; Mario
	.byte $0F, $1A, $30, $36, $0F, $1A, $30, $31	; Luigi
	.byte $0F, $16, $30, $36, $0F, $16, $30, $21	; Toad

Map_PlayerPalFix:
	; Selects the correct color for Mario or Luigi on the map,
	; when not wearing a suit which overrides their base color.
	.byte $16, $1A, $16, $00, $00, $00	; Mario, Luigi, Toad, Toad, Toad, Toad

InitPal_Per_MapPowerup:
	; Sets INITIAL palette per map power-up
	; this has no effect to later changes of suits.
	;      SM   BG   FR   LF   TN   HA   JU   PW   ST
	.byte $00, $01, $02, $03, $04, $05, $06, $07, $08

InitPals_Per_MapPUp:
	; Palettes as indexed by InitPal_Per_MapPowerup
	; Note that the first byte is never actually used.
	; Also note this should agree with Map_PostJC_PUpPP1/2 in PRG010
	; See alos PRG026 InvItem_PerPowerUp_Palette
	.byte $FF, $16, $36, $0F	; 0 Small
	.byte $FF, $16, $36, $0F	; 1 Big
	.byte $FF, $27, $36, $16	; 2 Fire
	.byte $FF, $17, $36, $0F	; 3 Leaf
	.byte $FF, $21, $31, $02	; 4 Penguin Suit
	.byte $FF, $30, $36, $0F	; 5 Rabbit
	.byte $FF, $30, $36, $0F	; 6 Hammer
	.byte $FF, $30, $36, $0F	; 7 Judgems
	.byte $FF, $16, $36, $0F	; 8 P-Wing


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Setup_PalData
;
; This subroutine loads the Pal_Data array with a set
; of colors based on Level_Tileset and the values in
; PalSel_Tile_Colors and PalSel_Obj_Colors OR base on
; the override value Pal_Force_Set12.  This also
; performs the corrections of red/green for Mario vs.
; Luigi (see Map_PlayerPalFix and BonusGame_PlayerPal)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Setup_PalData:
	LDA Level_Tileset
	ASL A
	TAY		 ; Y = Level_Tileset << 1 (index into Palette_By_Tileset)

	; Point to the palette associated with this tileset!
	LDA Palette_By_Tileset,Y
	STA <Temp_Var1	
	LDA Palette_By_Tileset+1,Y
	STA <Temp_Var2	

	LDY <Pal_Force_Set12	; Palette override
	BEQ PRG027_B86D	 	; If Pal_Force_Set12 = 0, jump to PRG027_B86D

	; If Pal_Force_Set12 <> 0...
	; Point to the palette associated with this override!
	LDA Palette_By_Tileset,Y
	STA <Temp_Var1		
	LDA Palette_By_Tileset+1,Y
	STA <Temp_Var2		

	; Copy 32 bytes of data into Pal_Data
	LDY #31	 ; Y = 31 (32 bytes total, a whole bg/sprite palette set)
PRG027_B85E:
	LDA [Temp_Var1],Y
	STA Pal_Data,Y	
	DEY		 ; Y--
	BPL PRG027_B85E	 ; While Y >= 0, loop

	LDA #$00	 
	STA <Pal_Force_Set12 ; Pal_Force_Set12 = 0
	JMP PRG027_B8F9	 ; Jump to PRG027_B8F9 (RTS)

PRG027_B86D:
	LDA PalSel_Tile_Colors	 ; A = PalSel_Tile_Colors
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 
	TAY			; Y = PalSel_Tile_Colors << 4; basically, offset by an entire 16 bytes (entire bg palette size) based on PalSel_Tile_Colors
	LDX #$00	 	; X = 0

	; Loop to copy the 16 BG colors to Pal_Data
PRG027_B877:
	LDA [Temp_Var1],Y	; Get byte of palette data
	STA Pal_Data,X	 	; Store it into Pal_Data
	INY		 	; Y++
	INX		 	; X++
	CPX #16			
	BNE PRG027_B877	 	; While X <> 16, loop!

	LDA PalSel_Obj_Colors
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 
	TAY			; Y = PalSel_Obj_Colors << 4; basically, offset by an entire 16 bytes (entire sprite palette size) based on PalSel_Tile_Colors

	LDA Player_RescuePrincess
	BEQ NoPalEndingOverride		; If this is not the ending, jump to NoPalEndingOverride
	BMI NoPalEndingOverride		; Not including World Zero ending

	; For the ending only: Override the object palette to copy appropriate player colors!
	LDA #LOW(Pal_Ending)
	STA <Temp_Var1
	LDA #HIGH(Pal_Ending)
	STA <Temp_Var2
	
	LDY #0

NoPalEndingOverride:

	; Daredevil comet palette override
	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BNE SPD_NotDDComet

	; Red where cyan once was!
	LDA #$05
	STA Pal_Data+3
	BNE SPD_NotPComet

SPD_NotDDComet:
	CMP #MAPOBJ_PURPLECOMET
	BNE SPD_NotPComet

	; Purple where cyan once was!
	LDA #$13
	STA Pal_Data+3

SPD_NotPComet:
	; Loop to copy the 16 sprite colors to Pal_Data
PRG027_B88A:
	LDA [Temp_Var1],Y	; Get byte of palette data
	STA Pal_Data,X	 	; Store it into Pal_Data
	INY		 	; Y++
	INX		 	; X++
	CPX #32		 
	BNE PRG027_B88A	 	; While X <> 32, loop!

	; Technically all transparent colors are duplicates, but this basically
	; ensures that they're all equivalent in the palette RAM copy...
	LDA Pal_Data
	STA Pal_Data+16
	STA Pal_Data+20
	STA Pal_Data+24
	STA Pal_Data+28

	LDA Player_RescuePrincess
	BNE PRG027_B8F9		; If doing the ending, don't do any other overrides

	LDA Level_Tileset
	CMP #19
	BNE PRG027_B8C3	 	; If Level_Tileset <> 19 (Bonus Game intro), jump to PRG027_B8C3

	; Level_Tileset = 19... (the intro to the bonus games)
	LDY Player_Current
	LDA Player_Character,Y
	ASL A		 
	ASL A		 
	ASL A		 
	TAY		 ; Y = Player_Current << 3

	; This loop copies in the correct palette for the Player
	; meeting with the bonus game host (Toad ... typically)
	LDX #$00	 ; X = 0
PRG027_B8B4:
	LDA BonusGame_PlayerPal,Y
	STA Pal_Data+4,X	 
	INY		 ; Y++
	INX		 ; X++
	CPX #$08
	BNE PRG027_B8B4	 ; While X <> 8, loop!
	JMP PRG027_B8F9	 ; (RTS)

PRG027_B8C3:
	CMP #18
	BNE NotVs_PalPatch

	; Specifically for versus, set player character's palette
	LDX Player_Current	; X = Player_Current
	LDA Player_Character,X
	TAX
	
	LDA Map_PlayerPalFix,X	; Get correct color for Player
	STA Pal_Data+17	 	; Store it!

	BNE PRG027_B8F9	; Jump (technically always) to PRG027_B8F9

NotVs_PalPatch:
	CMP #16
	BGE PRG027_B8F9	 	; For all Level_TileSet >= 16, don't do this next patch!

	; The following patches in the correct palette for the
	; power-up the Player current has active.  Note this is
	; ONLY for the INITIAL LOADING of the map screen.
	LDX Player_Current	; X = Player_Current
	LDY #$08	 	; Y = 8
	LDA World_Map_Power,X	; A = World_Map_Power of this player

PRG027_B8CF:
	CMP InitPal_Per_MapPowerup,Y	; Does this index match the player's current power-up?
	BEQ PRG027_B8D9	 	; If so, jump to PRG027_B8D9
	DEY		 	; Y--
	BPL PRG027_B8CF	 	; While Y >= 0, loop!

	BMI PRG027_B8F9	 ; If no match, jump to PRG027_B8F9 (RTS)

PRG027_B8D9:
	TYA		 
	ASL A		 
	ASL A		 
	TAY		 	; Y <<= 2

	; Store the correct power-up suit colors over the Player colors
	LDA InitPals_Per_MapPUp+3,Y
	STA Pal_Data+19
	LDA InitPals_Per_MapPUp+2,Y
	STA Pal_Data+18
	LDA InitPals_Per_MapPUp+1,Y
	STA Pal_Data+17 

	; Mario vs Luigi palette fix: $16 is the first byte in Small,
	; Big, and Starman.  
	CMP #$16	 
	BNE PRG027_B8F9	 ; If palette byte is not $16, jump to PRG027_B8F9 (RTS)

	LDA Player_Character,X
	TAX
	
	LDA Map_PlayerPalFix,X	; Get correct color for Player
	STA Pal_Data+17	 	; Store it!

PRG027_B8F9:

	LDA Level_Tileset
	BNE SPD_NoCometOverride		; If not tileset 0 (map), jump to SPD_NoCometOverride
	LDA Map_CometMode
	BEQ SPD_NoCometOverride		; If not in Comet Mode, jump to SPD_NoCometOverride
	LDA World_Num
	CMP #9
	BEQ SPD_NoCometOverride		; Never comet override on World Zero
	
	; Override map sprite palette to support Daredevil (red) and Purple Comets
	LDA #$15
	STA Pal_Data+22
	LDA #$24
	STA Pal_Data+26

SPD_NoCometOverride:
	RTS		 ; Return


Palette_PrepareFadeInTK:
	CLC			; signals to use "fade in" prep code 

Palette_PrepareFadeOutTK_Entry:
	; Set the palette address to the beginning of palettes, $3F00
	LDA #$3f	 
	STA Palette_AddrHi
	LDA #$00	 
	STA Palette_AddrLo

	STA Palette_Term	 ; Palette_Term = 0, Terminate the palette data

	LDA #32
	STA Palette_BufCnt	 ; Loading 32 colors

	; Prepare all 31 colors in their darkest shades!
	LDY #31		 ; Y = 31
PRG027_B90F:
	PHP		 ; Save CPU state

	LDA Pal_Data,Y	 ; Get next byte of target palette data

	BCS PRG027_B91C	 ; If carry is set (fade out), jump to PRG027_B91C (fade out needs the colors as they're to be targeted!)

	SUB #$30	 ; Otherwise, A -= $30 (darkest shade of this color)
	BCS PRG027_B91C	 ; If we didn't go "less than black", jump to PRG027_B91C
	LDA #$0f	 ; Otherwise, A = $F (black)

PRG027_B91C:
	PLP		 ; Restore CPU state

	STA Palette_Buffer,Y	; Copy this byte of palette data to the buffer
	DEY		 	; Y--
	BPL PRG027_B90F	 	; While Y >= 0, loop!

	LDA #$0b
	STA Fade_Level	 ; Fade_Level = $B

	LDA #$04
	STA Fade_Tick	 ; Fade_Tick = 4

	LDA #$06	 
	STA <Graphics_Queue	 ; Reset the graphics buffer
	RTS		 ; Return


	; Similar to Palette_DoFadeIn from PRG026, but has some additional functionality
Palette_DoFadeInTK:
	LDA Fade_Tick	 
	BEQ PRG027_B93A	 ; If Fade_Tick = 0, jump to PRG027_B93A
	DEC Fade_Tick	 ; Otherwise, Fade_Tick--

PRG027_B93A:
	LDA Fade_Level	 
	BEQ PRG027_B982	 ; If Fade_Level = 0, jump to PRG027_B982 (RTS)

	LDA Fade_Tick	 
	BNE PRG027_B982	 ; If Fade_Tick <> 0, jump to PRG027_B982 (RTS)

	LDA #$04	
	STA Fade_Tick	 ; Fade_Tick = 4 (reload) 

	DEC Fade_Level	 ; Fade_Level--

	BNE PRG027_B95F	 ; If Fade_Level <> 0, jump to PRG027_B95F

PRG027_B95F:
	LDY #31		 ; Y = 31
PRG027_ABF8:
	LDA Palette_Buffer,Y	; Get next byte of palette data 
	CMP #$0f	 	; Is this color black?
	BNE PRG027_B970	 	; If not, jump to PRG027_B970

	LDA Pal_Data,Y	 ; Get the target byte
	AND #$0f	 ; Gets the darkest shade of this color
	JMP PRG027_B978	 ; Jump to PRG027_B978

PRG027_B970:
	CMP Pal_Data,Y	 ; Compare this against the target palette byte
	BEQ PRG027_B97B	 ; If we reached the target, jump to PRG027_B97B
	ADD #$10	 ; Otherwise, add $10 (brighter)

PRG027_B978:
	STA Palette_Buffer,Y	 ; Update the buffer!

PRG027_B97B:
	DEY		 ; Y--
	BPL PRG027_ABF8	 ; While Y >= 0, loop!

	LDA #$06	 
	STA <Graphics_Queue	 ; Queue graphics routine 6

PRG027_B982:
	RTS		 ; Return


	; Functionally identical copy of Palette_PrepareFadeOut from PRG026
Palette_PrepareFadeOutTK:
	LDA FadeOut_Cancel
	BNE PRG027_B98C	 	; If FadeOut_Cancel <> 0, jump to PRG027_B98C (RTS)

	SEC			; signals to use "fade out" prep code		 
	JMP Palette_PrepareFadeOutTK_Entry

PRG027_B98C:
	RTS		 ; Return

	; ALMOST identical copy of Palette_DoFadeOut from PRG026
Palette_DoFadeOutTK:
	LDA FadeOut_Cancel
	BNE PRG027_B9C3	 ; If FadeOut_Cancel <> 0, jump to PRG027_B9C3

	LDA Fade_Tick
	BEQ PRG027_B99A	 ; If Fade_Tick = 0, jump to PRG027_B99A

	DEC Fade_Tick	 ; Fade_Tick--

PRG027_B99A:
	LDA Fade_Level
	BEQ PRG027_B9C3	 ; If Fade_Level = 0, jump to PRG027_B9C3

	LDA Fade_Tick
	BNE PRG027_AC5F	 ; If Fade_Tick <> 0, jump to PRG027_AC5F

	LDA #$04
	STA Fade_Tick	 ; Fade_Tick = 4

	DEC Fade_Level	 ; Fade_Level--

	; For all palette colors...
	LDY #31
PRG027_B9AE:
	LDA Palette_Buffer,Y	; Get this color
	SUB #16		 	; Subtract 16 from it
	BPL PRG027_B9B8	 	; If we didn't go below zero, jump to PRG027_B9B8

	LDA #$0f	 	; Otherwise, set it to safe minimum

PRG027_B9B8:
	STA Palette_Buffer,Y	; Update palette color
	DEY		 	; Y--
	BPL PRG027_B9AE	 	; While Y >= 0, loop!

	; Update palette
	LDA #$06
	STA <Graphics_Queue

PRG027_AC5F:
	RTS		 ; Return

PRG027_B9C3:
	; Fade out cancellation request

	LDA #$00
	STA FadeOut_Cancel
	RTS		 ; Return


; Rest of this pulled from PRG007 to make room...

PlayerFireball_Pats:		.byte $65, $67, $65, $67
PlayerFireball_FlipBits:	.byte SPR_PAL0, SPR_PAL0, SPR_PAL0 | SPR_HFLIP | SPR_VFLIP, SPR_PAL0 | SPR_HFLIP | SPR_VFLIP

PlayerHammer_FlipBits:	.byte $00, SPR_VFLIP, SPR_HFLIP | SPR_VFLIP, SPR_HFLIP
PlayerHammer_YOff:	.byte $00 ; NOTE: Next three values overlap into following table)
PlayerHammer_XOff:	.byte $06, $06, $00, $00

PRG027_A328:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PlayerProjs_UpdateAndDraw
;
; Update and draw Player Projectiles 
; (weapons, i.e. fireballs/hammers/fireball poofs)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PlayerProjs_UpdateAndDraw27:
	LDX #$01	; X = 1  
	STX <SlotIndexBackup		 ; SlotIndexBackup = 1

	JSR PlayerProj_UpdateAndDraw	 ; Update and draw this Player Projectile

	DEC <SlotIndexBackup		 ; SlotIndexBackup = 0
	DEX		 ; X = 0

PlayerProj_UpdateAndDraw:
	LDA PlayerProj_ID,X
	BEQ PRG027_A328	 ; If Player Projectile slot is empty, jump to PRG027_A328 (RTS)
 
	CMP #$03
	BLT PRG027_A33F	 ; If Player Projectile ID < 3 (not the fireball poof), jump to PRG027_A33F

	JMP PRG027_A705	 ; Jump to PRG027_A705

PRG027_A33F:

	; Hammer or Fireball...

	LDA AScrlURDiag_WrapState_Copy
	BEQ PRG027_A361	 ; If diagonal scroller is not wrapping, jump to PRG027_A361

	LDA <Player_HaltGame
	BNE PRG027_A361	 ; If gameplay is halted, jump to PRG027_A361

	; Offset Player projectile to compensate for the diagonal autoscroller's wrap
	LDA PlayerProj_X,X
	ADD AScrlURDiag_OffsetX
	STA PlayerProj_X,X
	LDA PlayerProj_Y,X
	ADD AScrlURDiag_OffsetY
	STA PlayerProj_Y,X

	BCC PRG027_A361
	INC PlayerProj_YHi,X	 ; Apply carry

PRG027_A361:
	LDY <Player_HaltGame
	BEQ PProj_NoHalt

	JMP PRG027_A3DB	 ; If gameplay halted, jump to PRG027_A3DB

PProj_NoHalt:
	LDA PlayerProj_YVel,X
	LDY Player_ReverseGrav
	BEQ PlayerProj_YVel_NoRev

	; SB: If Player is under reverse gravity, invert the YVel
	JSR Negate

PlayerProj_YVel_NoRev:
	STA <Temp_Var1
	
	LDY #$00	 ; Y = 0 (positive high part)
	
	ASL A
	ASL A
	ASL A
	ASL A		 	; Fractional part shifted up
	ADD PlayerProj_YVelFrac,X
	STA PlayerProj_YVelFrac,X	; Add to object's Y vel fractional accumulator

	PHP		 ; Save CPU status

	LDA <Temp_Var1
	LSR A
	LSR A
	LSR A
	LSR A		 ; Whole part shifted down (integer)
	CMP #%00001000	 ; Check the sign bit
	BLT PProjYVelFracSign	 ; If the value was not negatively signed, jump to PRG027_A3AC
	ORA #%11110000	 ; Otherwise, apply a sign extension
	DEY		 ; Y = $FF (negative high part)
PProjYVelFracSign:
	PLP		 ; Restore CPU status

	ADC PlayerProj_Y,X	 ; Apply X velocity
	STA PlayerProj_Y,X	 ; Update X

	; Cascade into Y Hi
	TYA
	ADC PlayerProj_YHi,X
	STA PlayerProj_YHi,X

	LDA PlayerProj_ID,X
	CMP #$02
	BNE PRG027_A3C0	 ; If this is NOT the hammer, jump to PRG027_A3C0

	JSR PBoomerang_Update

	; Hammer specific velocity code...

	LDA PlayerProj_XVel,X
	ASL A
	ASL A
	ASL A
	ASL A		 	; Fractional part shifted up
	ADD PlayerProj_XVelFrac,X
	STA PlayerProj_XVelFrac,X	; Add to object's X vel fractional accumulator

	PHP		 ; Save CPU status

	LDY #$00	 ; Y = 0 (positive high part)

	LDA PlayerProj_XVel,X	; Get X Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 ; Whole part shifted down (integer)
	CMP #%00001000	 ; Check the sign bit
	BLT PRG027_A3AC	 ; If the value was not negatively signed, jump to PRG027_A3AC
	ORA #%11110000	 ; Otherwise, apply a sign extension
	DEY		 ; Y = $FF (negative high part)
PRG027_A3AC:
	PLP		 ; Restore CPU status

	ADC PlayerProj_X,X	 ; Apply X velocity
	STA PlayerProj_X,X	 ; Update X

	TYA		 ; A = $00 or $FF as appropriate

	ADC PlayerProj_XHi,X
	STA PlayerProj_XHi,X ; Add to the high part

	JSR PProj_CalcCoarseXDiff
	
	LDA PlayerProj_XVel,X
	BMI PProj_BoomerangLeftScrChk	; If going left, jump to PProj_BoomerangLeftScrChk
	
	LDA <Temp_Var15
	CMP #96
	BGS PProj_FireballErase		; If too far away right, jump to PProj_FireballErase
	JMP PProj_BoomerangScrChk
	
PProj_BoomerangLeftScrChk:
	LDA <Temp_Var15
	CMP #-96
	BLS PProj_FireballErase		; If too far away left, jump to PProj_FireballErase

PProj_BoomerangScrChk:
	LDA PlayerProj_X,X
	ADD #8
	STA <Temp_Var15		; Temp_Var15 = object's X + ??

	LDA PlayerProj_XHi,X
	ADC #$00	 
	STA <Temp_Var16		; Temp_Var16 = Object's X Hi with carry applied

	LDA <Temp_Var15
	CMP <Horz_Scroll
	LDA <Temp_Var16	
	SBC <Horz_Scroll_Hi
	BNE PRG027_A3EF		; If boomerang is horizontally off-screen, jump to PRG027_A3EF (RTS)


	; Temp_Var2 = scroll relative X
	LDA PlayerProj_X,X
	SUB <Horz_Scroll
	STA <Temp_Var2
	ADD #3
	STA <Temp_Var14

	JMP PRG027_A400

PRG027_A3C0:

	; Fireball specific velocity code...
	INC PlayerProj_Cnt,X	 ; PlayerProj_Cnt++

	; X velocity is applied as integer (no fractional accumulator)
	LDA PlayerProj_X,X
	ADD PlayerProj_XVel,X
	STA PlayerProj_X,X
	LDA PlayerProj_XHi,X
	ADC #0
	STA PlayerProj_XHi,X

	LDA PlayerProj_YVel,X
	CMP #$40
	BEQ PRG027_A3DB	 ; If fireball's Y velocity = $40, jump to PRG027_A3DB

	ADD #$04
	STA PlayerProj_YVel,X	 ; Increase Y velocity (gravity)

PRG027_A3DB:
	; Fireball off screen check...

	; Temp_Var2 = scroll relative X
	LDA PlayerProj_X,X
	SUB <Horz_Scroll
	STA <Temp_Var2	

	ADD #11
	CMP #19
	BGE PRG027_A3F0	 ; If Player Projectile X >= 19, jump to PRG027_A3F0

PProj_FireballErase:
	; Otherwise remove it and let's get out of here!
	LDA #$00
	STA PlayerProj_ID,X

PRG027_A3EF:
	RTS		 ; Return

PRG027_A3F0:
	; Fireball only...
	ADC #-$08	 ; X Relative - 8
	STA <Temp_Var14	 ; -> Temp_Var14

	LDA PlayerProj_YVel,X
	BMI PRG027_A40E	 ; If fireball is moving upward, jump to PRG027_A40E

PRG027_A400:
	LDA PlayerProj_Y,X
	CMP Level_VertScroll
	LDA PlayerProj_YHi,X
	SBC Level_VertScrollH
	BMI PRG027_A3EF	 ; If Player projectile is vertically off-screen, jump to PRG027_A3EF (RTS)

PRG027_A40E:
	TXA
	ASL A
	ASL A		; A = Player Projectile slot index * 4
	ADD Object_SprRAM+6	 ; Offset into high end Sprite RAM
	TAY		 ; -> 'Y'

	; Set projectile sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	LDA PlayerProj_Y,X
	SUB Level_VertScroll
	CMP #192
	BGE PProj_FireballErase	 ; If projectile relative Y >= 192, jump to PProj_FireballErase (too low, remove projectile)

	; Set projectile sprite Y
	STA Sprite_RAM+$00,Y

	ADC #14		; Y + 14
	STA <Temp_Var13	; -> Temp_Var13

	LDA Player_ReverseGrav
	BEQ PlayerProj_FireDet_NoRev

	; Under reverse gravity, fireball just detects from top
	LDA <Temp_Var13
	SUB #14
	STA <Temp_Var13

PlayerProj_FireDet_NoRev:
	; Temp_Var3 = initial sprite attribute by Player's travel direction
	LDA PlayerProj_XVel,X
	LSR A		; Sign bit shifted right
	AND #SPR_HFLIP
	STA <Temp_Var3

	LDA PlayerProj_ID,X
	CMP #$02
	BNE PRG027_A471	 ; If this is NOT the hammer, jump to PRG027_A471

	; Hammer only...

	LDA <Player_Suit
	CMP #PLAYERSUIT_HAMMER
	BNE PlayerProj_ChangeToPoof	 ; If Player is NOT wearing the Hammer Suit anymore (uh oh), jump to PlayerProj_ChangeToPoof

	LDA Level_NoStopCnt
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3

	LDA PlayerHammer_XOff,X	 ; Get X offset
	BIT <Temp_Var3	 ; Check for horizontal flip
	BVC PRG027_A453	 ; If no flip, jump to PRG027_A453

	EOR #$06	 ; Otherwise, invert X offset

PRG027_A453:
	ADD <Temp_Var2		 ; Apply X offset
	STA Sprite_RAM+$03,Y	 ; Set Hammer X

	LDA PlayerHammer_YOff,X	 ; Get Y offset
	ADD Sprite_RAM+$00,Y	 ; Add to Sprite Y
	STA Sprite_RAM+$00,Y	 ; Update Sprite Y

	; Hammer pattern
	LDA #$4d
	STA Sprite_RAM+$01,Y

	LDA <Temp_Var3		; Get horizontal flip bit
	EOR PlayerHammer_FlipBits,X	 ; XOR in the hammer flip bits

	SEC		 ; Set carry (hammer)
	JMP PRG027_A485	 ; Jump to PRG027_A485

PRG027_A471:

	; Fireball only...

	LDA Level_NoStopCnt
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3

	; Set fireball pattern
	LDA PlayerFireball_Pats,X
	STA Sprite_RAM+$01,Y

	; Set fireball attributes
	LDA <Temp_Var3		 ; Get horizontal flip bit
	EOR PlayerFireball_FlipBits,X	 ; XOR in the fireball flip bits

	CLC		 ; Clear carry (fireball)

PRG027_A485:
	LDX Player_Behind
	BEQ PRG027_A48C	 ; If Player is not "behind the scenes", jump to PRG027_A48C

	ORA #SPR_BEHINDBG	; Set priority

PRG027_A48C:
	STA Sprite_RAM+$02,Y	 ; Set Player Projectile attributes

	LDX <SlotIndexBackup	 ; X = Player Projectile slot index

	LDA <Player_HaltGame
	BNE PRG027_A4A2	 ; If gameplay is halted, jump to PRG027_A4A2

	; Gameplay not halted...

	;BCS PRG027_A49A	 ; If this is the hammer, jump to PRG027_A49A (PlayerProj_HitEnemies)

	JSR Fireball_DetectWorld	 ; Hit tests for fireball (bounce, poof, etc.)

;PRG027_A49A:
	JMP PlayerProj_HitEnemies	 ; Jump to PlayerProj_HitEnemies

PlayerProj_ChangeToPoof:

	; Change Player Projectile to "Poof"
	LDA #$03
	STA PlayerProj_ID,X

PRG027_A4A2:
	RTS		 ; Return

Fireball_DetectWorld:
	LDA Level_7Vertical
	BEQ PRG027_A4CF	 ; If this is not a vertically oriented level, jump to PRG027_A4CF

	; Vertical level...

	LDA <Temp_Var13		; Detect Y of fireball
	ADD Level_VertScroll	; Apply vertical scroll
	STA <Temp_Var6		; -> Temp_Var6

	AND #$f0		; Aligned to grid row
	STA <Temp_Var3		; -> Temp_Var3

	; Temp_Var2 = high byte of tile memory
	LDA Level_VertScrollH	; Current vertical scroll high
	ADC #HIGH(Tile_Mem)	; Add the upper byte of the Tile_Mem address
	STA <Temp_Var2		; -> Temp_Var2

	; Temp_Var14 = fireball X + 4
	LDA PlayerProj_X,X
	ADC #$04
	STA <Temp_Var14

	; Temp_Var1 = Row/Column offset value
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3
	STA <Temp_Var1

	LDY #$00	 ; Y = 0 (don't need additional offset)
	JMP PRG027_A52D	 ; Jump to PRG027_A52D

PRG027_A4CF:

	; Non-vertical level...

	LDA Player_PartDetEn
	BEQ PRG027_A4E7	 ; If Player_PartDetEn is not enabled, jump to PRG027_A4E7

	; When fireball Y >= 160, force detection of bottom two rows of tiles

	LDA <Temp_Var13	 ; Detect Y of fireball
	CMP #160
	BLT PRG027_A4E9	 ; If < 160, jump to PRG027_A4E9

	SBC #16		 ; Detect Y - 16
	STA <Temp_Var6	 ; -> Temp_Var6

	AND #$f0	 ; Aligned to grid row
	STA <Temp_Var3	 ; -> Temp_Var3

	LDA #$01	 ; A = 1 (force bottom tiles)
	JMP PRG027_A4F8	 ; Jump to PRG027_A4F8

PRG027_A4E7:
	LDA <Temp_Var13	 ; Detect Y of fireball

PRG027_A4E9:
	ADD Level_VertScroll	 ; Apply vertical scroll
	STA <Temp_Var6		 ; -> Temp_Var6

	AND #$f0	 ; Aligned to grid row
	STA <Temp_Var3	 ; -> Temp_Var3

	LDA Level_VertScrollH	; Current vertical scroll high
	ADC #$00	 ; Apply carry

PRG027_A4F8
	STA <Temp_Var4	 ; -> Temp_Var4
	BEQ PRG027_A506	 ; If vertical high = 0, jump to PRG027_A506

	CMP #$02
	BGE PRG027_A557	 ; If vertical high >= 2 (way too low), jump to PRG027_A557

	LDA <Temp_Var3
	CMP #$B0
	BGE PRG027_A557	 ; If at or lower than $1B0 (too low), jump to PRG027_A557

PRG027_A506:
	LDA <Temp_Var14	 ; Fireball detect X
	ADD <Horz_Scroll ; Apply horizontal scroll
	STA <Temp_Var5	 ; -> Temp_Var5

	LDA <Horz_Scroll_Hi
	ADC #$00
	STA <Temp_Var7	 ; High value -> Temp_Var7

	ASL A		 ; Multiply by 2 for Tile_Mem_Addr index
	TAY		 ; -> 'Y'

	; Temp_Var1 = low byte of Tile_Mem_Addr
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1

	; Temp_Var2 = high byte of Tile_Mem_Addr
	LDA <Temp_Var4
	AND #$01	; Only 0 or 1 is valid in non-vertical
	ADD Tile_Mem_Addr+1,Y
	STA <Temp_Var2

	; Y = row/column offset index
	LDA <Temp_Var5
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3
	TAY

PRG027_A52D:
	LDA [Temp_Var1],Y	 ; Get the tile at the Player Projectile 
	JSR PSwitch_SubstTileAndAttr	 ; Handle P-Switch changed tiles
	PHA		 ; Save adjusted tile

	ASL A
	ROL A
	ROL A
	AND #$03
	TAY		 ; Y = quadrant of tile
	STY <Temp_Var2	 ; -> Temp_Var2

	PLA		 ; Restore adjusted tile
	STA <Temp_Var1	 ; -> Temp_Var1

	CMP Tile_AttrTable,Y
	BLT PRG027_A557	 ; If this tile is not solid on top, jump to PRG027_A557

	; Tile is solid on top...

	CMP Tile_AttrTable+4,Y
	BLT PRG027_A59F	 ; If this tile is not solid on the sides/bottom, jump to PRG027_A59F

	; Tile is solid all around

	JMP PRG027_A566

	; SB: Removed thaw code just for needed space

	;LDY Level_TilesetIdx
	;CPY #$0b
	;BNE PRG027_A566	 ; If this is not an Ice level, jump to PRG027_A566

	;CMP #TILE12_FROZENMUNCHER
	;BNE PRG027_A55D		; If the fireball did not hit a frozen muncher, jump to PRG027_A55D

	; Fireball hit a frozen muncher!

	;LDA #CHNGTILE_FROZENMUNCHER
	;BNE PRG027_A563	 ; Jump (technically always) to PRG027_A563

PRG027_A557:

	; Fireball_HitChkPass = 0
	LDA #$00
	STA Fireball_HitChkPass,X

	RTS		 ; Return

;PRG027_A55D:
	;CMP #TILE12_FROZENCOIN
	;BNE PRG027_A566	 ; If the fireball did not hit a frozen coin, jump to PRG027_A566

	; Fireball hit a frozen coin!

	;LDA #CHNGTILE_FROZENCOIN

;PRG027_A563:
	;JSR Fireball_ThawTile	 ; Thaw the frozen tile!

PRG027_A566:
	LDA <Temp_Var1

	LDY Level_SlopeEn
	BEQ PRG027_A579	 ; If this level is NOT sloped, jump to PRG027_A579

	; If this is a slope level and fireball hit level ground, jump to PRG027_A594
	CMP #TILE14_ABOVE_MIDGROUND
	BEQ PRG027_A594
	CMP #TILE3_MIDGROUND
	BEQ PRG027_A594
	CMP #TILE3_WMIDGROUND
	BEQ PRG027_A594

PRG027_A579:
	INC Fireball_HitChkPass,X	; Fireball_HitChkPass++

	LDA Fireball_HitChkPass,X
	CMP #$02
	BNE PRG027_A586	 ; If Fireball_HitChkPass <> 2, jump to PRG027_A586

	; Fireball has been through hit check too many times, it's obviously done

Jmp_PRG027_A637:
	JMP PRG027_A637	 ; Jump to PRG027_A637 ("Poof" away, fireball..)

Fireball_BounceAdj:	.word -2, 2	; SB: Not-reverse-gravity and reverse gravity fireball bounce adjustment

PRG027_A586:

	LDA PlayerProj_ID,X
	CMP #2
	BEQ Jmp_PRG027_A637		; Boomerang (former hammer) now uses this detection code, but just poof

	; Y = 0 or 2, if gravity not reversed or it is
	LDA Player_ReverseGrav
	ASL A
	TAY

	; Adjust fireball Y for bounce
	LDA PlayerProj_Y,X
	ADD Fireball_BounceAdj,Y
	STA PlayerProj_Y,X

	LDA PlayerProj_YHi,X
	ADC Fireball_BounceAdj+1,Y
	STA PlayerProj_YHi,X

PRG027_A594:
	; Bounce fireball!
	LDA #-$30

PRG027_A596:
	STA PlayerProj_YVel,X

	; Reset counter to 3
	LDA #$03
	STA PlayerProj_Cnt,X

	RTS		 ; Return

PRG027_A59F:

	; Tile not solid on sides/bottom...

	LDA Level_SlopeEn
	BNE PRG027_A5DC		; If this is a sloped level, jump to PRG027_A5DC

	; Not a sloped level...

	LDA <Temp_Var6	; Relative Y of fireball
	AND #$0f	; Within tile
	CMP #$05	
	BLT PRG027_A594	; If fireball is high enough on the top-solid-only tile, then bounce! (Jump to PRG027_A594)

	RTS		 ; Return


;Fireball_ThawTile:
	
	;STA Level_ChgTileEvent	 ; Queue tile change event!

	;JSR BrickBust_MoveOver	 ; Open up a brick bust

	; Brick bust "poof" style (over top of the changing tile)
	;LDA #$01
	;STA BrickBust_En

	; Set block change Y 
	;LDA <Temp_Var3
	;STA Level_BlockChgYLo

	; Set poof Y
	;SBC Level_VertScroll
	;STA BrickBust_YUpr

	; Set block change Y Hi
	;LDA <Temp_Var4
	;STA Level_BlockChgYHi

	; Set block change X
	;LDA <Temp_Var5
	;AND #$f0
	;STA Level_BlockChgXLo

	; Set poof X
	;SBC <Horz_Scroll
	;STA BrickBust_X	

	; Set block change X Hi
	;LDA <Temp_Var7
	;STA Level_BlockChgXHi

	;JMP PlayerProj_ChangeToPoof	 ; Change the projectile itself into a poof


PRG027_A5DC:

	; Temp_Var6 will remain as "Y offset within tile"
	LDA <Temp_Var6
	AND #$0f
	STA <Temp_Var6

	; Temp_Var5 will remain as "X offset within tile"
	LDA <Temp_Var5
	AND #$0f
	STA <Temp_Var5

	LDY <Temp_Var2	 ; Y = tile quadrant
	TYA
	ASL A
	TAX		 ; X = tile quadrant * 2 (2 byte index into Level_SlopeSetByQuad)

	; Temp_Var3/4 pointer into appropriate Level_SlopeSetByQuad
	LDA Level_SlopeSetByQuad,X
	STA <Temp_Var3
	LDA Level_SlopeSetByQuad+1,X
	STA <Temp_Var4

	LDX <SlotIndexBackup	 ; X = Player Projectile index

	LDA <Temp_Var1
	SUB Tile_AttrTable,Y
	TAY		 ; Y = tile made relative to solid set

	LDA [Temp_Var3],Y
	TAY		 ; Y = slope offset for this tile

	LDA Slope_ObjectVel_Effect,Y
	CMP #$80
	BEQ PRG027_A637	 ; If this tile has no effect, jump to PRG027_A637 ("Poof" away, fireball..)

	STA <Temp_Var7	 ; Effect value -> Temp_Var7

	LDA PlayerProj_ID,X
	CMP #2
	BEQ PRG027_A637		; Boomerang (former hammer) now uses this detection code, but just poof

	; SB: Retooling to work more like Player's retrieval of slopes so fireballs
	; can properly utilize ceiling slopes $10+
	LDA #LOW(Slope_LUT)
	STA <Level_GndLUT_L

	; Tile "shape" index values $1x will add 1 to Level_GndLUT_H
	; Because of 16 entries per tile in Slope_LUT
	TYA	; Slope shape index -> 'A'
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ADD #HIGH(Slope_LUT)
	STA <Level_GndLUT_H

	TYA	; Slope shape index -> 'A'
	ASL A
	ASL A
	ASL A
	ASL A	; multiply by 16, since there's 16 entries per slope
	ADD <Temp_Var5	 ; Add the tile-relative horizontal position (offset to pixel specific height on this slope)
	TAY

	LDA Player_ReverseGrav
	BNE Fireball_SlopeChk_Rev	; If Player is under reverse gravity, jump to Fireball_SlopeChk_Rev

	; Lower 4 bits of Slope_LUT (the "sloped floor height" component) -> Temp_Var2
	LDA [Level_GndLUT_L],Y
	AND #$0f
	STA <Temp_Var2

	LDA <Temp_Var6
	CMP #12
	BGE PRG027_A626	 ; If fireball is deeper than 12 pixels into the tile, jump to PRG027_A626

	CMP <Temp_Var2
	BLT PRG027_A645	 ; If fireball is higher than the slope height, jump to PRG027_A645 (RTS)

PRG027_A626:
	LDA <Temp_Var7
	BEQ PRG027_A642	 ; If effect value = 0, jump to PRG027_A642

	LDY #-$50	 ; Y = -$50 (high bounce velocity)
	EOR PlayerProj_XVel,X
	BMI PRG027_A633
	LDY #-$20	 ; Y = -$20 (low bounce velocity)
PRG027_A633:
	TYA
	JMP PRG027_A596	 ; Jump to PRG027_A596


Fireball_SlopeChk_Rev:
	; SB: Under reverse gravity, we use the "ceiling" component instead
	LDA [Level_GndLUT_L],Y
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var2

	LDA <Temp_Var6
	CMP #4
	BLT PRG027_A626	 ; If fireball is higher than 4 pixels into the tile, jump to PRG027_A626

	CMP <Temp_Var2
	BGE PRG027_A645	 ; If fireball is lower than the slope height, jump to PRG027_A645 (RTS)
	BLT PRG027_A626	; Otherwise, jump to PRG027_A626


PRG027_A637:

	; "Bump" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	JMP PlayerProj_ChangeToPoof	; Turn into a "poof" and don't come back!

PRG027_A642:
	JMP PRG027_A594	 ; Jump to PRG027_A594 (another pass through the hit routines, should cause it to "poof" out)

PRG027_A645:
	RTS		 ; Return

PlayerProj_HitEnemies:

	; Fireball/hammer common...

	LDY #$04	 ; Y = 4 (enemies only exist in the lower slots)
PRG027_A648:
	LDA Objects_SprHVis,Y
	ORA Objects_SprVVis,Y
	BNE PRG027_A667	 ; If object has sprites horizontally or vertically off-screen, jump to PRG027_A667 (Forget it!)

	LDX Objects_State,Y	; X = object's state
	LDA Obj2Obj_EnByState,X
	BNE PRG027_A667	 ; If this state does not support object-to-object (object-to-Projectile), jump to PRG027_A667 (Forget it!)

	; SB: Sort of inline version of Object_CalcAttrFlagOff, done for 'X' instead of 'Y'
	; because that's how this loop was coded... needed to support extended objects!
	LDX Level_ObjectID,Y	; X = object's ID
	CPX #OBJ_EXTBANK_BEGIN
	BLT Object_CalcAttrFlagOffX_Done	; If not an extended object, jump to Object_CalcAttrFlagOff_Done

	; There's a gap between the last valid "regular" object and the special objects;
	; This intends to offset the gap...
	TXA		; 'X' (object ID) -> 'A'
	SUB #(OBJ_EXTBANK_BEGIN - (Object_AttrFlags_Ext - Object_AttrFlags))	; Offset to line up with ID gap
	TAX		; -> 'X'
	
Object_CalcAttrFlagOffX_Done:		
	LDA Object_AttrFlags,X	
	STA <Temp_Var1		; Object attribute flags -> Temp_Var1

	AND #OAT_WEAPONIMMUNITY
	BNE PRG027_A667	 ; If object is immune to Player weapons, jump to PRG027_A667
	
	LDA Objects_FrozenTimer,Y
	BNE PRG027_A667	 ; If object is frozen, jump to PRG027_A667

	JSR PlayerProj_HitObject	 ; See if Player Project hit an object and respond!

PRG027_A667:
	DEY		 ; Y--
	BPL PRG027_A648	; While Y >= 0, loop

	LDX <SlotIndexBackup	 ; X = Player Projectile slot index

PRG027_A66C:
	RTS		 ; Return

	; A Y range per bounding box index
Projectile_BBoxY:	.byte $18, $18, $28, $18, $18, $18, $18, $18, $18, $18, $20, $18, $18, $28, $18, $18

	; An X range per bounding box index
Projectile_BBoxX:	.byte $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $18, $10, $10


	; SB: List of objects that are ice-immune (Penguin Suit)
	; Not my preferred way to go, but "cheaper" than a full 256 byte LUT?
Projectile_IceImmunity:
	.byte OBJ_BOSS_BOWSER
	.byte OBJ_BOSS_BOWSER2
	.byte OBJ_BOSS_BOWSERFINAL
	.byte OBJ_BOSSBIRDO
	.byte OBJ_BOSS_BOWSERJR
	.byte OBJ_BOSS_MOUSER
	.byte OBJ_BOSS_WART
	.byte OBJ_BOSS_TOPMANIAC
	.byte OBJ_BOSS_BIGBOO1
	.byte OBJ_BOSS_BIGBOO2
	.byte OBJ_BOSS_BIGBOO3
	.byte OBJ_BOSS_BOOMER
	.byte OBJ_BOSS_REZNOR
	.byte OBJ_BOSS_TOTOMESU
	.byte OBJ_BOSS_CLYDE
	.byte OBJ_BOSS_PETEY
	.byte OBJ_BOSS_BLECK
	.byte OBJ_BIRDOEGG
	.byte OBJ_THWOMP
	.byte OBJ_THWOMPDIAGONALDL
	.byte OBJ_THWOMPDIAGONALUL
	.byte OBJ_THWOMPLEFTSLIDE
	.byte OBJ_THWOMPRIGHTSLIDE
	.byte OBJ_THWOMPUPDOWN
	.byte OBJ_BOO
	.byte OBJ_EERIE
	.byte OBJ_BOOMBOOMQBALL
	.byte OBJ_ENEMYSUN
	.byte OBJ_LAVALOTUS
	.byte OBJ_ICESNAKE
	.byte OBJ_BOSS_BLECK
	.byte OBJ_TREASUREBOX
	.byte OBJ_TREASUREBOXAPPEAR
	.byte OBJ_CHECKPOINT
	.byte OBJ_CHECKPOINT_FORCE
	.byte OBJ_ENDLEVELCARD
	
Projectile_IceImmunity_End


PlayerProj_HitObject:
	; Advanced Player behind check to support behind-fence enemies
	LDA Objects_IsBehind,Y	; Get if object is or isn't behind the scenes
	EOR Player_Behind_En	; Get if Player is or isn't behind the scenes
	BNE PRG027_A66C	 	; If mismatched, jump to PRG027_A66C (RTS)


	LDA <Temp_Var1		 
	AND #OAT_BOUNDBOXMASK
	TAX		 ; X = Object's bounding box index
	STX <Temp_Var2	 ; -> Temp_var2

	LDA <Temp_Var13	 	; Detect Y of projectile
	SUB Objects_SpriteY,Y	; Difference against this object's Sprite Y
	CMP Projectile_BBoxY,X
	LDX <SlotIndexBackup	; X = Player Projectile slot index
	BGE PRG027_A66C	 	; If projectile is out of range vertically, jump to PRG027_A66C (RTS)

	LDA <Temp_Var14		; Detect X of projectile
	SUB Objects_SpriteX,Y	; Difference against this object's Sprite X
	LDX <Temp_Var2		; X = bounding box index
	CMP Projectile_BBoxX,X
	LDX <SlotIndexBackup	; X = Player Projectile slot index
	BGE PRG027_A6FD	 	; If projectile is out of range horizontally, jump to PRG027_A6FD (RTS)

	LDA PlayerProj_ID,X
	CMP #$02
	BEQ PRG027_A6BD	 ; If this is a hammer, jump to PRG027_A6BD

	JSR PlayerProj_ChangeToPoof	 ; "Poof" goes the fireball
	JMP PRG027_A6C3	 ; Jump to PRG027_A6C3

PRG027_A6BD:

	; Hammer hit...

	LDA <Temp_Var1	; Object's attributes
	BMI PRG027_A6FD	 ; If OAT_HITNOTKILL is set, jump to PRG027_A6FD (RTS)
	BPL PRG027_A6C9	 ; Otherwise, jump to PRG027_A6C9

PRG027_A6C3:

	; Fireball only...

	LDA <Player_Suit
	CMP #PLAYERSUIT_PENGUIN
	BNE PW_FireballImmunity

	; Penguin suit uses ice immunity check instead!
	LDA Level_ObjectID,Y	; Get object ID
	LDX #(Projectile_IceImmunity_End - Projectile_IceImmunity - 1)
IceImmuneCheck_Loop:
	CMP Projectile_IceImmunity,X
	BEQ IceImmune_Found
	
	DEX							; X--
	BPL IceImmuneCheck_Loop		; While X >= 0, loop!
	
IceImmune_Found:
	PHP		; Save flags
	LDX <SlotIndexBackup	; X = Player Projectile slot index
	PLP		; Restore flags
	
	BEQ PRG027_A6FE		; If object is immune to ice, jump to PRG027_A6FE
	BNE PRG027_A6C9		; Otherwise, jump to PRG027_A6C9

PW_FireballImmunity:
	LDA <Temp_Var1
	AND #OAT_FIREIMMUNITY
	BNE PRG027_A6FE	 ; If object is immune to fire, jump to PRG027_A6FE

PRG027_A6C9:

	; Weapon successfully hit!

	; Play "kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	LDA Objects_HitCount,Y
	BEQ PRG027_A6DD	 ; If enemy has no hits left, jump to PRG027_A6DD

	; Otherwise, just remove a hit...
	SUB #$01
	STA Objects_HitCount,Y

	RTS		 ; Return


PRG027_A6DD:
	LDA <Player_Suit
	CMP #PLAYERSUIT_PENGUIN
	BEQ PPHit_Penguin	; If Player is wearing a Penguin suit, jump to PPHit_Penguin

	; Enemy bounces upward a bit
	LDA #-$34
	STA Objects_YVel,Y

	; Set object's velocity based on Player's velocity (sort of works)
	LDA PlayerProj_XVel,X
	ASL A
	LDA #$0C
	BCC PRG027_A6EC	 ; If Player's X Velocity is negative, jump to PRG027_A6EC
	LDA #-$0C
PRG027_A6EC:
	STA Objects_XVel,Y

	TYA
	TAX	; object index -> 'X'

	; 100 pts!
	LDA #$05
	JSR Score_PopUp

	LDX <SlotIndexBackup	 ; X = Player Projectile slot index

	; But the enemy is killed...
	LDA #OBJSTATE_KILLED
	STA Objects_State,Y

PRG027_A6FD:
	RTS		 ; Return

PRG027_A6FE:
	JMP PRG027_A637	 ; Jump to PRG027_A637

PPHit_Penguin:
	; As a penguin, these "fireballs" are iceballs, and free things!
	; Freeze enemy!
	; Set Objects_FrozenTimer
	LDA #$FE
	STA Objects_FrozenTimer,Y

	; If now-frozen object was in "kicked" state, revert to just "shelled"
	; We'll reuse "kicked" later to make frozen enemies kickable!
	LDA Objects_State,Y
	CMP #OBJSTATE_KICKED
	BNE PPHit_NotKicked

	; Revert to "shelled"
	LDA #OBJSTATE_SHELLED
	STA Objects_State,Y
	
	; Halt horizontal velocity (in case you let him thaw out so he doesn't jerk)
	LDA #0
	STA Objects_XVel,Y

PPHit_NotKicked:
	RTS

Fireball_PoofPattern:	.byte $45, $41, $43, $47

PRG027_A705:

	; Fireball poof!

	LDY <Player_HaltGame
	BNE PRG027_A719	 ; If gameplay halted, jump to PRG027_A719

	; PlayerProj_ID is now the fireball poof counter for the remainder

	INC PlayerProj_ID,X	 ; PlayerProj_ID++

	LDA PlayerProj_ID,X
	CMP #$10
	BNE PRG027_A719	 ; If PlayerProj_ID <> $10, jump to PRG027_A719

PRG027_A713:
	; Poof is over; clear it!
	LDA #$00
	STA PlayerProj_ID,X

	RTS		 ; Return

PRG027_A719:
	TXA
	ADD <Counter_1
	AND #$01	; A = 0 or 1
	ASL A
	ASL A
	ASL A		; A = 0 or 8
	ADC #$18	; A = $18 or $20
	TAY		; -> 'Y'

	; Set poof left sprite X
	LDA PlayerProj_X,X
	SBC #$04
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	; Set poof right sprite X
	ADD #$08
	STA Sprite_RAM+$07,Y

	LDA PlayerProj_Y,X
	SUB Level_VertScroll
	CMP #208
	BGE PRG027_A713	 ; If poof has fallen too low, jump to PRG027_A713 (remove it)

	; Set left and right "poof" sprite Ys
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	LDA PlayerProj_ID,X
	LSR A
	LSR A
	TAX		 ; X = index into Fireball_PoofPattern
	LDA Fireball_PoofPattern,X	 ; Get proper poof pattern

	; Set left and right "poof" sprite pattern
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	LDA #SPR_PAL1

	LDX Player_Behind_En
	BEQ PRG027_A75F	 ; If Player is not behind the scenes, jump to PRG027_A75F

	ORA #SPR_BEHINDBG

PRG027_A75F:
	STA Sprite_RAM+$02,Y	; Set left sprite attributes
	ORA #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$06,Y	 ; Set right sprite attributes

	LDX <SlotIndexBackup	 ; X = Player Projectile slot index

	RTS		 ; Return

PBoomerang_XVelDelta:	.byte -$01, $01
PBoomerang_XVelLimit:	.byte -$30, $30
PBoomerang_YVelDelta:	.byte -$01, $01
PBoomerang_YVelLimit:	.byte -$20, $20

PBoomerang_Update:

	LDA SndCur_Level2
	AND #SND_BOOMERANG
	BNE PRG027_B8D3	 ; If PBoomerang sound is currently playing, jump to PRG027_B8D3

	; Player PBoomerang sound
	LDA Sound_QLevel2
	ORA #SND_BOOMERANG
	STA Sound_QLevel2

PRG027_B8D3:
	LDA PlayerProj_Var2,X
	PHA		; Save Var2 for Y vel check later
	AND #$01
	TAY		 ; Y = 0 or 1 (PBoomerang Direction)

	; 0 when thrown right (so it's heading left on return)
	; 1 when thrown left  (so it's heading right on return)
		
	; Accelerate PBoomerang
	LDA PlayerProj_XVel,X
	CMP PBoomerang_XVelLimit,Y
	BEQ PProj_NoXVelAccel
	
	ADD PBoomerang_XVelDelta,Y
	STA PlayerProj_XVel,X
	
PProj_NoXVelAccel:

	JSR PProj_CalcCoarseXDiff
	LDA <Temp_Var15
	STA <Temp_Var1

	CPY #0
	BEQ PProj_BoomerangLeft	; If Y = 0, boomerang is heading left (for return), jump to PProj_BoomerangLeft
	
	; Y = 1 Boomerang is heading right (for return)
	CMP #12
	BLS PProj_BoomerangYVel
	
	; Reverse direction!
	LDA PlayerProj_Var2,X
	AND #~1
	STA PlayerProj_Var2,X

	JMP PProj_BoomerangYVel
	
PProj_BoomerangLeft:
	; Y = 0 Boomerang is heading left (for return)

	CMP #-4
	BGS PProj_BoomerangYVel
	
	; Reverse direction!
	LDA PlayerProj_Var2,X
	ORA #1
	STA PlayerProj_Var2,X
		
PProj_BoomerangYVel:
	PLA		; Var2, for Y vel check
	STA <Temp_Var15		; -> Temp_Var15
	
	AND #$40	; Check if we still haven't done first turn around
	BEQ PProj_FollowPlayerY		; If we've done it, jump to PProj_FollowPlayerY
	
	; Check if there's been a turn around
	LDA PlayerProj_XVel,X	; And if there's a conflict in sign (boomerang has reversed direction), bit 7 will be set
	EOR <Temp_Var15			; Basically, bit 7 is set or not depending on initial velocity
	BPL PProj_NoYVelAccel	; If there hasn't been a reversal, jump to PProj_NoYVelAccel
	
	; OK, start Y following
	LDA <Temp_Var15
	AND #%00111111
	STA PlayerProj_Var2,X

PProj_FollowPlayerY:
	JSR PProj_CalcCoarseYDiff
	
	LDA <Temp_Var15
	SUB #2
	BNE PProj_BoomerangYNotOK

	; OK
	LDA #0
	STA PlayerProj_YVel,X

PProj_BoomerangYNotOK:
	; Boomerang is not on a good Y level; depending on sign, move!
	ASL A
	ROL A
	AND #1
	EOR Player_ReverseGrav	; Flips on reverse gravity
	TAY		; Y = 0 if player above, 1 if player below

	; Accelerate PBoomerang
	LDA PlayerProj_YVel,X
	CMP PBoomerang_YVelLimit,Y
	BEQ PProj_NoYVelAccel
	
	ADD PBoomerang_YVelDelta,Y
	STA PlayerProj_YVel,X
	
PProj_NoYVelAccel:

	; Don't catch until count has worn down to prevent instantly catching
	LDA PlayerProj_Cnt,X
	BEQ PProj_BCanCatch

	DEC PlayerProj_Cnt,X
	RTS

PProj_BCanCatch:
	; Temp_Var15 is the coarse Y offset; if between -2 and 2, catch!
	LDA <Temp_Var15
	SUB #2
	CMP #4
	BGE PRG027_B979	; Out of range, jump to PRG027_B979 (RTS)

	; Temp_Var1 is the coarse X offset; if between -3 and 3, potential catch...
	LDA <Temp_Var1
	ADD #3		; Make it 0 to 6 for ease
	CMP #6
	BGE PRG027_B979	; Out of range, jump to PRG027_B979 (RTS)


	; Caught!
	LDA #0
	STA PlayerProj_ID,X

PRG027_B979:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PProj_CalcCoarseXDiff
;
; Calculates a "coarse" X difference with the Player,
; returning a one byte value that determines the
; difference in X/XHi coordinates in units of 4 pixels
; in Temp_Var15.  Temp_Var16 is set to $40 and the
; carry flag is set if the difference was negative.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PProj_CalcCoarseXDiff:
	LDA PlayerProj_X,X	 
	SUB <Player_X	
	STA <Temp_Var15		; Temp_Var15 = difference between Object and Player X

	LDA PlayerProj_XHi,X
	SBC <Player_XHi		; Calc diff between X His

	LSR A			; Push low bit of "hi" difference -> carry
	ROR <Temp_Var15		; Cycle carry into Temp_Var15 at high bit; will be discarding low bit
	LSR A			; Push low bit of "hi" difference -> carry
	ROR <Temp_Var15		; Cycle carry into Temp_Var15 at high bit; will be discarding low bit

	; Temp_Var15 now holds a difference between the Object and Player
	;  X coordinates in units of 4 pixels (works up to two screen
	; widths; anything greater and object was probably removed anyway)

	; Note the following only works because there is no way that bit 5 and 7
	; could be a part of the actual difference, just the sign factor, since
	; a level cannot be more than 10 screens in width.
	ASL A			; Shift remaining difference left 1; carry set means negative difference
	AND #$40
	STA <Temp_Var16		; Temp_Var16 being $40 also means negative difference

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PProj_CalcCoarseYDiff
;
; Calculates a "coarse" Y difference with the Player,
; returning a one byte value that determines the
; difference in Y/YHi coordinates in units of 8 pixels.
; Returns Temp_Var15 in the format of a crude signed
; value for Y Hi in bit 6 and 7 
; [00 -> Y Hi = 0, 01 -> Y Hi = 1, 11 -> Y Hi = negative]
; and the base Y difference in the bits 0 - 5 (so units 
; of 8 pixels.)
; Temp_Var16 holds the raw difference in "Y Hi"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PProj_CalcCoarseYDiff
	LDA PlayerProj_Y,X
	SUB <Player_Y	
	STA <Temp_Var15		 ; Temp_Var15 = difference between object's Y and Player's Y

	LDA PlayerProj_YHi,X
	SBC <Player_YHi	
	STA <Temp_Var16		 ; Temp_Var16 = difference between object's Y Hi and Player's Y Hi

	LSR A		 	; least significant bit of Y Hi -> carry

	ROR <Temp_Var15		; Temp_Var15 takes on the "Hi" value in its most significant bit

	LSR A			; next least significant bit of Y Hi -> carry

	ROR <Temp_Var15		; The new Temp_Var15's least significant bit is pushed into its bit 7

	; So now Temp_Var15 holds the main Y difference in its first 5 bits
	; Bit 6 and 7 form a signed portion of the "hi" value -- 00 -> Y Hi = 0, 01 -> Y Hi = 1, 11 -> Y Hi = negative

	RTS		 ; Return
	
