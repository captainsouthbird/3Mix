; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg030.bin, File Size: 8193, ORG: $8000
;     -> NES mode enabled
;---------------------------------------------------------------------------
	; STANDARD HORIZONTAL SCREEN

Tile_Mem_Addr:	
	; This breaks up the overall "tile" layout memory into screen-based chunks
	; With a screen width of 256 pixels, that makes 16 blocks across every "screen",
	; NTSC res of 224, two screens tall, is 448 / 16px-per-tile = 28 POTENTIAL rows per screen
	; but the status bar occludes one, so only 27 rows are stored... 
	; Up to 15 screens!
	.word Tile_Mem,       Tile_Mem+$01B0, Tile_Mem+$0360, Tile_Mem+$0510, Tile_Mem+$06C0, Tile_Mem+$0870, Tile_Mem+$0A20, Tile_Mem+$0BD0
	.word Tile_Mem+$0D80, Tile_Mem+$0F30, Tile_Mem+$10E0, Tile_Mem+$1290, Tile_Mem+$1440, Tile_Mem+$15F0, Tile_Mem+$17A0


	; ALTERNATE VERTICAL SCREEN

	; Each "screen" (stacked vertically) is made up of 15 rows of tiles
	; which amounts to $F0 bytes per screen; the following split LUT defines tile memory
	; offsets gapped by $F0... not sure why they had to make the address lookup into two LUTs
	; like they did, but whatever... 16 vertical screens available

	; High bytes are separate from low
Tile_MemH = HIGH(Tile_Mem)

	; Vertical low byte, per screen
Tile_Mem_AddrVL:
	.byte $00, $F0, $E0, $D0, $C0, $B0, $A0, $90, $80, $70, $60, $50, $40, $30, $20, $10

	; Vertical high byte, per screen
Tile_Mem_AddrVH:
	.byte Tile_MemH+$0, Tile_MemH+$0, Tile_MemH+$1, Tile_MemH+$2
	.byte Tile_MemH+$3, Tile_MemH+$4, Tile_MemH+$5, Tile_MemH+$6
	.byte Tile_MemH+$7, Tile_MemH+$8, Tile_MemH+$9, Tile_MemH+$A
	.byte Tile_MemH+$B, Tile_MemH+$C, Tile_MemH+$D, Tile_MemH+$E



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This table contains commands for Video_Misc_Updates which tells
; it how to generate certain graphical elements programatically
;
; Format:
;	[2B TVA][CMD][DATA]
;	TVA: Target Video Address, typ. inside the nametable somewhere
;	CMD: 	- Bit 7 set = Use vertical updates (32B) else use horizontal (1B)
;		- Bit 6 set = Means that there is only one byte of DATA, repeated
;		- Bits 0-5  = Count of bytes to write directly to PPU 
;	DATA: Raw byte(s) to write to the PPU, count specified by CMD
; After a data chunk has been read, a new TVA is expected, or a $00 byte which terminates the stream.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Remember that the left edge is typically clipped, so nothing is visible there...
Video_Upd_Table: ; $803E
	.word Graphics_Buffer	; $00 - Graphics buffer for dynamically generated content
	.word Video_DoStatusBarV; $01 - status bar (vertical level)
	.word Video_DoStatusBar	; $02 - status bar (typical)
	.word $A000		; $03 - ???
	.word $A06F		; $04 - ???
	.word Video_DoStatusBarHM; $05 - status bar appropriate for horizontal mirroring
	.word Video_DoPalUpd	; $06 - Updates palettes per values in the $07BE+ Palette_* vars; used during fade in/out routines
	.word Video_RoulBordAttr; $07 - Roulette sliders border and attribute settings
	.word Bonus_InstBoxTop	; $08 - Top of Bonus Game instruction box
	.word Bonus_InstBoxLine1; $09 - First line of Bonus Game instruction box
	.word Bonus_InstBoxLine2; $0A - Second line of Bonus Game instruction box
	.word Bonus_InstBoxLine3; $0B - Third line of Bonus Game instruction box
	.word Bonus_InstBoxBot	; $0C - Bottom of Bonus Game instruction box
	.word Video_NSpadeBG	; $0D - N-Spade candy striping background
	.word Video_DoWXMario00	; $0E - "World X" Intro, Mario (horizontal scroll at $00)
	.word Video_DoWXLuigi00	; $0F - "World X" Intro, Luigi (horizontal scroll at $00)
	.word Video_DoWXToad00	; $10 - "World X" Intro, Toad (horizontal scroll at $00)
	.word Video_DoWXMario80	; $11 - "World X" Intro, Mario (horizontal scroll at $80)
	.word Video_DoWXLuigi80	; $12 - "World X" Intro, Luigi (horizontal scroll at $80)
	.word Video_DoWXToad80	; $13 - "World X" Intro, Toad (horizontal scroll at $80)
	.word Video_Blackout	; $14 - Blacks out 3 colors, used during end-level triple card match; not sure what for?
	.word Video_DoGameOver00; $15 - "GAME OVER" Box (horizontal scroll at $00)
	.word Video_DoGameOver80; $16 - "GAME OVER" Box (horizontal scroll at $80)
	.word $0000	; $17 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $18 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $19 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $1A - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $1B - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $1C - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $1D - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $1E - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $1F - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $20 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $21 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $22 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $23 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $24 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $25 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $26 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $27 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $28 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $29 - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word $0000	; $2A - SB: Removed, used to be 3CM fanfare, now using flagpole
	.word Video_DoW2WZ	; $2B - "WELCOME TO WARP ZONE" banner
	.word Video_CourseClearH	; $2C - SB: "COURSE CLEAR" High
	.word Video_CourseClear	; $2D - "COURSE CLEAR"
	.word $0000	; $2E - SB: Removed, used to be "YOU GOT A CARD" (and the card space) [for the End Level otherwise]

	; The status bar comes in three identical versions with different VRAM start addresses
	; Might as well make a macro out of that, eh?

	; NOTE!! If you want to edit the status bar, you should also sync up
	; with the "flip" data in PRG026 as noted below...
StatusBar	.macro

	; Sync next three with PRG026 Flip_TopBarCards
	vaddr \1 + $00
	.byte $02, $FC, $A0		; Upper left corner

	vaddr \1 + $02
	.byte VU_REPEAT | $12, $A1	; Bar across the top

	vaddr \1 + $14
	.byte $0C, $A2, $A0, $A1, $A1, $A3, $A1, $A1, $A3, $A1, $A1, $A2, $FC	; top of card slots

	; Sync this with PRG026 Flip_MidTStatCards
	vaddr \1 + $20
	.byte $20, $FC, $A6, $70, $71, $72, $73, $FE, $FE, $EF, $EF, $EF, $EF, $EF, $EF, $3C	; |WORLD  >>>>>>[P] $  | |  | |  | |  | |
	.byte $3D, $FE, $EC, $F0, $F0, $A7, $A6, $FE, $FE, $AA, $FE, $FE, $AA, $FE, $FE, $A7, $FC
	; Discrepency --------^  (Pattern is ... $FE, $F0 ... in PRG026 status bar graphics)

	; Sync this with PRG026 Flip_MidBStatCards
	vaddr \1 + $40
	; Discrepency --------v  (Pattern is ... $FE, $FE ... in PRG030 status bar)  Unimportant; inserts <M> which is replaced anyway
	.byte $20, $FC, $A6, $FE, $FE, $FB, $FE, $F3, $FE, $F0, $F0, $F0, $F0, $F0, $F0, $F0	; [M/L]x  000000 c000| etc.
	.byte $FE, $ED, $F0, $F0, $F0, $A7, $A6, $FE, $FE, $AA, $FE, $FE, $AA, $FE, $FE, $A7, $FC
	; Discrepency --------^  (Pattern is ... $F4, $F0 ... in PRG030 status bar graphics)

	; Sync next three with PRG026 Flip_BottomBarCards
	vaddr \1 + $60
	.byte $02, $FC, $A8	; Lower corner

	vaddr \1 + $62
	.byte VU_REPEAT | $12, $A4	; Bottom bar

	vaddr \1 + $74
	.byte $0C, $A5, $A8, $A4, $A4, $A9, $A4, $A4, $A9, $A4, $A4, $A5, $FC	; lower corner and card bottoms

	; End PRG026 sync

	vaddr \1 + $80
	.byte VU_REPEAT | $20, $FC	; black space

	vaddr \1 + $A0
	.byte VU_REPEAT | $20, $FC	; black space

	; Terminator
	.byte $00
	.endm

	; Typical status bar (vertical level)
Video_DoStatusBarV:
	StatusBar $2700

	; Typical status bar (non-vertical level)
Video_DoStatusBar:
	StatusBar $2B00

	; Status bar used when Horizontal Mirroring in effect (Roulette game)
Video_DoStatusBarHM:
	StatusBar $2300

Video_3CMStarTop:
	vaddr $208F
	.byte VU_REPEAT | $02, $A9
	vaddr $20AE
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $20B1
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $20ED
	.byte $01, $A9
	vaddr $20F2
	.byte $01, $A9
	vaddr $2108
	.byte VU_REPEAT | $06, $A9
	vaddr $2112
	.byte VU_REPEAT | $06, $A9
	.byte $00	; Terminator

Video_3CMStarTip:
	vaddr $2128
	.byte $01, $A9
	vaddr $2137
	.byte $01, $A9
	vaddr $2149
	.byte $01, $A9
	vaddr $214E
	.byte VU_VERT | VU_REPEAT | $03, $A9
	vaddr $2151
	.byte VU_VERT | VU_REPEAT | $03, $A9
	vaddr $2156
	.byte $01, $A9
	.byte $00	; Terminator

Video_3CMStarSide:
	vaddr $216A
	.byte $01, $A9
	vaddr $2175
	.byte $01, $A9
	vaddr $218B
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $2194
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $21CA
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $21D5
	.byte VU_VERT | VU_REPEAT | $02, $A9
	.byte $00	; Terminator

Video_3CMStarBot1:
	vaddr $2209
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $220F
	.byte VU_REPEAT | $42, $A9
	vaddr $2216
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $222D
	.byte VU_REPEAT | $02, $A9
	vaddr $2231
	.byte VU_REPEAT | $02, $A9
	.byte $00	; Terminator

Video_3CMStarBot2:
	vaddr $2248
	.byte $05, $A9, $FC, $FC, $A9, $A9
	vaddr $2253
	.byte $05, $A9, $A9, $FC, $FC, $A9
	vaddr $2268
	.byte VU_REPEAT | $03, $A9
	vaddr $2275
	.byte VU_REPEAT | $03, $A9
	.byte $00	; Terminator

Video_3CMAppear1:
	vaddr $23CA
	.byte VU_REPEAT | $04, $FF
	vaddr $23D2
	.byte VU_REPEAT | $04, $FF
	vaddr $23DA
	.byte VU_REPEAT | $04, $FF
	vaddr $23E2
	.byte VU_REPEAT | $04, $FF
	.byte $00	; Terminator

Video_3CMAppear3:
	vaddr $23D3
	.byte $02, $BF, $EF
	vaddr $23DB
	.byte $02, $FB, $FE
	.byte $00	; Terminator
	
Video_3CMAppear4:
	vaddr $23D3
	.byte $02, $6A, $9A
	vaddr $23DB
	.byte $02, $A6, $A9
	.byte $00	; Terminator

Video_3CMAppear5:
	vaddr $23CA
	.byte $04, $BF, $AF, $AF, $EF
	vaddr $23D2
	.byte $04, $BB, $55, $55, $EE
	vaddr $23DA
	.byte $04, $BB, $55, $55, $EE
	vaddr $23E2
	.byte $04, $FB, $FA, $FA, $FE
	.byte $00	; Terminator

Video_3CMAppear6:
	vaddr $23CA
	.byte $04, $7F, $5F, $5F, $DF
	vaddr $23D2
	.byte $04, $77, $55, $55, $DD
	vaddr $23DA
	.byte $04, $77, $55, $55, $DD
	vaddr $23E2
	.byte $04, $F7, $F5, $F5, $FD
	.byte $00	; Terminator

Video_3CMAppear7:
	vaddr $23CA
	.byte VU_REPEAT | $04, $55
	vaddr $23D2
	.byte VU_REPEAT | $04, $55
	vaddr $23DA
	.byte VU_REPEAT | $04, $55
	vaddr $23E2
	.byte VU_REPEAT | $04, $55
	.byte $00	; Terminator

	; Blacks out a little bit of the palette during end level triple-card match sequecnce
Video_Blackout:
	vaddr $3F0D
	.byte VU_REPEAT | $03, $0F, $00


Video_3CMAppear2:
	vaddr $3F05
	.byte $03

EndLevelCard_PalData:
	.byte $0F, $30, $3C
	vaddr $3F09
	.byte $03, $0F, $10, $2C
	vaddr $3F0D
	.byte VU_REPEAT | $03, $0F
	.byte $00	; Terminator

Video_CourseClear:
	vaddr $2989
	.byte $0E
	;       C    O    U    R    S    E         C    L    E    A    R         !
	.byte $85, $8E, $8A, $82, $83, $84, $FC, $85, $8B, $84, $80, $82, $FC, $9B, $00

Video_CourseClearH:
	vaddr $21C9
	.byte $0E
	;       C    O    U    R    S    E         C    L    E    A    R         !
	.byte $85, $8E, $8A, $82, $83, $84, $FC, $85, $8B, $84, $80, $82, $FC, $9B, $00


Map_Y_Starts:
	; Map Y start positions, World 1-8 (X is always $20)
	.byte $40, $60, $A0, $40, $60, $A0, $30, $50, $00, $40

	; A clear pattern set by Level_Tileset (for use with Clear_Nametable_Short)
ClearPattern_ByTileset:
	.byte $FF	; 0 - Map
	.byte $FC	; 1 - Plains
	.byte $FF	; 2 - Mini fortress style
	.byte $FC	; 3 - Hills style
	.byte $FC	; 4 - High-Up style
	.byte $FC	; 5 - Ghose House
	.byte $FC	; 6 - Water world
	.byte $FF	; 7 - Toad house
	.byte $FC	; 8 - Vertical pipe maze
	.byte $FC	; 9 - desert level
	.byte $FC	; 10 - airship
	.byte $FC	; 11 - Giant World
	.byte $FC	; 12 - ice level
	.byte $FC	; 13 - coin heaven / sky level
	.byte $FC	; 14 - underground
	.byte $FF	; 15 - ext
	.byte $FF	; 16 - spade game sliders
	.byte $FF	; 17 - N-spade
	.byte $FC	; 18 - 2P Vs
	.byte $FF	; 19 - bonus game intro


	; SB: Starting star coin tile (expecting 2 adjacent)
Level_StarCoinByTileset:
	.byte $FF		; 0 - Map
	.byte TILE1_STARCOIN1	; 1 - Plains
	.byte TILE2_STARCOIN1	; 2 - Mini fortress style
	.byte TILE3_STARCOIN1		; 3 - Hills style
	.byte TILE4_STARCOIN1	; 4 - High-Up style
	.byte TILE5_STARCOIN1	; 5 - Ghose House
	.byte TILE6_STARCOIN1	; 6 - Water world
	.byte TILE7_STARCOIN1	; 7 - Toad house
	.byte TILE8_STARCOIN1	; 8 - Vertical pipe maze
	.byte TILE9_STARCOIN1		; 9 - desert level
	.byte TILE10_STARCOIN1		; 10 - airship
	.byte TILE13_STARCOIN1		; 11 - Giant World
	.byte TILE4_STARCOIN1		; 12 - ice level
	.byte TILE13_STARCOIN1	; 13 - coin heaven / sky level
	.byte TILE14_STARCOIN1	; 14 - underground
	.byte TILE5_STARCOIN1	; 15 - ext
	.byte $FF		; 16 - spade game sliders
	.byte $FF		; 17 - N-spade
	.byte $FC		; 18 - 2P Vs
	.byte $FF		; 19 - bonus game intro

	; Index by Level_TilesetIdx
	; Enables spike tiles where available (this tile and tile before it)
SpikesEnable:
	.byte $FF	;  0 Plains style
	.byte TILE2_SPIKEDOWN	;  1 Mini Fortress style
	.byte $FF	;  2 Hills style
	.byte $FF	;  3 High-Up style
	.byte $FF	;  4 ghost house
	.byte TILE8_SPIKE_UP	;  5 water world
	.byte $FF	;  6 Toad House
	.byte TILE8_SPIKE_UP	;  7 Vertical pipe maze
	.byte TILE9_SPIKEUP	;  8 desert levels
	.byte $FF	;  9 Airship
	.byte $FF	; 10 Giant World
	.byte $FF	; 11 Ice level
	.byte $FF	; 12 Sky level
	.byte $FF	; 13 Underground
	.byte TILE15_SPIKEDOWN	; 14 ext

	; Index by Level_TilesetIdx
	; Enables conveyor tiles where available (this tile and tile before it)
ConveyorEnable:
	.byte $00	;  0 Plains style
	.byte TILE2_CONVEYORR	;  1 Mini Fortress style
	.byte $00	;  2 Hills style
	.byte TILE2_CONVEYORR	;  3 High-Up style
	.byte TILE2_CONVEYORR	;  4 ghost house
	.byte $00	;  5 water world
	.byte $00	;  6 Toad House
	.byte $00	;  7 Vertical pipe maze
	.byte $00	;  8 desert levels
	.byte $00	;  9 Airship
	.byte $00	; 10 Giant World
	.byte $00	; 11 Ice level
	.byte $00	; 12 Sky level
	.byte $00	; 13 Underground
	.byte $00	; 14 ext

	; Index by Level_TilesetIdx
	; Sets the tile which is a pain in the ass (typically muncher, sometimes jelectro)
	; Although TILEA_MUNCHER is always considered anyway for Kuribo's shoe... 
	; (see after PRG008_BD96) which is probably a bug/mistake!  (Although to their
	; credit, you can never normally have Kuribo's shoe in a Jelectro level)
MuncherJelectroSet:
	.byte TILEA_MUNCHER	;  0 Plains style
	.byte TILEA_MUNCHER	;  1 Mini Fortress style
	.byte TILEA_MUNCHER	;  2 Hills style
	.byte TILEA_MUNCHER	;  3 High-Up style
	.byte TILEA_MUNCHER	;  4 ghost house
	.byte TILE4_JELECTRO	;  5 water world
	.byte TILEA_MUNCHER	;  6 Toad House
	.byte TILE4_JELECTRO	;  7 Vertical pipe maze
	.byte TILEA_MUNCHER	;  8 desert levels
	.byte TILEA_MUNCHER	;  9 Airship
	.byte TILEA_MUNCHER	; 10 Giant World
	.byte TILE4_JELECTRO	; 11 Ice level
	.byte TILEA_MUNCHER	; 12 Sky level
	.byte TILEA_MUNCHER	; 13 Underground
	.byte TILEA_MUNCHER	; 14 ext

	; Index by Level_TilesetIdx
	; Enables quicksand tiles where available (this tile and tile before it)
QuicksandEnable:
	.byte $00	;  0 Plains style
	.byte $00	;  1 Mini Fortress style
	.byte TILE3_QUICKSAND_MID	;  2 Hills style
	.byte $00	;  3 High-Up style
	.byte $00	;  4 ghost house
	.byte $00	;  5 water world
	.byte $00	;  6 Toad House
	.byte $00	;  7 Vertical pipe maze
	.byte TILE9_QUICKSAND_MID	;  8 desert levels
	.byte $00	;  9 Airship
	.byte $00	; 10 Giant World
	.byte $00	; 11 Ice level
	.byte $00	; 12 Sky level
	.byte TILE3_QUICKSAND_MID	; 13 Underground
	.byte $00	; 14 ext

	; List of C000 pages to switch to by Level_Tileset
PAGE_C000_ByTileset: ; $83D6
	.byte 10, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 22, 22, 14, 22

	; List of A000 pages to switch to by Level_Tileset
PAGE_A000_ByTileset: ; $83E9
	.byte 11, 15, 21, 16, 17, 40, 18, 44, 18, 20, 23, 19, 17, 19, 13, 45, 26, 26,  9, 26

	; The normal level VROM page cycle set
PT2_Anim:	.byte $60, $62, $64, $66

	; FIXME: This is dumb to store identical bit lookup arrays

	; Bits set when pipe raise is needed (Level_PipeRaiseData)
PipeRaise_NeedRaiseBits:		.byte $01, $02, $04, $08

	; Bits set when pipe raise has been completed (Level_PipeRaiseData)
PipeRaise_AlreadyRaisedBits:	.byte $10, $20, $40, $80

MapObj_CompleteBit:
Arena_CompleteBit:
WorldIntro_CheckBit:	.byte $01, $02, $04, $08, $10, $20, $40, $80

	; The BGM per world (SB: Removed silly World_BGM_Restore in PRG010)
World_BGM:	
	.byte MUS2A_WORLD1, MUS2A_WORLD2, MUS2A_WORLD3, MUS2A_WORLD4
	.byte MUS2A_WORLD5, MUS2A_WORLD6, MUS2A_WORLD7, MUS2A_WORLD8
	.byte MUS2A_SKY, MUS2B_UNDERGROUND

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; IntReset_Part2
	;
	; Part 2 of the Reset routine...
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IntReset_Part2:
	LDA PPU_STAT	 ;
	BPL IntReset_Part2 ; Wait until VBlank
	LDA #$00	 ; 
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg
	STA PPU_CTL1	 ; Most likely just to disable further Resets

	; Note: This is setting up the address $7F00 @ $00/$01, the last page of SRAM
	LDY #$00	 ; Y = $00
	STY <Temp_Var1	 ; <Temp_Var1 = $00
	LDA #$7D	 ; A = $7D		(SB: NOT clearing $7E00-$7FFF -- that's my save data now!!)
	STA <Temp_Var2	 ; <Temp_Var2 = $7D

	; The following loop clears all of $6000 - $7FFF ... a lot of RAM!
PRG062_8437:
	LDA #$00	 	; A = 0
	STA [Temp_Var1],Y	; Clear 
	DEY			; Y--
	BNE PRG062_8437	 	; While Y is not zero, loop (since Y started at 0, this does a full 256 bytes)

	; This decrement then moves to $7E, $7D ... $60
	DEC <Temp_Var2	 ; Next lower page
	LDA <Temp_Var2	 ; Get page -> A
	CMP #$5f	 ; 
	BNE PRG062_8437	 ; If A <> $5F, loop again (clears down to $6000)

	; Clear $07FF - $0000, excluding $01xx
	LDY #$07
	JSR Clear_RAM_thru_ZeroPage

	; Reset_Latch = $5A (magic value that prevents reset vector from being run)
	LDA #$5a
	STA Reset_Latch

	; SB: Removing N-Spade from map

	; N-Spade appears every 80,000 points, but the leading zero is fake, so 8000

	; Middle byte of the N-Spade score
	;LDA #HIGH(8000)
	;STA Map_NSpade_NextScore+1

	; Lowest byte of the N-Spade score
	;LDA #LOW(8000)
	;STA Map_NSpade_NextScore+2

PRG062_845A:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	; Load title screen graphics
	LDA #$78
	STA PatTable_BankSel
	LDA #$7a	
	STA PatTable_BankSel+1
	LDA #$20	
	STA PatTable_BankSel+2
	LDA #$21	
	STA PatTable_BankSel+3
	LDA #$04	
	STA PatTable_BankSel+4
	LDA #$7f	
	STA PatTable_BankSel+5

	; Load page 24 into A000 and page 25 into C000
	JSR SetEndingPages

	LDA #$20
	STA Update_Select	 ; Update_Select = $20 (Title Screen)
	STA Raster_Effect	 ; Raster_Effect = $20 (Title Screen style)

	LDA #%10101000
	STA PPU_CTL1	 	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	JSR Do_Title_Screen	; Do the title screen!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BEGINNING INITIALIZATION OF WORLD MAP!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG062_84A0:

	; Load page 11 into A000 and page 10 into C000
	LDA #10
	STA PAGE_C000
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_Both2	


	JSR Map_Init	 ; Initialize map variables (page 11)

	LDA #$00
	STA Map_Operation	; Map_Operation = 0 ("World X" intro)
	STA Map_Airship_Dest	; Map_Airship_Dest = 0
	STA Map_SetBothPlayers	; Clear the flag that sets both Players to start of map!
	STA Map_Anchored	; Map_Anchored = 0 (not anchored yet)

	; Map_UnusedGOFlag = $F8?
	LDA #$f8
	STA <Map_UnusedGOFlag
		
	; SB: Get base offset into completions to aid in calculating unique ID
	; Only need to do this if persisting across worlds
	;LDY World_Num
	;LDA MapCompletions_Starts,Y
	;STA LevCP_BaseID

	LDA #$00	 ; 
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg

	; Stop Update_Select activity temporarily while we initialize
	INC UpdSel_Disable

	; SB: Do NOT clear Map_Completions anymore!!
	; The following clears Map_Completions (stores completed levels on the map)
;	LDY #$7f	 ; Y = $7F
;	LDA #$00	 ; A = $00
;PRG062_84D1:
;	STA Map_Completions,Y
;	DEY		 ; Y--
;	BPL PRG062_84D1	 ; While Y >= 0, loop!

PRG062_84D7:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	; Init for lost bonus game??
	LDA #$2b
	STA Bonus_UnusedVH
	LDA #$35
	STA Bonus_UnusedVL

	LDA #$00
	STA Level_Tileset	; Level_Tileset = 0
	STA Map_March_Count	; Not sure about this
	STA Raster_Effect	; Raster Effects disabled
	STA UpdSel_Disable 	; Stop Update_Select activity
	STA Vert_Scroll_Off	; Vert_Scroll_Off = 0
	STA Horz_Scroll_Off32PP	; Horz_Scroll_Off32PP = 0

	; Init for lost bonus game??
	LDA #$04
	STA BonusText_CharPause
	STA Bonus_DieCnt

	; Reload the timer tick for the next time it's used
	LDA #$28	
	STA Level_TimerTick

	; Unused699 = 3 (never used)
	LDA #$03	 
	STA Unused699

	; Update_Select = $C0
	LDA #$c0	 	
	STA Update_Select

	; Load world map graphics
	LDA #$14
	STA PatTable_BankSel
	LDA #$16
	STA PatTable_BankSel+1

	; SB: Map sprite graphics are now Common/Player/World bound...

	; Common bank
	LDX #241
	STX PatTable_BankSel+2
	
	; Player bank
	LDX Player_Current
	LDA Player_Character,X
	ADD #242	; Base at 242
	TAX			; -> 'X'
	STX PatTable_BankSel+3
	
	; World specific banks
	LDA #148
	LDX Map_CometMode
	BNE MapLoad_Comet148B	; If comet mode, jump to MapLoad_Comet148B

	; World specific banks
	LDX World_Num
	
MapLoad_Comet148B:	
	LDA #148
	STA PatTable_BankSel+4

	LDA #149
	
	LDX World_Num
	CPX #8
	BNE MapLoad_NotW8
	
	; World 9 (Star Road) needs numbers!
	LDA #145
	
MapLoad_NotW8:
	STA PatTable_BankSel+5

	; Changes pages at A000 and C000 based on value Level_Tileset (0)
	JSR SetPages_ByTileset	 ;	A000 = Page 11, C000 = Page 10
	
	LDX Player_Current	; X = Player_Current
	LDA #(Inventory_Score - Inventory_Items)	; Base offset to score from Inventory_Items
	CPX #$00	 	; 
	BEQ PRG062_853F	 	; If X = 0 (Player is Mario), jump to PRG062_853F
	ADD #(Inventory_Score2 - Inventory_Score)	 ; Otherwise, add $23

PRG062_853F:
	TAY		 ; Y = $1F (Mario) or $42 (Luigi)

	; Copies the 3 byte score of this Player to the status bar
	; loading area to display their score...
	LDX #$00	 ; X = 0
PRG062_8542:
	LDA Inventory_Items,Y	; Starts at $1F or $42, score offset
	STA Player_Score,X	; Store into buffer area..
	INY		 	; Y++
	INX		 	; X++
	CPX #$03	 
	BNE PRG062_8542	 ; While X <> 3, loop


	; fixme piggies
	
	; Init Player's on map
	LDX Total_Players
	DEX		 ; X = Total_Players-1
PRG062_8552:
	; Set Player's Y position
	LDA Map_Entered_Y,X
	STA <World_Map_Y,X

	; Set Player's X position
	LDA Map_Entered_XHi,X
	STA <World_Map_XHi,X
	LDA Map_Entered_X,X
	STA <World_Map_X,X

	; SB: Now a world backup!
	;LDA Map_Previous_World,X
	;STA <Map_UnusedPlayerVal2,X

	; Map_UnusedPlayerVal = $20 each Player (not used for anything)
	LDA #$20
	STA <Map_UnusedPlayerVal,X

	DEX		 ; X--
	BPL PRG062_8552	 ; If more players to initialize, loop!

	LDX Player_Current
	LDA Map_Previous_World,X
	STA World_Num

	LDA #$00	 
	STA Level_Tileset	 ; Map uses Level_Tileset = 0
	STA World_EnterState	 ; World_EnterState = 0 (just arriving)
	STA <Map_EnterLevelFX	 ; Scratch = 0
	STA <Map_Intro_CurStripe ; Start with the first "strip" of erasing the World X intro box
	STA <Map_WarpWind_FX	 ; No warp whistle wind effects
	STA Map_Intro_Tick	 ; Map_Intro_Tick = 0 (forces init in some functions)

PRG062_857E:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	LDA #$01	 
	STA MMC3_MIRROR	 ; Set vertical mirroring

	LDX Player_Current	 ; X = current Player index

	LDA World_Map_Power,X	; X = Player's current world map power
	STA Map_Power_Disp	; Set as powerup currently displayed 

	LDY #$00	 ; "Darkness" flag (only works correctly on World 8 level 2)
	LDA World_Num	 ; A = World_Num
	CMP #$07	 
	BNE PRG062_85A5	 ; If this is NOT World 8, jump to PRG062_85A5

	; We're in World 8...
	LDA <World_Map_XHi,X
	CMP #$02	 
	BNE PRG062_85A5	 ; If NOT on the third level of World 8, jump to PRG062_85A5
	INY		 ; Activate darkness

PRG062_85A5:
	STY World_8_Dark ; Set the darkness flag

	; Not sure what this assignment means here?
	LDA #$00
	STA Bonus_UnusedFlag

	; Changes pages at A000 and C000 based on value Level_Tileset (0)
	JSR SetPages_ByTileset	 ;	A000 = Page 11, C000 = Page 10

	JSR Scroll_Map_SpriteBorder	; Draw sprite-based border on map

	; Set A000 page to 12
	LDA #12
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	; Restore map objects for this player
	JSR_THUNKA 11, Map_RestoreObjects

	JSR Map_CountStarCoins
	JSR Map_Reload_with_Completions	 	; Load map and set already completed levels
	JSR Fill_Tile_AttrTable_ByTileset	; Load tile attribute tiles by the tileset

	LDA Inventory_Open	
	BNE PRG012_85CE		; If Inventory is open, jump to PRG012_85CE

	; If Inventory is not open
	LDX Player_Current	; X = Player_Current

	LDA Map_Previous_Dir,X 	; Get Player's previous moment direction
	STA <World_Map_Dir,X	; Restore it

PRG012_85CE:
	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync

	LDY Player_Current	; Y = current Player index

	; This sets up the scroll correctly given wherever the Player last was on the map
	LDA Map_Prev_XOff,Y	 
	STA <Scroll_Temp	 ; Scroll_Temp = X offset
	LDA Map_Prev_XHi,Y	 ; A = hi byte of X offset
	JSR Scroll_Update_Ranges ; Off to Scroll_Update_Ranges...

	LDA #$00	 
	STA <Scroll_LastDir	 ; Scroll_LastDir = 0

	LDA <Scroll_ColumnL	
	STA <Scroll_ColumnR	; Scroll_ColumnR = Scroll_ColumnL

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

	; This (re)draws the status bar
	LDA #$02
	JSR Video_Do_Update

	; Switch to page 26 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #26		
	STA MMC3_PAGE	 

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	LDA #$00	 		; Commit graphics in Graphics_Buffer
	JSR Video_Do_Update		; Do it!

	JSR Scroll_Dirty_Update 	; Do a full draw of the map tiles

	; Clear all the map object Y to zero!
	LDY #$0d	 ; Y = $D
	LDA #$00	 ; A = 0
PRG062_8617:
	STA Map_Object_ActY,Y
	DEY		 ; Y--
	BPL PRG062_8617	 ; While Y >= 0, loop!

	LDA World_8_Dark
	BEQ PRG062_8625	 	; If World_8_Dark = 0 (not doing the effect), jump to PRG062_8625

	JSR Map_W8DarknessFill	; Fill in the entire screen with black

PRG062_8625:

	; SB: Temporary? removal
	LDA World_Num	 
	CMP #$FF
	BNE PRG062_8634	 ; If World_Num <> REMOVED, jump to PRG062_8634

	LDA #$2b	
	JSR Video_Do_Update	 ; Print the "WELCOME TO WARP ZONE" banner
	JSR PRGROM_Change_A000	 ; Fix bank A000

PRG062_8634:
	LDY Player_Current	 ; Y = Player_Current
	LDA Map_Prev_XOff,Y	 ; Get player's previous X offset (low byte)
	STA <Horz_Scroll	 ; Set the scroll to that
	STA <Scroll_Temp	 
	LDA Map_Prev_XHi,Y	 ; Get player's previous X offset (high byte) 
	STA <Horz_Scroll_Hi	 ; Store as current scroll "high"
	JSR Scroll_Update_Ranges

PRG062_8646:
	JSR Map_DrawAndPan	 ; Draw and pan map as necessary

	; Pushes any buffered graphics thru
	LDA #$00	 	
	JSR Video_Do_Update	

	LDA Map_DrawPanState
	BNE PRG062_8646	 	; If some kind of map drawing/panning activity is occurring, loop around

	; SB: Skipping the whole "World X" intro thing!

	LDA Map_Operation
	BNE PRG062_86A2	 	; If map operation is anything besides zero, jump to PRG062_86A2

	LDY World_Num
	CPY #9
	BNE Map_ShowIntro_NotWZero
	
	; World zero special
	LDA Map_WVisit2
	ORA #1
	STA Map_WVisit2
	BNE Map_ShowIntro_OKWZero
	
Map_ShowIntro_NotWZero:
	LDA Map_WVisit1
	AND WorldIntro_CheckBit,Y
	BEQ Map_ShowIntro_OK		; If not already been to this world, jump to Map_ShowIntro_OK

	; SB: World intro bypass
	INC Map_Operation
	BNE PRG062_86A2		; Jump (technically always) to PRG062_86A2

Map_ShowIntro_OK:

	; Mark world (not Zero) as seen
	LDA Map_WVisit1
	ORA WorldIntro_CheckBit,Y
	STA Map_WVisit1
	
Map_ShowIntro_OKWZero:

	; Map_Operation = 0 ... the "World X" intro
	; Used at the beginning of a world, and alternating players
	LDA Inventory_Open
	BNE PRG062_86A2	; If inventory is open, jump to PRG062_86A2

	; Set bank at A000 to page 11
	LDA #11	
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_IntroAttrSave	; Pick up the current attribute info under the box

	LDX #$0E 		; Standard $00 aligned box

	LDA <Horz_Scroll 	; A = Horz_Scroll
	BEQ PRG062_8670	 	; If Horz_Scroll = 0, jump to PRG062_8670

	LDX #$11		; Otherwise, map halfway scroll $80 aligned box
PRG062_8670:

	LDY Player_Current
	LDA Player_Character,Y
	STA <Temp_Var1

	TXA		 	; A = X ($0E/$11)
	ADD <Temp_Var1
	JSR Video_Do_Update	; Do the World X intro box!

	JSR Map_ConfigWorldIntro	; Apply the world number and lives count

	; Push the buffered update
	LDA #$00
	JSR Video_Do_Update	 

	LDX World_Num
	LDY World_BGM,X		; Get BGM index for this world


	LDA #0

	CPX #9
	BNE PRG062_8698		; If we're NOT on World Zero, jump to PRG062_8698

	; Enable inverted music on World Zero
	LDA #$18

PRG062_8698:
	STA Music_InvertEn

	; Not World Zero
	LDA Map_MusicBox_Cnt	
	BEQ PRG062_869F		; If Map_MusicBox_Cnt = 0, jump to PRG062_869F
	LDY #MUS2A_MUSICBOX	 	; Otherwise, play the music box song

PRG062_869F:
	STY Sound_QMusic2	; Play BGM!

PRG062_86A2:
	LDA #$00
	STA Inventory_Open	; Inventory_Open = 0

	LDA #$ef	 	
	STA <Vert_Scroll	; Vert_Scroll = $EF (map always stays at this height)

	LDA #$c0	 	
	STA Update_Select	; Update_Select = $C0 (Normal)

	; Switch bank A000 to page 11
	LDA #11	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000
	JSR Map_DoAnimations	; On page 11

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Switch bank A000 to page 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

WorldMap_Loop:
	JSR GraphicsBuf_Prep_And_WaitVSync	; This is probably just using it to VSync
	JSR Sprite_RAM_Clear	 		; Clear sprites!

	; Switch bank A000 to page 11 
	LDA #11
	STA PAGE_A000	
	JSR PRGROM_Change_A000
	JSR Map_DoAnimations	; On page 11 -- animate world map

	LDA InvFlip_Counter
	BNE PRG062_86F9	 	; If InvFlip_Counter <> 0, jump to PRG062_86F9

	LDA Inventory_Open	
	BEQ PRG062_8715	 	; If Inventory_Open = 0, jump to PRG062_8715

PRG062_86F9:
	; Inventory_Open <> 0 && InvFlip_Counter = 0 ...

	; Switch bank A000 to page 26
	LDA #26	
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Map_DoInventory_And_PoofFX	; Do everything with that inventory bar (On page 26)

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000
	JSR PRGROM_Change_A000	

	;JSR World5_Sky_AddCloudDeco	 ; World 5 sky area gets an extra cloud sprite (strange?)
	JSR WorldMap_UpdateAndDraw	 ; Update and draw map graphics
	JMP WorldMap_Loop	 	; Loop back around...

PRG062_8715:
	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_DoMap	 		; Do the map!

	LDA Map_Operation
	CMP #$02	 
	BLT PRG062_8732	 		; If Map_Operation < 2, jump to PRG062_8732 

	; Map_Operation >= 2...

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR StatusBar_UpdateValues	; Update status bar

PRG062_8732:
	LDY Map_Operation
	CPY #$0d	 
	BNE PRG062_873F	 		; If Map_Operation <> $D (Normal), jump to PRG062_873F

	LDA <Map_WarpWind_FX
	AND #$7F	; Bit 7 specifies WZero unlock sequence, so don't use it
	CMP #$04
	BEQ PRG062_874F	 		; If Map_WarpWind_FX = 4 (initialize for warp island), jump to PRG062_874F

PRG062_873F:
	; Map_WarpWind_FX <> 3 or Map_Operation <> $D...

	CPY #$04
	BEQ PRG062_874F	 		; If Map_Operation <> $4, jump to PRG010_874F

	CPY #$0f	 
	BLT WorldMap_Loop	 	; If Map_Operation < $F (edge scroll), jump to WorldMap_Loop

	; Map_Operation >= $F...

	LDX Player_Current	
	LDA Map_Player_SkidBack,X
	BEQ PRG062_87BD			; If Map_Player_SkidBack = 0, jump to PRG062_87BD

PRG062_874F:
	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeOut	 		; Fade out
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Likely just using this for VSync

	; Disable the display
	LDA #$00	 
	STA <PPU_CTL2_Copy
	STA PPU_CTL2	 

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	LDA <Map_WarpWind_FX
	BNE PRG062_8772	 		; If Map_WarpWind_FX <> 0 (warp wind is active), jump to PRG062_8772

	LDA Map_Operation
	CMP #$04	 
	BNE PRG062_8775	 		; If Map_Operation <> 4, jump to PRG062_8775

PRG062_8772:
	JMP PRG062_857E			; Jump to PRG062_857E (partial loop back)

PRG062_8775:
	; Map_Operation <> 4

	LDX Player_Current

	; Store current map scroll positions and Player positions 
	; into the respective backup variables...
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X

	LDA <Horz_Scroll_Hi	
	STA Map_Prev_XHi,X

	LDA <World_Map_Y,X
	STA Map_Entered_Y,X

	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X

	LDA <World_Map_X,X
	STA Map_Entered_X,X

	;LDA <Map_UnusedPlayerVal2,X
	LDA World_Num	; SB: Now a world backup!
	STA Map_Previous_World,X	

	LDA #$00
	STA Map_Player_SkidBack,X

PRG062_879B:
	; Switch to the other Player (if any!)
	INX
	STX Player_Current
	CPX Total_Players
	BNE PRG062_87A9	 	; If not at the total Player count, jump to PRG062_87A9

	LDA #$00	 
	STA Player_Current	; Otherwise, back to 0 (basically keeps at 0 for 1P or goes 0, 1, 0, 1...)
PRG062_87A9:

	LDA Player_Current
	TAX		 
	LDA Player_Lives,X	
	BMI PRG062_879B	 	; If Player's lives are negative (dead!), jump to PRG062_879B (makes assumption at least ONE Player is alive...)

	LDA #$00
	STA Map_Operation		; Map_Operation = 0
	STA Map_PlayerLost2PVs	; Clear Map_PlayerLost2PVs

	JSR Map_UpdateStarCoins_AtPlayer

	JMP PRG062_84D7	 	; Jump to PRG062_84D7 (partial loop)

PRG062_87BD:
	; Map_Operation >= $F...

	JSR GraphicsBuf_Prep_And_WaitVSync	; Vertical sync

	; Copy the Player's positions into respective backup variables
	LDX Player_Current
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X
	LDA <Horz_Scroll_Hi
	STA Map_Prev_XHi,X
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X	
	STA Map_Entered_X,X	
	;LDA <Map_UnusedPlayerVal2,X	
	LDA World_Num	; SB: Now a world backup!
	STA Map_Previous_World,X	

	LDA #$00
	STA <Map_EnterLevelFX		; Map_EnterLevelFX = 0
	STA Map_EntTran_BorderLoop	; Map_EntTran_BorderLoop = 0
	STA Update_Select		; Update_Select = 0
	STA World_EnterState		; World_EnterState = 0
 
	JSR Map_Clear_EntTranMem	; Clear entrance transition memory

	; Set initial "high" parts of VRAM addresses
	LDA #$28	 
	STA Map_EntTran_BVAddrH	 	; top VRAM high
	STA Map_EntTran_BVAddrH+2	; left VRAM high
	STA Map_EntTran_BVAddrH+3	; right VRAM high

	LDA #$2a	 
	STA Map_EntTran_BVAddrH+1	; bottom VRAM high

	LDA #$00	 
	STA Map_EntTran_BVAddrL	 	; top VRAM low
	STA Map_EntTran_BVAddrL+3	; right VRAM low

	LDA #$1f	 
	STA Map_EntTran_BVAddrL+2	; left VRAM low
	STA Map_EntTran_TBCnt	 	; Map_EntTran_TBCnt also happens to be $1f

	LDA #$e0	 
	STA Map_EntTran_BVAddrL+1	; bottom VRAM low

	LDA #$17	 
	STA Map_EntTran_LRCnt	 	; Map_EntTran_LRCnt = $17


	; Top 0, bottom 1, right 2, left 3
	LDX #$03	 	; X = 3
PRG062_881D:
	LDA <Scroll_ColumnL
	AND #$0f
	ASL A	
	ADD Map_EntTran_BVAddrL,X	; adds 2 per column scrolled
	STA Map_EntTran_BVAddrL,X
	DEX		 	; X--
	BPL PRG062_881D	 	; While X >= 0, loop!

	LDA Map_EntTran_BVAddrL+2
	AND #$1f	 
	STA Map_EntTran_BVAddrL+2

	LDA #$30
	STA Map_EntTran_Cnt	 ; Map_EntTran_Cnt = $30

	LDA #SND_MAPENTERLEVEL
	STA Sound_QMap	 ; Play "enter level" sound effect!

	; Loop until V-Blank is not occurring
PRG062_883E:
	LDA PPU_STAT
	AND #$80	
	BNE PRG062_883E	

	LDA #%10101000		; sprites on PT2, 8x16 sprites, generate V-Blank NMIs
	STA PPU_CTL1	 
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	; The actual border rendering occurs in the interrupt's "Update_Select" routine
	; which calls "Map_EnterLevel_Effect" in PRG026
PRG062_884C:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Just VSyncs

	LDA #$01
	STA <Map_EnterLevelFX	; Map_EnterLevelFX = 1

	LDX Map_EntTran_BorderLoop	; Get current border loop counter (0-3: Top 0, bottom 1, right 2, left 3)
	TXA
	AND #$02
	BEQ PRG062_887F		 	; If Map_EntTran_BorderLoop & 2 = 0, jump to PRG062_887F (means jump if doing top/bottom)

	; Left/right edge sprite removal check...

	; This calculates the border's relative X position -> Temp_Var1
	LDA Map_EntTran_BVAddrL,X
	ASL A
	ASL A
	ASL A
	SUB <Horz_Scroll
	STA <Temp_Var1		; Temp_Var1 = (Map_EntTran_BVAddrL[X] << 3) - Horz_Scroll

	; This goes through all system sprites and removes them as the encroaching black border hits them
	LDX #$00	 	; X = 0
PRG062_8868:
	LDA Sprite_RAM+$03,X	; Get this sprite's X coordinate
	AND #$f8	 	; Only considering its nearest-8 position (aligned to the pattern-based border)
	CMP <Temp_Var1		
	BNE PRG062_8876	 	; If this sprite hasn't been touched yet, jump to PRG062_8876

	LDA #$f8	 
	STA Sprite_RAM+$00,X	; Set this sprite's Y to $F8 (make invisible)

PRG062_8876:
	DEX
	DEX
	DEX
	DEX		 	; X -= 4
	BNE PRG062_8868	 	; While X <> 0, loop!

	JMP PRG062_88A5	 	; Jump to PRG062_88A5

PRG062_887F:
	; Top/bottom edge sprite removal check...

	; This calculates the border's relative Y position -> Temp_Var1
	LDA Map_EntTran_BVAddrL,X
	AND #$c0	
	STA <Temp_Var1
	LDA Map_EntTran_BVAddrH,X
	LSR A		
	ROR <Temp_Var1	
	LSR A		
	ROR <Temp_Var1	

	LDX #$00	 	; X = 0
PRG062_8891:
	LDA Sprite_RAM+$00,X	; Get this sprite's Y position
	AND #$f0	 	; Only check its nearest-16 position (16 because of 16 pixel tall sprites)
	CMP <Temp_Var1
	BNE PRG062_889F	 	; If this sprite hasn't been touched yet, jump to PRG062_889F

	LDA #$f8	 
	STA Sprite_RAM+$00,X	; Set this sprite's Y to $F8 (make invisible)

PRG062_889F:
	DEX
	DEX
	DEX
	DEX		 	; X -= 4
	BNE PRG062_8891	 	; While X <> 0, loop!

PRG062_88A5:
	DEC Map_EntTran_Cnt	; Map_EntTran_Cnt--
	BMI PRG062_88AD	 	; If Map_EntTran_Cnt < 0, jump to PRG062_88AD

	JMP PRG062_884C	 	; Jump to PRG062_884C (loop)

PRG062_88AD:
	; Completed the entrance transition...

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites

	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Waiting for vertical sync

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!
	STA PPU_CTL1	 	

	; Disable display
	LDA #$00
	STA PPU_CTL2

	LDA #$04	
	STA Level_TimerMSD	; Level_TimerMSD = 4

PRG062_88C8:

	; Clearing scroll variables
	LDA #$00
	STA <Horz_Scroll_Hi
	STA <Horz_Scroll
	STA <Vert_Scroll_Hi
	STA <Vert_Scroll
	STA <Scroll_ColumnR
	STA <Scroll_ColumnL
	STA <Scroll_LastDir
	STA Coins_ThisLevel	 ; Clear "coins earned this level" counter
	STA Map_BonusCoinsReqd	 ; Clear the "coins required for bonus"
	STA Map_BonusType	 ; Clear the "bonus type"

	STA <Temp_Var1	; Temp_Var1 = 0

	LDX #$05	
	STX <Temp_Var2	; Temp_Var2 = 5

	; Going to clear memory from $9D to $01
	LDY #$9d	; Y = $9D
PRG062_88E9:
	STA [Temp_Var1],Y	; Clear this byte
	DEY		 	; Y--
	BNE PRG062_88E9	 	; While Y <> 0, loop!

	STA [Temp_Var1],Y	; And address $00 is cleared too (though this is technically unnecessary)

	LDA <Map_Enter2PFlag
	BEQ PRG062_891A	 	; If not entering 2P Vs mode, jump to PRG062_891A

Begin_BattleMode:	; SB
	; 2P Vs mode begin!

	; Level_Tileset = 18 (2P Vs)
	LDA #18
	STA Level_Tileset

	JSR SetPages_ByTileset

	;INC Map_2PVsGame	; Map_2PVsGame++ (play next game style)

	LDA Map_2PVsGame
	;CMP #12
	;BNE PRG062_890B	 ; If Map_2PVsGame <> 12 (overflow), jump to PRG062_890B

	; Otherwise, restart count
	;LDA #$00
	;STA Map_2PVsGame

;PRG062_890B:
	ASL A	; Multiply game style by 2
	TAX	; -> 'X'

	; Load address to battlefield level data
	LDA Vs_Battlefields,X
	STA <Level_LayPtr_AddrL
	LDA Vs_Battlefields+1,X
	STA <Level_LayPtr_AddrH

	JMP PRG062_892A	 ; Jump to PRG062_892A

PRG062_891A:

	; Non-2P Mode begin!
	
	; SB: Ending already set the pointers, so skip Map_PrepareLevel
	LDA Player_RescuePrincess
	BNE PRG062_892A

	; Set bank C000 to page 22 and A000 to page 12
	LDA #22
	STA PAGE_C000
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_Both2

	; The ultimate output is properly configured
	; Level_ObjPtr_AddrL/H and Level_ObjPtrOrig_AddrL/H (object list pointer)
	; Level_LayPtr_AddrL/H and Level_LayPtrH_AddrL/H (tile layout pointer)
	; Level_Tileset
	JSR Map_PrepareLevel	 

PRG062_892A:
	LDA World_Num
	CMP #$08	
	BNE PRG062_893F	 ; If World_Num <> 8 (World 9), jump to PRG062_893F

	; Warp zone special
	LDA #MUS1_STOPMUSIC	 
	STA Sound_QMusic1	; Stop BGM

	; The destination world is fed back out through Map_Warp_PrevWorld
	LDX Player_Current
	LDA Map_Warp_PrevWorld
	STA World_Num	 	; World_Num = Map_Warp_PrevWorld
	STA Map_Previous_World,X
	JMP PRG062_84A0	 	; Jump to PRG062_84A0 (initialize the world map!)

PRG062_893F:
	LDY Level_Tileset	; Y = Level_Tileset
	LDA ClearPattern_ByTileset,Y
	STA ClearPattern	 	; ClearPattern = ClearPattern_ByTileset[Y]

	;CPY #$07	 
	;BNE PRG062_8964	 	; If Level_Tileset <> 7 (Toad House), jump to PRG062_8964

	; Toad House object pointer override!

	; The object set pointer has different meaning for a Toad House!
	;LDA <Level_ObjPtr_AddrL
	;STA THouse_ID		; Toad House ID; not used, would have tracked boxes already opened (multiple visits perhaps??)
	;LDA <Level_ObjPtr_AddrH
	;STA THouse_Treasure	 

	; Force object set at TOADO (Toad and the message object)
	;LDA #LOW(TOADO)
	;STA <Level_ObjPtr_AddrL
	;STA Level_ObjPtrOrig_AddrL	
	;LDA #HIGH(TOADO)
	;STA <Level_ObjPtr_AddrH
	;STA Level_ObjPtrOrig_AddrH	

;PRG062_8964:

	; Clears $7F bytes starting at Level_BlockGrabHitMem ($7E02)
	; Clear Level_BlockGrabHitMem (collected coins and 1-ups memory)
	LDY #$7f	; Y = $7f
	LDA #$00	; A = 0
PRG062_8968:
	STA Level_BlockGrabHitMem,Y
	DEY		 ; Y--
	BPL PRG062_8968	 ; While Y >= 0, loop!

	; Clears $80 bytes starting at Player_XHi ($75, gameplay context)
	LDY #$80	 ; Y = $80
	LDA #$00	 ; A = 0
	STA LevelJctBQ_Flag	 ; LevelJctBQ_Flag = 0 
PRG062_8975: 
	STA Player_XHi,Y
	DEY		 ; Y--
	BNE PRG062_8975	 ; While Y >= 0, loop!

PRG062_897B:
	; Level junctions enter here, to continue with preparation to display!

	LDA #$00	
	STA Vert_Scroll_Off	; Vert_Scroll_Off = 0

	; If Level_Tileset = 16 (Spade game sliding cards) or 17 (N-Spade), jump to PRG062_89AB
	LDA Level_Tileset
	CMP #16
	BEQ PRG062_89AB
	CMP #17
	BEQ PRG062_89AB	

	; Inline clone of "SetPages_ByTileset"
	; Change A000 and C000 pages by Level_Tileset
	LDY Level_Tileset
	LDA PAGE_C000_ByTileset,Y
	STA PAGE_C000	 
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000	 
	JSR PRGROM_Change_Both2

	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BNE LL_NoPCometSkip		; If Purple Comet is not active, jump to LL_NoPCometSkip

	LDY #$08	; Y = 8 (check if we should start on alt for purple comet)
	LDA [Level_LayPtr_AddrL],Y
	AND #LEVEL5_PCOMET_STARTALT
	BEQ LL_NoPCometSkip		; If this level doesn't start on alternate, jump to LL_NoPCometSkip

	; Purple comet active and this level should start on its alternate!
	LDY #$00	 ; Y = 0

	LDA [Level_LayPtr_AddrL],Y
	PHA
	INY
	LDA [Level_LayPtr_AddrL],Y
	PHA
	INY		 

	LDA [Level_LayPtr_AddrL],Y
	PHA
	INY		
	LDA [Level_LayPtr_AddrL],Y
	PHA
	INY		

	LDY #$06	; Y = 6 (get tileset)
	LDA [Level_LayPtr_AddrL],Y
	AND #$0f	
	STA Level_Tileset
	JSR SetPages_ByTileset
	
	PLA 
	STA Level_ObjPtr_AddrH
	PLA
	STA Level_ObjPtr_AddrL

	PLA 
	STA Level_LayPtr_AddrH
	PLA
	STA Level_LayPtr_AddrL

LL_NoPCometSkip:
	
	JSR LevelLoad_ByTileset			; Load the level layout data!
	JSR Sprite_RAM_Clear			; Clear the sprites
	JSR Fill_Tile_AttrTable_ByTileset	; Load tile attribute tiles by the tileset


	; SB: Checkpoint support: Override values for active checkpoint

	; 'X' = offset to LevCP values for this Player
	LDX Player_Current
	LDA LevCP_ByPlayer,X
	TAX

	; We will NOT enforce checkpoints on a junction!
	LDA Level_JctCtl
	BNE LevCP_Done		; If this is a junction, jump to LevCP_Done

	; Compare the Player's last hit checkpoint ID with active level's checkpoint ID
	LDA LevCP_ID,X
	CMP LevCP_ActiveID
	BNE LevCP_NotValidAtLoad	; If there's a mismatch, checkpoint data is invalid, and jump to LevCP_NotValidAtLoad

	; Setup the checkpoint!
	JSR Level_SetupCPStart
	
	JMP LevCP_Done		; Jump to LevCP_Done

LevCP_NotValidAtLoad:

	; Invalidate any old checkpoint ID for this Player
	; (i.e. in case they've entered a different level, so clear old checkpoint)
	LDA #$FF
	STA LevCP_ID,X

LevCP_Done:
	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

PRG062_89AB:
	JSR Reset_PPU_Clear_Nametables2		; Blank display, clear nametables
	JSR Sprite_RAM_Clear	 		; Clear the sprites

	; Select the first bank of BG VROM as specified by Level_BG_Page1_2
	LDY Level_BG_Page1_2
	LDA Level_BG_Pages1,Y
	STA PatTable_BankSel

	LDA Level_BG_Pages2,Y

	LDX Level_PSwitchCnt
	BEQ PRG062_89C4	 	; If P-Switch not active, jump to PRG062_89C4

	LDA #$3e	 	; Otherwise, force override to page $3E

PRG062_89C4:
	STA PatTable_BankSel+1	 ; Select second bank of BG VROM

	LDA Level_Tileset	
	CMP #16
	BEQ PRG062_89D1	 	; If Level_Tileset = 16 (Spade game sliders), jump to PRG062_89D1

	JMP PRG062_8A4E	 	; Otherwise, jump to PRG062_8A4E

	; Offset to LevCP values by Player index
LevCP_ByPlayer:	.byte 0, (LevCP_ID2 - LevCP_ID)

PRG062_89D1:
	; Spade game sliders (Roulette Game)

	; Set pattern banks on sprite side... only really need the border sprites??
	LDY #$20
	STY PatTable_BankSel+2
	INY
	STY PatTable_BankSel+3
	INY
	STY PatTable_BankSel+4
	INY
	STY PatTable_BankSel+5

	; Horizontal mirroring
	LDA #$00
	STA MMC3_MIRROR

	JSR Roulette_DrawShapes	 	; Draw in the Roulette Shapes
	JSR Roulette_DrawBorderSprites	; Draw the sprite borders

	; Render Roulette borders and set attributes
	LDA #$07
	JSR Video_Do_Update

	; Status bar suitable for the horizontal mirroring mode
	LDA #$05
	JSR Video_Do_Update

	; Switch to page 26 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #26		
	STA MMC3_PAGE	 

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	; Push through what's in graphics buffer
	LDA #$00
	JSR Video_Do_Update

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Set scrolling to absolute top
	LDA #$00
	STA <Vert_Scroll

	; Resume Update_Select activity
	STA UpdSel_Disable

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; Setup palette data

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeIn	 ; Fade in palette

	; Enable the Roulette slider raster effect
	LDA #UPDATERASTER_SPADEGAME
	STA Update_Request

	; We actually get hung up here until afer the end of the Roulette
	; game when it has completely faded out due to Update_Request = UPDATERASTER_SPADEGAME
	JSR GraphicsBuf_Prep_And_WaitVSync

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Vertical mirroring
	LDA #$01
	STA MMC3_MIRROR

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Returning to map
	JMP PRG062_8FA1	 ; Jump to PRG062_8FA1

PRG062_8A4E:
	; Not spade game sliders

	CMP #17
	BEQ PRG062_8A55	 ; If Level_Tileset = 17 (N-Spade game), jump to PRG062_8A55
	JMP PRG062_8AE0	 ; Otherwise, jump to PRG062_8AE0

PRG062_8A55:
	; N-Spade Game

	; Load graphics for N-Spade
	LDY #$28
	STY PatTable_BankSel+2
	INY
	STY PatTable_BankSel+3
	INY
	INY
	STY PatTable_BankSel+5
	LDA #$5a
	STA PatTable_BankSel+4

	; Card_Index = $0E (this assignment isn't really used for anything)
	LDA #$0E
	STA Card_Index

	; Temp_Var1 = $20 (VRAM High Address for Clear_Nametable_Short)
	LDA #$20
	STA <Temp_Var1
	JSR Clear_Nametable_Short

	; Generate the candystripe background of the N-Spade game
	LDA #$0d
	JSR Video_Do_Update

PRG062_8A79:
	JSR Card_InitGame	 ; Do this stage of initialization

	LDA <Graphics_Queue
	JSR Video_Do_Update	 ; Push graphics update

	LDA Card_InitState
	CMP #$03
	BNE PRG062_8A79		; While Card_InitState <> 3, loop!

	; Status bar suitable for the card game
	LDA #$05
	JSR Video_Do_Update

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	; Push through what's in graphics buffer
	LDA #$00
	JSR Video_Do_Update

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Set scrolling to absolute top
	LDA #$00
	STA <Vert_Scroll

	; Resume Update_Select activity
	STA UpdSel_Disable

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; Setup palette data

	; Set bank at A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeIn	 ; Fade in palette

PRG062_8AC0:
	JSR GraphicsBuf_Prep_And_WaitVSync	; VSync

	JSR NSpade_DoGame	 ; Run N-Spade game

	JSR StatusBar_UpdateValues	 ; Update status bar

	LDA <Level_ExitToMap
	BEQ PRG062_8AC0	 ; If we're not exiting to map, loop N-Spade game

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Set bank at A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

	JMP PRG062_8FA1	 ; Jump to PRG062_8FA1

PRG062_8AE0:
	CMP #18
	BNE PRG062_8AE7	 ; If Level_Tileset <> 18 (2P Vs), jump to PRG062_8AE7

	JMP Do_2PVsChallenge	 ; Jump Do_2PVsChallenge

PRG062_8AE7:
	; Normal gameplay...

	; Clear Update_Request
	LDA #$00
	STA Update_Request

	; Vertical mirroring
	LDA #$01
	STA MMC3_MIRROR

	LDA #$02	 ; A = 2
	LDX #$c0	 ; X = $C0 (Normal style updating)

	LDY Level_7Vertical
	BEQ PRG062_8B03	 	; If level is NOT a vertical one, jump to PRG062_8B03

	; Level is vertical!

	; Horizontal mirroring
	LDA #$00
	STA MMC3_MIRROR

	LDA #$01	 ; A = 1
	LDX #$80	 ; X = $80 (Vertical style updating)

PRG062_8B03:
	STX Update_Select	; Set Update_Select

	LDX Player_RescuePrincess
	BNE Ending_SkipStatusBar	; SB: Skip status bar for ending sequence (we're putting credits there!)
	LDX Player_FallToKing
	BNE Ending_SkipStatusBar	; SB: Skip status bar for ending sequence (we're putting credits there!)

	JSR Video_Do_Update	; Video update

	; Set bank at A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

Ending_SkipStatusBar:
	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	JSR Scroll_Dirty_Update	 ; Entering level, do dirty update

	LDA Level_Tileset
	CMP #19
	BEQ PRG062_8B6D	 ; If Level_Tileset = 19 (Bonus game intro), jump to PRG062_8B6D

	; Changes pages at A000 and C000 to 26 and 6, respectively
	LDA #6
	STA PAGE_C000
	
	LDA Player_RescuePrincess
	BPL Ending_NotWZEnding
	
	; World Zero ending only: Use bank 25 instead
	LDA #25
	STA PAGE_C000
	
Ending_NotWZEnding:
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_Both2

	JSR LevelLoad_CopyObjectList	 ; Copy in level objects!

	LDX Player_Current
	LDA Player_FallToKing
	BNE PRG062_8B6D	 	; If Player is bound for king, jump to PRG062_8B6D

	LDA Inventory_Open
	BNE PRG062_8B51	 	; If inventory is open (only normally happens at this point in Toad House), jump to PRG062_8B51

	LDA Level_JctCtl
	BNE PRG062_8B51	 	; If we're using a level junction override, jump to PRG062_8B51

	JMP PRG062_8B6D	 	; Otherwise, jump to PRG062_8B6D

PRG062_8B51:


	; Level junction override!  Copy in junction variables as appropriate
	LDA Level_Jct_HS
	STA <Horz_Scroll
	LDA Level_Jct_HSHi
	STA <Horz_Scroll_Hi

	LDA Level_Jct_VS
	STA <Vert_Scroll

	LDA Level_Jct_VSHi
	STA <Vert_Scroll_Hi

	; Junction complete (and inventory is NOT open)
	LDA #$00	 
	STA Inventory_Open
	STA Level_JctCtl

PRG062_8B6D:
	LDX Player_Current

	LDA Player_FallToKing
	BEQ PRG062_8B78	 	; If player is NOT bound for king's room, jump to PRG062_8B78

	JMP PRG062_9009	 ; Jump to PRG062_9009

PRG062_8B78:
	LDA #$00	
	STA Raster_Effect ; Raster_Effect = $00 (Normal status bar)
	STA UpdSel_Disable	; Resume Update_Select activity

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; Setup palette data

	LDA Level_Tileset
	CMP #19
	BNE PRG062_8B9A	 ; If Level_Tileset <> 19 (Bonus game intro), jump to PRG062_8B9A

	; Otherwise, set page @ C000 to 22
	LDA #22
	STA PAGE_C000
	JSR PRGROM_Change_Both2

PRG062_8B9A:
	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeIn	 ; Fade in palette

	; Set page @ A000 as appropriate for this tileset
	LDY Level_Tileset
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000
	JSR PRGROM_Change_A000

;	; This is the init code for the level "boxing out" effect removed in the US release

;	; US VERSION DOES THIS:
;	JMP PRG062_8CB8	 ; Jump to PRG062_8CB8 (skipping code related to the "Boxing out" effect, removed in US version)

;	; Leftover optional code, see below
;	LDA #$00
;	STA <Map_EnterLevelFX		 ; Map_EnterLevelFX = 0

;	; ORIGINAL VERSION DID THIS (addresses relate to original code!):
;;	LDA Level_Tileset
;;	CMP #15
;;	BEQ PRG062_8BC2	 ; If Level_Tileset = 15 (bonus game intro), jump to PRG062_8BC2
;;
;;	LDA Map_UNK713
;;	BEQ PRG062_8BC5	 ; If Map_UNK713 = 0, jump to PRG062_8BC5
;;
;;PRG062_8BC2:
;;	JMP PRG062_8CC9	 ; Jump to PRG062_8CC9
;;
;;PRG062_8BC5:
;;	LDA #$00
;;	STA <Map_EnterLevelFX		 ; Map_EnterLevelFX = 0
;;PRG062_8CC9:

;	JSR Map_Clear_EntTranMem	 ; Clear entrance transition memory

;	LDA #$ff
;	STA Map_EntTran_Temp	 ; Map_EntTran_Temp = $ff

;	LDA Level_7Vertical
;	BEQ PRG062_8BD5	 	; If not a vertical level, jump to PRG062_8BD5

;	; Set address as appropriate for vertical
;	LDY Level_SizeOrig
;	LDA Tile_Mem_AddrVL,Y
;	STA <Map_Tile_AddrL
;	LDA Tile_Mem_AddrVH,Y
;	STA <Map_Tile_AddrH

;	JMP PRG062_8BDF	; Jump to PRG062_8BDF

;PRG062_8BD5: 

;	; First screen is always where non-vertical maps start
;	LDA Tile_Mem_Addr
;	STA <Map_Tile_AddrL
;	LDA Tile_Mem_Addr+1
;	STA <Map_Tile_AddrH

;PRG062_8BDF:
;	LDA #$00	
;	STA Map_EntTran_VLHalf	 ; Map_EntTran_VLHalf = 0

;	LDA <Vert_Scroll
;	BEQ PRG062_8BF4	 	; If Vert_Scroll = 0, jump to PRG062_8BF4

;	; Otherwise, offset initial address by $F0 (15 rows) and
;	; flag we're performing this on the lower vertical
;	LDA <Map_Tile_AddrL
;	ADD #$f0	 
;	STA <Map_Tile_AddrL	; Map_Tile_AddrL += $F0

;	LDA #$01
;	STA Map_EntTran_VLHalf	 ; Map_EntTran_VLHalf = 1

;PRG062_8BF4:
;	LDY #$04	; Y = 4 (search begin)

;PRG062_8BF6:
;	LDA <Vert_Scroll
;	CMP BoxOut_ByVStart,Y
;	BEQ PRG062_8C00
;	DEY		 ; Y--
;	BPL PRG062_8BF6	 ; While Y >= 0, loop

;PRG062_8C00:
;	STY Map_EntTran_InitValIdx ; Store initial value index

;	LDA BoxOut_InitVAddrH,Y	 ; Get initial high part of VRAM address
;	STA Map_EntTran_BVAddrH
;	STA Map_EntTran_BVAddrH+1
;	STA Map_EntTran_BVAddrH+2
;	STA Map_EntTran_BVAddrH+3

;	; Copy in the four low bytes
;	LDA BoxOut_InitVAddrL0,Y
;	STA Map_EntTran_BVAddrL	

;	LDA BoxOut_InitVAddrL2,Y
;	STA Map_EntTran_BVAddrL+2

;	LDA BoxOut_InitVAddrL1,Y
;	STA Map_EntTran_BVAddrL+1

;	LDA BoxOut_InitVAddrL3,Y
;	STA Map_EntTran_BVAddrL+3

;	LDA #$00
;	STA Map_EntTran_BorderLoop	 ; Map_EntTran_BorderLoop = 0

;	LDA #$04
;	STA Map_EntTran_TBCnt	 ; Map_EntTran_TBCnt = 4

;	LDY #$01	
;	STY Map_EntTran_LRCnt	 ; Map_EntTran_LRCnt= 1

;	LDA #$00	 
;	STA Update_Select	; Insist (again!) that Update_Select = 0

;PRG062_8C3E:
;	JSR GraphicsBuf_Prep_And_WaitVSync	; VSync

;	; Set page @ A000 as appropriate by Level_Tileset
;	LDY Level_Tileset
;	LDA PAGE_A000_ByTileset,Y
;	STA PAGE_A000
;	JSR PRGROM_Change_A000

;	LDX Map_EntTran_BorderLoop	 ; X = current border index (0-3: Top 0, bottom 1, right 2, left 3)

;	LDA Map_EntTran_BVAddrH,X	 ; Get high byte of VRAM addres
;	STA Map_EntTran_VAddrH	 	; Store it

;	LDA Map_EntTran_BVAddrL,X	 ; Get low byte of VRAM address
;	STA Map_EntTran_VAddrL	 	; Store it

;	LDA Map_EntTran_BorderLoop	 ; A = current border index (0-3: Top 0, bottom 1, right 2, left 3)
;	AND #$02
;	BNE PRG062_8C74	 		; If not updating top/bottom, jump to PRG062_8C74

;	; top/bottom update...
;	LDX Map_EntTran_TBCnt

;	LDA #$01
;	STA Map_EntTran_VRAMGap	 ; Map_EntTran_VRAMGap = 1

;	LDA Map_EntTran_VAddrL
;	AND #$01
;	BEQ PRG062_8C8C	 ; If on even address, jump to PRG062_8C8C
;	BNE PRG062_8C83	 ; If on odd address, jump to PRG062_8C83

;PRG062_8C74:

;	; left/right update...
;	LDX Map_EntTran_LRCnt

;	LDA #32
;	STA Map_EntTran_VRAMGap	 ; PRG062_8C8C = 32

;	LDA Map_EntTran_VAddrL
;	AND #$20
;	BEQ PRG062_8C8C	 ; If on 32 byte aligned address, jump to PRG062_8C8C

;PRG062_8C83:
;	JSR BoxOut_PutPatternInStrip	 ; Put an 8x8 pattern into the strip
;	JSR BoxOut_SetThisBorderVRAM	 ; Set the VRAM offset for this border
;	DEX		 		; X-- (counter decrement)
;	BMI PRG062_8CAA	 		; If X < 0, jump to PRG062_8CAA

;PRG062_8C8C:
;	JSR BoxOut_PutPatternInStrip	 ; Put an 8x8 pattern into the strip
;	DEX		 		; X-- (counter decrement)
;	BMI PRG062_8CAA	 		; If X < 0, jump to PRG062_8CAA

;	INC <Temp_Var14		 ; Temp_Var14++ (tile pattern layout high, jump to next pattern)

;	LDA Map_EntTran_VRAMGap
;	AND #$01	
;	BEQ PRG062_8C9D	 	; If Map_EntTran_VRAMGap & 1 jump to PRG062_8C9D

;	INC <Temp_Var14		 ; Temp_Var14++ (tile pattern layout high, jump to next pattern)

;PRG062_8C9D:
;	LDA [Temp_Var13],Y	 ; Get 8x8 pattern
;	STA <Scroll_ColorStrip,X	 ; Store into strip

;	JSR BoxOut_SetThisBorderVRAM	; Set border VRAM
;	JSR BoxOut_SetThisBorderVRAM	; Called twice??
;	DEX		 ; X--
;	BPL PRG062_8C8C	 ; While X >= 0, loop!

;PRG062_8CAA:
;	LDA #$02
;	STA <Map_EnterLevelFX	 ; Map_EnterLevelFX = 2 (begin the proper box out effect!)

;	LDA Map_EntTran_Cnt
;	CMP #$34	 
;	BEQ PRG062_8CB8	 ; If Map_EntTran_Cnt = $34, jump to PRG062_8CB8
;	JMP PRG062_8C3E	 ; Otherwise, loop!

;PRG062_8CB8:
;	; End of box-out effect (removed in US version)
	
	; Set page @ A000 as appropriate for Tileset
	LDY Level_Tileset
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA #$00
	STA <Map_EnterLevelFX	 ; Map_EnterLevelFX = 0

	LDX #$c0	 	; X = $C0 (Normal style updating)
	LDA Level_7Vertical	
	BEQ PRG062_8CD1	 	; If not a vertical level, jump to PRG062_8CD1

	LDX #$80	 ; X = $80 (Vertical style updating)

PRG062_8CD1:
	STX Update_Select	 ; Set Update_Select as appropriate

	LDA Level_Tileset
	CMP #19
	BEQ PRG062_8CDE	 ; If Level_Tileset = 19 (bonus game intro), jump to PRG062_8CDE
	
	LDA Player_RescuePrincess
	BEQ NotEnding_JumpMain

	; Load page 24 into A000 and page 25 into C000
	JSR SetEndingPages
	
	LDA Player_RescuePrincess
	BPL Ending_LoopNormal
	
	; World Zero ending
	JMP Ending_LoopWZ
	
Ending_LoopNormal:
	JMP Ending_Loop
	
NotEnding_JumpMain:
	JMP PRG062_8DCB	 ; Jump to PRG062_8DCB

Arena_BattleMode:	.byte 4, 5, 11, 7

PRG062_8CDE:
	; Bonus game intro 

	LDA #$04
	STA BonusText_CharPause	; BonusText_CharPause = $04
	STA Bonus_UnusedFlag	; Bonus_UnusedFlag = $04

	; Set text VRAM pointer to $28C5
	LDA #$28
	STA BonusText_VH
	LDA #$c5
	STA BonusText_VL

	LDA #$2b
	STA ToadTalk_VH
	STA PatTable_BankSel+4	 ; Load host graphics

	LDA #$35
	STA ToadTalk_VL

	; BonusDie_YVel = -$60
	LDA #-$60
	STA <BonusDie_YVel

	; Set the die to Y = $78, X = $78
	LDA #$78
	STA <BonusDie_Y
	STA <BonusDie_X
	
	; Queue the bonus music
	LDA #MUS2A_BONUSGAME
	STA Level_MusicQueue

	; The Bonus Game Loop begins here...
	
BonusGame_Loop:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for VSync

	LDA SndCur_Map
	AND #SND_MAPENTERLEVEL
	BNE PRG062_8D23	 ; If the "entering" sound is still playing, jump to PRG062_8D23

	LDA Level_MusicQueue
	BEQ PRG062_8D23	 ; If nothing is in the music queue, jump to PRG062_8D23

	; Start the queued music
	STA Sound_QMusic2

	; Clear the music queue
	LDA #$00
	STA Level_MusicQueue

PRG062_8D23:
	JSR BonusGame_Do	 ; Run the Bonus Game
	JSR StatusBar_Fill_Score ; Update score

	LDA <Level_ExitToMap
	BEQ BonusGame_Loop	 ; If Level_ExitToMap = 0, loop!!

	; Exiting the Bonus Game loop...

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA Bonus_GameType
	CMP #BONUS_UNUSED_2RETURN
	BNE PRG062_8D4A	 ; If Bonus_GameType <> BONUS_UNUSED_2RETURN (??!), jump to PRG062_8D4A

	; BONUS_UNUSED_2RETURN (??!) only...

	JSR Bonus_Return2_SetMapPos	; Change Player's map position and mark them as having died??

PRG062_8D4A:
	SUB #BONUS_ARENA_KEY1
	CMP #4
	BGE NotBONUS_ARENA_KEY1

BonusArenaKeys:
	TAY
	LDA Arena_BattleMode,Y
	STA Map_2PVsGame

	; If we've already given the prize, don't come back in again :P
	LDA Bonus_DieCnt
	BNE NotBONUS_ARENA_KEY1

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

	LDA #$00	 ; 
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg

	; Stop Update_Select activity temporarily while we initialize
	INC UpdSel_Disable

	; Clears page 0 addresses $00-$FD, excluding $69-$74 (?)
	JSR Page0_SafeClear

	LDA #0
	STA Level_ExitToMap

	JMP Begin_BattleMode

NotBONUS_ARENA_KEY1:
	; BonusText_CPos = 0
	LDA #$00
	STA BonusText_CPos
	STA Bonus_UnusedFlag	 ; Bonus_UnusedFlag = 0

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites

	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for vertical sync

	LDA #$00
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg

	; NOTE: This jumps to PRG062_8DC3, which returns to World Map, if the die is face value 1.
	; Seems like the die face logic for jumping to "Roulette" / "Card" is not implemented.
	LDA Bonus_DieCnt
	BEQ PRG062_8DC3	 ; If Bonus_DieCnt = 0 (Face value 1), jump to PRG062_8DC3

	LDY #$00	 ; Level tileset 0 (World Map)

	LDA Bonus_GameType
	CMP #BONUS_SPADE
	BNE PRG062_8D85	 ; If Bonus_GameType <> BONUS_SPADE, jump to PRG062_8D85

	; Select palettes
	LDA #$01
	STA PalSel_Tile_Colors
	LDA #$09
	STA PalSel_Obj_Colors

	LDY #16		; Level tileset 16 (Spade)

	BNE PRG062_8D95	 ; Jump (technically always) to PRG062_8D95

PRG062_8D85:
	CMP #BONUS_NSPADE
	BNE PRG062_8D95	 ; If Bonus_GameType <> BONUS_NSPADE, jump to PRG062_8D95

	; Select palettes
	LDA #$02
	STA PalSel_Tile_Colors
	LDA #$0a
	STA PalSel_Obj_Colors

	LDY #17		; Level tileset 17 (N-Spade)

PRG062_8D95:
	STY Level_Tileset	; Update Level_Tileset
	STY Level_BG_Page1_2	; Use proper BG patterns

	CPY #$00
	BEQ PRG062_8DC3	 ; If tileset = 0 (exit back to world map :(), jump to PRG062_8DC3


	; About to enter Spade / N-Spade game!

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	; A little cleanup loop...

	; Clears page 0 addresses $00-$FD, excluding $69-$74 (?)
	JSR Page0_SafeClear

	; Clears memory $0400-$04CF (mainly Bonus game cleanup)
	LDY #$cf	 ; Y = $CF
PRG062_8DB8:
	STA Roulette_Pos,Y	; Clear this byte

	DEY		 ; Y--
	CPY #$ff
	BNE PRG062_8DB8	 ; If Y <> $FF (underflow), loop!

	JMP PRG062_897B	 ; Jump to PRG062_897B

PRG062_8DC3:

	; Exiting to world map...

	; Bonus_DieCnt = 0
	LDA #$00
	STA Bonus_DieCnt

	JMP PRG062_8FA8	; Jump to PRG062_8FA8 (proceed back to World Map)

Page0_SafeClear:	; SB: Used to be inline, broke out for reuse
	; Clears page 0 addresses $00-$FD, excluding $69-$74 (?)

	LDY #$fd	 ; Y = $FD
	LDA #$00	 ; A = 0
PRG062_BDA6:
	STA Temp_Var1,Y	 ; Clear this byte

PRG062_BDA9:
	DEY		 ; Y--

	CPY #World_Map_Y
	BGE PRG062_8DB2	 ; If Y >= World_Map_Y, jump to PRG062_8DB2

	; Range between $69-$74 is not cleared ... mainly protecting sound engine I think

	CPY #Video_Upd_AddrL
	BGE PRG062_BDA9	 ; If Y >= Video_Upd_AddrL, jump to PRG062_BDA9
PRG062_8DB2: 
	CPY #$ff
	BNE PRG062_BDA6	 ; If Y <> $FF (underflow), loop!

	RTS


LevelScroll_Set_Ranges:
	LDY <Scroll_LastDir	; Y = Scroll_LastDir

	LDA Level_7Vertical
	BEQ PRG062_8EC3	 	; If level is NOT vertical, jump to PRG062_8EC3

	; Forms a value of current "scroll row" in upper 4 bits
	; and "current screen" in lower 4 bits -> Scroll_Temp
	LDA <Vert_Scroll
	AND #$f0	 
	ORA <Vert_Scroll_Hi
	STA <Scroll_Temp

	JMP PRG062_8EC9	 	; Jump to PRG062_8EC9

PRG062_8EC3:
	LDA <Horz_Scroll
	STA <Scroll_Temp	; Scroll_Temp = Horz_Scroll
	LDA <Horz_Scroll_Hi	; A = Horz_Scroll_Hi

PRG062_8EC9:
	JMP Scroll_Update_Ranges



PRG062_8DCB:

	; LEVEL MAIN LOOP BEGIN!

Level_MainLoop:
	JSR GraphicsBuf_Prep_And_WaitVSync

	LDA SndCur_Map
	AND #$04	
	BNE PRG062_8DF4	; If enter level sound is still playing, jump to PRG062_8DF4

	LDA Level_MusicQueue
	BEQ PRG062_8DF4	 	; If Music Queue is empty, jump to PRG062_8DF4

	CMP SndCur_Music2
	BEQ PRG062_8DEF	 	; If we're queueing the BGM already playing, jump to PRG062_8DEF (don't re-queue)

	STA Sound_QMusic2	 ; Queue the song that's waiting in Level_MusicQueue

PRG062_8DEF:
	LDA #$00
	STA Level_MusicQueue	 ; Queue is emptied

PRG062_8DF4:


	JSR Level_DoAnimations

	; SB: Don't have this outer system handle pressing START after
	; pause anymore so I can handle it in the pause menu instead...
	LDA Level_PauseFlag
	BNE Game_ContinuePause

	LDA <Player_IsDying
	BNE PRG062_8EAD

	; Game is not paused...
	LDX Player_Current
	LDA <Controller1Press,X
	AND #PAD_START
	BEQ PRG062_8EAD	 ; If Player is NOT pressing START, jump to PRG062_8EAD

	; Game is pausing!
	LDX #PAUSE_STOPMUSIC	 ; for Sound_QPause, pause sound
	STX Sound_QPause ; Set appropriately

	; Set pause flag
	LDA #1
	STA Level_PauseFlag
  
  	LDA #0
	STA Level_PauseSelect
	
	; Clearing start so it's not immediately handled
	LDX Player_Current
	LDA <Controller1Press,X
	AND #~PAD_START
	STA <Controller1Press,X

Game_ContinuePause:
	JSR Game_DoPause

	; Updates palette
	LDA #$06	 
	STA <Graphics_Queue

	; Nothing else to do while paused; loop!
	JMP Level_MainLoop

Game_DoPause:
	JMP_THUNKC 30, Game_DoPause30


PRG062_8EAD:
	; Not paused!

	LDA <Player_IsDying
	BNE PRG062_8ECC	 	; If Player is dying, jump to PRG062_8ECC

	JSR LevelScroll_Set_Ranges

PRG062_8ECC:
	LDA Level_JctCtl	 
	BEQ PRG062_8EE7	 	; If not junctioning, jump to PRG062_8EE7

	; Level junction!

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JMP HandleLevelJunction	; Handle the junction!

PRG062_8EE7:
	; Not junctioning...

	JSR Scroll_Update

	LDA #$00
	STA PAGE_C000	 ; Load page 0 @ C000

	LDA #$00
	STA Level_ScrollDiffH	 ; Level_ScrollDiffH = 0
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = 0

	LDA #$08	 
	STA PAGE_A000	 ; Load page 8 @ A000

	; Change both A000/C000 pages!
	JSR PRGROM_Change_Both2

	JSR Player_DoGameplay	 ; Does just about everything that makes the Player in gameplay mode!

	LDA <Player_IsDying
	CMP #$03
	BEQ PRG062_8F31	 ; If dead due to TIME UP, jump to PRG062_8F31

	; Load page 0 @ C000
	LDA #$00
	STA PAGE_C000
	JSR PRGROM_Change_Both2	 

	JSR Objects_HandleScrollAndUpdate

	; Load page 7 @ A000
	LDY #$07
	STY PAGE_A000
	JSR PRGROM_Change_A000

	JSR Scores_GiveAndDraw	 ; Give point awards and draw score sprites


	; Color rotation effects, lava, donut lifts, arrow platforms,
	; brick busts, water/waterfall visual effects, bubbles, splashes,
	; pop-up coins, Special Objects, Cannon Fires, Player Projectiles,
	; and, last but not least (well, maybe least), "shell kill flashes"!
	JSR Gameplay_UpdateAndDrawMisc

	LDA Level_HAutoScroll
	BEQ PRG062_8F31	 ; If Auto Horizontal Scrolling is NOT active, jump to PRG062_8F31

	; Load page 9 @ A000
	LDA #$09
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR AutoScroll_Do	 ; Perform auto scroll, if any

PRG062_8F31:
	LDA <Level_ExitToMap
	BEQ PRG062_8F42	 ; If Level_ExitToMap flag is not set, jump to PRG062_8F42

	LDX Player_Current	 ; X = Player_Current

	; Transfer Player's current power up to the World Map counterpart
	LDA <Player_Suit
	STA World_Map_Power,X

	; Level_GetWandState = 0
	LDA #$00
	STA Level_GetWandState

PRG062_8F42:

	; Load page 29 @ C000
	LDA #29
	STA PAGE_C000
	JSR PRGROM_Change_C000

	JSR BlockChange_Do	 ; Do Block Change event, if necessary

	; Load page 0 @ C000
	LDA #$00
	STA PAGE_C000
	JSR PRGROM_Change_C000

	; If scroll updates need to be committed, jump to PRG062_8F80 
	LDA Scroll_ToVRAMHi
	BNE PRG062_8F80
	LDA Scroll_ToVRAMHA
	BNE PRG062_8F80

	; No scroll updates need committed...

	LDA Level_SkipStatusBarUpd
	BNE PRG062_8F80	 ; If requesting we skip the status bar updates for this frame, jump to PRG062_8F80

	LDA <Graphics_Queue
	BNE PRG062_8F80	 ; If we have a video update to do, skip the status bar updates for this frame, jump to PRG062_8F80

	; Switch bank A000 to page 26
	LDA #26	
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA InvFlip_Counter
	BNE PRG062_8F7D	 ; If InvFlip_Counter <> 0 (flipping open Inventory), jump to PRG062_8F7D

	JSR StatusBar_UpdateValues	; Just update values on the status bar

	LDA Inventory_Open
	BEQ PRG062_8F85	 ; If Inventory is not open, jump to PRG062_8F85

PRG062_8F7D:
	JSR Map_DoInventory_And_PoofFX	; Do everything with that inventory bar (On page 26)

PRG062_8F80:

	; StatusBar_UpdFl = 0 (we just updated it)
	LDA #$00
	STA StatusBar_UpdFl

PRG062_8F85:

	; Level_SkipStatusBarUpd = 0 (only skip updating for one frame)
	LDA #$00
	STA Level_SkipStatusBarUpd

	LDA <Level_ExitToMap
	BEQ PRG062_9006	 ; If not exiting to map, jump to PRG062_9006 (Level_MainLoop)

	LDX Player_Current	 ; X = Player_Current

	; Map_Unused749 = 1 (just set here, never read back)
	LDA #$01
	STA Map_Unused749,X

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

PRG062_8FA1:
	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for VSync

PRG062_8FA8:
	; World_EnterState = 0
	LDA #$00
	STA World_EnterState

	; Disable the display
	STA <PPU_CTL2_Copy
	STA PPU_CTL2	 

PRG062_8FB2:
	LDA #$01	 
	STA MMC3_MIRROR	 ; Set vertical mirroring

	LDX Player_Current	 ; X = LDX Player_Current

	LDA Player_FallToKing
	BEQ PRG062_8FCA	 ; If not falling to the King's room, jump to PRG062_8FCA

	; Exiting to King's room...

	LDA Map_ReturnStatus
	BNE PRG062_8FCA	 ; If Player died, jump to PRG062_8FCA

	; Player is alive...

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	JMP PRG062_88C8	 ; Jump to PRG062_88C8

PRG062_8FCA:
	; Clear $06FF - $0000, excluding $01xx
	LDY #$06
	JSR Clear_RAM_thru_ZeroPage

	; Vert_Scroll_Off = 0
	LDA #$00
	STA Vert_Scroll_Off

	; Stop the music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	LDA Map_ReturnStatus
	BNE PRG062_8FFC	 ; If Player died, jump to PRG062_8FFC

	LDA Player_RescuePrincess
	BEQ PRG062_8FFC	 ; If not rescuing the Princess, jump to PRG062_8FFC

	; Load page 24 into A000 and page 25 into C000
	JSR SetEndingPages

	LDA #%10101000
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA #$20
	STA Update_Select	 ; Update_Select = $20 (Title Screen... or ending in this case)

	JMP Rescue_Princess	 ; Do the Princess Rescue sequence!!

SetEndingPages:
	; Load page 24 into A000 and page 25 into C000
	LDA #25
	STA PAGE_C000
	LDA #24
	STA PAGE_A000
	JMP PRGROM_Change_Both2


PRG062_8FFC:

	; Player died or not rescuing the princess...

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!
	STA PPU_CTL1	 	

	JMP PRG062_9097	 	; Jump to PRG062_9097

PRG062_9006:
	JMP Level_MainLoop	; Gameplay loop!

PRG062_9009:
	; Player is falling into king's room...

	LDA #$c0
	STA Update_Select	; Update_Select = $C0 (Normal)

	LDA #$00
	STA Raster_Effect	; Raster_Effect = $00 (Normal status bar)

	LDA #$00
	STA World_EnterState	; World_EnterState = 0
	STA <Level_ExitToMap	; Level_ExitToMap = 0 (not going to exit to map)

	; Set page @ C000 to 10
	LDA #10
	STA PAGE_C000
	JSR PRGROM_Change_C000

	; Set page @ A000 to 11
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; Restore Player's map position first so we can do the next step...
	JSR Map_RestorePlayerPos
	
	; Need to mark level complete on map
	JSR Map_MarkLevelComplete

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR EndWorldLetter_GenerateText	; Generate the text for the end-of-world letter

	; SB: Set low scroll
	LDA #$EF
	STA <Vert_Scroll

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData	 ; Setup palette data

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in

	; Load font graphics
	LDA #$5e
	STA PatTable_BankSel+1

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

PRG062_904D:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; VSync

	JSR CineKing_DoWandReturn	 ; Do the returned wand scene!

	LDA <Level_ExitToMap
	BEQ PRG062_904D		; While Level_ExitToMap = 0, loop

	; Clear $06FF - $0000, excluding $01xx
	LDY #$06
	JSR Clear_RAM_thru_ZeroPage

	; Clear some relevant Player values
	LDX Total_Players
	DEX		 ; X = Total_Players - 1
	LDA #$00	 ; Clear value
PRG062_9062:
	STA Player_FallToKing
	STA Map_ReturnStatus
	
	; SB: Don't want to clear these here!  Messes up the 2P unique world positioning!
	;STA Map_Prev_XOff,X
	;STA Map_Prev_XHi,X

	DEX		 ; X--
	BPL PRG062_9062	 ; While X >= 0, loop

	LDX Player_Current	 ; X = current Player index

	LDA #(Inventory_Score - Inventory_Items)	; Mario's score

	CPX #$00
	BEQ PRG062_907D	 ; If Player is Mario, jump to PRG062_907D
	ADD #(Inventory_Score2 - Inventory_Score)	; offset to Luigi's score
PRG062_907D:
	TAY		 ; Y = offset to score

	LDX #$00	 ; X = 0
PRG062_9080:
	LDA Player_Score,X
	STA Inventory_Items,Y
	INY		 ; Y++ (next byte of Inventory score)
	INX		 ; X++ (next byte of Player's score)
	CPX #$03
	BNE PRG062_9080	 ; If X <> 3, jump to PRG062_9080

	; Stop any music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	LDA World_Num
	CMP #9
	BEQ PRG062_9097		; There's nothing after World Zero!

	LDX Player_Current
	INC World_Num	 ; Go to next world!
	INC Map_Previous_World,X

	JMP PRG062_84A0	 	; Jump to PRG062_84A0 (initialize the world map!)

PRG062_9097:

	; Exiting to map somehow

	LDA #$c0
	STA Update_Select	; Update_Select = $C0 (Normal)

	LDA #$00
	STA Raster_Effect	; Raster_Effect = $00 (Normal status bar)


	; Need to transfer Player's "gameplay score" to their "inventory" score storage...

	LDX Player_Current	; X = Player_Current

	LDA #(Inventory_Score - Inventory_Items)	; Offset to Mario's Score

	CPX #$00
	BEQ PRG062_90AD	 ; If Player is Mario, jump to PRG062_90AD

	ADD #(Inventory_Score2 - Inventory_Score)	; Offset to Luigi's Score

PRG062_90AD:
	TAY		 ; -> 'Y'

	LDX #$00	 ; X = 0

PRG062_90B0:
	LDA Player_Score,X	 ; Get this byte of score
	STA Inventory_Items,Y	 ; Transfer into Mario/Luigi's specific score storage

	INY		 ; Y++ (next score storage byte)
	INX		 ; X++ (next gameplay score byte)

	CPX #$03
	BNE PRG062_90B0	 ; While X <> 3, loop!

	LDA Map_MusicBox_Cnt
	BEQ PRG062_90C4	 ; If Map_MusicBox_Cnt = 0, jump to PRG062_90C4

	DEC Map_MusicBox_Cnt	 ; Otherwise, one less turn with music box...

PRG062_90C4:
	LDY #$06	 ; Y = 6

	LDA Map_ReturnStatus
	BNE PRG062_910C	 ; If Player died, jump to PRG062_910C

	; Player did not die...

	; Toad House and bonuses jump to PRG062_9128
	LDA Level_Tileset
	CMP #16
	BGE PRG062_9128	 ; If Level_Tileset >= 16 (some kind of Bonus Game), jump to PRG062_9128
	;CMP #$07
	;BEQ PRG062_9128	 ; If Level_Tileset = 7 (Toad House), jump to PRG062_9128

	; Typical levels go here...

	LDX Player_Current	 ; X = Player_Current

	; Set bonus appearance coordinates at your last valid location!
	LDA Map_Previous_Y,X
	STA Map_BonusAppY
	LDA Map_Previous_XHi,X
	STA Map_BonusAppXHi
	LDA Map_Previous_X,X
	STA Map_BonusAppX

	LDA Map_Entered_Y,X
	STA Map_Previous_Y,X

	LDA Map_Entered_XHi,X
	STA Map_Previous_XHi,X

	LDA Map_Entered_X,X
	STA Map_Previous_X,X

	LDA Map_Prev_XOff,X
	STA Map_Prev_XOff2,X

	LDA Map_Prev_XHi,X
	STA Map_Prev_XHi2,X

	JMP PRG062_9128	 ; Jump to PRG062_9128

PRG062_910C:

	; Player returns to map dead

	;LDY #$02	 ; Y = 2 (Will be the Map_Operation value)
	LDY #$0B	; Y = $B (SB: No more skidding!)

	; SB: Delaying this a bit so the marching logic can see you died
	; Map_ReturnStatus = 0
	;LDA #$00
	;STA Map_ReturnStatus

	LDX Player_Current	 ; X = Player_Current

	; SB: No more skidding!
	; Skid backward
	;LDA #$01
	;STA Map_Player_SkidBack,X

	LDA Map_PlayerLost2PVs
	BNE PRG062_9128	 ; If Map_PlayerLost2PVs is set, jump to PRG062_9128

	DEC Player_Lives,X	; One less life for the Player...
	
	; SB: Disabling map based game over
	;BMI PRG062_9133	 	; If fell below zero, GAMEOVER!; jump to PRG062_9133

PRG062_9128:

	; SB: Clear Map_PlayerLost2PVs
	LDA #0
	STA Map_PlayerLost2PVs

	; Stop any music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	STY Map_Operation	 ; Map_Operation = 2
	JMP PRG062_84D7	 	; Jump to PRG062_84D7

	; SB: Broken into its own function for reuse
Map_RestorePlayerPos:
	; Set both Players to their previous map values
	LDX Total_Players
	DEX		 ; X = Total_Players - 1

PRG062_9185:
	LDA Map_Entered_Y,X
	STA <World_Map_Y,X
	LDA Map_Entered_XHi,X
	STA <World_Map_XHi,X
	LDA Map_Entered_X,X
	STA <World_Map_X,X


	; Set Player's previous travel direction
	LDA Map_Previous_Dir,X
	STA <World_Map_Dir,X

	DEX		 ; X--
	BPL PRG062_9185	; While X >= 0, loop!

	LDX Player_Current
	LDA Map_Previous_World,X
	STA World_Num	; SB: Now a world backup!

	RTS

PRG062_9133:

	; GAME OVER!!

	; Set Player as twirling (in case they Continue...)
	LDA #$01	 
	STA World_Map_Twirl,X

	; Init map vars
	LDA #$00
	STA Level_Tileset
	STA <Map_EnterLevelFX
	STA <Map_WarpWind_FX
	STA Map_Intro_Tick

	; Map_GameOver_CursorY = $60
	LDA #$60
	STA Map_GameOver_CursorY

PRG062_9149:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	;LDA World_EnterState
	;BNE PRG062_9163	 ; If World_EnterState <> 0, jump to PRG062_9163

	; Otherwise, gotta player the game over music!
	;LDA #MUS1_GAMEOVER
	;STA Sound_QMusic1

;PRG062_9163:

	; Load up graphics
	LDA #$14
	STA PatTable_BankSel
	LDA #$16
	STA PatTable_BankSel+1
	LDX #$20
	STX PatTable_BankSel+2
	INX
	STX PatTable_BankSel+3
	INX
	STX PatTable_BankSel+4
	INX
	STX PatTable_BankSel+5
	JSR SetPages_ByTileset

	; Set both Players to their previous map values
	JSR Map_RestorePlayerPos

	JSR Scroll_Map_SpriteBorder	 ; Keep that map border going!

	; Set page @ A000 to 12
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_A000
	
	JSR Map_Reload_with_Completions	 ; Load map and set already completed levels

	LDX Player_Current	 ; X = Player_Current

	; Set Player's previous movement direction
	LDA Map_Previous_Dir,X
	STA <World_Map_Dir,X

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDY #$00	 ; Y = 0

	LDA World_Num
	CMP #$07
	BNE PRG062_91D1	 ; If World_Num <> 7 (World 8), jump to PRG062_91D1

	; World 8 only...

	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_XHi,X
	CMP #$02
	BNE PRG062_91D1	 ; If Player is not on the "dark" part of World 8, jump to PRG062_91D1

	INY		 ; Y = 1 (enable the World 8 darkness)

PRG062_91D1:
	STY World_8_Dark	 ; Set World_8_Dark appropriately

	LDY Player_Current	 ; Y = Player_Current

	; Scroll updates
	LDA Map_Prev_XOff,Y
	STA <Scroll_Temp
	LDA Map_Prev_XHi,Y
	JSR Scroll_Update_Ranges

	LDA <Scroll_ColumnL
	STA <Scroll_ColumnR

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

	; This (re)draws the status bar
	LDA #$02
	JSR Video_Do_Update

	; Set page @ A000 to 26
	LDA #26		
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	JSR Scroll_Dirty_Update 	; Do a full draw of the map tiles

	LDA World_8_Dark
	BEQ PRG062_9214	 	; If World_8_Dark = 0 (not doing the effect), jump to PRG062_9214

	JSR Map_W8DarknessFill	; Fill in the entire screen with black

PRG062_9214:

	LDY Player_Current	 ; Y =  Player_Current

	LDA Map_Prev_XOff,Y
	STA <Horz_Scroll
	STA <Scroll_Temp
	LDA Map_Prev_XHi,Y
	STA <Horz_Scroll_Hi
	JSR Scroll_Update_Ranges

PRG062_9226:
	JSR Map_DrawAndPan	 ; Draw and pan map as necessary

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	LDA Map_DrawPanState
	BNE PRG062_9226	 	; If some kind of map drawing/panning activity is occurring, loop around

	LDA World_EnterState
	BNE PRG062_9257	 ; If World_EnterState <> 0, jump to PRG062_9257

	; Set page @ A000 to 11
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_IntroAttrSave	; Pick up the current attribute info under the box

	LDX #$12 		; X = $12 (standard $00 aligned GAME OVER box)

	LDA <Horz_Scroll 	; A = Horz_Scroll
	BEQ PRG062_924B	 	; If Horz_Scroll = 0, jump to PRG062_924B

	LDX #$13		; Otherwise, X = $13 (map halfway scroll $80 aligned GAME OVER box)

PRG062_924B:
	TXA		 ; A = X
	JSR Video_Do_Update	 ; Draw up the Game Over! box

	JSR GameOver_PatchPlayerName	 ; Add MARIO/LUIGI to gameover box

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

PRG062_9257:
	LDA #$ef	 	
	STA <Vert_Scroll	; Vert_Scroll = $EF (map always stays at this height)

	LDA #$c0	 	
	STA Update_Select	; Update_Select = $C0 (Normal)

	; Switch bank A000 to page 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

PRG062_927E:
	JSR GraphicsBuf_Prep_And_WaitVSync	; This is probably just using it to VSync
	JSR Sprite_RAM_Clear	 		; Clear sprites!
	JSR GameOver_Loop	 		; Do Gameover stuff
	;JSR World5_Sky_AddCloudDeco	 	; World 5 sky area gets an extra cloud sprite (strange?)

	LDA GameOver_State

	CMP #$06
	BEQ PRG062_929C	 ; If GameOver_State = 6 (Player aligning to start panel Y), jump to PRG062_929C

	CMP #$09
	BNE PRG062_927E	 ; If GameOver_State <> 9 (Player did not choose to END), jump to PRG062_927E (loop around)

	; Player chose to END...

	LDA Total_Players
	CMP #$01
	BEQ PRG062_92B6	 ; If Total_Players = 1, jump to PRG062_92B6

	; More than 2 Players

PRG062_929C:
	
	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	; Fade out

	LDA GameOver_State
	CMP #$09
	BEQ PRG062_92B6	 ; If GameOver_State = 9 (Player chose to END), jump to PRG062_92B6

	JMP PRG062_9149	 ; Jump to PRG062_9149

PRG062_92B6:

	LDA #$00
	STA World_EnterState	 ; World_EnterState = 0 (just arriving)

	LDX Player_Current	 ; X = Player_Current

	LDA Map_GameOver_CursorY
	AND #$08
	BNE PRG062_932A	 ; If Player chose to END, jump to PRG062_932A

	; Player's live reset to 4
	LDA #$04
	STA Player_Lives,X

	; Set up position variables
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X
	LDA <Horz_Scroll_Hi
	STA Map_Prev_XHi,X
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X
	STA Map_Entered_X,X
	;LDA <Map_UnusedPlayerVal2,X
	LDA World_Num
	STA Map_Previous_World,X

	; Reset map variables
	LDA #$00
	STA Map_Player_SkidBack,X
	STA World_EnterState
	STA Map_GameOver_CursorY

	; SB: FIXME Game Over needs work

	;LDY #(Inventory_Coins - Inventory_Cards)	; Y = offset to Mario's coins

	;CPX #$00
	;BEQ PRG062_92FE	 ; If Player is Mario, jump to PRG062_92FE

	;LDY #(Inventory_Coins2 - Inventory_Cards)	; Y = offset to Luigi's coins

;PRG062_92FE:
	;LDA #(Inventory_Coins - Inventory_Cards)
	;STA <Temp_Var1		 ; Temp_Var1 = total bytes to clear

	;LDA #$00	 ; A = 0
;PRG062_9304:
	;STA Inventory_Cards,Y	 ; Clear cards/coins

	;DEY		 ; Y--
	;DEC <Temp_Var1	 ; Temp_Var1--
	;BPL PRG062_9304	 ; While Temp_Var1 >= 0, loop

	;LDY #$3f	 ; Y = $3F (End of Mario's Map Completions)

	;CPX #$00
	;BEQ PRG062_9314	 ; If Player is Mario, jump to PRG062_9314

	;LDY #$7f	 ; Y = $7F (End of Luigi's Map Completions)

;PRG062_9314:
	;LDA #$3f
	;STA <Temp_Var1	 ; Temp_Var1 = $3F
 
;PRG062_9318:
	;TYA
	;EOR #$40
	;TAX

	; Clear this Player's map completions
	;LDA Map_Completions,X
	;AND Map_Completions,Y
	;STA Map_Completions,Y

	;DEY		 ; Y--
	;DEC <Temp_Var1	 ; Temp_Var1--
	;BPL PRG062_9318	 ; While Temp_Var1 >= 0, loop!

PRG062_932A:
	;LDY Total_Players	 ; Y = Total_Players
	;DEY		 ; Y = 0 if 1P, or 1 if 2P

;PRG062_932E:
	;LDA Player_Lives,Y
	;BPL PRG062_933E	 ; If this Player isn't dead, jump to PRG062_933E

	;DEY		 ; Y--
	;BPL PRG062_932E	 ; While Y >= 0, loop

	; All Players are dead and have given up

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Reset game
	JMP IntReset_Part2

PRG062_933E:

	; A Player gave up, but there's one left

	JSR GameOver_PlayerQuitCleanup	 ; Performs some cleanup work for the Player who left

	; Map_Operation = 0
	LDY #$00
	STY Map_Operation

	LDX Player_Current	 ; X = Player_Current
	JMP PRG062_879B	 ; Jump to PRG062_879B


	; Alternate Scroll_Update that's ending-compatible
Scroll_Update_Ending:
	JSR Scroll_Update
	JMP SetEndingPages

Level_DoAnimations:
	LDA Level_TimerEn
	BMI PRG062_8E2E	 	; If bit 7 is set (animations disabled), jump to PRG062_8E2E

	LDY Level_Tileset

	; SB: No longer need this exception
	;CPY #$07
	;BNE PRG062_8E24	 ; If Level_Tileset <> 7 (Toad House), jump to PRG062_8E24
	;JMP PRG062_8EAD	 ; Toad House's also do not use the standard animations

;PRG062_8E24:
	; NOT TOAD HOUSE

	LDA Level_PSwitchCnt
	BEQ PRG062_8E31	 	; If P-Switch is not active, jump to PRG062_8E31

	; Otherwise force pattern override to $3E
	LDA #$3e
	STA PatTable_BankSel+1

PRG062_8E2E:
	JMP PRG062_8E5D	 ; Jump to PRG062_8E5D (skip main anim code)

PRG062_8E31:
	CPY #10
	BNE PRG062_8E4F	 ; If Level_Tileset <> 10 (Airship), jump to PRG062_8E4F

	; AIRSHIP ONLY

	LDY PatTable_BankSel+1
	CPY #$6a	
	BEQ PRG062_8E5D	 ; If the current animation active pattern table is $6A (Airship standard), jump to PRG062_8E5D (do nothing)

	; Otherwise...
	LDA <Counter_1
	AND #$03	
	BNE PRG062_8E5D	 ; Only update every 4 ticks (otherwise nothing, jump to PRG062_8E5D)

	INY
	INY		; +2 pattern tables

	CPY #$56	 
	BNE PRG062_8E4A	 ; If we're not at $56, jump to PRG062_8E4A

	LDY #$50	 ; Otherwise, use $50

PRG062_8E4A:
	STY PatTable_BankSel+1 ; Update active pattern table
	BNE PRG062_8E5D	 ; Jump (technically always) to PRG062_8E5D

PRG062_8E4F:
	; REGULAR LEVEL ANIMATIONS

	LDA <Counter_1
	AND #$18
	LSR A	
	LSR A	
	LSR A		
	TAX	        ; 0-3, changing every 8 ticks

	LDA PT2_Anim,X	
	STA PatTable_BankSel+1 ; Set pattern for this tick

PRG062_8E5D:
	; End of animations...
	RTS

Do_2PVsChallenge:
	; 2P Vs Challenge!

	; Load page 14 @ C000
	LDA #14
	STA PAGE_C000
	JSR PRGROM_Change_Both2

	JSR Scroll_Dirty_Update	 ; Render the 2P Vs terrain

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Raster_Effect = $80
	LDA #$80
	STA Raster_Effect

	; Load graphics for 2P Vs
	LDY #$04
	STY PatTable_BankSel+2
	INY
	STY PatTable_BankSel+3
	INY
	STY PatTable_BankSel+4
	INY
	STY PatTable_BankSel+5

	; Play battle (2P Vs) music
	LDA #MUS2B_BATTLE
	STA Level_MusicQueue

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Set page @ A000 to 9
	LDA #$09
	STA PAGE_A000
	JSR PRGROM_Change_A000

PRG062_939A:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; V Sync

	LDA SndCur_Map
	AND #SND_MAPENTERLEVEL
	BNE PRG062_93B1	 ; If the level entrance sound is still playing, jump to PRG062_93B1

	LDA Level_MusicQueue
	BEQ PRG062_93B1	 ; If no BGM is queued, jump to PRG062_93B1

	; Play the queued music
	STA Sound_QMusic2

	; Clear music queue
	LDA #$00
	STA Level_MusicQueue

PRG062_93B1:
	JSR Sprite_RAM_Clear	 ; Clear Sprite RAM 
	JSR Vs_2PVsPauseHandler	 ; Handle pausing

	LDA Level_ExitToMap
	BEQ PRG062_939A	 ; If not exiting to map, loop 2P Vs!

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeOut	 		; Fade out

	; Stop 2P Vs music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites

	JSR GraphicsBuf_Prep_And_WaitVSync	; Vertical sync

	; Disable display
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2

	; Make sure we have GOOD map return status! (SB)
	LDA #0
	STA Map_ReturnStatus

	; But check loss (SB)
	LDA Map_PlayerLost2PVs
	BNE Battle_PlayerLost
	
	; Get a key!
	LDA #7
	JSR Player_GetItem

	; Otherwise, Player won; get prize or whatever we do
	LDA #%10101000
	STA PPU_CTL1	 	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	; Set both Players to their previous map values
	; Required because we're re-entering the bonus area
	JSR Map_RestorePlayerPos

	; Not exiting to map (yet)
	LDA #0
	STA Level_ExitToMap

	; Do Return-From-Battle state
	LDA #10
	STA Bonus_GameState

	LDA #0
	STA Bonus_CurBufOffset
	STA Bonus_Timer

	; Ensure that the bonus area is re-entered (needed for tileset override)
	LDA #TILE_QBLOCK
	STA World_Map_Tile

	JMP PRG062_88AD

Battle_PlayerLost:
	INC Map_ReturnStatus

	JMP PRG062_8FB2	 ; Jump to PRG062_8FB2

	; SB: Old 2P Vs code; removed because no longer used for competition

	;LDX Map_PlayerLost2PVs
	;DEX
	;CPX Player_Current
	;BNE PRG062_93E7	 ; If the Player who lost the match was not the Player whose turn it was, jump to PRG062_93E7

	;JMP PRG062_946C	 ; Jump to PRG062_946C

PRG062_93E7:
	;LDA #(Inventory_Score - Inventory_Items)	; Offset to Mario's score

	;LDX Player_Current
	;BEQ PRG062_93F1	 ; If current Player is Mario, jump to PRG062_93F1

	;ADD #(Inventory_Score2 - Inventory_Score)	; Offset to Luigi's score

;PRG062_93F1:
	;TAY		 ; Y = offset to Player's score

	;LDX #$00	 ; X = 0
;PRG062_93F4:
	;LDA Inventory_Items,Y
	;STA Player_Score,X

	;INY		 ; Y++ (next "inventory" score byte)
	;INX		 ; X++ (next "active" score byte)

	;CPX #$03
	;BNE PRG062_93F4	; While X <> 3, loop!

	;LDX Map_PlayerLost2PVs
	;DEX
	;TXA
	;EOR #$01
	;TAY		 ; Y = the OTHER Player's index

	; Swap all Player map position variables because the challenger lost!
	;LDA Map_Previous_Y,Y
	;STA <Temp_Var1
	;LDA Map_Previous_XHi,Y
	;STA <Temp_Var2
	;LDA Map_Previous_X,Y
	;STA <Temp_Var3
	;LDA Map_Prev_XOff2,Y
	;STA <Temp_Var4
	;LDA Map_Prev_XHi2,Y
	;STA <Temp_Var5
	;LDA Map_Prev_XOff,Y
	;STA <Temp_Var6
	;LDA Map_Prev_XHi,Y
	;STA <Temp_Var7
	;LDA Map_Previous_Y,X
	;STA Map_Previous_Y,Y
	;LDA Map_Previous_XHi,X
	;STA Map_Previous_XHi,Y
	;LDA Map_Previous_X,X
	;STA Map_Previous_X,Y
	;LDA Map_Prev_XOff2,X
	;STA Map_Prev_XOff2,Y
	;LDA Map_Prev_XHi2,X
	;STA Map_Prev_XHi2,Y
	;LDA <Temp_Var1
	;STA Map_Previous_Y,X
	;LDA <Temp_Var2
	;STA Map_Previous_XHi,X
	;LDA <Temp_Var3
	;STA Map_Previous_X,X
	;LDA <Temp_Var4
	;STA Map_Prev_XOff2,X
	;LDA <Temp_Var5
	;STA Map_Prev_XHi2,X
	;LDA <Temp_Var6
	;STA Map_Prev_XOff,X
	;LDA <Temp_Var7
	;STA Map_Prev_XHi,X

;PRG062_946C:

	; Flag as "death" so challenger flies backward
	;LDX Map_PlayerLost2PVs
	;STX Map_ReturnStatus

	; Set new current Player
	;DEX		 ; X--
	;STX Player_Current

	;JMP PRG062_8FB2	 ; Jump to PRG062_8FB2

;GameOver_WhiteMapObjs:
;	.byte MAPOBJ_NSPADE, MAPOBJ_WHITETOADHOUSE, MAPOBJ_UNK0C


GameOver_PlayerQuitCleanup:
	LDY Total_Players	; Y = Total_Players
	CPY #$01
	BEQ PRG062_948F	 	; If only a 1P game, jump to PRG062_948F

	; This is a 2P game

	DEY		 ; Y-- (Y = 1)
PRG062_9484:
	LDA Player_Lives,Y
	BPL PRG062_948E	 ; If this is the living Player, jump to PRG062_948E (RTS)

	DEY		 ; Y--
	BPL PRG062_9484	 ; While Y >= 0, loop!

	BMI PRG062_948F	 ; Jump to PRG062_948F

PRG062_948E:
	RTS		 ; Return

PRG062_948F:
	; BUG!! Apparently the game is SUPPOSED to delete all 
	; bonus objects after a game over, but code starts with
	; the wrong index (see immediately below) and that causes
	; this to not work correctly!  Strange, huh?

	; As my brother put it:
	; "It may have been because of the 2P mode. You can't punish
	; the other player because one of you sucks bad."

	;LDX #-$04	; <-- BUG!  BAD INDEX!!  (Should be X = 2??)
;PRG062_9491:
	;LDY #(MAPOBJ_TOTAL-1)	 ; Y = (MAPOBJ_TOTAL-1) (all Map Objects)

;PRG062_9493:
	;LDA Map_Objects_IDs,Y
	;BEQ PRG062_94A2	 ; If this Map Object is empty, jump to PRG062_94A2

	;CMP GameOver_WhiteMapObjs,X
	;BNE PRG062_94A2	 ; If this is NOT one of the "white" objects (White Toad House, Coin Ship, and the ??), jump to PRG062_94A2

	; Delete the bonus objects!  You don't deserve them!

	;LDA #MAPOBJ_EMPTY
	;STA Map_Objects_IDs,Y

;PRG062_94A2:
	;DEY		 ; Y--
	;BPL PRG062_9493	 ; While Y >= 0, loop

	;DEX		 ; X--
	;BPL PRG062_9491	 ; While X >= 0, loop	<-- BUG! This will fail on the first pass!

	; SB: Removing N-Spade from map

	LDA #$00
	;STA Map_NSpade_NextScore	 ; Highest byte in the N-Spade score = 0
	STA Map_Anchored ; Airship is no longer anchored

	; N-Spade appears every 80,000 points, but the leading zero is fake, so 8000

	; Middle byte of the N-Spade score
	;LDA #HIGH(8000)
	;STA Map_NSpade_NextScore+1

	; Lowest byte of the N-Spade score
	;LDA #LOW(8000)
	;STA Map_NSpade_NextScore+2

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SetPages_ByTileset
;
; This routine uses sets both A000 and C000 pages based on the active Level_Tileset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SetPages_ByTileset:	; $94BB
	LDY Level_Tileset	 	; Y = Level_Tileset

	; Change A000 and C000 pages based on Page_A/C000_List
	LDA PAGE_C000_ByTileset,Y
	STA PAGE_C000
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000	 
	JMP PRGROM_Change_Both2		; JUMP to page routine, do not continue below...


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Video_Do_Update
;
; This very important subroutine takes an index value in 'A'
; and sets up to execute one of the Video_Upd_Table updates
; to the screen, e.g. A = 2 for the status bar.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Video_Do_Update:	; $94CD
	PHA		 ; Push A

	ASL A		 ; A << 1 (multiply by 2, looks up different address)
	TAY		 ; Y = A

	; Set update VRAM address high/low
	LDA Video_Upd_Table,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table+1,Y
	STA <Video_Upd_AddrH	

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Video_Misc_Updates	 

	PLA		 ; Pop A

	BNE PRG062_94EE	 ; If A <> 0, jump to PRG062_94EE
	STA Graphics_BufCnt	; Clear the buffer counter
	STA Graphics_Buffer	; Immediately terminate the buffer

PRG062_94EE:
	; Jump into SetPages_ByTileset to "correct" the tables back
	; (mainly A000)
	JMP SetPages_ByTileset

	; Select the attribute table (which loads 8 bytes into Tile_AttrTable)
TileAttribute_ByTileset:
	.word Tile_Attributes_TS0		; 0 - Map
	.word Tile_Attributes_TS1		; 1 - Plains [15]
	.word Tile_Attributes_TS2		; 2 - Mini fortress style [21]
	.word Tile_Attributes_TS3		; 3 - Hills style [16]
	.word Tile_Attributes_TS4_TS12		; 4 - High-Up style [17]
	.word Tile_Attributes_TS5		; 5 - Ghose House [19]
	.word Tile_Attributes_TS6_TS8	; 6 - Water world [18]
	.word Tile_Attributes_TS7	; 7 - Toad house [18]
	.word Tile_Attributes_TS6_TS8	; 8 - Vertical pipe maze [18]
	.word Tile_Attributes_TS9		; 9 - desert level [20]
	.word Tile_Attributes_TS10		; 10 - airship [23]
	.word Tile_Attributes_TS11_TS13		; 11 - Giant World [19]
	.word Tile_Attributes_TS4_TS12		; 12 - ice level [17]
	.word Tile_Attributes_TS11_TS13		; 13 - coin heaven / sky level [19]
	.word Tile_Attributes_TS14		; 14 - underground [13]
	.word Tile_Attributes_TS15		; 15 - ext [45]
	.word Tile_Attributes_TS15_TS16_TS17	; 16 - spade game sliders [22]
	.word Tile_Attributes_TS15_TS16_TS17	; 17 - N-spade [22]
	.word Tile_Attributes_TS18		; 18 - 2P Vs [14]
	.word Tile_Attributes_TS15_TS16_TS17	; 19 - bonus game intro [22]

	; NOT USED Tile Attribute values (not valid either; incomplete set!)
Tile_Attributes_TS15_TS16_TS17:
	; Unused space
	.byte $FF, $FF, $FF, $FF


Fill_Tile_AttrTable_ByTileset:
	LDA Level_Tileset
	ASL A		 
	TAY		 	; Y = Level_Tileset << 1

	; Index into TileAttribute_ByTileset and store address to [Temp_Var2][Temp_Var1]
	LDA TileAttribute_ByTileset,Y
	STA <Temp_Var1		
	LDA TileAttribute_ByTileset+1,Y
	STA <Temp_Var2		

	LDY #$07		; Y = 7
PRG062_952C:
	LDA [Temp_Var1],Y	
	STA Tile_AttrTable,Y	
	DEY			; Y--
	BPL PRG062_952C	 	; While Y >= 0, loop!

	RTS			; Return

	; This LUTs are for the unused-in-US-release "Box out" effect when a level starts
	
	; This one selects the appropriate init values for everything
	; else based on what the vertical start position is...
BoxOut_ByVStart:	.byte $00, $30, $70, $B0, $EF	; Needs to sync with GamePlay_VStart

	; The init values, each column links to an above vertical start position
BoxOut_InitVAddrH:	.byte $21, $22, $23, $28, $29
BoxOut_InitVAddrL0:	.byte $6E, $2E, $2E, $6E, $6E
BoxOut_InitVAddrL1:	.byte $8E, $4E, $4E, $8E, $8E
BoxOut_InitVAddrL2:	.byte $73, $33, $33, $73, $73
BoxOut_InitVAddrL3:	.byte $6D, $2D, $2D, $6D, $6D

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Clear_EntTranMem
;
; Clears memory used by the entrance transition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Clear_EntTranMem:
	LDY #$1c	 ; Y = $1C
PRG062_9555:
	LDA #$00	 ; A = 0
	STA Map_EntTran_VLHalf,Y
	DEY		 ; Y--
	BPL PRG062_9555	 ; While Y >= 0, loop!
	RTS		 ; Return


BoxOut_SetThisBorderVRAM:
	; Map_EntTran_VAddrL/H += Map_EntTran_VRAMGap
	LDA Map_EntTran_VAddrL
	ADD Map_EntTran_VRAMGap
	STA Map_EntTran_VAddrL
	LDA Map_EntTran_VAddrH
	ADC #$00
	STA Map_EntTran_VAddrH

	LDA Map_EntTran_InitValIdx
	CMP #$04
	BEQ PRG062_95AD	 ; If the initial index was 4, jump to PRG062_95AD (RTS)

	LDA Map_EntTran_Temp
	CMP #$ff	 
	BNE PRG062_95AD	 ; If Map_EntTran_Temp <> $FF, jump to PRG062_95AD (RTS)

	LDY Map_EntTran_BorderLoop	 ; Y = current border index (0-3: Top 0, bottom 1, right 2, left 3)

	; Prevent out of range video writes
	LDA Map_EntTran_BVAddrH,Y
	CMP #$28	 
	BGE PRG062_95AD	 	; If border's VRAM high address >= $28, jump to PRG062_95AD (RTS)
 
	LDA Map_EntTran_VAddrH
	CMP #$23
	BLT PRG062_95AD	 	; If border's VRAM high address < $23, jump to PRG062_95AD (RTS)

	LDA Map_EntTran_VAddrL
	CMP #$c0
	BLT PRG062_95AD	 	; If border's VRAM low address < $C0, jump to PRG062_95AD (RTS)

	; Set VRAM address to [$28][Map_EntTran_BVAddrL & $1f]
	LDA #$28
	STA Map_EntTran_VAddrH

	LDA Map_EntTran_VAddrL
	AND #$1f
	STA Map_EntTran_VAddrL

	LDA Map_EntTran_BorderLoop	 ; A = current border index (0-3: Top 0, bottom 1, right 2, left 3)
	AND #$02	
	BEQ PRG062_95AD	 	; If not doing right side update, jump to PRG062_95AD (RTS)

	STX Map_EntTran_Temp	 ; Store X (LRCnt) into Map_EntTran_Temp

PRG062_95AD:
	RTS		 ; Return


	; As part of the "boxing out" effect, calculate adjusted VRAM 
	; addresses as fit to the arbitrary positioning of the screen
BoxOut_CalcOffsets:
	; I'll let someone else figure this out in particular,
	; I'm not as concerned about a removed effect...

	LDA Map_EntTran_VAddrL
	AND #$c0
	STA Map_EntTran_TileOff

	LDA Map_EntTran_VAddrH
	AND #$0f
	STA Map_EntTran_VAddrHAdj

	CLC
	ROR Map_EntTran_VAddrHAdj
	ROR Map_EntTran_TileOff
	CLC
	ROR Map_EntTran_VAddrHAdj
	ROR Map_EntTran_TileOff
	LDA Map_EntTran_VAddrL
	AND #$1f
	LSR A	
	ADD Map_EntTran_TileOff
	STA Map_EntTran_TileOff

	RTS		 ; Return


	; Determine which 8x8 of the tile layout we're going to need
BoxOut_CalcWhich8x8:
	LDA Map_EntTran_VAddrL
	AND #$01
	STA Map_EntTran_Tile8x8

	LDA Map_EntTran_VAddrL
	AND #$20	 
	BNE PRG062_95EF	

	ASL Map_EntTran_Tile8x8
	JMP PRG062_95F3	 	; Jump to PRG062_95F3

PRG062_95EF: 
	SEC		 
	ROL Map_EntTran_Tile8x8

PRG062_95F3:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Calc_NT2Addr_By_XY
;
; This calculates the Nametable 2 address where a modification
; is about to take place (e.g. when a hammer has broken a rock)
; X = X coordinate on map (e.g. MapPoof_X)
; A = Y coordinate on map (e.g. MapPoof_Y)
;
; High byte of address is in Temp_Var15
; Low byte of address is in Temp_Var16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Calc_NT2Addr_By_XY:

	; This rearranges 'A' such that the two highest bits become
	; the two lowest bits, and the other 6 are shifted up.
	; Basically a ROL without the carry being involved
	ASL A
	ADC #$00
	ASL A	
	ADC #$00
	STA <Temp_Var13	 	; Stored into Temp_Var13

	TXA		 	; A = X coordinate
	LSR A
	LSR A
	LSR A
	STA <Temp_Var14 	; Temp_Var14 = X coord >> 3
 
	LDA <Temp_Var13		; A = Temp_Var13
	AND #%11		; Get just the lower 2 bits (which are the upper 2 bits of Y coordinate)
	ORA #$28		; OR $28 (upper byte of video address for Nametable 2)
	STA <Temp_Var15		; Store into Temp_Var15

	LDA <Temp_Var13		; A = Temp_Var13
	AND #%11000000		; Get just the upper 2 bits of Temp_Var13
	ORA <Temp_Var14	; OR in Temp_Var14
	STA <Temp_Var16	; Store into Temp_Var16

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bonus_Prize1
;
; FOR UNUSED BONUS GAMES
; This is the routine used to give a prize for a roll of "2" on the die
; It's not completely clear what was intended, but that might be because
; the memory it is manipulating used to be something else once...
;
; It uses Inventory_Cards as the base but the only use of "Bonus_Prize1"
; is the lost bonus game die and it uses an input value of X = 3, which
; ultimately means we edit the first byte of Inventory_Score instead.
; But not in a "safe" way with carried arithmetic etc... which makes me
; think that memory space was once home to some other idea...
; And not that it'd make sense to "increment" your card storage either!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Bonus_Prize1:

	; Backup Y/X
	TYA
	PHA
	TXA
	PHA

	; Temp_Var16 = 0 (offset to Mario's Inventory)
	LDA #$00
	STA <Temp_Var16

	LDY Player_Current
	CPY #$00
	BEQ PRG062_962C	; If Player is Mario, jump to PRG062_962C

PRG062_9622:
	; SB: This is dead code anyway, maybe redo??

	; Offset to Luigi's Inventory
	LDA <Temp_Var16
	;ADD #(Inventory_Cards2 - Inventory_Cards)
	ADD #0
	STA <Temp_Var16

	DEY		 ; Y will equal 1 here, so this just makes Y zero
	BNE PRG062_9622	 ; Jump technically NEVER to PRG062_9622 (?!)

PRG062_962C:
	TXA		 ; Input value -> 'A'

	ADD <Temp_Var16	 ; Add to offset value
	TAX		 ; -> 'X'

	INC Inventory_Cards,X	 ; The intention of this is unclear!

	; Restore X/Y
	PLA
	TAX
	PLA
	TAY

	RTS		 ; Return

;BoxOut_PutPatternInStrip:
;	JSR BoxOut_CalcOffsets	 ; Calculate offset to tile
;	JSR BoxOut_CalcWhich8x8	 ; Calculate which 8x8 pattern of the tile layout we're going to use

;	LDA Level_7Vertical
;	BEQ PRG062_9654	 	; If level is not vertical, jump to PRG062_9654

;	LDY Level_SizeOrig

;	; Correct base address for vertical levels
;	LDA Tile_Mem_AddrVL,Y
;	STA <Map_Tile_AddrL
;	LDA Tile_Mem_AddrVH,Y
;	STA <Map_Tile_AddrH

;	JMP PRG062_965E	 	; Jump to PRG062_965E

;PRG062_9654:
;	; Correct base address for non-vertical levels
;	LDA Tile_Mem_Addr
;	STA <Map_Tile_AddrL
;	LDA Tile_Mem_Addr+1
;	STA <Map_Tile_AddrH

;PRG062_965E:
;	LDA Map_EntTran_VAddrH
;	AND #$08	 
;	BEQ PRG062_966C	 ; If "high" address is not halfway through vertically, jump to PRG062_966C

;	; Otherwise, offset halfway through screen
;	LDA <Map_Tile_AddrL
;	ADD #$f0
;	STA <Map_Tile_AddrL	; Map_Tile_AddrL += $F0

;PRG062_966C:
;	LDA Level_Tileset
;	ASL A		
;	TAY		 

;	; Set Temp_Var13/14 to point to the layout data for this Tileset
;	LDA TileLayout_ByTileset,Y
;	STA <Temp_Var13	
;	LDA TileLayout_ByTileset+1,Y
;	STA <Temp_Var14	

;	LDY Map_EntTran_TileOff
;	LDA [Map_Tile_AddrL],Y	 ; Get the tile we're working on

;	TAY		 
;	LDA Map_EntTran_Tile8x8
;	ADD <Temp_Var14		
;	STA <Temp_Var14		
;	LDA [Temp_Var13],Y	 ; Get the specific 8x8 tile of the tile we're working on

;	STA <Scroll_ColorStrip,X ; Store into the strip
;	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Update_Ranges
;
; This subroutine updates Scroll_ColumnL/R based on
; where the screen has currently scrolled to...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Update_Ranges: 
	LDY Level_7Vertical
	BNE PRG062_96A5	 	; If Level_7Vertical, jump to PRG062_96A5

	; Non-vertical map
	; Expected that 'A' is currently set to the "Hi byte" of the X Scroll coordinate

	; This loop puts the lower 4 bits of the "hi byte" X into the 
	; upper 4 bits of Scroll_Temp, and shifts Scroll_Temp 4 bits down... or basically,
	; Scroll_Temp = (Scroll_Temp >> 4) | (A << 4)

	; Most importantly, this has taken a pixel-based scroll X and a "high byte" of X
	; scroll and combined them into a reduced accuracy (column-based) value of where
	; we're at horizontally...
	LDX #$03	 ; X = 3
PRG062_9695:
	LSR A		 ; Pushes the LSb -> Carry
	ROR <Scroll_Temp	 ; Shift everything in Scroll_Temp to the right, and pull in the carry
	DEX		 ; X--
	BPL PRG062_9695	 ; If X >= 0, loop!

	LDA <Scroll_Temp	; A = result from loop...
	STA <Scroll_ColumnL	; Store as the current "left side" column
	ADD #16	
	STA <Scroll_ColumnR	; Scroll_ColumnR = Scroll_ColumnL + 16 (always -- 256/16 = 16 columns spanning the screen)
	RTS			; Return!

PRG062_96A5:
	; Vertical level

	LDA <Scroll_Temp
	BEQ PRG062_96B7	 	; If Scroll_Temp = 0, jump to PRG062_96B7

	SUB #16			
	STA <Scroll_Temp	; Scroll_Temp -= 16

	CMP #$f0	 
	BLT PRG062_96B7	 ; If Scroll_Temp < $F0 (would only happen if it was previously $00-$0F), jump to PRG062_96B7

	SUB #17
	STA <Scroll_Temp	; Scroll_Temp -= 17

PRG062_96B7:
	LDA <Scroll_Temp	
	STA <Scroll_VOffsetT	; Scroll_VOffsetT = Scroll_Temp

	; Calculate bottom tile row offset

	ADD #$e0	 	; A = Scroll_Temp + $E0
	BCC PRG062_96C2	 	; If no carry occurred, jump to PRG062_96C2

	ADC #$10	 	; A = Scroll_Temp + $F0

PRG062_96C2:
	CMP #$f0	 	
	BLT PRG062_96CB	 	; If A < $F0, jump to PRG062_96CB
	AND #$0f	 	; A &= $F
	ADD #$01	 	; A += 1

PRG062_96CB:
	STA <Scroll_VOffsetB	; Update Scroll_VOffsetB
	RTS		 	; Return!

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Clear_RAM_thru_ZeroPage
	; 
	; Starting at the page provided in Y, this will clear everything
	; (except the stack space) $YY00 to $0000
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Clear_RAM_thru_ZeroPage:
	STY <Temp_Var2	 ; Save Y in <Temp_Var2
	LDY #$00	 ; Y = 0
	STY <Temp_Var1	 ; Clear <Temp_Var1
	TYA		 ; A = 0

	; Y is the initial input as the high byte of the address
	; low first then high, so [Temp_Var2][Temp_Var1]
PRG062_96D5:
	LDX <Temp_Var2	 ; X = current high byte of address in this case
	CPX #$01	 ; If we've reached the $01xx bank...
	BEQ PRG062_96DD	 ; ... skip the next line (don't clear the stack space!)
	STA [Temp_Var1],Y	 ; Otherwise, clear this byte
PRG062_96DD:
	DEY		 ; Y--
	BNE PRG062_96D5	 ; While Y <> 0, loop around again (goes $00, $FF, $FE, ... back to $00) again
	DEC <Temp_Var2	 ; Next lower bank
	BPL PRG062_96D5	 ; While we're >= bank $00
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GraphicsBuf_Prep_And_WaitVSync
;
; This subroutine takes Graphics_Queue and loads and address
; from Video_Upd_Table into the Video_Upd_Addr, then waits for
; a VBlank cycle to occur via reading the VBlank_Tick after
; force-setting it to zero.  This gets the system into a state
; where it can actually apply the update!
;
; See also GraphicsBuf_Prep_And_WaitVSyn2 in PRG024
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GraphicsBuf_Prep_And_WaitVSync:	; 96E5
	LDA <Graphics_Queue
	ASL A		 	
	TAY		 	; Y = Graphics_Queue * 2

	; Get the address where the video update data is
	LDA Video_Upd_Table,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table+1,Y
	STA <Video_Upd_AddrH	

	LDA #$01	
	STA <VBlank_TickEn	 ; Enable the VBlank tick
	LDA #$00	 
	STA <VBlank_Tick	 ; Force VBlank_Tick = 0, so we know when a VBlank has occurred

	; Waiting for VBlank...
PRG062_96FB:
	LDA <VBlank_Tick
	BPL PRG062_96FB	

	LDA #$00	 
	STA <VBlank_TickEn	 ; Disable the VBlank

	CLI		 ; Enable further masked interrupts
	RTS		 ; Return


	; Tile_Mem_ClearA/B form a way to rapidly clear all of the tile
	; memory to a specific value (A), used in conjunction with the
	; proper iterative loop...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tile_Mem_ClearA
;
; $1B0 is the size of one screen, so this essentially writes to the
; same place on all screens, offset by 'Y'.  Unfortunately since 
; one screen is $1B0, 'Y' cannot cover the entire space, so we have
; Tile_Mem_ClearB with a different offset...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Tile_Mem_ClearA:	; $9705
	STA Tile_Mem,Y	 
	STA Tile_Mem+$1B0,Y
	STA Tile_Mem+$360,Y
	STA Tile_Mem+$510,Y
	STA Tile_Mem+$6C0,Y
	STA Tile_Mem+$870,Y
	STA Tile_Mem+$A20,Y
	STA Tile_Mem+$BD0,Y
	STA Tile_Mem+$D80,Y
	STA Tile_Mem+$F30,Y
	STA Tile_Mem+$10E0,Y
	STA Tile_Mem+$1290,Y
	STA Tile_Mem+$1440,Y
	STA Tile_Mem+$15F0,Y
	STA Tile_Mem+$17A0,Y
	INY		 ; Y++

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tile_Mem_ClearB
;
; Similar to Tile_Mem_ClearA, writes to the same place on all screens,
; only this one begins at the 12th row (making up for the 'Y'
; register coming up short of a full screen)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Tile_Mem_ClearB:	; $9734
	STA Tile_Mem+$0C0,Y
	STA Tile_Mem+$270,Y
	STA Tile_Mem+$420,Y
	STA Tile_Mem+$5D0,Y
	STA Tile_Mem+$780,Y
	STA Tile_Mem+$930,Y
	STA Tile_Mem+$AE0,Y
	STA Tile_Mem+$C90,Y
	STA Tile_Mem+$E40,Y
	STA Tile_Mem+$FF0,Y
	STA Tile_Mem+$11A0,Y
	STA Tile_Mem+$1350,Y
	STA Tile_Mem+$1500,Y
	STA Tile_Mem+$16B0,Y
	STA Tile_Mem+$1860,Y
	RTS		 ; Return


	; Array of bank selections by Level_BG_Page1_2 
	; What LEVEL4_BGBANK_INDEX references
Level_BG_Pages1:
	.byte $00	;  0 Not Used
	.byte $08	;  1 Plains
	.byte $10	;  2 Fortress
	.byte $1C	;  3 Hills / Underground
	.byte $0C	;  4 High-Up
	.byte $82	;  5 Ghose House
	.byte $58	;  6 Underwater
	.byte $68	;  7 Delfino
	.byte $58	;  8 Pipe Maze
	.byte $30	;  9 Desert
	.byte $34	; 10 Airship
	.byte $6E	; 11 Giant world
	.byte $18	; 12 Ice
	.byte $38	; 13 Sky
	.byte $22	; 14 SMW Plains (SB: Plains rebranded)
	.byte $24	; 15 Bonus Room
	.byte $2C	; 16 Spade (Roulette)
	.byte $5C	; 17 N-Spade (Card)
	.byte $58	; 18 2P Vs
	.byte $6C	; 19 Hills / Underground alternate
	.byte $F6	; 20 Delfino N&B Blocks
	.byte $34	; 21 World 8 War Vehicle
	.byte $28	; 22 Throne Room
	.byte $80	; 23 SMB2 style (SB: High-Up rebranded)
	.byte $84	; 24 Ghost Plains (SB: Plains rebranded)
	.byte $48	; 25 Fire and Ice Galaxy (SB: Hills/Underground rebranded)
	.byte $4A	; 26 Topmaniac Fortress
	.byte $76	; 27 Castle Bleck

Level_BG_Pages2:
	.byte $00	;  0 Not Used
	.byte $60	;  1 Plains
	.byte $60	;  2 Fortress
	.byte $60	;  3 Hills / Underground
	.byte $60	;  4 High-Up
	.byte $60	;  5 Ghose House
	.byte $60	;  6 Underwater
	.byte $60	;  7 Delfino
	.byte $60	;  8 Pipe Maze
	.byte $60	;  9 Desert
	.byte $6A	; 10 Airship
	.byte $60	; 11 Giant world
	.byte $60	; 12 Ice
	.byte $60	; 13 Sky
	.byte $60	; 14 SMW Plains (SB: Plains rebranded)
	.byte $5E	; 15 Bonus Room
	.byte $2E	; 16 Spade (Roulette)
	.byte $5E	; 17 N-Spade (Card)
	.byte $60	; 18 2P Vs
	.byte $60	; 19 Hills / Underground alternate
	.byte $60	; 20 Delfino N&B Blocks
	.byte $50	; 21 World 8 War Vehicle
	.byte $60	; 22 Throne Room
	.byte $60	; 23 SMB2 style (SB: High-Up rebranded)
	.byte $60	; 24 Ghost Plains (SB: Plains rebranded)
	.byte $60	; 25 Fire and Ice Galaxy (SB: Hills/Underground rebranded)
	.byte $60	; 26 Topmaniac Fortress
	.byte $60	; 27 Castle Bleck


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad
;
; The master level loader function!  Without this, there's no game!
;
; This function performs all the work necessary to translate 
; "layout" data into functional geometry.  Note that based on
; the value of Level_Tileset, there are different "generators"
; that are employed, so while the overall macro format is consistent,
; the stylization and inner format may not be!
;
; Best to follow through to figure out the format to each "style"...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; There are 8 defined vertical start positions

	; Defines Player's Y "high" start
GamePlay_YHiStart:	.byte $01, $00, $00, $01, $00, $00, $00, $01

	; Defines Player's Y start
GamePlay_YStart:	.byte $70, $40, $00, $40, $70, $B0, $F0, $80

	; Defines screen vertical position starts
	; NOTE: If the "box out" effect were to be used, needs to sync with BoxOut_ByVStart
GamePlay_VStart:	.byte $EF, $00, $00, $EF, $30, $70, $B0, $EF

	; Available MSD time start values
GamePlay_TimeStart:	.byte 4, 5, 3, 0	; SB: Bumped up all by 100 (except the infinite, of course)

	; Available BGMs for levels (16 possible with stock code)
GamePlay_BGM:
	.byte MUS2B_OVERWORLD	; 0
	.byte MUS2B_UNDERGROUND	; 1
	.byte MUS2B_UNDERWATER	; 2
	.byte MUS2B_FORTRESS	; 3
	.byte MUS2B_BOSS	; 4
	.byte MUS2B_AIRSHIP	; 5
	.byte MUS2B_BATTLE	; 6
	.byte MUS2B_TOADHOUSE	; 7
	.byte MUS2B_ATHLETIC	; 8
	.byte MUS2A_THRONEROOM	; 9
	.byte MUS2A_SKY		; 10
	.byte MUS2C_GOODEGG	; 11
	.byte MUS2C_MINIBOSS	; 12
	.byte MUS2C_GHOSTHOUSE	; 13
	.byte MUS2C_GHOSTHOUSE2	; 14
	.byte MUS2C_MARIOLAND	; 15
	.byte MUS2C_SPECIAL	; 16
	.byte MUS2C_CASTLE	; 17
	.byte MUS2C_BOSSEOW	; 18
	.byte MUS2C_YOLD	; 19
	.byte MUS2C_MANSION	; 20
	.byte MUS2C_RUINS	; 21
	.byte MUS2C_ATHLETIC2	; 22
	.byte MUS2C_FFGALAXYF	; 23
	.byte MUS2B_PURPLECOMET	; 24
	.byte MUS2C_REDCOMET	; 25
	.byte $00	; 26

GamePlay_InvertMusic:	.byte $00, $18	; Invert disabled/enabled

	; SB: Used in PRG026 to fetch level size from header; needed to fix a bug,
	; but actual level data is not available at the moment required...
Level_FetchHeaderSize:
	; Change to page where level will be
	LDY Level_Tileset		; Will be effective tileset for junction destination
	LDA PAGE_A000_ByTileset,Y	; Get page we need
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	; Get the fourth byte of the header, keep lower 4 bits only (size)
	LDY #4
	LDA [Level_LayPtr_AddrL],Y
	AND #$0F
	TAY	; -> Keep it safe in 'Y'

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; Return result in 'A'
	TYA

	RTS

LevelLoad:	; $97B7

	; Clear loading variables
	LDA #$00
	STA TileAddr_Off
	STA Player_GravityEffect
	STA Level_PCometCoins
	STA Level_PCometCoins+1

	LDY #$04	 ; Y = 4 (in case we're skipping first 4 bytes of header)

	; If we're using a "junction" device (door/pipe/etc.), we don't want to (incorrectly) set the "alternates"...
	LDA Level_JctCtl	 
	CMP #$80	 
	BEQ PRG062_980D	 ; If Level_JctCtl = $80, jump to PRG062_980D (use current Level_AltLayout/Level_AltObjects values)

	LDY #$00	 ; Y = 0

	; Get bytes 0-3 of layout data; pointers Level_AltLayout and Level_AltObjects

	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltLayout
	INY
	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltLayout+1
	INY		 

	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltObjects
	INY		
	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltObjects+1
	INY		

	LDA Level_JctCtl	
	BNE PRG062_980D	 ; If Level_JctCtl <> 0, jump to PRG062_980D (skip setting vertical start position)

	LDA [Level_LayPtr_AddrL],Y
	AND #%11100000
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 	; X = upper 3 bits, shifted down, from byte 4 (0-7)

	; Set up the vertical starting position!
	LDA GamePlay_YHiStart,X
	STA <Player_YHi		; Player_YHi = GamePlay_YHiStart[X]

	LDA GamePlay_YStart,X
	STA <Player_Y		; Player_Y = GamePlay_YStart[X]

	LDA #$00	 
	STA <Player_XHi		; Player_XHi = 0

	; Set the starting vertical position
	LDA GamePlay_VStart,X
	STA <Vert_Scroll	; Vert_Scroll = GamePlay_VStart[X]

PRG062_980D:

	; Set the width of the level (in screens) from byte 4
	LDA [Level_LayPtr_AddrL],Y
	PHA
	AND #%00001111
	STA <Level_Width
	STA Level_SizeOrig	 
	
	PLA
	AND #LEVEL1_MUCK
	STA Level_WaterMuck

	;;;;;;;;;;;;;;;
	INY		 

	; First 3 bits of byte 5 determine the palette select for tiles
	LDA [Level_LayPtr_AddrL],Y
	AND #%00000111
	STA PalSel_Tile_Colors

	; Next 2 bits select an object palette, root value 8
	LDA [Level_LayPtr_AddrL],Y
	AND #%00011000
	LSR A		
	LSR A		
	LSR A		
	ORA #%00001000		; forces minimum value of 8
	STA PalSel_Obj_Colors

	; Next 2 bits sets Level_SelXStart (sets Player_X after level starts)
	LDA [Level_LayPtr_AddrL],Y
	AND #%01100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	STA Level_SelXStart	 

	; Finally, bit 7 sets Music_InvertEn (SB)
	LDA [Level_LayPtr_AddrL],Y
	AND #$80
	ASL A
	ROL A
	AND #$01	; A = 0 or 1
	TAX		; -> 'X'

	; Set music invert
	LDA GamePlay_InvertMusic,X
	STA Music_InvertEn

	;;;;;;;;;;;;;;;
	INY		 

	; Bit 7 of byte 6 sets Level_PipeNotExit
	LDA [Level_LayPtr_AddrL],Y
	AND #$80	 
	STA Level_PipeNotExit

	; Bits 5-6 set Level_FreeVertScroll
	LDA [Level_LayPtr_AddrL],Y
	AND #%01100000
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	STA Level_FreeVertScroll

	CMP #$02
	BNE PRG062_9864	 ; If Level_FreeVertScroll <> 2 (arbitrary scroll lock), jump to PRG062_9864

	; Otherwise for a level started with the arbitrary lock, it picks Vert_Scroll = 0 (highest point)
	; if Vert_Scroll is less than $B0, otherwise it picks $EF (lowest point)
	; NOTE however that these two points are not required during normal gameplay; you can arbitrarily
	; lock to ANY Vert_Scroll value and it will work just fine!

	LDX #$00		; X = 0

	LDA <Vert_Scroll
	CMP #$b0
	BLT PRG062_985F	 	; If Vert_Scroll < $B0, jump to PRG062_985F

	LDX #$ef	 	; Otherwise, X = $EF

PRG062_985F:
	STX <Vert_Scroll	; Vert_Scroll = X
	STX Level_Jct_VS	; Level_Jct_VS = Vert_Scroll

PRG062_9864:

	; Bit 4 sets whether this level is a vertical one
	LDA [Level_LayPtr_AddrL],Y
	AND #%00010000
	STA Level_7Vertical
	BEQ PRG062_9893	 	; If not vertical, jump to PRG062_9893

	LDX Level_JctCtl
	BNE PRG062_987C	 	; If Level_JctCtl <> 0, jump to PRG062_987C

	; Start at bottom of vertical level
	LDA Level_SizeOrig
	STA <Vert_Scroll_Hi
	STA <Player_YHi		; Player's Y High is the same!
	JMP PRG062_9893	


PRG062_987C:
	LDA #$00	
	STA Level_SizeOrig	; ?? Why?

	LDA <Player_YHi	
	BEQ PRG062_988E	 	; If the Player Y high is zero, jump to PRG062_988E

	LDA <Level_Width
	STA <Vert_Scroll_Hi
	STA <Player_YHi	
	STA Level_SizeOrig

PRG062_988E:
	LDA <Vert_Scroll_Hi
	STA Level_Jct_VSHi	 ; Level_Jct_VSHi = Vert_Scroll_Hi

	; End of Vertical alternative

PRG062_9893:

	; Bits 0-3 set Level_AltTileset
	LDA [Level_LayPtr_AddrL],Y
	AND #$0f	
	STA Level_AltTileset

	;;;;;;;;;;;;;;;
	INY		; Y++	

	; Bits 5-7 of byte 7 set Level_InitAction (sets an action to begin level, see Level_InitAction_JumpTable)
	LDA [Level_LayPtr_AddrL],Y
	AND #%11100000	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA Level_InitAction

	; Bits 0-4 set Level_BG_Page1_2 (an index to which pages of BG graphics should be loaded)
	LDA [Level_LayPtr_AddrL],Y
	AND #%00011111	 
	STA Level_BG_Page1_2

	;;;;;;;;;;;;;;;
	INY		 ; Y++

	LDA Level_JctCtl
	BNE PRG062_98C8	 ; If using a junction device, don't set the time; jump to PRG062_98C8

	; Bits 6-7 of byte 8 select a time setting (0=300, 1=400, 2=200, 3=000 [unlimited])
	LDA [Level_LayPtr_AddrL],Y
	AND #%11000000	
	CLC		
	ROL A		
	ROL A		
	ROL A		
	TAX		
	LDA GamePlay_TimeStart,X
	STA Level_TimerMSD
	BNE PRG062_98C8	 	; If not using the 000 time, jump to PRG062_98C8

	INC Level_TimerEn	; Otherwise Level_TimerEn = 1 (disable the clock, hence unlimited time)

PRG062_98C8:
	
	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BNE LLMEVI_NotDDComet
	
	; Daredevil Comet music override!
	LDA #MUS2C_REDCOMET
	BNE LLMEVI_MusicOverride
	
LLMEVI_NotDDComet:
	CMP #MAPOBJ_PURPLECOMET
	BNE LLMEVI_NotPComet

	; Purple Comet music override!
	LDA #MUS2B_PURPLECOMET
	BNE LLMEVI_MusicOverride

LLMEVI_NotPComet
	; Bits 0-4 (SB) select a BGM
	LDA [Level_LayPtr_AddrL],Y
	AND #%00011111
	TAX
	LDA GamePlay_BGM,X	; A = target music
	LDX SndCur_Music2	; X = currently playing music

	CPX #MUS2B_PSWITCH
	BEQ PRG062_98DE		; If playing the P-Tab music, don't queue this song right now
	CPX #MUS2A_INVINCIBILITY		
	BEQ PRG062_98DE		; If playing the Invincibility music, don't queue this song right now

LLMEVI_MusicOverride:
	; Queue this music to play
	STA Level_MusicQueue

PRG062_98DE:
	; Set this as the music to "restore" to when P-Tab / Invincibility ends
	STA Level_MusicQueueRestore

	; Level_LayPtr_AddrL/H += 9 (i.e. move pointer to after the header)
	LDA <Level_LayPtr_AddrL
	ADD #$09
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

PRG062_98EE:
	LDY #$00	 		; Y = 0 (beginning of post-header)

	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	CMP #$ff	 		
	BEQ PRG062_9934	 		; If $FF, jump to PRG062_9934 (RTS)

	; Otherwise...
	STA <Temp_Var15			; Store byte into Temp_Var15

	INY		 		; Y++
	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	STA <Temp_Var16		 	; Store into Temp_Var16

	INY				; Y++
	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	STA LL_ShapeDef	 		; Store into LL_ShapeDef

	INY		 		; Y++
	TYA		 		; A = Y

	; Add current offset into Level_LayPtr_AddrL/H, moving it ahead
	ADD <Level_LayPtr_AddrL
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH
	
	LDA <Temp_Var15		 	; Retrieve first byte we read
	AND #$e0	 
	CMP #$e0	 
	BNE PRG062_991E	 		; If its upper 3 bits are not all set, jump to PRG062_991E

	; *****************
	; Upper 3 bits of Temp_Var15 are ALL set... i.e. Temp_Var15 = 111x xxxx
	; *****************

	JSR LoadLevel_StoreJctStart 	; Temp_Var16 and LL_ShapeDef define junction start positions
	JMP PRG062_98EE	 		; Loop around

PRG062_991E:

	; *****************
	; Upper 3 bits of Temp_Var15 are NOT ALL set... i.e. Temp_Var15 DOES *NOT follow* the mask 111x xxxx
	; *****************

	; Temp_Var15 and Temp_Var16 are the input parameters to LoadLevel_Set_TileMemAddr,
	; which set, most importantly, "Map_Tile_Addr" to some root screen address, and
	; set "TileAddr_Off" as an offset value within that screen.

	; "Map_Tile_Addr" is formed Tile_Mem_Addr[ (Temp_Var16 & $F0) >> 3 ]
	;	- The upper 4 bits of Temp_Var16 select the starting screen
	;
	; "TileAddr_Off" is formed (Temp_Var15 << 4) | (Temp_Var16 & $f)
	;	- The lower 4 bits of Temp_Var15, and lower 4 bits of Temp_Var16
	JSR LoadLevel_Set_TileMemAddr

	LDA LL_ShapeDef
	AND #$f0
	BEQ PRG062_992E	 	; If upper 4 bits of LL_ShapeDef are all zero, jump to PRG062_992E

	; *****************
	; Upper 4 bits of LL_ShapeDef are NOT ALL clear... i.e. LL_ShapeDef DOES *NOT follow* the mask 0000 xxxx
	; *****************

	; Otherwise, we handle this as a construction command, and so turn
	; to the "generators" which define what the bytes mean...
	JSR LeveLoad_Generators	

	JMP PRG062_9931	 	; (Essentially) loop around (pointless jump, heh)

PRG062_992E:
	; *****************
	; Upper 4 bits of LL_ShapeDef are ALL NOT set... i.e. LL_ShapeDef = 0000 xxxx
	; *****************

	; This is a fixed-size construction type
	JSR LeveLoad_FixedSizeGens

PRG062_9931:
	JMP PRG062_98EE	 	; Loop around...

PRG062_9934:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Set_TileMemAddr
;
; Used while loading a level.  Sets the Map_Tile_AddrL/H pointer
; to a specified "screen", and also sets TileAddr_Off to an offset
; within that screen.
;
; Takes input parameters of Temp_Var15 and Temp_Var16 and from 
; there generates:
;
; Guide to help visualize the input:
; Temp_Var15 Temp_Var16
; FEDC BA98  7654 3210	<-- bits
;
;
; * Map_Tile_AddrL/H points to Tile_Mem_Addr(V)[7654 0] <-- '0' is a one-up shift, not bit 0 of Temp_Var16; (V) is the "Vertical" table, used if applicable
;
; * If 'C' (bit 4) of Temp_Var15 is set, then Map_Tile_AddrH is incremented
;
; * Temp_Var5 = Map_Tile_AddrH + 1 -- Pre-'C' increment, ONLY WHEN NOT VERTICAL (otherwise unassigned)
;
; * Temp_Var6 = Map_Tile_AddrH -- Post-'C' increment (i.e. equals whatever Map_Tile_AddrH does at end of function)
;
; * TileAddr_Off = BA98 3210 -OR- (Temp_Var15 << 4) | (Temp_Var16 & $f)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Set_TileMemAddr:
	; Upper 3 bits of first byte were all set...


	LDA <Temp_Var15	 ; Get that first byte
	ASL A		
	ASL A		
	ASL A		
	ASL A		
	STA <Temp_Var7	 ; Temp_Var7 = Temp_Var15 << 4 (take lower 4 bits and multiply by 16)

	LDA <Temp_Var16	 ; Second byte
	AND #$0f	 ; Lower 4 bits
	ORA <Temp_Var7	 ; Applied to Temp_Var7
	STA TileAddr_Off	 ; Stored into TileAddr_Off

	; TileAddr_Off = BA98 3210 -OR- (first byte << 4) | (second byte & $f)


	LDA <Temp_Var16	 ; Second byte
	AND #$f0	 ; Upper 4 bits
	LSR A		 
	LSR A		 
	LSR A		 
	TAX		 ; X = (Temp_Var16 & $F0) >> 3 (value in upper 4 bits times 2, 2 byte index for Tile_Mem_Addr)

	; X = 7654 0 <-- '0' is a one-up shift, not bit 0 of Temp_Var16

	LDA Level_7Vertical
	BEQ PRG062_9963	 ; If not a vertical level, jump to PRG062_9963

	; Vertical level

	TXA
	LSR A
	TAX		; X >>= 1 (single byte index, since the Tile_Mem_AddrV lookup is split into two tables)

	; Load the target address into Map_Tile_AddrH/L
	LDA Tile_Mem_AddrVL,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,X
	STA <Map_Tile_AddrH

	JMP PRG062_997F	 ; Jump to PRG062_997F

PRG062_9963:

	; Non-vertical level

	CPX #$1e
	BNE PRG062_9969	 ; If X <> $1E (the max value), jump to PRG062_9969

	; Otherwise, X -= 2
	DEX
	DEX

PRG062_9969:

	; Load the target address into Map_Tile_AddrH/L
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	STA <Temp_Var5	
	INC <Temp_Var5		; Temp_Var5 = Map_Tile_AddrH + 1

	LDA <Temp_Var15	
	AND #$10	
	BEQ PRG062_997F		; If bit 4 of the first byte is not set, jump to PRG062_997F

	; Otherwise, Map_Tile_AddrH++
	INC <Map_Tile_AddrH

PRG062_997F:
	LDA <Map_Tile_AddrH
	STA <Temp_Var6		; Temp_Var6 = Map_Tile_AddrH

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Randomize
;
; Shakes up the random number pool a bit!
; Anyone want to detail the algorithm, go right ahead...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Randomize:
	LDX #$00	
	LDY #$09	
	LDA Random_Pool	
	AND #$02	
	STA <Temp_Var1	
	LDA RandomN	
	AND #$02	
	EOR <Temp_Var1	
	CLC		
	BEQ PRG062_999A	
	SEC		
PRG062_999A:
	ROR Random_Pool,X
	INX		 
	DEY		 
	BNE PRG062_999A	 

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_RecordBlockHit
;
; Called after a coin is collected or a hidden 1-Up is found.
; This records those events so if the level is swapped with its
; alternate, these things do not retun.  Next best thing to
; actually having enough memory to hold both levels together...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RecordBlockHitBits:
	.byte $80, $40, $20, $10, $08, $04, $02, $01

Level_RecordBlockHit:

	; Currently Temp_Var13-16 are defined as follows:
	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo
	; ... of Player detection coordinates

	TYA
	PHA		 ; Save 'Y'

	TXA
	PHA		 ; Save 'X'

	LDA <Temp_Var16
	PHA		 ; Save Temp_Var16

	LDA <Temp_Var13
	PHA		 ; Save Temp_Var13

	; This converts Temp_Var15/Temp_Var16 into a tile row stored in Temp_Var16
	; Essentially a 16-bit right shift 4 bits
	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var16
	LDA <Temp_Var15
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var16
	STA <Temp_Var16

	; This turns Temp_Var13 into an index into Level_BlockGrabHitMem
	LDA <Temp_Var16
	AND #%11111000
	LSR A
	LSR A
	ORA <Temp_Var13
	STA <Temp_Var13

	LDA Level_JctFlag
	BEQ PRG062_99DC	 ; If we're not junctioning, jump to PRG062_99DC

	; If junctioning, Temp_Var13 += $40
	LDA <Temp_Var13
	ADD #$40
	STA <Temp_Var13

PRG062_99DC:
	LDA <Temp_Var16
	AND #$07
	TAX
	LDY <Temp_Var13
	LDA Level_BlockGrabHitMem,Y
	ORA RecordBlockHitBits,X
	STA Level_BlockGrabHitMem,Y

	; Restore everything we saved
	PLA
	STA <Temp_Var13
	PLA
	STA <Temp_Var16
	PLA
	TAX
	PLA
	TAY

	RTS		 ; Return

TileLayout_ByTileset:
	; Defines the 8x8 blocks to build a particular 16x16 "tile"

	.word Tile_Layout_TS0		; 0 - Map
	.word Tile_Layout_TS1		; 1 - Plains [15]
	.word Tile_Layout_TS2		; 2 - Mini fortress style [21]
	.word Tile_Layout_TS3		; 3 - Hills style [16]
	.word Tile_Layout_TS4_TS12	; 4 - High-Up style [17]
	.word Tile_Layout_TS11_TS13	; 5 - Ghose House [36]
	.word Tile_Layout_TS6_TS8	; 6 - Water world [18]
	.word Tile_Layout_TS7	; 7 - Toad house [18]
	.word Tile_Layout_TS6_TS8	; 8 - Vertical pipe maze [18]
	.word Tile_Layout_TS9		; 9 - desert level [20]
	.word Tile_Layout_TS10		; 10 - airship [23]
	.word Tile_Layout_TS11_TS13	; 11 - Giant World [19]
	.word Tile_Layout_TS4_TS12	; 12 - ice level [17]
	.word Tile_Layout_TS11_TS13	; 13 - coin heaven / sky level [19]
	.word Tile_Layout_TS14		; 14 - underground [13]
	.word Tile_Layout_TS15		; 15 - ext [45]
	.word Tile_Layout_TS15_TS16_TS17; 16 - spade game sliders [22]
	.word Tile_Layout_TS15_TS16_TS17; 17 - N-spade [22]
	.word Tile_Layout_TS18		; 18 - 2P Vs [14]
	.word Tile_Layout_TS15_TS16_TS17; 19 - bonus game intro [22]

LevelLoad_ByTileset:
	LDA Level_Tileset
	JSR DynJump

	; Page numbers are determined by PAGE_A000_ByTileset and PAGE_C000_ByTileset, indexed by Level_Tileset

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word $0000			; 0 - Map [11] (not used)
	.word LevelLoad_TS1		; 1 - Plains [15]
	.word LevelLoad_TS2		; 2 - Mini fortress style [21]
	.word LevelLoad_TS3		; 3 - Hills style [16]
	.word LevelLoad_TS4_TS12	; 4 - High-Up style [17]
	.word LevelLoad_TS5		; 5 - Ghose House [36]
	.word LevelLoad_TS6		; 6 - Water world [18]
	.word LevelLoad_TS7		; 7 - Toad house [18]
	.word LevelLoad_TS8		; 8 - Vertical pipe maze [18]
	.word LevelLoad_TS9		; 9 - desert level [20]
	.word LevelLoad_TS10		; 10 - airship [23]
	.word LevelLoad_TS11		; 11 - Giant World [19]
	.word LevelLoad_TS4_TS12	; 12 - ice level [17]
	.word LevelLoad_TS13		; 13 - coin heaven / sky level [19]
	.word LevelLoad_TS14		; 14 - underground [13]
	.word LevelLoad_TS15	; 15 - ext
	
	.word LevelLoad_TS15_TS16_TS17	; 16 - spade game sliders [22]
	.word LevelLoad_TS15_TS16_TS17	; 17 - N-spade [22]
	.word LevelLoad_TS18		; 18 - 2P Vs [14]
	.word LevelLoad_TS15_TS16_TS17	; 19 - bonus game intro [22]


; RegEx S&R:
; LDA LL_ShapeDef.*\n.*AND #\$0f.*\n.*STA <Temp_Var(.)		 ; .*
; LDA LL_ShapeDef\n\tAND #$0f\n\tSTA <Temp_Var\1		 ; Temp_Var\1 = lower 4 bits of LL_ShapeDef

; LDA LL_ShapeDef.*\n.*AND #\$0f.*\n.*TAX		 ; .*
; LDA LL_ShapeDef\n\tAND #$0f\n\tTAX		 ; X = lower 4 bits of LL_ShapeDef

; LDA <Temp_Var(.).*\n.*STA <Temp_Var(.)		 ; .*
; LDA <Temp_Var\1\n\tSTA <Temp_Var\2		 ; Temp_Var\2 = Temp_Var\1

; DEC <Temp_Var(.)		 ; .*
; DEC <Temp_Var\1		 ; Temp_Var\1--

; LDA <Map_Tile_AddrL.*\n.*STA <Temp_Var1.*\n.*LDA <Map_Tile_AddrH.*\n.*STA <Temp_Var2.*
;; Backup Map_Tile_AddrL/H into Temp_Var1/2\n\tLDA <Map_Tile_AddrL\n\tSTA <Temp_Var1\n\tLDA <Map_Tile_AddrH\n\tSTA <Temp_Var2

; LDA <Temp_Var1.*\n.*STA <Map_Tile_AddrL.*\n.*LDA <Temp_Var2.*\n.*STA <Map_Tile_AddrH.*
;; Restore Map_Tile_Addr from backup\n\tLDA <Temp_Var1\n\tSTA <Map_Tile_AddrL\n\tLDA <Temp_Var2\n\tSTA <Map_Tile_AddrH

LeveLoad_Generators:
	LDA Level_Tileset
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LT0B				; 0 - Map [11] (not used, enters in the middle of nowhere, in a not logical place)
	.word LoadLevel_Generator_TS1		; 1 - Plains [15]
	.word LoadLevel_Generator_TS2		; 2 - Mini fortress style [21]
	.word LoadLevel_Generator_TS3		; 3 - Hills style [16]
	.word LoadLevel_Generator_TS4_TS12	; 4 - High-Up style [17]
	.word LoadLevel_Generator_TS5		; 5 - Ghose House [19]
	.word LoadLevel_Generator_TS68		; 6 - Water world [18]
	.word LoadLevel_Generator_TS7		; 7 - Toad house [18]
	.word LoadLevel_Generator_TS68		; 8 - Vertical pipe maze [18]
	.word LoadLevel_Generator_TS9		; 9 - desert level
	.word LoadLevel_Generator_TS10		; 10 - airship
	.word LoadLevel_Generator_TS1113	; 11 - Giant World
	.word LoadLevel_Generator_TS4_TS12	; 12 - ice level [17]
	.word LoadLevel_Generator_TS1113	; 13 - coin heaven / sky level [19]
	.word LoadLevel_Generator_TS14		; 14 - underground [13]
	.word LoadLevel_Generator_TS15		; 15 - ext
	.word LoadLevel_Generator_TS151617	; 16 - spade game sliders
	.word LoadLevel_Generator_TS151617	; 17 - N-spade
	.word LoadLevel_Generator_TS18		; 18 - 2P Vs
	.word LoadLevel_Generator_TS151617	; 19 - bonus game intro

LeveLoad_FixedSizeGens:
	LDA Level_Tileset
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LT0B				; 0 - Map [11] (not used, enters in the middle of nowhere, in a not logical place)
	.word LeveLoad_FixedSizeGen_TS1		; 1 - Plains
	.word LeveLoad_FixedSizeGen_TS2		; 2 - Mini fortress style
	.word LeveLoad_FixedSizeGen_TS3		; 3 - Hills style [16]
	.word LeveLoad_FixedSizeGen_TS4_TS12	; 4 - High-Up style [17]
	.word LeveLoad_FixedSizeGen_TS5		; 5 - Ghose House [36]
	.word LeveLoad_FixedSizeGen_TS68	; 6 - Water world
	.word LeveLoad_FixedSizeGen_TS7	; 7 - Toad house
	.word LeveLoad_FixedSizeGen_TS68	; 8 - Vertical pipe maze
	.word LeveLoad_FixedSizeGen_TS9		; 9 - desert level
	.word LeveLoad_FixedSizeGen_TS10	; 10 - airship
	.word LeveLoad_FixedSizeGen_TS1113	; 11 - Giant World [19]
	.word LeveLoad_FixedSizeGen_TS4_TS12	; 12 - ice level [17]
	.word LeveLoad_FixedSizeGen_TS1113	; 13 - coin heaven / sky level [19]
	.word LeveLoad_FixedSizeGen_TS14	; 14 - underground [13]
	.word LeveLoad_FixedSizeGen_TS15	; 15 - bonus game intro
	.word LeveLoad_FixedSizeGen_TS151617	; 16 - spade game sliders
	.word LeveLoad_FixedSizeGen_TS151617	; 17 - N-spade
	.word LeveLoad_FixedSizeGen_TS18	; 18 - 2P Vs
	.word LeveLoad_FixedSizeGen_TS151617	; 19 - bonus game intro

PRG062_9AA1:
	.byte $01, $FF

PRG062_9AA3:
	.byte $08, $F8

PRG062_9AA5:
	.byte $00, $08


TileLayoutPage_ByTileset:
	; A000 page selected per-Level_Tileset...
	.byte BANK(Tile_Layout_TS0)		; 0 - Map [11]
	.byte BANK(Tile_Layout_TS1)		; 1 - Plains [15]
	.byte BANK(Tile_Layout_TS2)		; 2 - Mini fortress style [21]
	.byte BANK(Tile_Layout_TS3)		; 3 - Hills style [16]
	.byte BANK(Tile_Layout_TS4_TS12)	; 4 - High-Up style [17]
	.byte BANK(Tile_Layout_TS5)		; 5 - Ghose House [36]
	.byte BANK(Tile_Layout_TS6_TS8)	; 6 - Water world [18]
	.byte BANK(Tile_Layout_TS7)	; 7 - Toad house [18]
	.byte BANK(Tile_Layout_TS6_TS8)	; 8 - Vertical pipe maze [18]
	.byte BANK(Tile_Layout_TS9)		; 9 - desert level [20]
	.byte BANK(Tile_Layout_TS10)		; 10 - airship [23]
	.byte BANK(Tile_Layout_TS11_TS13)	; 11 - Giant World [19]
	.byte BANK(Tile_Layout_TS4_TS12)	; 12 - ice level [17]
	.byte BANK(Tile_Layout_TS11_TS13)	; 13 - coin heaven / sky level [19]
	.byte BANK(Tile_Layout_TS14)		; 14 - underground [13]
	.byte BANK(Tile_Layout_TS15)	; 15 - ext [45]
	.byte BANK(Tile_Layout_TS15_TS16_TS17)	; 16 - spade game sliders [22]
	.byte BANK(Tile_Layout_TS15_TS16_TS17)	; 17 - N-spade [22]
	.byte BANK(Tile_Layout_TS18)		; 18 - 2P Vs [14]
	.byte BANK(Tile_Layout_TS15_TS16_TS17)	; 19 - bonus game intro [22]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Dirty_Update
;
; This function performs a full-screen redraw of all tiles, 
; used when first showing map/level, but not for scrolling!
; (Though it does call the same routine USED for scrolling)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Dirty_Update:
	LDA Level_7Vertical
	BNE PRG062_9B10	 	; If level is vertical, jump to PRG062_9B10

	; Non-vertical level
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	STA <Scroll_RightUpd,X	; Current horizontal scroll stored into appropriate left/right value

PRG062_9AC5:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	; Buffers a single 8x8 column of tiles
	JSR Scroll_DoColumn

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; Commits the buffer
	JSR Scroll_Commit_Column

	LDX <Scroll_LastDir	 ; X = Scroll_LastDir
	LDA <Scroll_RightUpd,X	 ; A = Get the last 8 pixel location update
	ADD PRG062_9AA3,X	 ; Add an appropriate offset given the direction of travel
	STA <Scroll_RightUpd,X	 ; Update it!

	; Produce the attribute data and commits the buffer
	JSR Scroll_Do_AttrColumn
	JSR Scroll_Commit_Column

	LDX <Scroll_LastDir	; Last direction to index the following
	LDA <Scroll_RightUpd,X	; Get updated column
	AND #$08	 	; Every half screen
	CMP PRG062_9AA5,X
	BNE PRG062_9B02	 	; For updating on half-tiles (??), jump to PRG062_9B02
	LDA <Scroll_ColumnR,X	
	ADD PRG062_9AA1,X
	STA <Scroll_ColumnR,X

PRG062_9B02:
	DEC Scroll_Cols2Upd	 ; Scroll_Cols2Upd--
	BNE PRG062_9AC5	 ; While Scroll_Cols2Upd <> 0, loop!

	LDA #$ff
	STA <Scroll_RightUpd		 ; Scroll_RightUpd = $ff (marker as in "not last updated"; flat for dirty)
	STA <Scroll_LeftUpd		 ; Scroll_LeftUpd = $ff (marker as in "not last updated"; flat for dirty)
	JMP SetPages_ByTileset	 ; JUMP to SetPages_ByTileset to reset pages (will take care of the RTS)

PRG062_9B10:

	; Scroll_LastDir = 0
	LDA #$00
	STA <Scroll_LastDir

	; Vert_Scroll = $E0
	LDA #$e0
	STA <Vert_Scroll

	; Scroll_RightUpd = $E8
	ADD #$08
	STA <Scroll_RightUpd

	; Scroll_ColumnR = (Level_SizeOrig - 1) | $E0
	LDY Level_SizeOrig	 ; Y = Level_SizeOrig
	DEY		 ; Y--
	TYA
	ORA #$e0
	STA <Scroll_ColumnR

PRG062_9B26:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	JSR VScroll_PageAndDoPatAttrRow	 ; Do the row of patterns and attributes for vertical scroll

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Scroll_ToVRAM_Apply	 ; Applies Scroll_ToVRAMHi and Scroll_ToVRAMHA updates
	JSR Scroll_ToVRAM_Apply	 ; Applies Scroll_ToVRAMHi and Scroll_ToVRAMHA updates

	LDA <Vert_Scroll
	ADD #$08
	STA <Vert_Scroll

	CMP #$f0
	BNE PRG062_9B59	 ; If not changing to new screen, jump to PRG062_9B59

	INC <Scroll_VOffsetT		 ; Scroll_VOffsetT++

	; Loop vertical offset to new screen
	LDA <Scroll_VOffsetT
	AND #$0f
	STA <Scroll_VOffsetT

	JMP PRG062_9B66	 ; Jump to PRG062_9B66

PRG062_9B59:
	LDA <Vert_Scroll
	AND #$08
	BNE PRG062_9B66	 ; If only halfway vertically through tile row, jump to PRG062_9B66

	; Otherwise, go to next row
	LDA <Scroll_VOffsetT
	ADD #$10
	STA <Scroll_VOffsetT

PRG062_9B66:
	LDA <Vert_Scroll
	CMP #$d0
	BNE PRG062_9B26	 ; While Vert_Scroll <> $D0, loop!

	LDA #$00
	STA <Vert_Scroll	; Vert_Scroll = 0
	STA <Scroll_VertUpd	; Scroll_VertUpd = 0

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Update
;
; This subroutine updates one column of tiles worth
; of scroll (tile and attribute) as needed per
; changes in Horz_Scroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Update:
	LDA Level_7Vertical
	BNE PRG062_9BB2	 	; If this is a vertical scroller world, jump to PRG062_9BB2

	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	AND #$f8		; Only caring about every 8 pixels (for valid comparison to Scroll_RightUpd)
	CMP <Scroll_RightUpd,X	; Compared to whichever update applies to the last scroll
	BEQ PRG062_9BA9	 	; If we are updated completely, jump to PRG062_9BA9

	; Otherwise ...
	TAY		 	; Y = A (Horz_Scroll, 8 pixel aligned)

	LDA Scroll_Cols2Upd
	BNE PRG062_9B9B	 	; If columns remain to be updated, jump to PRG062_9B9B

	LDA <Horz_Scroll
	AND #$07		; How many pixels across a tile boundary of 8 (0 - 7)

	CPX #$00
	BNE PRG062_9B97	 	; If last scroll direction <> 0 (last moved left), jump to PRG062_9B97

	; Last moved right...
	CMP #$02
	BGE PRG062_9B9B	 	; If greater-or-equal to 2 pixels to the right, jump to PRG062_9B9B

	JMP PRG062_9BA9	 	; Otherwise, jump to PRG062_9BA9

PRG062_9B97:
	; Last moved left...

	CMP #$05
	BGE PRG062_9BA9	 ; If greater-or-equal to 5 pixels in (complement to 2 pixels from right case), jump to PRG062_9BA9

	; Otherwise...

PRG062_9B9B:
	STY <Scroll_RightUpd,X	 ; Store our right/left update

	LDA <Scroll_LastDir
	EOR #$01	 
	TAX		 
	LDA #$ff	 
	STA <Scroll_RightUpd,X	 ; Store $FF on the other side

	JSR Scroll_DoColumn	 ; Render a column of tiles...

PRG062_9BA9:
	LDA Scroll_UpdAttrFlag	
	BEQ PRG062_9BB1	 	; If Scroll_UpdAttrFlag is not set (not time to update attributes), jump to PRG062_9BB1 (RTS)

	JSR Scroll_Do_AttrColumn ; Otherwise, Render a column of attributes...

PRG062_9BB1:
	RTS		 ; Return


PRG062_9BB2:
	LDA <Vert_Scroll
	AND #$f8
	CMP <Scroll_VertUpd
	BEQ PRG062_9BD2	 ; If the vertical scroll hasn't changed 8 pixels, jump to PRG062_9BD2 (RTS)

	; Otherwise, change the Scroll_VertUpd value
	LDA <Vert_Scroll
	AND #$f8
	STA <Scroll_VertUpd

VScroll_PageAndDoPatAttrRow:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	JSR VScroll_CalcPatternVRAMAddr	 ; Calculate start of pattern row
	JSR VScroll_DoPatternAndAttrRow	 ; Do the pattern row AND attributes

PRG062_9BD2:
	RTS		 ; Return

PRG062_9BD3:	.byte $00, $01

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_DoColumn	
;
; This subroutine renders a "column" of 8x8 blocks for the
; screen scrolling.  Also used by the "dirty update" routine
; to sweep across and render the blocks...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_DoColumn:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Scroll_RightUpd,X	; Related last update value
	AND #$08	 	; Take just whether we've moved onto an 8
	LSR A		 	
	LSR A		 
	LSR A		 
	STA <Scroll_OddEven	; <Scroll_OddEven is 0 for 0, 1 for 8
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	AND #$0f	 	; A is now 0-15
	CPX #$00	 	
	BNE PRG062_9BFD	 	; If Scroll_LastDir = 0 (last scrolled right), jump to PRG062_9BFD

	; Last scrolled left
	CMP #$04	 	
	BGE PRG062_9C01	 ; If the horizontal scroll is 4-15, jump to PRG062_9C01
	JMP PRG062_9C06	 ; Otherwise, jump to PRG062_9C06

PRG062_9BFD:
	; Last scrolled right
	CMP #12	
	BGE PRG062_9C06	 ; If the horizontal scroll is 12-15, jump to PRG062_9C06

PRG062_9C01:	; (Scrolled left and scroll is 4-15) OR (Scrolled right and scroll is 0-11)

	; Scroll_UpdAttrFlag = 1 (time to update attributes!)
	LDA #$01
	STA Scroll_UpdAttrFlag

PRG062_9C06:
	LDA Level_Tileset 
	ASL A		 ; A = Level_Tileset << 1 (index into TileLayout_ByTileset)
	TAY		 ; -> 'Y'

	; A tile is laid out like:
	; 02
	; 13

	; Store the low byte of the address into Temp_Var11/Temp_Var13
	; This defines addresses used to look up the construction of a tile
	; by its index number; note that top and bottom half use a common
	; low byte.
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var11		 
	STA <Temp_Var13		 

	; The following takes the high byte of the "TileLayout_ByTileset"
	; and either adds nothing or a jump of 512, and still adds a jump of
	; 256 to the after address 
	LDX TileLayout_ByTileset+1,Y	; X = High byte of address (block 0 of tile)
	LDA <Scroll_OddEven		; A = Scroll_OddEven
	BEQ PRG062_9C1B			; If Scroll_OddEven = 0, jump to PRG062_9C1B
	INX		 		; +256 (block 1)
	INX		 		; +256 (block 2) beginning of the right half

PRG062_9C1B:
	STX <Temp_Var12		; High byte [?] into Temp_Var12
	INX		 		; block 1 or 3, depending on Scroll_OddEven
	STX <Temp_Var14		; High byte [?] into Temp_Var14

	LDX <Scroll_LastDir		; X = Scroll_LastDir
	LDA <Scroll_ColumnR,X	 	; A = appropriate current column (right or left)
	AND #$f0	 	 	; Checking what screen we're on (every 16 columns is a screen's worth)
	LSR A		 
	LSR A		 
	LSR A		 
	TAY		 		; Y = ((Scroll_ColumnR & $F0) >> 3), or basically, 2 for every screen we've moved (for indexing...)

	; Set the address of the tiles we need to modify!
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var15	
	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var16	

	LDA #26	 		; Number of rows to update (NTSC res of 224, two screens tall, is 448 / 16px-per-tile = 26)
	STA <Temp_Var1		; Temp_Var1 = 26 (see immediately above)
	LDA <Scroll_ColumnR,X	; Get the column we're on
	AND #$0f	 	; Make it relative to THIS screen, 0-15
	STA <Temp_Var2		; Temp_Var2 stores this value

	LDX #$00	 	; X = 0
PRG062_9C40:
	LDY <Temp_Var2		; Y = Temp_Var2 (screen relative column)
	LDA [Temp_Var15],Y	; Get tile to display
	TAY		 	; Tile becomes offset 'Y'

	; Store the top block for this tile
	LDA [Temp_Var11],Y
	STA Scroll_PatStrip,X

	; Store the bottom block for this tile
	LDA [Temp_Var13],Y
	STA Scroll_PatStrip+1,X

	LDA <Temp_Var2
	ADD #16	
	STA <Temp_Var2	 	; Temp_Var2 += 16 (next row in this column is 16 bytes down)
	BCC PRG062_9C5A	 	; If we haven't overflowed, jump to PRG062_9C5A
	INC <Temp_Var16	; Otherwise we need to increment the upper part of the tile address
PRG062_9C5A:
	INX		 
	INX		 ; X += 2 (two tiles added)

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG062_9C40	 ; If more tiles to go, loop!


	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Scroll_ColumnR,X	; A = last column value
	AND #$0f	 	; Screen column relative
	ASL A		 	; A << 1 (0, 2, 4, ... E)
	ORA <Scroll_OddEven	; Apply the odd/even (forms an 8x8 current column)
	STA Scroll_LastCol8	; Store this in Scroll_LastCol8

	LDA #$20	 	; 
	STA Scroll_ToVRAMHi	; Scroll_ToVRAMHi = $20
	JMP SetPages_ByTileset	; JUMP to SetPages_ByTileset (restores page A000 most importantly, and will do the RTS)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Do_AttrColumn
;
; This subroutine renders a "column" of attributes for the
; screen scrolling.  Also used by the "dirty update" routine
; to sweep across and render the blocks...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG062_9C74:
	.byte $F1, $01

PRG062_9C76:
	.byte $ff, $0f

Scroll_Do_AttrColumn:
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDY <Scroll_ColumnR,X	; Y = get column
	TYA		 	; A = Y
	AND #$01	 	; Get odd/even
	BEQ PRG062_9C87	 	; If even, jump to PRG062_9C87

	TYA		 	; A = back to column again
	ADD PRG062_9C76,X	; Add appropriate value, whether going right or left (-1 or +15)
	TAY		 	; Y = A

PRG062_9C87:
	STY <Temp_Var1		; column, possibly offset, into Temp_Var1
	LDA #$00	 	
	STA <Temp_Var2		; Temp_Var2 = 0

PRG062_9C8D:
	LDA <Temp_Var1		; A = Temp_Var1 (column, possibly offset)
	AND #$f0	 	; Figure out which SCREEN we're on
	LSR A		 
	LSR A		 
	LSR A		 	; A >> 3 (2 byte per screen index)
	TAY		 	; Y = A

	; Setup pointer to tile memory we need to be focusing on!
	LDA Tile_Mem_Addr,Y	
	STA <Temp_Var15		
	LDA Tile_Mem_Addr+1,Y	
	STA <Temp_Var16	

	LDX <Temp_Var2	 	; X = Temp_Var2
	LDA <Temp_Var1	 	; A = Temp_Var1
	AND #$0f	 	; Current screen-relative column
	TAY		 	; Y = A (screen relative column)
PRG062_9CA6:
	LDA [Temp_Var15],Y	; Get next tile
	AND #$c0	 	; Set attributes based on the "range" of the tile, like palette 0 for tiles 00-3f, palette 1 for tiles 40-7f, etc.
	STA <Scroll_ColorStrip,X	; Store this into the attribute strip
	TYA		 	; A = Y (the tile offset)
	ADD #16		 	; A += 16 (every tile row is 16 bytes)
	TAY		 	; Y = A
	BCC PRG062_9CB5	 	; If we didn't overflow, jump to PRG062_9CB5
	INC <Temp_Var16	; Increment the high byte
PRG062_9CB5:
	INX			; X++ (next byte in the Scroll_ColorStrip)
	STX <Temp_Var2		; Temp_Var2 = X
	CPX #27	
	BNE PRG062_9CD0	 	; If X <> 27, jump to PRG062_9CD0

	; X is 27, we need to go to the next page
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDY <Scroll_ColumnR,X	; Get the column
	TYA		 	; A = Y
	AND #$01	 	; 
	BNE PRG062_9CCB	 	; If odd, jump to PRG062_9CCB
	TYA			; A = Y (back to the column)
	ADD PRG062_9C74,X
	TAY		 	; -> 'Y'
PRG062_9CCB:
	STY <Temp_Var1		; -> Temp_Var1
	JMP PRG062_9C8D	 	; Loop around again...

PRG062_9CD0:
	CPX #54
	BNE PRG062_9CA6	 ; If A <> 54, loop!


	LDY #$00	 ; Y = 0
	LDX #$00	 ; X = 0 

PRG062_9CD8:
	; Attributes store colors for 4 tiles in one byte, this
	; forms the coloring information for all four blocks; this
	; also explains the odd-but-necessary offsets
	LDA <Scroll_ColorStrip,X
	LSR A		 
	LSR A		 ; A >>= 2
	ORA <Scroll_ColorStrip+27,X
	LSR A		 
	LSR A		 ; A >>= 2 
	ORA <Scroll_ColorStrip+1,X
	LSR A		 
	LSR A		 ; A >>= 2
	ORA <Scroll_ColorStrip+28,X

	STA Scroll_AttrStrip,Y
	INX		 ; X++
	INX		 ; X++
	CPY #$07	 
	BNE PRG062_9CF8	 ; If Y <> 7, jump to PRG062_9CF8

	; Only store half the attribute data on row 7
	LDA Scroll_AttrStrip,Y	
	AND #$0f
	STA Scroll_AttrStrip,Y	
	DEX		 ; X--	; Redo other half later!

PRG062_9CF8:
	INY		 ; Y++
	CPY #14	 	 
	BNE PRG062_9CD8	 ; If Y <> 14, loop!

	LDA #$23	 
	STA Scroll_ToVRAMHA	; Scroll_ToVRAMHA = $23
	LDX <Scroll_LastDir	
	LDA <Scroll_ColumnR,X	; Get column
	AND #$0f	 	; Screen relative
	LSR A		 	; A >> 1 (every two blocks when dealing with attributes)
	ORA #$c0	 	; $C0 is the base offset into Attribute Table 0/2
	STA Scroll_LastAttr	; Store into Scroll_LastAttr

	; Scroll_UpdAttrFlag = 0
	LDA #$00	 
	STA Scroll_UpdAttrFlag

	RTS		 	; Return!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_CalcPatternVRAMAddr
;
; Calculates Scroll_ToVRAMHi/Lo for patterns for the current vertical scroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
VScroll_CalcPatternVRAMAddr:
	LDX <Scroll_LastDir	; X = Scroll_LastDir

	; Calculate VRAM High into nametable for this offset
	LDA <Scroll_VOffsetT,X
	AND #$c0
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	ADD #$20
	STA Scroll_ToVRAMHi

	; Calculate VRAM Low into nametable for this offset
	LDA <Scroll_VOffsetT,X
	AND #$30
	ASL A
	ASL A
	STA Scroll_LastOff8

	LDA <Vert_Scroll
	AND #$08
	BEQ PRG062_9D3E	 ; If not on odd row, jump to PRG062_9D3E (RTS)

	; +32 bytes to offset to reach next tile row in VRAM
	LDA Scroll_LastOff8
	ADD #32
	STA Scroll_LastOff8

PRG062_9D3E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_DoPatternAndAttrRow
;
; This subroutine renders a "row" of 8x8 blocks for the vertical
; screen scrolling.  Also creates the attributes for the same.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
VScroll_DoPatternAndAttrRow:
	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
	AND #$0f
	TAY		 ; Y = offset column

	; Get address of tile at this vertical position
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Temp_Var9 = offset at leftmost column in current row
	LDA <Scroll_VOffsetT,X
	AND #$f0
	STA <Temp_Var9

	; Temp_Var10 = 0
	LDA #$00
	STA <Temp_Var10

PRG062_9D5A:
	LDY <Temp_Var9		 ; Y = current offset along row
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	STA <Temp_Var11		 ; -> Temp_Var11

	INC <Temp_Var9		 ; Temp_Var9++ (next column)

	JSR TileLayout_GetBaseAddr	 ; Get tile layout address -> Temp_Var13/14

	LDX <Temp_Var10		 ; X = Temp_Var10

	LDA <Vert_Scroll
	AND #$08
	BEQ PRG062_9D6F	 ; If not vertically halfway on the tile, jump to PRG062_9D6F

	INC <Temp_Var14		 ; Otherwise, Temp_Var14++ (next row of layout)

PRG062_9D6F:
	LDA [Temp_Var13],Y	 ; Get pattern of tile
	STA Scroll_PatStrip,X	 ; Store into pattern strip

	INX		 ; X++ (next pattern strip byte)

	; Temp_Var14 += 2 (next adjacent tile pattern)
	INC <Temp_Var14
	INC <Temp_Var14

	LDA [Temp_Var13],Y	 ; Get pattern of tile
	STA Scroll_PatStrip,X	 ; Store into pattern strip

	INX		 ; X++ (next pattern strip byte)

	STX <Temp_Var10		 ; X -> Temp_Var10

	CPX #$20
	BLT PRG062_9D5A	 ; If not at end of strip row, loop

	LDA Scroll_LastOff8
	CMP #$20
	BEQ PRG062_9D92	 ; If Scroll_LastOff8 = $20 (end of top row), jump to PRG062_9D92

	CMP #$a0
	BEQ PRG062_9D92	 ; If Scroll_LastOff8 = $A0 (end of bottom row), jump to PRG062_9D92

	BNE PRG062_9D98	 ; Otherwise, jump to PRG062_9D98 (RTS)

PRG062_9D92:
	JSR VScroll_CalcAttributeVRAMAddr	; Calculate the attribute VRAM addresses
	JSR Scroll_Do_AttrRow	 		; Do row of attributes

PRG062_9D98:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_CalcAttributeVRAMAddr
;
; Calculates Scroll_ToVRAMHA/Scroll_LastAttr for attributes for the current vertical scroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
VScroll_CalcAttributeVRAMAddr:

	; VRAM High address to attributes
	LDA #$23
	STA Scroll_ToVRAMHA

	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

	; VRAM Low address to attributes
	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
	AND #$c0
	LSR A
	LSR A
	ADD #$c0
	STA Scroll_LastAttr

	LDA <Scroll_VOffsetT,X
	AND #$20
	BEQ PRG062_9DBB	

	; Scroll_LastAttr += 8
	LDA Scroll_LastAttr
	ADD #$08
	STA Scroll_LastAttr

PRG062_9DBB:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Do_AttrRow
;
; This subroutine renders a "row" of attributes for the
; screen scrolling.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Do_AttrRow:
	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
	AND #$0f
	TAY		 ; Y = offset column

	; Get address of tile at this vertical position
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Temp_Var9 = offset at leftmost column in current row
	LDA <Scroll_VOffsetT,X
	AND #$f0
	STA <Temp_Var9

	AND #$10
	BNE PRG062_9DDE

	LDA <Temp_Var9
	ADD #$10
	STA <Temp_Var9 

PRG062_9DDE:
	INC <Temp_Var9		 ; Temp_Var9++ (next column)

	; Temp_Var8 = 0
	LDA #$00
	STA <Temp_Var8
PRG062_9DE4:
	LDY <Temp_Var9		 ; Y = current offset along row
	JSR VScroll_TileQuads2Attrs	 ; Create attribute bits out of tile values

	; Y -= 15 (previous row; 15 because VScroll_TileQuads2Attrs already subtracted 1)
	TYA
	SUB #$0f
	TAY

	JSR VScroll_TileQuads2Attrs	 ; Create attribute bits out of tile values

	; Temp_Var9 += 2 (next 2 columns over)
	INC <Temp_Var9
	INC <Temp_Var9

	; Temp_Var8++ (next Scroll_AttrStrip byte)
	INC <Temp_Var8

	LDA <Temp_Var8
	CMP #$08
	BLT PRG062_9DE4	 ; While not at end of row, loop

	LDA Scroll_LastAttr
	CMP #$f8
	BNE PRG062_9E11

	LDY #$07	 ; Y = 7
PRG062_9E06:

	LDA Scroll_AttrStrip,Y
	AND #$0f
	STA Scroll_AttrStrip,Y

	DEY		 ; Y--
	BPL PRG062_9E06	 ; While Y >= 0, loop

PRG062_9E11:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; TileLayout_GetBaseAddr
;
; Set layout pointer for the active tileset -> Temp_Var13/14
; also reloads 'Y' with the tile in Temp_Var11
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TileLayout_GetBaseAddr:
	LDA Level_Tileset 
	ASL A
	TAX		 ; X = Level_Tileset * 2

	; Set Temp_Var13/14 to point to the layout data for this Tileset
	LDA TileLayout_ByTileset,X
	STA <Temp_Var13
	LDA TileLayout_ByTileset+1,X
	STA <Temp_Var14

	LDY <Temp_Var11		 ; Y = tile temp

	RTS		 ; Return


VScroll_TileQuads2Attrs:
	LDX <Temp_Var8		 ; X = Temp_Var8 (Scroll_AttrStrip offset)

	LDA [Map_Tile_AddrL],Y	 ; Get the tile

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits
	ASL A
	ROL Scroll_AttrStrip,X
	ASL A
	ROL Scroll_AttrStrip,X

	DEY		 ; Y--

	LDA [Map_Tile_AddrL],Y	 ; Get the tile

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits
	ASL A
	ROL Scroll_AttrStrip,X
	ASL A
	ROL Scroll_AttrStrip,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTileV
;
; Gets tile in vertical level
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetTileV:	; $9E3C 

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	LDA <Temp_Var13	 ; A = Temp_Var13 (Y Hi)
	PHA		 ; Save it
	TAY		 ; Y = Y Hi

	LDA <Temp_Var14	 ; A = Temp_Var14 (Y Lo)
	PHA		 ; Save it

	JSR LevelJct_GetVScreenH

	STA <Temp_Var14	 ; Adjusted Y for vertical -> Temp_Var14

	; Select root offset into tile memory
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Combine positions into Temp_Var15 to form tile mem offset
	LDA <Temp_Var14
	AND #$f0
	STA <Temp_Var15

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var15

	TAY		 ; Offset -> 'Y'

	PLA		 ; Restore original value for Temp_Var14
	STA <Temp_Var14	 ; Store it

	PLA		 ; Restore original value for Temp_Var13
	STA <Temp_Var13	 ; Store it

	LDA [Map_Tile_AddrL],Y	 ; Get tile
	STA <Level_Tile	 ; Store into Level_Tile

	RTS		 ; Return


	; This is basically a lookup for any given "Player Y Hi" shifted up 4 bits
PRG062_9E6C:
	.byte $00, $10, $20, $30, $40, $50, $60, $70, $80, $90, $A0, $B0, $C0, $D0, $E0, $F0

	; Translates the Player position into appropriate "high" value
	; as Vertical describes it ($0(00), $0(F0), $1(E0), ...)
LevelJct_GetVScreenH:
	; Y = Player_YHi
	; A = Player_Y

	CPY #$00
	BLS PRG062_9E8E	 ; If Y < 0 (i.e. if the Player Y High is less than zero, which shouldn't happen!), jump to PRG062_9E8E (RTS)

	ADD PRG062_9E6C,Y	; Player_Y += Player_YHi[Y]
	BCS PRG062_9E8A	 	; If carry set (overflow occurred), jump to PRG062_9E8A

	CMP #$f0	
	BLT PRG062_9E8E	 	; If result is < $F0, jump to PRG062_9E8E

PRG062_9E8A:
	; Add $10 and roll over 'Y' (Considered in the lower vertical half)
	ADD #$10
	INY	

PRG062_9E8E:
	RTS		 ; Return


	; Something similar to LevelJct_GetVScreenH, but I'm 
	; not quite following the purpose
LevelJct_GetVScreenH2:
	; A = Player_Y
	; Y = Player_YHi
	CPY #$00
	BLS PRG062_9E9A	 ; If YHi < 0 (shouldn't happen?), jump to PRG062_9E9A

	SUB PRG062_9E6C,Y
	BCS PRG062_9E9A	 ; If carry set, jump to PRG062_9E9A

	DEY		 ; Y--

PRG062_9E9A:
	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTileAndSlope_Normal
;
; Get tile and slope for given position and offset
; for non-vertical ("normal") levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetTileAndSlope_Normal:	; $9E9D

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	; Clear slope array
	LDA #$00	
	STA <Player_Slopes
	STA <Player_Slopes+1	; Not used; see below with Temp_Var1 assignment
	STA <Player_Slopes+2	; Not used; see below with Temp_Var1 assignment

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Level_TileOff	 ; Level_TileOff = Temp_Var16 >> 4 (current column Player is in)

	LDA <Temp_Var15
	AND #$0f	
	ASL A		
	TAX		 ; X = (Temp_Var15 & $0F) << 1 (current "high" part of Player X shifted up by 1, indexing Tile Mem)

	; Set Map_Tile_AddrL/H to appropriate screen based on Player's position
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	LDA <Temp_Var13
	BEQ PRG062_9EC3	 ; If Temp_Var13 (Y Hi) = 0, jump to PRG062_9EC3

	INC <Map_Tile_AddrH ; Otherwise, go to second half of screen

PRG062_9EC3:
	LDA <Temp_Var14
	AND #$f0
	ORA <Level_TileOff	 ; Level_TileOff gets the Player's current row in the upper 4 bits

	; Level_TileOff is now Player's current offset in Tile Mem from the selected pointer

	STA <Temp_Var12		 ; ... and copied into Temp_Var12

	TAY		 	; Y = current offset
	LDA [Map_Tile_AddrL],Y	; Get tile here
	STA <Level_Tile	; Store into Level_Tile

	LDY Level_Tileset
	CPY #3
	BEQ PRG062_9EDB	 ; If Level_Tileset = 3 (Hills style), jump to PRG062_9EDB

	CPY #14
	BNE PRG062_9F0D	 ; If Level_Tileset <> 14 (Underground), jump to PRG062_9F0D

PRG062_9EDB:
	; NOTE: Temp_Var1 = 0 and is used directly; at one time there was probably some kind
	; of loop here that would have implicated Player_Slopes+1 and Player_Slopes+2
	LDA #$00
	STA <Temp_Var1		 ; Temp_Var1 = 0

	LDY <Temp_Var12		 ; Y = current offset in Tile Mem
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	STA <Temp_Var2		 ; Store into Temp_Var2

PGSAT_GetSlope:
	LDA <Temp_Var2		 ; Re-get tile
	AND #$c0
	CLC
	ROL A
	ROL A
	ROL A
	TAY		; Y = tile quadrant (0 to 3)

	LDA <Temp_Var2		 ; Re-get tile
	CMP Tile_AttrTable,Y
	BLT PRG062_9F0D	 	; If it's less than the tile specified in Tile_AttrTable[Y], jump to PRG062_9F0D

	TYA
	ASL A
	TAX		 ; X = Y (tile quadrant) << 1 (two byte index)

	; Temp_Var3/4 are loaded with address inside PRG000_C000
	LDA Level_SlopeSetByQuad,X
	STA <Temp_Var3
	LDA Level_SlopeSetByQuad+1,X
	STA <Temp_Var4

	LDX <Temp_Var1	 	; X = Temp_Var1 (always 0)
	LDA <Temp_Var2	 	; A = Temp_Var2 (the retrieved tile)
	SUB Tile_AttrTable,Y	; Subtract the root tile value
	TAY		 	; Y = result

	LDA [Temp_Var3],Y		; Get value 
	STA <Player_Slopes,X	; Store into Player_Slopes

PRG062_9F0D:
	LDA <Level_Tile	; A = Level_Tile (the tile retrieved)
	RTS		 ; Return


PRG062_SUB_9F40:
	LDA #$00
	STA Raster_State 	; Reset Raster_State

	LDA Update_Request
	JMP PRG063_F499


	; Sub part of A0 mode of IRQ
PRG062_SUB_9F50:
	; Some kind of delay loop?
	LDX #$17	 ; X = $17
PRG062_9F52:
	NOP		 ; ?
	DEX		 ; X--
	BPL PRG062_9F52 ; While X > 0, loop

	; Latch this value, and force it into the counter!
	STA MMC3_IRQLATCH
	STA MMC3_IRQDISABLE
	STA MMC3_IRQENABLE
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_SetupCPStart (SB)
;
; Configures checkpoint start position and scroll for starting
; Player at checkpoint rather than level header position
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_SetupCPStart:

	; Level_SelXStart magic value that means to not set X pixel start from level header
	LDA #$80
	STA Level_SelXStart

	; Set X pixel start for Player
	LDA LevCP_X,X
	STA <Player_X
	LDA LevCP_XHi,X
	STA <Player_XHi
		
	; Set Y pixel start for Player
	LDA LevCP_Y,X
	STA <Player_Y
	LDA LevCP_YHi,X
	STA <Player_YHi

	; Scroll position settings (FIXME VERTICAL)

	LDA Level_Width
	BEQ LevCP_OneScreenNoX	; On single screen level, don't set horizontal

	; Set horizontal scroll as Player X - $80
	LDA <Player_X
	SUB #$80
	STA <Horz_Scroll
	LDA <Player_XHi
	SBC #0
	STA <Horz_Scroll_Hi

LevCP_OneScreenNoX:
	; Vertical scroll is tightly bound and therefore tricky...

	; Set vertical scroll as Player Y - 34
	LDA <Player_Y
	SUB #34
	STA <Vert_Scroll
	LDA <Player_YHi
	SBC #0
	BEQ CPVScr_Done		; If we didn't overflow, jump to CPVScr_Done
	BPL CPVScr_OFNotNeg	; If this component is high, we overflowed, jump to CPVScr_OFNotNeg

	; Went negative, use zero for scroll
	LDA #0
	STA <Vert_Scroll
	BEQ CPVScr_Done		; Jump (technically always) to CPVScr_Done
	
CPVScr_OFNotNeg:
	; Overflowed, use $EF for scroll
	LDA #$EF
	STA <Vert_Scroll

CPVScr_Done:

	; Need to fix for special case of Level_FreeCPVScr = 2 (lock it absolute top or absolute bottom)
	LDA Level_FreeVertScroll
	CMP #2
	BNE CPVScr_NotFixed		; If not using the lock scroll type, jump to CPVScr_NotFixed
	
	; Need to lock high/low
	LDA <Vert_Scroll
	CMP #$B0
	BLT CPVScr_FixedLow		; If scroll is < $B0, jump to CPVScr_FixedLow
	
	; Low enough; lock bottom low
	LDA #$EF
	BNE CPVScr_SetVS	; Jump (technically always) to CPVScr_SetVS

CPVScr_FixedLow:
	LDA #0
	
CPVScr_SetVS:
	STA <Vert_Scroll

CPVScr_NotFixed:
	; Setup scroll ranges as appropriate
	JSR LevelScroll_Set_Ranges

	; Set Scroll_ColumnR equal to Scroll_ColumnL; dirty sweep will fix Scroll_ColumnR
	LDA <Scroll_ColumnL
	STA <Scroll_ColumnR

	RTS



IntIRQ_32PixelPartition_Part5:
	NOP		 ; ?
	DEX		 ; X--
	BPL IntIRQ_32PixelPartition_Part5 ; While X > 0, loop

	; More NOPs
	NOP
	NOP
	NOP

	STA MMC3_IRQLATCH ; Latch A (last set to 27!)
	STA MMC3_IRQENABLE ; Enable IRQ again
	JMP PRG063_FA3C	 ; Jump to PRG063_FA3C

IntIRQ_32PixelPartition_Part2:	; $9FA0
	LDA Update_Request	 
	AND #UPDATERASTER_32PIXSHOWSPR
	BNE PRG062_9FAA	 ; If UPDATERASTER_32PIXSHOWSPR is set, go to PRG062_9FAA

	; Otherwise, change loaded pattern tables to hide sprites that fall beneath the 32 pixel partition
	JMP IntIRQ_32PixPart_HideSprites

PRG062_9FAA:

	; I think the following NOPs and loop are to help synchronize the IRQ
	; routine if it didn't perform the IntIRQ_32PixPart_HideSprites step
	NOP
	NOP
	NOP

	LDX #$03	 ; X = 3
PRG062_9FAF:
	NOP		 ; ?
	DEX		 ; X--
	BPL PRG062_9FAF	 ; While X > 0, loop

	JMP IntIRQ_32PixelPartition_Part3


Input_ReverseUpDown:
	PHA		; Save input (Pad_Input or Pad_Holding)
	PHA		; Save input (Pad_Input or Pad_Holding)

	; Reverse up/down bits
	AND #PAD_UP		; Take current "up" status...
	LSR A			; ... move it into "down" bit...
	STA <Temp_Var1	; -> Temp_Var1
	
	PLA		; Restore input (Pad_Input or Pad_Holding)
	AND #PAD_DOWN	; Take current "down" status...
	ASL A			; ... move it into "up" bit...
	ORA <Temp_Var1	; ... combine with reversed up
	STA <Temp_Var1	; -> Temp_Var1

	PLA		; Restore input (Pad_Input or Pad_Holding)
	AND #~(PAD_UP | PAD_DOWN)
	ORA <Temp_Var1
	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Debug_GetStarCoins
;
; Used by debug menu to run proper map completions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Debug_GetStarCoins:
	; Load page 11 into A000 and page 10 into C000
	LDA #10
	STA PAGE_C000
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_Both2	
	
	JSR Map_DebugGetStarCoins
	JSR Debug_SetCompletedToWorld
	
	; Load page 24 into A000 and page 25 into C000
	LDA #25
	STA PAGE_C000
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_Both2
	
	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Game_SaveData
;
; Write out save data!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; SAVE FORMAT:
	;	High world reached	(1)  	[Mainly for display purposes, but also starts on this world]
	;	Star Coins Collect	(2)		[Display purposes only, star coins are calculated live]
	;	Map_Completions 	(128)
	;	Map_ObjCompletions	(10)
	;	Map_CometMode		(1)
	;	Inventory_Items 	(9)
	;	Inventory_Score		(3)
	;	Inventory_Score2	(3)	@157
	;	... 
	;	Checksum			(2)
	
	; NOTE: If we keep it no larger than 170, we can have 3 slots!
	; Keep even length for Checksum

	; Save idea:
	;	Create 32-bit sum by adding 16-bit components (two bytes at a time)
	;	"Fold" sum by summing upper 16-bit with lower 16-bit
	;	EOR $FFFF

SAVE_SLOT_SIZE	= 170
Save_DataSlotOffsets:	.word SAVE_SLOT_SIZE*0, SAVE_SLOT_SIZE*1, SAVE_SLOT_SIZE*2, SAVE_SLOT_SIZE*3	; 4th index for finding end of 3rd slot; there's no 4th slot

	; 32-bit sum

	; Save data copy loop
	; Temp_Var3/4 point to source
	; Temp_Var5 is length
Save_CopyLoop:
	LDY #0
Save_MapCompCopyLoop:
	LDA [Temp_Var3],Y
	JSR Save_CopyByte
	
	INY
	CPY <Temp_Var5
	BLT Save_MapCompCopyLoop
	RTS

Save_CopyByte:
	STA <Temp_Var10

	TYA
	PHA
	
	TXA
	TAY 	; FIXME: Better way than swapping X into Y?
	
	LDA <Temp_Var10
	STA [Temp_Var1],Y
	
	PLA
	TAY
	
	INX
	RTS


Save_GetTotalStarsAndHighWorld:
	TXA
	PHA

	LDA PAGE_A000
	PHA
	LDA PAGE_C000
	PHA

	; Load page 11 into A000 and page 10 into C000
	LDA #10
	STA PAGE_C000
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_Both2	
		
	JSR Map_CountAllStarCoins
	
	JSR Save_GetHighestWorld
	
	; Restore A000/C000 pages
	PLA
	STA PAGE_C000
	PLA
	STA PAGE_A000
	JSR PRGROM_Change_Both2
	
	PLA
	TAX
	RTS


	; Calculate checksum for the given save slot
	; Result is in Temp_Var3/4
Save_CalcChecksum:
	; Calculate save base address -> Temp_Var1/2
	ASL A
	TAY
	
	LDA #LOW(SaveData)
	ADD Save_DataSlotOffsets,Y
	STA <Temp_Var1 
	LDA #HIGH(SaveData)
	ADC Save_DataSlotOffsets+1,Y
	STA <Temp_Var2

	; 32-bit sum will be in Temp_Var3-6
	LDA #0
	STA <Temp_Var3
	STA <Temp_Var4
	STA <Temp_Var5
	STA <Temp_Var6
	
	LDY #0
Save_SummationLoop:
	; Adds 16-bit component to 32-bit sum
	LDA <Temp_Var3
	ADD [Temp_Var1],Y
	INY
	STA <Temp_Var3
	LDA <Temp_Var4
	ADC [Temp_Var1],Y
	INY
	STA <Temp_Var4
	LDA <Temp_Var5
	ADC #0
	STA <Temp_Var5
	LDA <Temp_Var6
	ADC #0
	STA <Temp_Var6

	CPY #(SAVE_SLOT_SIZE - 2)	; -2: Do not include checksum itself!
	BLT Save_SummationLoop
	
	; Now we "fold" sum by summing upper 16-bit with lower 16-bit
	; and take 1s complement
	LDA <Temp_Var3
	ADD <Temp_Var5
	EOR #$FF
	STA <Temp_Var3
	LDA <Temp_Var4
	ADC <Temp_Var6
	EOR #$FF
	STA <Temp_Var4
	
	RTS
	
	
Game_SaveData:
	; SaveData_Index
	; SaveData

	LDA Map_StarCoin_Got
	PHA
	LDA Map_StarCoin_Total
	PHA
	
	JSR Save_GetTotalStarsAndHighWorld
	
	; Calculate save base address -> Temp_Var1/2
	LDA SaveData_Index
	ASL A
	TAY
	
	LDA #LOW(SaveData)
	ADD Save_DataSlotOffsets,Y
	STA <Temp_Var1 
	LDA #HIGH(SaveData)
	ADC Save_DataSlotOffsets+1,Y
	STA <Temp_Var2
	
	; X will be running index into SaveData
	LDX #0
	
	LDA <Temp_Var10
	JSR Save_CopyByte
	
	LDA Map_StarCoin_Got
	JSR Save_CopyByte
	LDA Temp_VarNP0
	JSR Save_CopyByte

	PLA
	STA Map_StarCoin_Total
	PLA
	STA Map_StarCoin_Got
	
	; Copy Map_Completions
	LDA #LOW(Map_Completions)
	STA <Temp_Var3
	LDA #HIGH(Map_Completions)
	STA <Temp_Var4
	LDA #(Map_ObjCompletions - Map_Completions)
	STA <Temp_Var5
	JSR Save_CopyLoop

	; Copy Map_ObjCompletions
	LDA #LOW(Map_ObjCompletions)
	STA <Temp_Var3
	LDA #HIGH(Map_ObjCompletions)
	STA <Temp_Var4
	LDA #(Map_CometMode - Map_ObjCompletions)
	STA <Temp_Var5
	JSR Save_CopyLoop
	
	; Copy Map_CometMode
	LDA Map_CometMode
	JSR Save_CopyByte
	
	; Copy Inventory_Items
	LDA #LOW(Inventory_Items)
	STA <Temp_Var3
	LDA #HIGH(Inventory_Items)
	STA <Temp_Var4
	LDA #9
	STA <Temp_Var5
	JSR Save_CopyLoop

	; Copy Inventory_Score
	LDA #LOW(Inventory_Score)
	STA <Temp_Var3
	LDA #HIGH(Inventory_Score)
	STA <Temp_Var4
	LDA #3
	STA <Temp_Var5
	JSR Save_CopyLoop
	
	; Copy Inventory_Score2
	LDA #LOW(Inventory_Score2)
	STA <Temp_Var3
	LDA #HIGH(Inventory_Score2)
	STA <Temp_Var4
	LDA #3
	STA <Temp_Var5
	JSR Save_CopyLoop

	; ... FIXME: anymore? ...
	
	; Now, finally, we must make a 32-bit sum by adding 16-bit chunks
	; of the save data so we can generate the checksum!

	LDA SaveData_Index
	JSR Save_CalcChecksum
	
	; Checksum is ready! Will be last 2 bytes of save slot.
	LDY #(SAVE_SLOT_SIZE - 2)
	LDA <Temp_Var3
	STA [Temp_Var1],Y
	INY
	LDA <Temp_Var4
	STA [Temp_Var1],Y
	
	RTS
	
EndingWZ_Objects:
	LDA PAGE_C000
	PHA
	LDA PAGE_A000
	PHA
	
	; Load page 0 @ C000
	LDA #$00
	STA PAGE_C000
	JSR PRGROM_Change_Both2	 

	JSR Objects_HandleScrollAndUpdate

	LDA #43
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR SpecialObjs_UpdateAndDraw	 ; Update and draw Special objects
	
	PLA
	STA PAGE_A000
	PLA
	STA PAGE_C000
	JMP PRGROM_Change_Both2	 
	
	
	
