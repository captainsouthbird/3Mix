; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg007.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoLavaDonutArrowBounce
;
; Handles the Player coming into contact with lava, donut lifts,
; or arrow platforms (supported in vertical level only)
; This also checks to see if the Player should bounce because the
; block beneath his feet bounced (by checking for the 
; TILEA_BLOCKBUMP_CLEAR tile...)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Specifies which kind of arrow lift should be created relative to which tile
	; the Player stepped on.  Note the zero near the end; if you look at tileset #8
	; the donut lift appears right between what would be the multidirectional lift.
ArrowPlat_ByTile:
	.byte OBJ_ARROWONE, OBJ_ARROWONE, OBJ_ARROWONE, OBJ_ARROWONE, OBJ_ARROWONE, OBJ_ARROWONE, OBJ_ARROWANY, $00, OBJ_ARROWANY

	; Sets the direction value as used by the arrow platform
ArrowPlat_DirByTile:
	.byte $00, $00, $03, $03, $01, $01, $00, $00, $00

ArrowPlat_XOff:
	.byte 0, -16, 0, -16, 0, -16, 0, 0, -16

PDLDAB_GravityOff:	.byte 32, 0	; Non-reversed gravity and reversed gravity

Player_DoLavaDonutArrowBounce:
	LDA <Player_IsDying		  
	BNE PRG007_A06F	 ; If Player is dying, jump to PRG007_A06F (RTS)

	LDA Level_7Vertical
	BEQ PRG007_A027	 ; If this is NOT a vertically-oriented level, jump to PRG007_A027

	JMP PRG007_A0DE	 ; Otherwise, jump to PRG007_A0DE

PRG007_A027:

	; Not vertically oriented level...

	LDY Player_ReverseGrav
	LDA <Player_Y	; Get Player Y
	ADD PDLDAB_GravityOff,Y
	STA <Temp_Var5	; -> Temp_Var5

	LDA <Player_YHi
	BMI PRG007_A06F	; If Player is up off the top of the screen, jump to PRG007_A06F (RTS)

	ADC #$00	; Apply carry
	AND #$01	; Only bit 0 is valid anyway in non-vertical mode
	STA <Temp_Var3	; -> Temp_Var3

	LDA Level_32PPSlopeFlag
	BEQ SpecTile_Not32PP		; If Player is not on sloped 32PP floor, jump to SpecTile_Not32PP

	; Adjust for relativity...
	LDA <Temp_Var5
	SUB Level_VertScroll	; Make relative to Vertical Scroll
	SBC #16		; - 16
	STA <Temp_Var5	; -> Temp_Var14

	LDA #$01
	STA <Temp_Var3	 ; Temp_Var13 = 1 (implied high byte / carry)
	
SpecTile_Not32PP:
	LDA <Temp_Var5
	AND #$F0
	STA <Temp_Var5	; Align to tile grid

	LDA <Player_X	; Get Player X
	ADD #$08	; +8
	AND #$f0	; Align to tile grid
	STA <Temp_Var4	; -> Temp_Var4

	LDA <Player_XHi
	ADC #$00	; Apply carry
	STA <Temp_Var6	; -> Temp_Var6

	CMP #16		; 16 screens are the max!!
	BCS PRG007_A06F	; If Player is really far to the right (somehow), jump to PRG007_A06F (RTS)

	ASL A		; 2 byte index for current screen
	TAY		; -> 'Y'

	; Store high byte of screen address -> Temp_Var1
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1	

	; Store low byte of screen address + Player's Y Hi -> Temp_Var2
	LDA Tile_Mem_Addr+1,Y
	ADD <Temp_Var3	
	STA <Temp_Var2

	; Calculate a proper offset into the tile memory for the X/Y position of the Player
	LDA <Temp_Var4
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var5
	TAY	; -> 'Y'

	LDA [Temp_Var1],Y	; Get the tile here

	CMP #TILEA_BLOCKBUMP_CLEAR
	BNE PRG007_A070	 ; If this is not a bumped block tile, jump to PRG007_A070

	; Otherwise, bounce Player!
	LDA #-$30
	STA <Player_YVel

PRG007_A06F:
	RTS		 ; Return


PRG007_A070:
	CMP #TILE15_LAVATOP
	BNE Tile_NotLava15

	LDY Level_Tileset

	CPY #15
	BEQ PRG007_A07F	 ; If this is tileset 15 ext, jump to PRG007_A07F

Tile_NotLava15:

	CMP #TILE3_LAVATOP
	BNE Tile_NotPurpleGoo

	LDY Level_Tileset

	CPY #3
	BEQ PRG007_A07F	 ; If this is tileset 3 (Hills), jump to PRG007_A07F

Tile_NotPurpleGoo:
	CMP #TILE2_LAVATOP
	BNE PRG007_A082	 ; If this is not (possibly) a lava tile, jump to PRG007_A082

	LDY Level_Tileset
	
	;CPY #3
	;BEQ PRG007_A07F	 ; If this is tileset 3 (Hills), jump to PRG007_A07F
	CPY #14
	BEQ PRG007_A07F	 ; If this is tileset 14 (Underground), jump to PRG007_A07F

	CPY #2
	BNE PRG007_A082	 ; If this is NOT tileset 2 (Fortress style), jump to PRG007_A082

PRG007_A07F:
	JMP PRG007_A183	 ; Jump to PRG007_A183 (Player dies!)

PRG007_A082:
	CMP #TILE2_DONUTLIFT
	BNE ArrowLift_Support	 ; If this is not (possibly) a Donut Lift, jump to ArrowLift_Support

PRG007_A086:
	; If this is tileset 4, 8, 12, or 2 (all valid for Donut Lift), jump to PRG007_A099, otherwise jump to PRG007_A06F (RTS)
	LDY Level_Tileset
	CPY #4
	BEQ PRG007_A099

	CPY #8
	BEQ PRG007_A099

	CPY #12
	BEQ PRG007_A099

	CPY #15
	BEQ PRG007_A099

	CPY #2
	BNE PRG007_A06F

PRG007_A099:
	LDA Level_ChgTileEvent
	BNE PRG007_A06F	 ; If there's already a tile change event queued, jump to PRG007_A06F (RTS)

	JSR PrepareNewObjectOrAbort	 ; Prepare a new object or don't come back!

	; This is a falling donut lift!
	LDA #OBJ_DONUTLIFTSHAKEFALL
	STA Level_ObjectID,X

	; Set donut lift Y 
	LDA <Temp_Var5
	SUB #$01
	STA <Objects_Y,X
	LDA <Temp_Var3
	SBC #$00
	STA <Objects_YHi,X

	; Set donut lift X
	LDA <Temp_Var4
	STA <Objects_X,X
	LDA <Temp_Var6
	STA <Objects_XHi,X

	; Set donut lift object's Var5 = $20
	LDA #$20
	STA <Objects_Var5,X

	; Set sprite attribute = 3
	LDA #$03
	STA Objects_SprAttr,X

	; Do tile change event to clear the tile version of the donut lift
	LDA #$02
	STA Level_ChgTileEvent
	LDA <Temp_Var3	
	STA Level_BlockChgYHi
	LDA <Temp_Var5	
	STA Level_BlockChgYLo
	LDA <Temp_Var4	
	STA Level_BlockChgXLo
	LDA <Temp_Var6	
	STA Level_BlockChgXHi

	RTS

ArrowLift_Support:

	; Backup tile -> 'X'
	TAX

	; SB: Support arrow lift in non-vertical mode
	LDA Level_Tileset
	SUB #6
	CMP #3
	BGE PRG007_A0DD	; If tileset < 6 or > 8, can't be an arrow lift, jump to PRG007_A0DD (RTS)

	; Restore tile
	TXA

	; COULD be an arrow lift...
	BNE PRG007_A113	; Jump (most likely) to PRG007_A113

PRG007_A0DD:
	RTS		 ; Return

PRG007_A0DE:

	; Vertically oriented level...

	LDA <Player_Y	; Get Player Y
	ADD #33		; +33
	AND #$f0	; Aligned to tile grid
	STA <Temp_Var1	; -> Temp_Var1
	STA <Temp_Var5	; -> Temp_Var5

	LDA <Player_YHi
	BMI PRG007_A0DD	 ; If Player is up off the top of the level, jump to PRG007_A0DD (RTS)

	ADC #$00	; Apply carry
	STA <Temp_Var3	; -> Temp_Var3

	; High byte of Tile_Mem -> Temp_Var2
	ORA #HIGH(Tile_Mem)
	STA <Temp_Var2

	LDA <Player_X	; Get Player X
	ADD #$08	; +8
	AND #$f0	; Aligned to tile grid
	STA <Temp_Var4	; -> Temp_Var4

	; Construct tile offset
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var1
	STA <Temp_Var1

	; Temp_Var6 = 0 (would be "X Hi", which is always zero in vertical level)
	LDY #$00
	STY <Temp_Var6

	LDA [Temp_Var1],Y	 ; Get tile here

	CMP #TILE2_DONUTLIFT
	BNE PRG007_A113	 ; If this is not donut lift tile, jump to PRG007_A113

	JMP PRG007_A086	 ; Otherwise, jump to PRG007_A086

PRG007_A113:
	LDY Level_Tileset
	CPY #8
	BNE PRG007_A0DD		; If this is not tileset 8 (Vertical pipe maze), jump to PRG007_A0DD (RTS)

	LDY <Player_InAir
	BNE PRG007_A0DD	 ; If Player is mid-air, jump to PRG007_A0DD (RTS)

	LDY ArrowPlat_IsActive
	BNE PRG007_A0DD	 ; If an arrow platform is already active, jump to PRG007_A0DD (RTS)

	; If not standing on some kind of arrow platform tile, jump to PRG007_A0DD (RTS)
	CMP #TILE8_ARROWLIFT_UPL
	BLT PRG007_A0DD
	CMP #(TILE8_ARROWLIFT_RANDOMR+1)
	BGE PRG007_A0DD

	SUB #TILE8_ARROWLIFT_UPL
	TAY		 ; Y = relative index of tile for arrow platform

	; Temp_Var3 = $FF
	LDA #$ff
	STA <Temp_Var3

	LDX #$04	 ; X = 4
PRG007_A12E:
	LDA Objects_State,X
	BEQ PRG007_A144	 ; If this object slot is dead/empty, jump to PRG007_A144

	; If this object slot is not some type of arrow platform, jump to PRG007_A146
	LDA Level_ObjectID,X
	CMP #OBJ_ARROWONE
	BLT PRG007_A146
	CMP #(OBJ_ARROWANY+1)
	BGE PRG007_A146

	; There's another arrow platform already active in this slot...

	JSR Object_SetDeadEmpty	; Set this slot as dead/empty
	JMP PRG007_A144	 	; Jump to PRG007_A144

	; ^ I think the above is partially a mistake; they probably wanted to jump to something
	; that would set 'X' and exit the loop.  This logic works as-is, but it requires another
	; frame before the arrow lift will actually come into existence... unless another dead/
	; empty object appears forward of this position...

PRG007_A144:
	STX <Temp_Var3		; Temp_Var3 = index we just searched

PRG007_A146:
	DEX		 ; X--
	BPL PRG007_A12E	 ; While X >= 0, loop!

	LDX <Temp_Var3	 ; X = free object slot!
	BMI PRG007_A182	 ; If no free object slot was found, jump to PRG007_A182

	; Set this to "Normal!"
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Create the correct arrow platform by the tile
	LDA ArrowPlat_ByTile,Y
	STA Level_ObjectID,X

	; Set the direction value by tile
	LDA ArrowPlat_DirByTile,Y
	STA <Objects_Var4,X

	; Arrow platform's Var5 (lifespan counter) = $FF
	LDA #$ff
	STA <Objects_Var5,X

	LDA Level_7Vertical
	BNE ArrowLift_Vert	; SB: If vertical, jump to ArrowLift_Vert

	; SB: Non-vertical support...
	LDA <Player_Y
	AND #$F0
	ADD #31
	STA <Objects_Y,X
	LDA <Player_YHi
	ADC #0
	STA <Objects_YHi,X

	LDA ArrowPlat_XOff,Y
	STA <Temp_Var1

	LDA <Player_X
	ADD #8
	AND #$F0
	ADD <Temp_Var1
	STA <Objects_X,X

	LDY #0	; Y = 0 (16-bit extension)

	LDA <Temp_Var1
	BPL ArrowPlat_XOffNotNeg

	LDY #$FF ; Y = $FF (16-bit negative extension)

ArrowPlat_XOffNotNeg:
	STY <Temp_Var1

	LDA <Player_XHi
	ADC <Temp_Var1
	STA <Objects_XHi,X

	RTS


ArrowLift_Vert:
	; Arrow platform Y
	LDA <Temp_Var1
	AND #$f0
	SUB #$01
	STA <Objects_Y,X
	LDA <Temp_Var2
	SBC #$00
	AND #$0f
	STA <Objects_YHi,X

	; Arrow platform X
	LDA <Temp_Var1
	ASL A
	ASL A
	ASL A
	ASL A
	ADD ArrowPlat_XOff,Y
	STA <Objects_X,X
	LDA #$00
	STA <Objects_XHi,X

PRG007_A182:
	RTS		 ; Return

PRG007_A183:

	; Player hit death tile!

	; Zap suit
	LDA #$01
	STA Player_QueueSuit

	JMP Player_Die	 ; Player dies and don't come back!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ColorRotation_Do
;
; Performs the palette color rotation effects per RotatingColor_Cnt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; The palette color forcefully applied in a color rotation
Rotation_Colors:
	.byte $26, $2A, $22, $36

ColorRotation_Do:
	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	LDA RotatingColor_Cnt
	BEQ PRG007_A1EA	 ; If RotatingColor_Cnt = 0 (No color rotation active), jump to PRG007_A1EA (RTS)

	PHA		 ; Save rotation value

	AND #$03
	TAY		 ; Y = 0 to 3, based on rotation value

	DEC RotatingColor_Cnt	 ; RotatingColor_Cnt--

	PLA		 ; Restore rotation value
	BPL PRG007_A1EB	 ; If bit 7 not set on rotation value, jump to PRG007_A1EB

	; Bit 7 set on RotatingColor_Cnt

	AND #%01111111	 ; Ignore bit 7
	BNE PRG007_A1A8	 ; If does not amount to zero, jump to PRG007_A1A8

	STA RotatingColor_Cnt	 ; Otherwise, clear RotatingColor_Cnt

PRG007_A1A8:

	; Address of palette to modify
	LDA #$3f
	STA Graphics_Buffer+$00,X
	LDA #$04
	STA Graphics_Buffer+$01,X

	; 8 bytes to go
	LDA #$08
	STA Graphics_Buffer+$02,X

	; Set the rotation colors into the buffer
	LDA Rotation_Colors,Y
	STA Graphics_Buffer+$04,X
	STA Graphics_Buffer+$05,X
	STA Graphics_Buffer+$06,X
	STA Graphics_Buffer+$08,X

	LDA Palette_Buffer+$4
	STA Graphics_Buffer+$03,X

	LDA Palette_Buffer+$8
	STA Graphics_Buffer+$07,X

	LDA Palette_Buffer+$A
	STA Graphics_Buffer+$09,X

	LDA Palette_Buffer+$B
	STA Graphics_Buffer+$0A,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$0B,X

	; Add to the graphics buffer counter
	TXA
	ADD #$0b
	STA Graphics_BufCnt

PRG007_A1EA:
	RTS		 ; Return


PRG007_A1EB:

	; Bit 7 not set on RotatingColor_Cnt

	LDA RotatingColor_Cnt
	BEQ PRG007_A1F5	 ; If RotatingColor_Cnt = 0, jump to PRG007_A1F5

	; Set the rotation colors into the buffer
	LDA Rotation_Colors,Y
	BNE PRG007_A1F8	 ; Jump (technically always) to PRG007_A1F8

PRG007_A1F5:
	LDA Palette_Buffer+$10

PRG007_A1F8:
	STA Graphics_Buffer+$03,X

	LDA #$10
	STA Graphics_Buffer+$01,X

	LDA Palette_Buffer+$11
	STA Graphics_Buffer+$04,X

	LDA Palette_Buffer+$12
	STA Graphics_Buffer+$05,X

	LDA Palette_Buffer+$13
	STA Graphics_Buffer+$06,X

	; Address of palette to modify
	LDA #$3f
	STA Graphics_Buffer+$00,X
	LDA #$04
	STA Graphics_Buffer+$02,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$07,X

	; Add to the graphics buffer counter
	TXA
	ADD #$07
	STA Graphics_BufCnt

	RTS		 ; Return
	
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Gameplay_UpdateAndDrawMisc
;
; Color rotation effects, lava, donut lifts, arrow platforms,
; brick busts, water/waterfall visual effects, bubbles, splashes,
; pop-up coins, Special Objects, Cannon Fires, Player Projectiles,
; and, last but not least (well, maybe least), "shell kill flashes"!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Gameplay_UpdateAndDrawMisc:
	JSR ColorRotation_Do	 	 ; Do color rotation effects, if any
	JSR ActionSwitch_Do		; Do Action Switch event, if any
	JSR Player_DoLavaDonutArrowBounce	 ; Handle Lava, Donut Lifts, and Arrow platforms
	JSR BrickBusts_DrawAndUpdate	 ; Draw and update brick bust effects
	JSR Player_WaterOrWaterfallVizFX ; Standing in a waterfall splashing or periodic bubbles underwater
	JSR Bubbles_UpdateAndDraw	 ; Update and draw underwater bubbles
	JSR Splash_UpdateAndDraw	 ; Update and draw water surface splashes
	JSR CoinPUps_DrawAndUpdate	 ; Update and draw coins that have popped out of boxes
	JSR_THUNKA 43, SpecialObjs_UpdateAndDraw	 ; Update and draw Special objects
	JSR CannonFire_UpdateAndDraw	 ; Update and draw the Cannon Fires
	JSR_THUNKA 27, PlayerProjs_UpdateAndDraw27	; Update and draw Player's weapon projectiles

	LDA <Player_Suit
	CMP #PLAYERSUIT_HAMMER
	BEQ PRG007_A251	 ; If Player is wearing a Hammer Suit, jump to PRG007_A251

	CMP #PLAYERSUIT_PENGUIN
	BEQ PRG007_A251	 ; If Player is wearing a Penguin Suit, jump to PRG007_A251

	CMP #PLAYERSUIT_FIRE
	BNE PRG007_A268	 ; If Player is not Fire, jump to PRG007_A268

PRG007_A251:

	; Player wearing a Hammer Suit or Fire

	LDA Player_HaltTick	; If Player is not halted ...
	ORA Player_IsDucking	; ... Player is ducking ...
	ORA Player_Kick	 	; ... Player is kicking ...
	ORA Player_InPipe	; ... Player is in a pipe ...
	ORA <Player_HaltGame	; ... gameplay is halted ...
	BNE PRG007_A268	 	; ... then jump to PRG007_A268

	; SB: Support disabling weapons
	LDA Player_DisTailAtk
	BNE Player_DisWeapon 

	BIT <Pad_Input
	BVC PRG007_A268	 ; If Player is NOT pressing B, jump to PRG007_A268

	JSR PlayerProj_ThrowWeapon	 ; Player throws weapon, whatever's appropriate

Player_DisWeapon:
	; SB: Disable weapons briefly
	LDA #0
	STA Player_DisTailAtk

PRG007_A268:
	LDA ShellKillFlash_Cnt
	BEQ PRG007_A2AE	 ; If ShellKillFlash_Cnt = 0, jump to PRG007_A2AE (RTS)

	DEC ShellKillFlash_Cnt	 ; ShellKillFlash_Cnt--

	LDY #$00	 ; Y = 0

	; Set the shell kill flash left/right sprite Y
	LDA ShellKillFlash_Y
	SUB Level_VertScroll
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Set left sprite X
	LDA ShellKillFlash_X
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	; Set right sprite X
	ADD #$08
	STA Sprite_RAM+$07,Y

	; Set left/right sprite pattern
	LDA Level_Tileset
	CMP #11
	BNE SKF_Normal
	
	LDA #$5F
	BNE SKF_UseGiantAlt
	
SKF_Normal:
	LDA #$73	; SB: Changed to make room for flag; not really the same I guess
	
SKF_UseGiantAlt:
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	; Temp_Var1 = toggled vertical flip bit
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP
	STA <Temp_Var1

	; OR in a palette cycle
	LDA <Counter_1
	AND #$03
	ORA <Temp_Var1

	; Set left sprite attribute
	STA Sprite_RAM+$02,Y

	; Set right sprite attribute
	EOR #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$06,Y

PRG007_A2AE:
	RTS		 ; Return

PlayerProj_ThrowWeapon:
	LDX #$01	 ; X = 1
PRG007_A2B1:
	LDA PlayerProj_ID,X
	BEQ PRG007_A2BA	 ; If this Player projectile slot is free

	DEX		 ; X--
	BPL PRG007_A2B1	 ; While X >= 0, loop!

	RTS		 ; Return


PRG007_A2BA:

	; Player "fire" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERFIRE
	STA Sound_QPlayer

	; Player should use "fire" frame!
	LDA #$0b
	STA Player_FireCount

	; Set projectile X
	LDA <Player_X
	ADD #$04
	STA PlayerProj_X,X
	LDA <Player_XHi
	ADC #$00
	STA PlayerProj_XHi,X

	LDA #$01	 ; A = 1

	LDY <Player_Suit
	CPY #PLAYERSUIT_HAMMER
	SEC		 ; Set carry (if NOT wearing the hammer suit)
	BNE PRG007_A2E3	 ; If Player is NOT wearing the Hammer Suit, jump to PRG007_A2E3
	ASL A		 ; Clears carry, also A = 2
PRG007_A2E3:
	STA PlayerProj_ID,X	 ; Set projectile as type 1 or 2

	SUB #1

	PHA
	
	ASL A	; A = 0 (fireball) or 2 (boomerang)
	ADD Player_ReverseGrav	; If reverse gravity, 1/3
	TAY		; Y = 0/2 or 1/3

	; Set projectile Y Hi
	LDA <Player_Y
	ADD PProj_RYOff,Y	; SB: Add offset for reverse gravity
	STA PlayerProj_Y,X
	LDA <Player_YHi
	ADC #0	; Apply carry
	STA PlayerProj_YHi,X
		
	PLA
	TAY		; Y = 0 (fireball) or 1 (boomerang)

	; Set Player Projectile Y velocity
	LDA PProj_InitYVel,Y
	STA PlayerProj_YVel,X

	; PlayerProj_Cnt = PProj_InitCount,Y
	LDA PProj_InitCount,Y
	STA PlayerProj_Cnt,X

	LDA #$00
	STA PlayerProj_YVelFrac,X
	
	LDA #$00
	STA <Temp_Var1

	LDA PProj_InitXVel,Y
	LDY <Player_FlipBits	; Keep in mind this is generally only $00 or $40 since Player doesn't vertically flip/etc.
	BNE PRG007_A30B	 	; If Player is horizontally flipped, jump to PRG007_A30B

	JSR Negate	 ; If Player is turned around, negate value
	INC <Temp_Var1

PRG007_A30B:
	LDY PlayerProj_ID,X
	CPY #1
	BEQ PProj_NoHammerAdj

	; Hammer only -- boost X velocity by Player
	ADD <Player_XVel
	AND #~1		; Make it even in any case so the checks don't fail

PProj_NoHammerAdj:
	STA PlayerProj_XVel,X	 ; Store Projectile X velocity

	AND #$80		; Keep sign bit for telling when boomerang has first turned around
	ORA #$40		; Bit means we need to do the turnaround check
	ORA <Temp_Var1	; Sets direction flag
	STA PlayerProj_Var2,X

	RTS		 ; Return

	; Fireball / Boomerang
PProj_InitYVel:		.byte $30, $00
PProj_InitXVel:		.byte $03, $30
PProj_InitCount:	.byte $00, $08
PProj_RYOff:	
	; SB: Y Offset for projectile if Player is under reverse gravity or not
	.byte 0, 17	; Fireball, normal and reverse gravity
	.byte 8, 8	; Hammer, normal and reverse gravity



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_WaterOrWaterfallVizFX
;
; Visual effects for standing in a waterfall (splashing on head)
; or the periodic bubbles underwater...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Y offsets for periodic bubble generated by the Player while underwater
SwimBubble_YOff:
	.byte $04, $04	; Not a penguin swimming frame
	.byte $08, $08	; Idle or left/right penguin swimming
	.byte $0D, $0D	; Down penguin swim
	.byte $00, $00	; Up penguin swim

	; X offsets for periodic bubble generated by the Player while underwater (left is not horizontally flipped, right is h-flipped)
SwimBubble_XOff:
	.byte $00, $0B	; Not a penguin swimming frame
	.byte $00, $0B	; Idle or left/right penguin swimming
	.byte $05, $05	; Down penguin swim
	.byte $05, $05	; Up penguin swim

Player_WaterOrWaterfallVizFX:
	LDY Player_FlyTime
	INY
	BNE PRG007_A783	 ; (Will be zero if Player_FlyTime = $FF, i.e. P-Wing) If not using P-Wing, jump to PRG007_A783

	; Otherwise, clear kill tally (P-Wing does not net you 1-ups)
	STY Kill_Tally

PRG007_A783:
	LDY <Player_HaltGame
	BNE PRG007_A7F0	 ; If gameplay halted, jump to PRG007_A7F0 (RTS)

	LDA Player_InWater
	BEQ PRG007_A7F0	 ; If Player is not underwater, jump to PRG007_A7F0 (RTS)

	LDY Player_StarInv
	BNE StarInv_NoWaterReset

	; Otherwise, clear kill tally (Being underwater also resets your chain stomping)
	STY Kill_Tally

StarInv_NoWaterReset:
	CMP #$01
	BEQ PRG007_A7F1	 ; If Player_InWater = 1 (water, not waterfall), jump to PRG007_A7F1

	; Player's in a waterfall!

	LDA <Player_YVel
	CMP #$3c
	BGS PRG007_A7A2	 ; If Player's Y velocity >= $3C, jump to PRG007_A7A2

	INC <Player_YVel ; Player_YVel++

	LDA <Counter_1
	LSR A	
	BCC PRG007_A7A2	 ; Every other tick, jump to PRG007_A7A2

	INC <Player_YVel ; Player_YVel++

PRG007_A7A2:
	JSR Object_GetRandNearUnusedSpr
	BEQ PRG007_A7F0	 ; If no free sprite, jump to PRG007_A7F0 (RTS)

	LDA Player_OffScreen
	BNE PRG007_A7F0	 ; If Player is off-screen, jump to PRG007_A7F0 (RTS)

	; Patterns for "splashing" effect seen above Player's head
	LDA #$47
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	LDA <Counter_1
	LSR A
	AND #$03
	ADD #$05	; Value of 5 to 8

	LDX Player_IsDucking
	BNE PRG007_A7C6	 ; If Player is ducking, jump to PRG007_A7C6

	LDX Player_Suit
	BNE PRG007_A7C9	 ; If Player is not small, jump to PRG007_A7C9

PRG007_A7C6:
	ADD #10		 ; Small or ducking, +10 (15 to 18)

PRG007_A7C9:
	STA <Temp_Var1	 ; -> Temp_Var1

	LDX <SlotIndexBackup	 ; Restore 'X' as slot index

	; Sprite "splashing" effect Y
	LDA <Player_SpriteY
	ADD <Temp_Var1
	SUB #10
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Sprite "splashing" effect X
	LDA <Player_SpriteX
	STA Sprite_RAM+$03,Y
	ADD #$08
	STA Sprite_RAM+$07,Y

	LDA <Counter_1
	AND #$03
	SUB #$02	 ; A = -2 to 1 (spread value)

	JSR Draw_SpreadAndColorful	 ; Spreads out the two sprites and rotates the color palette

PRG007_A7F0:
	RTS		 ; Return


PRG007_A7F1:

	; Player's in regular old water

	LDY #$7f	 ; Y = $7F ("slow" mask value for idle underwater player)

	LDA <Pad_Holding
	AND #(PAD_A | PAD_LEFT | PAD_RIGHT)
	BEQ PRG007_A7FB	 ; If Player is not pressing A, LEFT, or RIGHT (swim controls), jump to PRG007_A7FB

	LDY #$3f	 ; Y = $3F ("fast" mask value for idle underwater player)

PRG007_A7FB:
	TYA		 ; Mask -> 'Y'
	AND <Counter_1
	BNE PRG007_A80C	 ; Periodically jump to PRG007_A80C (RTS)

	; SlotIndexBackup = 2
	LDX #$02
PRG007_A802:
	STX <SlotIndexBackup

	LDA Bubble_Cnt,X
	BEQ PRG007_A80D	 ; If this bubble slot is empty, jump to PRG007_A80D

	DEX		 ; X--
	BPL PRG007_A802	 ; While X >= 0, loop!

PRG007_A80C:
	RTS		 ; Return


PRG007_A80D:
	LDA RandomN
	ORA #$10
	STA Bubble_Cnt,X ; Set random value -> Bubble_Cnt

	LDY #$00	 ; Y = 0

	LDA <Player_Frame
	CMP #PF_PENGUINSWIM_UPBASE
	BLT PRG007_A835	 ; If Player is not within the low end range of penguin suit swim frames, jump to PRG007_A835

	LDY #$03	 ; Otherwise, Y = 3 (pending this might be the "up" frame)

	CMP #PF_PENGUINHOP_BASE
	BLT PRG007_A835	 ; If frame < PF_PENGUINHOP_BASE (if true, then absolutely the "up" swim frame), jump to PRG007_A835

	LDY #$00	 ; Otherwise, Y = 0

	CMP #PF_PENGUINSWIM_IDLEBASE
	BLT PRG007_A835	 ; If not possibly just the "idling" penguin frames, jump to PRG007_A835

	INY		 ; Otherwise, Y = 1 (idle or left/right penguin swim)

	CMP #PF_PENGUINSWIM_LRBASE+2
	BLT PRG007_A835	 ; Not a down swimming frame, jump to PRG007_A835

	INY		 ; Otherwise, Y = 2 (down penguin swim)

	CMP #(PF_PENGUINSWIM_DOWNBASE+3)	; This is actually 1 passed the end of penguin suit swim frames
	BLT PRG007_A835	 ; If within range of the last penguin suit swim frame, jump to PRG007_A835

	LDY #$00	 ; Otherwise, Y = 0

PRG007_A835:

	; Y *= 2
	TYA
	ASL A
	TAY

	BIT <Player_FlipBits
	BVC PRG007_A83D	 ; If Player is not horizontally flipped, jump to PRG007_A83D

	INY		 ; Otherwise, Y++

PRG007_A83D:
	LDA #$00	; A = 0

	LDX <Player_Suit
	BNE PRG007_A845	 ; If Player is not small, jump to PRG007_A845
 
	LDA #$08	 ; Otherwise, A = 8

PRG007_A845:
	LDX <SlotIndexBackup	 ; X = slot backup

	; Set Bubble Y
	ADD <Player_Y
	ADC SwimBubble_YOff,Y
	STA Bubble_Y,X
	LDA <Player_YHi
	ADC #$00
	STA Bubble_YHi,X

	; Set Bubble X
	LDA <Player_X
	ADD SwimBubble_XOff,Y
	STA Bubble_X,X
	LDA <Player_XHi
	ADC #$00
	STA Bubble_XHi,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bubbles_UpdateAndDraw
;
; Update and draw bubbles that appear underwater
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Bubbles_UpdateAndDraw:
	LDX #$03	 ; X = 3
PRG007_A86A:
	STX <SlotIndexBackup	 ; -> Slot index backup

	LDA Bubble_Cnt,X
	BEQ PRG007_A874	 ; If this bubble slot is not in use, jump to PRG007_A874

	JSR Bubble_UpdateAndDraw	 ; Update and draw this bubble

PRG007_A874:
	DEX		; X--
	BPL PRG007_A86A	; While X >= 0, loop!

	RTS		 ; Return


Bubble_UpdateAndDraw:
	LDA <Player_HaltGame		 
	BEQ PRG007_A87F	 ; If gameplay is not halted, juimp to PRG007_A89A

	JMP PRG007_A89A	 ; Otherwise, jump to PRG007_A89A

PRG007_A87F:
	INC Bubble_Cnt,X ; Bubble counter increment

	; Fix bit 7 on bubble counter
	LDA Bubble_Cnt,X
	ORA #$80
	STA Bubble_Cnt,X

	AND #%00110000
	BEQ PRG007_A89A	 ; Periodically jump to PRG007_A89A

	DEC Bubble_Y,X	 ; Bubble Y --

	LDY Bubble_Y,X
	INY	
	BNE PRG007_A89A	 ; If no carry, jump to PRG007_A89A
	DEC Bubble_YHi,X ; Apply carry

PRG007_A89A:
	LDA Level_7Vertical
	BEQ PRG007_A8BF	 ; If this level is not vertical, jump to PRG007_A8F0

	; Vertical level...

	LDA Bubble_Y,X
	ADD #10		; Bubble Y + 10
	AND #$f0
	STA <Temp_Var3	; Temp_Var3 = bubble row (offset into tile memory)

	LDA Bubble_YHi,X
	ADC #HIGH(Tile_Mem)
	STA <Temp_Var2	; Temp_Var2 = bubble high offset into tile memory

	; Create row/column offset into tile memory for current screen of bubble -> Temp_var1
	LDA Bubble_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3
	STA <Temp_Var1

	LDY #$00	 ; Y = 0 (not using the offset like non-vertical does)
	BEQ PRG007_A8F0	 ; Jump (technically always) to PRG007_A8F0

PRG007_A8BF:
	LDA Bubble_Y,X
	ADD #10		 ; Bubble Y + 10
	AND #$f0
	STA <Temp_Var3	 ; Temp_Var3 = bubble row (offset into tile memory)

	LDA Bubble_YHi,X
	ADC #$00	 ; Apply carry
	PHA		 ; Save it

	; Temp_Var5 = bubble X
	LDA Bubble_X,X
	STA <Temp_Var5

	LDA Bubble_XHi,X
	ASL A		 ; 2 bytes per screen
	TAY		 ; Y = offset into Tile_Mem_Addr

	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1	 ; Temp_Var1 = low byte of this screen's tile memory address

	PLA		 ; Restore Bubble's Y Hi
	AND #$01	 ; Only 0/1 valid for non-vertical
	ADD Tile_Mem_Addr+1,Y	 ; Add to high byte of address
	STA <Temp_Var2	 ; -> Temp_Var2

	; Create row/column offset -> Temp_Var3
	LDA <Temp_Var5
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ORA <Temp_Var3

	TAY		 ; Y = this offset

PRG007_A8F0:
	LDA [Temp_Var1],Y ; Get the tile the bubble detects

	PHA		 ; Save it

	; Get tile "quadrant" -> Temp_Var1
	ASL A
	ROL A
	ROL A
	AND #$03
	STA <Temp_Var1

	PLA		 ; Restore specific tile
	STA <Temp_Var2	 ; -> Temp_Var2

	LDY <Temp_Var1	 ; Y = tile quadrant
	CMP Tile_AttrTable,Y
	BGE PRG007_A91E	 ; If this tile is solid, jump to PRG007_A91E (destroy bubble)

	LDA Level_TilesetIdx
	ASL A
	ASL A		; Tileset index * 4
	ADD <Temp_Var1	; + quadrant
	TAY	; -> 'Y' (offset into Level_MinTileUWByQuad)

	LDA <Temp_Var2
	CMP #TILE1_WFALLTOP
	BEQ PRG007_A91E	 ; If this is the top of a waterfall, jump to PRG007_A915 (indirect to PRG007_A91E)

	CMP #TILE1_WFALLMID

PRG007_A915:
	BEQ PRG007_A91E	 ; If this is the top or middle of a waterfall, jump to PRG007_A91E

	LDA Level_MinTileUWByQuad,Y
	CMP <Temp_Var2
	BLT Bubble_Draw	 ; If this tile is still considered underwater, jump to Bubble_Draw 

PRG007_A91E:

	; Remove this bubble
	LDA #$00
	STA Bubble_Cnt,X

	RTS		 ; Return

Bubble_XOff:		.byte $00, $01, $00, -$01
Bubble_SprRAMOff:	.byte $10, $14, $0C, $FF, $10, $14, $0C

Bubble_Draw:
	LDA Level_NoStopCnt
	AND #%00001100
	LSR A	
	LSR A	
	TAY		 ; Y = 0 to 3

	; Temp_Var1 = bubble's X offset
	LDA Bubble_XOff,Y
	STA <Temp_Var1

	LDA <Counter_1
	AND #%00000011
	ADC <SlotIndexBackup 	
	TAY		 ; Y = (0 to 3) + bubble's index

	LDA Bubble_SprRAMOff,Y
	BMI PRG007_A978	 ; If we hit the $FF value in Bubble_SprRAMOff, jump to PRG007_A978 (RTS)

	TAY		 ; -> 'Y'

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BNE PRG007_A978	 ; If this sprite is not free, jump to PRG007_A978 (RTS)

	; Bubble Y
	LDA Bubble_Y,X
	SUB Level_VertScroll
	STA Sprite_RAM+$00,Y

	CMP #200
	BGE PRG007_A91E	 ; If this bubble's sprite Y >= 200, jump to PRG007_A91E (destroy bubble)

	; Bubble X
	LDA Bubble_X,X
	ADD <Temp_Var1
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	CMP #248
	BCS PRG007_A91E	 ; If this bubble's X >= 248, jump  to PRG007_A91E (destroy bubble)

	; Bubble's pattern
	LDA #$17
	STA Sprite_RAM+$01,Y

	; Bubble's attributes
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

PRG007_A978:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Splash_UpdateAndDraw
;
; Update and draw water surface splashes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Splash_UpdateAndDraw:
	LDX #$02	 ; X = 2
PRG007_A97B:
	STX <SlotIndexBackup	 ; -> Slot Index backup

	LDA Splash_Counter,X
	BEQ PRG007_A9A0	 ; If no splash is active here, jump to PRG007_A9A0

	LDA <Player_HaltGame

	; This probably used to skip something if gameplay was halted, i.e. (BNE xxxx)
	NOP
	NOP

	INC Splash_Counter,X	 ; Splash counter++

	LDA <Counter_1
	LSR A
	BCC PRG007_A991	 ; Every other tick, jump to PRG007_A991

	INC Splash_Counter,X	 ; Splash counter++

PRG007_A991:
	LDA Splash_Counter,X
	CMP #$30
	BLT PRG007_A99D	 ; If splash counter < $30, jump to PRG007_A99D

	JSR Splash_Remove ; Remove this splash
	BEQ PRG007_A9A0	 ; Jump (technically always) to PRG007_A9A0

PRG007_A99D:
	JSR Splash_Draw	 ; Draw this splash

PRG007_A9A0:
	DEX		 ; X--
	BPL PRG007_A97B	 ; While X >= 0, loop!

	RTS		 ; Return

Splash_Patterns:
	.byte $11, $13, $15, $47, $47, $47

Splash_Remove:

	; Remove this splash
	LDA #$00	 
	STA Splash_Counter,X

PRG007_A9AF:
	RTS		 ; Return

Splash_Draw:
	JSR Object_GetRandNearUnusedSpr	 
	BEQ PRG007_A9AF	 ; If no sprite available, jump to PRG007_A9AF (RTS)

	STY <Temp_Var1	 ; Sprite RAM offset -> Temp_Var1

	LDA Splash_X,X
	SUB <Horz_Scroll	; Make scroll relative X for splash

	CMP #240
	BGE Splash_Remove	; If splash X >= 240, jump to Splash_Remove

	STA Sprite_RAM+$03,Y	 ; Set left splash sprite X

	ADC #$08	 ; +8
	STA Sprite_RAM+$07,Y	; Set right splash sprite X

	LDA Splash_Y,X		; Get splash Y

	LDY Splash_NoScrollY,X
	BNE PRG007_A9D5	 	; If Splash_NoScrollY is set, do not make splash Y scroll relative

	SUB Level_VertScroll	 ; Make scroll relative Y for splash

PRG007_A9D5:
	LDY <Temp_Var1		 ; Y = sprite RAM offset

	CMP #$ae
	BGE Splash_Remove	 ; If splash sprite RAM offset >= $AE (?), jump to Splash_Remove (remove it!)

	; Set splash sprites Y
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Set left splash sprite attributes
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

	; Set right splash sprite attributes
	LDA #(SPR_PAL1 | SPR_HFLIP)
	STA Sprite_RAM+$06,Y

	LDA Splash_Counter,X
	LSR A
	LSR A
	LSR A
	TAX		; X = splash counter / 8
	STX <Temp_Var1	; -> Temp_Var1

	; Set splash sprite patterns
	LDA Splash_Patterns,X
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	LDX <SlotIndexBackup	 ; X = splash index

	LDA <Temp_Var1
	CMP #$03
	BLT PRG007_AA4C	 ; If (splash counter / 8) < 3, jump to PRG007_AA4C (RTS)

	LDA <Counter_1
	AND #$01
	ORA <Player_HaltGame
	BNE PRG007_AA10	 ; Every other tick or gameplay halted, jump to 

	INC Splash_Y,X	 ; Splash_Y++

PRG007_AA10:
	LDA Splash_Counter,X
	SUB #24
	LSR A	
	LSR A	
	LSR A	
	AND #$03	 ; A = (splash counter - 24) / 8

Draw_SpreadAndColorful:
	STA <Temp_Var1		 

	; Subtract from sprite X
	LDA Sprite_RAM+$03,Y
	SUB <Temp_Var1	
	STA Sprite_RAM+$03,Y

	; Add to other sprite X
	LDA Sprite_RAM+$07,Y
	ADD <Temp_Var1
	STA Sprite_RAM+$07,Y

	; Set attributes of two sprites
	LDA #SPR_PAL1
	STA Sprite_RAM+$06,Y

	ORA #SPR_HFLIP
	STA Sprite_RAM+$02,Y

	LDA Level_NoStopCnt
	AND #$02
	BNE PRG007_AA4C	 ; 2 ticks on, 2 ticks off; jump to PRG007_AA4C (RTS)

	; Mess with attributes for a little sparkly fun
	LDA <Temp_Var1
	ORA #SPR_VFLIP
	STA Sprite_RAM+$02,Y

	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y

PRG007_AA4C:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scores_GiveAndDraw
;
; Gives awarded points and draws score sprites.  Also caps 
; the Kill_Tally variable at a maximum value of 8.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Patterns for the left and right sprites of the score sprite ($FF means "don't display")
	;		       10   20   40   80  100  200  400  800 1000 2000 4000 8000 1-up
Score_PatternLeft:	.byte $FF, $FF, $FF, $FF, $5B, $63, $6B, $6D, $5B, $63, $6B, $6D, $61
Score_PatternRight:	.byte $5B, $63, $6B, $6D, $59, $59, $59, $59, $59, $59, $59, $59, $6F
Score_OffsetRight:	.byte $08, $08, $08, $08, $04, $04, $04, $04, $08, $08, $08, $08, $08	; SB: To support sprite reuse

	; Score to add (low byte)
ScoreAdd_L:
	.byte LOW(  1)	;   10 points
	.byte LOW(  2)	;   20 points
	.byte LOW(  4)	;   40 points
	.byte LOW(  8)	;   80 points
	.byte LOW( 10)	;  100 points
	.byte LOW( 20)	;  200 points
	.byte LOW( 40)	;  400 points
	.byte LOW( 80)	;  800 points
	.byte LOW(100)	; 1000 points
	.byte LOW(200)	; 2000 points
	.byte LOW(400)	; 4000 points
	.byte LOW(800)	; 8000 points
	.byte $00	; 1-up (no score value)

	; Score to add (high byte)
ScoreAdd_H:
	.byte HIGH(  1)	;   10 points
	.byte HIGH(  2)	;   20 points
	.byte HIGH(  4)	;   40 points
	.byte HIGH(  8)	;   80 points
	.byte HIGH( 10)	;  100 points
	.byte HIGH( 20)	;  200 points
	.byte HIGH( 40)	;  400 points
	.byte HIGH( 80)	;  800 points
	.byte HIGH(100)	; 1000 points
	.byte HIGH(200)	; 2000 points
	.byte HIGH(400)	; 4000 points
	.byte HIGH(800)	; 8000 points
	.byte $00	; 1-up (no score value)


Scores_GiveAndDraw:
	LDA Kill_Tally	  
	CMP #$08
	BLT PRG007_AA8D	 ; If Kill_Tally < 8, jump to PRG007_AA8D

	; Max Kill_Tally at 8
	LDA #$08
	STA Kill_Tally

PRG007_AA8D:
	LDX #$04	; X = 4 (all five on-screen "scores")
PRG007_AA8F:
	STX <SlotIndexBackup	 ; Update SlotIndexBackup

	LDA Scores_Value,X
	AND #$7f	 ; Keep only lower 7 bits
	BEQ PRG007_AAAD	 ; If this score's value is $00 or $80, jump to PRG007_AAAD

	CMP #$0D
	BLT PRG007_AAA8	 ; If score value < $0D (1-up), jump to PRG007_AAA8

	LDA Scores_Value,X
	AND #$80	; Keep bit 7
	ORA #$0d	; Cap at 1-up ($0D) regardless of value
	STA Scores_Value,X	 ; Update value

	AND #$7f	 ; Keep only lower 7 bits

PRG007_AAA8:
	STA <Temp_Var1	 	; Score value -> Temp_Var1
	JSR Score_GiveAndDraw	; Give awarded points and draw score sprites

PRG007_AAAD:
	DEX		 ; X--
	BPL PRG007_AA8F	 ; While X >= 0, loop!
	RTS		 ; Return

Score_GiveAndDraw:
	LDA Player_Grow	  	; If Player is growing up...
	ORA Player_StarOff	; ... is losing invincibility (?) ...
	ORA Player_SuitLost	; ... or has lost their power-up ...
	BNE PRG007_AAC0	 	; ... then jump to PRG007_AAC0

	LDA <Player_HaltGame
	BNE PRG007_AB1D	 	; If gameplay is halted, jump to PRG007_AB1D

PRG007_AAC0:
	LDA Scores_Counter,X
	BNE PRG007_AACF	 ; If this score counter hasn't expired, jump to PRG007_AACF

PRG007_AAC5:
	; Otherwise, this score is finished; clear it out!
	LDA #$00
	STA Scores_Value,X

	RTS		 ; Return

	; Mask values that control how quickly the score rises
Score_RiseCounterMask:	.byte $03, $01, $00, $00

PRG007_AACF:
	DEC Scores_Counter,X	 ; Decrement the score counter

	CMP #$2a
	BNE PRG007_AB04	 ; If score counter <> $2A, jump to PRG007_AB04

	; Score counter = $2A...

	LDY <Temp_Var1	 ; Y = score value

	; Add Score's value to Score_Earned
	LDA Score_Earned
	ADD ScoreAdd_L-1,Y	; -1 because a score value of zero is "empty"
	STA Score_Earned
	LDA Score_Earned+1
	ADC ScoreAdd_H-1,Y
	STA Score_Earned+1

	CPY #$0d
	BNE PRG007_AB02	 ; If this is not 1-up level score, jump to PRG007_AB02

	; Play 1-up sound!
	LDA Sound_QLevel1
	ORA #SND_LEVEL1UP
	STA Sound_QLevel1

	LDX Player_Current	 ; X = current Player

	LDA Player_Lives,X
	BMI PRG007_AB02	 	; If this Player is dead (and how could we be here, hmm?), jump to PRG007_AB02

	INC Player_Lives,X	; Otherwise, give them the extra life!

PRG007_AB02:
	LDX <SlotIndexBackup	; X = score slot index

PRG007_AB04:
	LDA Scores_Counter,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = score counter / 16

	LDA <Counter_1
	AND Score_RiseCounterMask,Y
	BNE PRG007_AB1D	 ; Periodically jump to PRG007_AB1D

	LDA Scores_Y,X
	CMP #$04
	BLT PRG007_AB1D	 ; If this score's Y < 4, jump to PRG007_AB1D

	DEC Scores_Y,X	 ; Otherwise, rise up!

PRG007_AB1D:

	; Scroll score horizontally with screen
	LDA Scores_X,X
	SUB Level_ScrollDiffH
	STA Scores_X,X

	CMP #248
	BGE PRG007_AAC5	 ; If score's X >= 248, jump to PRG007_AAC5 (get rid of it!)

	; Scroll score vertically with screen
	LDA Scores_Y,X
	SUB Level_ScrollDiffV
	STA Scores_Y,X

	CMP #248
	BGE PRG007_AAC5	 ; If score's Y >= 248, jump to PRG007_AAC5 (get rid of it!)

	LDA Scores_Value,X
	BMI PRG007_AB53		; If score value has bit 7 set, jump to PRG007_AB53

	; Otherwise...

	; This just takes from object sprite RAM
	LDA Object_SprRAM,X
	ADD #16		; +16 (4 sprites over)
	TAY		 ; Y = Sprite RAM offset
	STY <Temp_Var5	 ; -> Temp_Var5

	ADD #$04	 ; +4 (1 sprite over)
	STA <Temp_Var6	 ; -> Temp_Var6

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG007_AB76	 ; If this sprite is free, jump to PRG007_AB76

PRG007_AB53:
	JSR Object_GetRandNearUnusedSpr		; Sprite is not free; get a nearby one

	STY <Temp_Var5	 ; -> Temp_Var5
	BNE PRG007_AB70	 ; As long as result wasn't zero, jump to PRG007_AB70

	; No sprites available...

	; Temp_Var6 = $FF
	LDA #$ff
	STA <Temp_Var6

	LDA <Counter_1
	LSR A
	BCC PRG007_AB6D	 ; Every other tick, jump to PRG007_AB6D

	; Basically only one or the other half of the score will actually display
	LDA <Temp_Var5
	PHA
	LDA <Temp_Var6
	STA <Temp_Var5
	PLA
	STA <Temp_Var6

PRG007_AB6D:
	JMP PRG007_AB76	 ; Jump to PRG007_AB76

PRG007_AB70:
	; New sprite RAM offset selected...
	TYA		 ; -> Y
	ADD #$04	 ; +4 (next sprite over)
	STA <Temp_Var6	 ; -> Temp_Var6

PRG007_AB76: 
	LDY <Temp_Var5	 ; Y = first sprite offset
	CPY #$ff
	BEQ PRG007_AB99	 ; If this sprite is marked as "don't display", jump to PRG007_AB99

	LDX <Temp_Var1	 ; X = score value

	LDA Score_PatternLeft-1,X	 ; -1 because a score value of zero is "empty"

	LDX <SlotIndexBackup	 ; X = score slot index

	CMP #$ff
	BEQ PRG007_AB99	 ; If this is the "don't display" marker, jump to PRG007_AB99

	; Otherwise, set the pattern
	STA Sprite_RAM+$01,Y

	; Score Sprite Y
	LDA Scores_Y,X
	STA Sprite_RAM+$00,Y

	; Score Sprite X
	LDA Scores_X,X
	STA Sprite_RAM+$03,Y

	JSR Score_SetAttribute

PRG007_AB99:
	LDY <Temp_Var6	 ; Y = second sprite offset
	CPY #$ff
	BEQ PRG007_ABC4	 ; If this sprite is marked as "don't display", jump to PRG007_ABC4

	; Score Sprite Y
	LDA Scores_Y,X
	STA Sprite_RAM+$00,Y

	; Score Sprite X
	LDA Scores_X,X

	; SB: Hack to free a couple patterns in CHR004
	; Use the double-zero for score values 5-8 (100, 200, 400, 800)
	; by moving it over by 4 instead of 8
	LDX <Temp_Var1	 ; X = score value
	ADD Score_OffsetRight-1,X
	STA Sprite_RAM+$03,Y

	; Score Sprite pattern
	LDA Score_PatternRight-1,X
	STA Sprite_RAM+$01,Y

Score_SetAttribute:
	LDA <Temp_Var1	 ; Get score value
	CMP #$0d
	LDA #$01	 ; A = 1
	BGE PRG007_ABBF	 ; If this is the 1-up, jump to PRG007_ABBF

	NOP		 ; Otherwise, do ... nothing!

PRG007_ABBF:
	; Set attribute
	STA Sprite_RAM+$02,Y

	LDX <SlotIndexBackup	 ; X = score slot index

PRG007_ABC4:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BrickBusts_DrawAndUpdate
;
; Draws and updates the brick bust debris/poof effects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BrickBusts_DrawAndUpdate:
	LDX #$01	 ; X = 1
PRG007_ABC7:
	STX <SlotIndexBackup	; -> SlotIndexBackup

	JSR BrickBust_DrawAndUpdate	 ; Draw and update this brick bust

	DEX		 ; X--
	BPL PRG007_ABC7	 ; While X >= 0, loop

PRG007_ABCF:
	RTS		 ; Return

BrickBust_SprRAMOff:	.byte $08, $18	; Four sprites required here
BrickPoof_SprRAMOff:	.byte $08, $10	; Only two sprites required here

	; Draw and update the specific brick bust
BrickBust_DrawAndUpdate:
	LDA BrickBust_En,X
	BEQ PRG007_ABCF	 ; If this brick bust slot is not active, jump to PRG007_ABCF

	CMP #$02
	BEQ PRG007_ABE0	 ; If the bust type is 2 (typical), jump to PRG007_ABE0

	JMP PRG007_AD27	 ; Otherwise, jump to PRG007_AD27

PRG007_ABE0:
	LDA <Player_HaltGame
	BNE PRG007_ABED	 ; If gameplay halted, jump to PRG007_ABED

	LDA <Counter_1
	AND #$03
	BNE PRG007_ABED	 ; 1:4 proceed, otherwise jump to PRG007_ABED

	INC BrickBust_YVel,X	 ; BrickBust_YVel++ (gravity)

PRG007_ABED:
	LDA BrickBust_YUpr,X
	PHA		 ; Save upper chunk Y

	CLC		 ; Clear carry (no point?)
	SUB Level_ScrollDiffV	 ; Adjust Y based on vertical screen scroll

	LDY <Player_HaltGame
	BNE PRG007_ABFE	 ; If gameplay is halted, jump to PRG007_ABFE

	ADD BrickBust_YVel,X	 ; Apply brick bust Y velocity

PRG007_ABFE:
	STA BrickBust_YUpr,X	 ; -> upper chunk Y

	PLA		 ; Restore original Y
	EOR BrickBust_YUpr,X
	BPL PRG007_AC1F	 ; If the sign hasn't changed, jump to PRG007_AC1F

	; Sign changed; need to make sure the block bust debris didn't wrap

	LDA Level_ScrollDiffV

	LDY <Player_HaltGame
	BNE PRG007_AC12	 ; If gameplay halted, jump to PRG007_AC12

	SUB BrickBust_YVel,X	 ; Apply velocity in reverse

PRG007_AC12:
	EOR BrickBust_YUpr,X
	BPL PRG007_AC1F	 ; If the sign didn't change, jump to PRG007_AC1F

	; Otherwise, toggle the upper chunk disable
	LDA BrickBust_HEn,X
	EOR #$08
	STA BrickBust_HEn,X

PRG007_AC1F:
	LDA BrickBust_YLwr,X
	PHA		 ; Save lower chunk Y

	CLC		 ; Clear carry (no point?)
	SUB Level_ScrollDiffV	 ; Adjust Y based on vertical screens croll

	LDY <Player_HaltGame
	BNE PRG007_AC36	 ; If gameplay is halted, jump to PRG007_AC36

	INC BrickBust_XDist,X	 ; Increase the chunk separation

	ADD BrickBust_YVel,X	 ; Apply Y velocity

	ADD #$02		; More impact on lower chunk
PRG007_AC36:
	STA BrickBust_YLwr,X

	PLA		 ; Restore lower chunk Y

	EOR BrickBust_YLwr,X
	BPL PRG007_AC5A	 ; If the sign hasn't changed, jump to PRG007_AC5A

	; Sign changed; need to make sure the block bust debris didn't wrap

	LDA Level_ScrollDiffV

	LDY <Player_HaltGame
	BNE PRG007_AC4D	 ; If gameplay halted, jump to PRG007_AC4D

	SUB BrickBust_YVel,X	 ; Apply velocity in reverse
	SUB #$02	 ; With the greater impact

PRG007_AC4D:
	EOR BrickBust_YLwr,X
	BPL PRG007_AC5A	 ; If sign didn't change, jump to PRG007_AC5A

	; Otherwise, toggle the lower chunk disable
	LDA BrickBust_HEn,X
	EOR #$04
	STA BrickBust_HEn,X

PRG007_AC5A:

	; Scroll brick bust debris horizontally with screen
	LDA BrickBust_X,X
	SUB Level_ScrollDiffH
	STA BrickBust_X,X

	TXA		 ; Keeps things interesting
	EOR <Counter_1
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA BrickBust_SprRAMOff,Y
	TAY		 ; Y = sprite RAM offset
	CPY #$08	 
	BNE PRG007_AC7A	 ; If NOT using the offset $08, jump to PRG007_AC7A

	LDA Sprite_RAM+$08
	CMP #$f8
	BEQ PRG007_AC7A	 ; If this sprite is not in use, jump to PRG007_AC7A

	RTS		 ; Return

PRG007_AC7A:
	LDA BrickBust_HEn,X
	STA <Temp_Var4	 ; Horizontal enable flag -> Var4

	CMP #$0c
	BLT PRG007_AC91	 ; If at least one of upper or lower are enabled, jump to PRG007_AC91

	; Upper and lower are both disabled!

	LDA <Player_HaltGame
	BNE PRG007_AC8E	 ; If gameplay halted, jump to PRG007_AC8E

	LDA BrickBust_YVel,X
	CMP #$08
	BLS PRG007_AC91	 ; If brick bust Y velocity < $08, jump to PRG007_AC91

PRG007_AC8E:
	JMP PRG007_AD21	 ; Otherwise, jump to PRG007_AD21 (disable this brick bust)

PRG007_AC91:
	LDA <Temp_Var4
	AND #$08
	BNE PRG007_ACA0	 ; If upper bust chunks are disabled, jump to PRG007_ACA0

	; Otherwise set sprite Y for left and right uppers
	LDA BrickBust_YUpr,X
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

PRG007_ACA0:
	LDA <Temp_Var4
	AND #$04
	BNE PRG007_ACAF	 ; If lower bust chunks are disabled, jump to PRG007_ACAF

	; Otherwise set sprite Y for left and right lowers
	LDA BrickBust_YLwr,X
	STA Sprite_RAM+$08,Y
	STA Sprite_RAM+$0C,Y

PRG007_ACAF:
	LSR <Temp_Var4
	BCC PRG007_ACBB	 ; If right bust chunks are NOT disabled, jump to PRG007_ACBB

	; Hide right-hand bust chunks
	LDA #$f8
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$08,Y

PRG007_ACBB:
	LSR <Temp_Var4
	BCC PRG007_ACC7	 ; If left bust chunks are NOT disabled, jump to PRG007_ACC7

	; Hide left-hand bust chunks
	LDA #$f8
	STA Sprite_RAM+$04,Y
	STA Sprite_RAM+$0C,Y

PRG007_ACC7:

	; Pattern for bust chunks
	LDA #$4b
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y
	STA Sprite_RAM+$09,Y
	STA Sprite_RAM+$0D,Y

	LDA BrickBust_X,X
	PHA		 ; Save chunk X
	ADD BrickBust_XDist,X	; Add the distance
	ADD #$08	 	; +8
	STA Sprite_RAM+$03,Y	; Set right upper chunk X
	STA Sprite_RAM+$0B,Y	; Set right lower chunk X

	CMP #248
	BLT PRG007_ACF2	 ; If bust chunk X < 248, jump to PRG007_ACF2

	; Otherwise, disable right chunks
	LDA BrickBust_HEn,X
	ORA #$01
	STA BrickBust_HEn,X

PRG007_ACF2:
	PLA		 ; Restore chunk X
	SUB BrickBust_XDist,X	 ; Subtract the distance
	STA Sprite_RAM+$07,Y	 ; Set left upper chunk X
	STA Sprite_RAM+$0F,Y	 ; Set left lower chunk X

	; Seems like this should be a >= 8 check??
	CMP #244
	BLT PRG007_AD09	 ; If bust chunk X < 244 (??), jump to PRG007_AD09

	; Otherwise, disable left chunks
	LDA BrickBust_HEn,X
	ORA #$02
	STA BrickBust_HEn,X

PRG007_AD09:

	; Rotate the horizontal / vertical flips
	LDA Level_NoStopCnt
	AND #$06
	LSR A
	LSR A
	ROR A
	ROR A
	ORA #SPR_PAL3
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y
	STA Sprite_RAM+$0A,Y
	STA Sprite_RAM+$0E,Y

	RTS		 ; Return

PRG007_AD21:

	; Disable this brick bust
	LDA #$00
	STA BrickBust_En,X

	RTS		 ; Return

PRG007_AD27:

	; Brick bust type non-2 ("poof" away the tile)

	LDA BrickBust_HEn,X
	BEQ PRG007_AD21	 ; If BrickBust_HEn = 0 (poof expired), jump to PRG007_AD21 (disable this brick bust)

	LDA <Player_HaltGame
	BNE PRG007_AD33	 ; If gameplay is halted, jump to PRG007_AD33

	DEC BrickBust_HEn,X	 ; BrickBust_HEn-- (used as a counter here)

PRG007_AD33:
	LDA BrickBust_YUpr,X

	LDY Level_AScrlConfig
	BNE PRG007_AD42	 ; If raster enabled, jump to PRG007_AD42

	; Otherwise, just be screen-scroll relative
	SUB Level_ScrollDiffV
	STA BrickBust_YUpr,X

PRG007_AD42:
	CMP #208
	BGE PRG007_AD21	 ; If the poof effect Y >= 208 (too low), jump to PRG007_AD21 (disable this brick bust)

	CPY #$00
	BNE PRG007_AD54	 ; If raster effects enabled, jump to PRG007_AD54

	; Scroll poof horizontally
	LDA BrickBust_X,X
	SUB Level_ScrollDiffH
	STA BrickBust_X,X

PRG007_AD54:
	CMP #240
	BGE PRG007_AD21	 ; If the poof effect X >= 24, jump to PRG007_AD21 (disable this brick bust)

	TXA		 ; Keep it interesting
	EOR <Counter_1	 
	AND #$01	 
	TAY		 ; Y = 0 or 1

	LDA BrickPoof_SprRAMOff,Y
	TAY		 ; Y = Sprite RAM offset

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BNE PRG007_ADA7	 ; If this sprite is not free, jump to PRG007_ADA7 (RTS)

	; Set left sprite X
	LDA BrickBust_X,X
	STA Sprite_RAM+$03,Y

	; Set right sprite X
	ADD #$08	 ; +8
	STA Sprite_RAM+$07,Y

	; Set left/right sprite Y
	LDA BrickBust_YUpr,X
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP
	STA <Temp_Var1	 ; Periodically vertically flip

	; Form attribute with sprite palette 1 for left half
	LDA #SPR_PAL1
	ORA <Temp_Var1
	STA Sprite_RAM+$02,Y

	; Right half uses opposite flips
	EOR #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$06,Y

	LDA BrickBust_HEn,X
	LSR A
	LSR A
	LSR A
	TAX	; X = 0 to 3

	LDA Poof_Patterns7,X	 ; Get appropriate "poof" pattern
	STA Sprite_RAM+$01,Y	 ; Left
	STA Sprite_RAM+$05,Y	 ; Right

	LDX <SlotIndexBackup	 ; X = restore slot index

PRG007_ADA7:
	RTS		 ; Return

Poof_Patterns7:	.byte $47, $45, $43, $41

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CoinPUp_DrawAndUpdate
;
; Draws and updates the coins which have popped out of blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CoinPUp_Patterns:	.byte $49, $4F, $49, $4F	; SB: Formerly $49, $4F, $4D, $4F
CoinPUp_Attributes:	.byte SPR_PAL3, SPR_PAL3 | SPR_HFLIP, SPR_PAL3, SPR_PAL3

CoinPUps_DrawAndUpdate:
	LDX #$03	 ; X = 3 (all "power up" coin slots)
PRG007_ADB2: 
	STX <SlotIndexBackup	 ; -> slot index backup

	LDA CoinPUp_State,X
	BEQ PRG007_ADBC	 ; If there's no active "powerup coin" here, jump to PRG007_ADBC

	JSR CoinPUp_UpdateAndDraw	 ; Update and draw powerup coin

PRG007_ADBC:
	DEX		 ; X--
	BPL PRG007_ADB2	 ; While X >= 0, loop!

	RTS		 ; Return

CoinPUp_UpdateAndDraw:
	LDA <Player_HaltGame		 
	BNE PRG007_ADF0	 ; If gameplay is halted, jump to PRG007_ADF0

	INC CoinPUp_Counter,X	 ; counter++

	; Apply coin's Y velocity
	LDA CoinPUp_Y,X
	ADD CoinPUp_YVel,X
	STA CoinPUp_Y,X

	LDA CoinPUp_Counter,X
	AND #$03
	BNE PRG007_ADE2	 ; 1:4 ticks proceed, otherwise jump to PRG007_ADE2

	INC CoinPUp_YVel,X	 ; coin YVel ++

	LDA CoinPUp_YVel,X
	CMP #$05
	BEQ PRG007_AE28	 ; If coin's Y velocity = 5, jump to PRG007_AE28

PRG007_ADE2:
	LDA CoinPUp_X,X
	SUB Level_ScrollDiffH	; Make relative coin X

	CMP #248
	BGE PRG007_AE4A	 ; If coin X >= 248, jump to PRG007_AE4A (remove coin)

	STA CoinPUp_X,X	 ; Update coin X

PRG007_ADF0:
	LDA <Player_HaltGame
	BEQ PRG007_AE02	 ; If gameplay is not halted, jump to PRG007_AE02

	; Move coin Y with vertical scroll
	LDA CoinPUp_Y,X	 
	SUB Level_ScrollDiffV
	STA CoinPUp_Y,X	 

	CMP #197
	BGE PRG007_AE4A	 ; If coin Y >= 197, jump to PRG007_AE4A (remove coin)

PRG007_AE02:
	JSR Object_GetRandNearUnusedSpr

	; Set coin Y
	LDA CoinPUp_Y,X
	STA Sprite_RAM+$00,Y

	; Set coin X
	LDA CoinPUp_X,X
	STA Sprite_RAM+$03,Y

	LDA CoinPUp_Counter,X
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3 by coin counter

	; Set pattern
	LDA CoinPUp_Patterns,X
	STA Sprite_RAM+$01,Y

	; Set attribute
	LDA CoinPUp_Attributes,X
	STA Sprite_RAM+$02,Y

	LDX <SlotIndexBackup	; X = power up coin slot index

	RTS		 ; Return

PRG007_AE28:
	JSR Score_FindFreeSlot

	; Get 100 pts
	LDA #$85
	STA Scores_Value,Y

	LDA #$30
	STA Scores_Counter,Y

	LDA CoinPUp_Y,X
	CMP #192
	BLT PRG007_AE3E	 ; If the coin is not too low, jump to PRG007_AE3E

	LDA #$05	 ; Otherwise use top of screen

PRG007_AE3E:
	STA Scores_Y,Y	 ; -> Scores_Y

	; Center score above coin
	LDA CoinPUp_X,X
	SUB #$04
	STA Scores_X,Y

PRG007_AE4A:

	; Remove coin
	LDA #$00
	STA CoinPUp_State,X

	RTS		 ; Return





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CannonFire_UpdateAndDraw
;
; Updates and draws the Cannon Fires
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CannonFire_UpdateAndDraw:
	LDA <Player_HaltGame		 
	ORA EndCard_Flag
	BNE PRG007_BB80	 ; If gameplay halted or end level card grabbed, jump to PRG007_BB80 (RTS)

	LDX #$07	 ; X = 7
PRG007_BB78:
	STX <SlotIndexBackup	 ; Update index backup

	JSR CannonFire_DrawAndUpdate	; Draw and Update Cannon Fire

	DEX		 ; X--
	BPL PRG007_BB78	; While X >= 0, loop!

PRG007_BB80:
	RTS		 ; Return


CannonFire_DrawAndUpdate:
	LDA CannonFire_ID,X
	BEQ PRG007_BB80	 ; If this slot is unused/empty, jump to PRG007_BB80 (RTS)

	PHA		 ; Save ID

	; Update CannonFire_Timer
	LDA CannonFire_Timer,X
	BEQ PRG007_BB8F	 ; If CannonFire_Timer = 0, jump to CannonFire_Timer
	DEC CannonFire_Timer,X	 ; CannonFire_Timer--
PRG007_BB8F:

	; Update CannonFire_Timer2
	LDA CannonFire_Timer2,X
	BEQ PRG007_BB97
	DEC CannonFire_Timer2,X
PRG007_BB97:

	PLA		 ; Restore ID
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG007_BB80	; 00: Unused (would never get here anyway)
	.word CFire_BulletBill	; 01: Bullet Bill cannon
	.word CFire_BulletBill	; 02: Missile Bill (homing Bullet Bill)
	.word CFire_RockyWrench	; 03: Creates Rocky Wrench
	.word CFire_4Way	; 04: 4-way cannon
	.word CFire_GoombaPipe	; 05: Sidestepper pipe (left output)
	.word CFire_GoombaPipe	; 06: Sidestepper pipe (right output)
	.word CFire_Cannonball 	; 07: Fires cannonballs horizontally left
	.word CFire_Cannonball	; 08: Fires BIG cannonballs horizontally left
	.word CFire_Cannonball	; 09: Fires cannonballs diagonally, upper left
	.word CFire_Cannonball	; 0A: Fires cannonballs diagonally, upper right
	.word CFire_Cannonball	; 0B: Fires cannonballs diagonally, lower left
	.word CFire_Cannonball	; 0C: Fires cannonballs diagonally, lower right
	.word CFire_Cannonball	; 0D:
	.word CFire_Cannonball	; 0E: 
	.word CFire_Cannonball 	; 0F: 
	.word CFire_Cannonball	; 10:
	.word CFire_Cannonball	; 11: Fires cannonballs horizontally right
	.word CFire_Cannonball	; 12: Fires BIG cannonballs horizontally right
	.word CFire_Cannonball	; 13: Launches fused Bob-ombs to the left
	.word CFire_Cannonball	; 14: Launches fused Bob-ombs to the right
	.word CFire_Laser	; 15: Laser fire
	.word CFire_Gravity	; 16: Gravity normal (not really a "cannon", but convenient)
	.word CFire_Gravity	; 17: Gravity reversed (not really a "cannon", but convenient)

CFire_Gravity:
	JMP_THUNKC 30, CFire_Gravity30

CFire_Laser:
	LDA CannonFire_X,X
	CMP <Horz_Scroll
	LDA CannonFire_XHi,X
	SBC <Horz_Scroll_Hi
	BNE PRG007_BBEB	 ; If the Cannon Fire laser is horizontally off-screen, jump to PRG007_BBEB (RTS)

	LDA CannonFire_X,X
	SUB <Player_X
	CMP #$38
	BLT PRG007_BBEB	; If Player is too far left, jump to PRG007_BBEB (RTS)
	CMP #$4c
	BGE PRG007_BBEB	; If Player is too far right, jump to PRG007_BBEB (RTS)

	LDY #$07	 ; Y = 7
PRG007_BBE3:
	LDA SpecialObj_ID,Y
	BEQ PRG007_BBEC	 ; If this special object slot is not in use, jump to PRG007_BBEC

	DEY		 ; Y--
	BPL PRG007_BBE3	; While Y >= 0, loop!

PRG007_BBEB:
	RTS		 ; Return

PRG007_BBEC:
	LDA SndCur_Player
	ORA Sound_QPlayer
	AND #SND_PLAYERPIPE
	BNE PRG007_BBFB	 ; If the pipe/shrink sound is queued or currently playing, jump to PRG007_BBFB

	; Otherwise play the "bump" sound (which played rapidly makes the laser sound)
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer

PRG007_BBFB:

	; This is a laser!
	LDA #SOBJ_LASER
	STA SpecialObj_ID,Y

	; Set laser X
	LDA CannonFire_X,X
	SUB #$08
	STA SpecialObj_XLo,Y

	; Set laser Y
	LDA CannonFire_Y,X
	ADD #$08
	STA SpecialObj_YLo,Y
	LDA CannonFire_YHi,X
	STA SpecialObj_YHi,Y

	RTS		 ; Return

CFire_Cannonball:

	LDA CannonFire_Timer,X
	BNE PRG007_BC5B	 ; If timer not expired, jump to PRG007_BC5B (RTS)

	LDA CannonFire_X,X
	CMP <Horz_Scroll
	LDA CannonFire_XHi,X
	SBC <Horz_Scroll_Hi
	BNE PRG007_BC5B	 ; If Cannon Fire is off-screen left, jump to PRG007_BC5B (RTS)

	LDA CannonFire_X,X
	SUB <Horz_Scroll
	CMP #240
	BGE PRG007_BC5B	 ; If Cannon Fire is off-screen right, jump to PRG007_BC5B (RTS)

	; Reload timer = $87
	LDA #$87
	STA CannonFire_Timer,X

	; Temp_Var1 = this particular Cannon Fire ID
	LDA CannonFire_ID,X
	STA <Temp_Var1

	CMP #CFIRE_HRBIGCANNON
	BEQ PRG007_BC4B	 ; If this is the right-shooting BIG Cannon, jump to PRG007_BC4B

	CMP #CFIRE_HLBIGCANNON
	BNE PRG007_BC4E	 ; If this is NOT the left-shooting BIG Cannon, jump to PRG007_BC4E

PRG007_BC4B:
	JMP PRG007_BC5C	 ; For all BIG Cannons, jump to PRG007_BC5C

PRG007_BC4E:
	CMP #CFIRE_LBOBOMBS
	BLT PRG007_BC55	 ; If this is not one of the Bob-omb cannons, jump to PRG007_BC55

	JMP PRG007_BCB4	 ; For all Bob-omb cannons, jump to PRG007_BCB4

PRG007_BC55: 
	ADD #(Cannons_CPXOff - CannonPoof_XOffs - CFIRE_HLCANNON)	; Offset to proper array index for this Cannon Fire
	JMP PRG007_BE59	 ; Jump to PRG007_BE59 (fire cannonball!)

PRG007_BC5B:
	RTS		 ; Return


PRG007_BC5C:

	; Left/right BIG Cannons

	JSR PrepareNewObjectOrAbort	; Get me an object slot or don't come back!

	; This is a BIG Cannon Ball!
	LDA #OBJ_BIGCANNONBALL
	STA Level_ObjectID,X

	; Big Cannon Ball is BIG
	INC Objects_IsGiant,X

	LDY <SlotIndexBackup	; Y = Cannon Fire slot index

	; Set BIG Cannon Ball Y
	LDA CannonFire_Y,Y
	STA <Objects_Y,X
	LDA CannonFire_YHi,Y
	STA <Objects_YHi,X

	LDA <Temp_Var1
	CMP #CFIRE_HRCANNON

	LDA #$30	 ; A = $30
	LDY #$12	 ; Y = $12

	BGE PRG007_BC81	 ; Basically if this is the right-shooting BIG Cannon, jump to PRG007_BC81

	LDY #$09	 ; Y = $09
	LDA #-$30	 ; A = -$30

PRG007_BC81:
	STY <Temp_Var1	 ; Temp_Var1 = $12 (if right-shooting) or $09 (if left-shooting)

	STA <Objects_XVel,X	 ; X velocity = -$30 or $30, depending on direction

	EOR #$80	 ; Invert the sign bit

	LDY <SlotIndexBackup	 ; Y = Cannon Fire slot index

	ASL A		 ; Inverted sign bit -> carry

	; Set BIG Cannon Ball X
	LDA CannonFire_X,Y
	BCS PRG007_BC92	 ; If right-shooting, jump to PRG007_BC92
	SUB #16		; -16 for left-shooting
PRG007_BC92:
	STA <Objects_X,X
	LDA CannonFire_XHi,Y
	SBC #$00
	STA <Objects_XHi,X

	JSR PRG007_BD09		; Set attribute and make noise and smoke!
	JSR CannonFire_NoiseAndSmoke	 ; make more smoke!!

	; +4 to this smoke though
	LDA CannonFire_Y,X
	SUB Level_VertScroll
	ADD #$04
	STA BrickBust_YUpr

	; +8 to the other smoke
	ADC #$08
	STA BrickBust_YUpr+1

	RTS		 ; Return

PRG007_BCB4:

	; Bob-omb cannons!

	JSR PrepareNewObjectOrAbort

	; It's a Bob-omb!!
	LDA #OBJ_BOBOMBEXPLODE
	STA Level_ObjectID,X

	; Bobomb's Timer3 = $80
	LDA #$80
	STA Objects_Timer3,X

	INC Objects_Var7,X	 ; Bob-omb's Var7++
	INC Objects_Var1,X	 ; Bob-omb's Var1++

	LDY <SlotIndexBackup	 ; Y = Cannon Fire slot index

	; Set Bob-omb's Y
	LDA CannonFire_Y,Y
	SUB #$08
	STA <Objects_Y,X
	LDA CannonFire_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	; Set Bob-omb's Y velocity
	LDA #-$30
	STA <Objects_YVel,X

	LDA <Temp_Var1
	CMP #CFIRE_RBOBOMBS

	LDA #$10	 ; A = $10
	LDY #$0b	 ; Y = $0B
	BCS PRG007_BCE9	 ; If this is a right-shot Bob-omb, jump to PRG007_BCE9

	DEY		 ; Y = $0A
	LDA #-$10	 ; A = -$10

PRG007_BCE9:
	STY <Temp_Var1	 ; Temp_Var1 = $0A or $0B
	STA <Objects_XVel,X	 ; Set Bob-omb's X velocity (-$10 or $10)

	ASL A		 ; Shift sign bit into carry

	; Temp_Var2 = $00 (16-bit sign extension)
	LDA #$00
	STA <Temp_Var2

	LDY <SlotIndexBackup	 ; Y = Cannon Fire slot index

	; Set Bob-omb's X
	LDA #$08	 ; A = $08
	BCC PRG007_BCFC	 ; If this is a right-shot Bob-omb, jump to PRG007_BCFC
	LDA #-$08	 ; A = -$08
	DEC <Temp_Var2	 ; Temp_Var2 = $FF (16-bit sign extension)
PRG007_BCFC:
	ADD CannonFire_X,Y
	STA <Objects_X,X
	LDA CannonFire_XHi,Y
	ADC <Temp_Var2	
	STA <Objects_XHi,X


PRG007_BD09:
	; Set Cannon Ball / Bob-omb attributes
	LDA #SPR_PAL3
	STA Objects_SprAttr,X

	LDX <SlotIndexBackup	 ; X = Cannon Fire slot index
	JMP CannonFire_NoiseAndSmoke	 ; Play cannon fire noise and make smoke


Goomba_InitFlipBits:	.byte SPR_HFLIP, $00

CFire_GoombaPipe:
	LDA CannonFire_Timer,X
	BNE PRG007_BD7A	 ; If timer not expired, jump to PRG007_BD7A (RTS)

	TXA
	TAY	; Cannon Fire index -> 'Y' (this isn't really used)

	; Set timer to $70
	LDA #$70
	STA CannonFire_Timer,Y	; (only used here, then it goes back to 'X' anyway)

	INC CannonFire_Var,X	 ; CannonFire_Var++

	LDA CannonFire_Var,X
	AND #$03
	BEQ PRG007_BD7A	 ; 1:4 ticks proceed, otherwise jump to PRG007_BD7A (RTS)

	JSR PrepareNewObjectOrAbort	 ; Prepare me a Goomba!

	; Set Goomba X
	LDA CannonFire_X,Y
	STA <Objects_X,X
	LDA CannonFire_XHi,Y
	STA <Objects_XHi,X

	JSR Level_ObjCalcXDiffs
	STY <Temp_Var2		 ; Store directional flag -> Temp_Var2

	LDY <SlotIndexBackup	 ; Y = Cannon Fire index

	LDA CannonFire_ID,Y

	LDY #$00	 ; Y = 0 (right output Goomba pipe)

	CMP #CFIRE_GOOMBAPIPE_L
	BNE PRG007_BD49	 ; If this is not a left output Goomba pipe, jump to CFIRE_GOOMBAPIPE

	INY		 ; Y = 1 (left output Goomba pipe)

PRG007_BD49:
	CPY <Temp_Var2
	BNE PRG007_BD7B	 ; If Player is on the wrong side of the Goomba pipe, jump to PRG007_BD7B

	; Set Goomba's initial flip bits
	LDA Goomba_InitFlipBits,Y
	STA Objects_FlipBits,X

	LDY <SlotIndexBackup	 ; Y = Cannon Fire slot index

	; Set Goomba's Y
	LDA CannonFire_Y,Y
	SUB #$03
	STA <Objects_Y,X
	LDA CannonFire_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	; It's ... random! (SB)
	;LDA RandomN
	;AND #1
	;ASL A
	;TAY
	
	; Neat idea, but not practical for challenge level, where this ultimately ended up
	LDY #2
	
	LDA PipeEnemy_IDPal,Y
	STA Level_ObjectID,X

	; Set Goomba's color
	LDA PipeEnemy_IDPal+1,Y
	STA Objects_SprAttr,X

	; Set Goomba's Var1 = $28
	LDA #$28
	STA Objects_Var1,X

	LDA #$ff
	STA Objects_SprHVis,X

PRG007_BD78:
	LDX <SlotIndexBackup	 ; X = Cannon Fire slot index

PRG007_BD7A:
	RTS		 ; Return

PipeEnemy_IDPal:
	.byte OBJ_GREENTROOPA,	SPR_PAL2
	.byte OBJ_FAZZYCRAB,	SPR_PAL1

PRG007_BD7B:

	; Player's on the wrong side of the goomba pipe; kill goomba! :(
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	BEQ PRG007_BD78	 ; Jump (technically always) to PRG007_BD78

PRG007_BD82:
	.byte $00, $08, $10, $18, $20, $28, $30, $38

FourWay_CannonballXVel:	.byte $00, $0B, $10, $0B, $00, -$0B, -$10, -$0B

	.byte $F0, $F0, $F5, $0B, $F5, $0B, $F5, $0B, $F5, $0B, $10, $10

FourWay_CannonballYVel:	.byte -$10, -$0B, $00, $0B, $10, $0B, $00, -$0B

	.byte $00, $00, $F5, $F5, $0B, $0B, $F5, $F5, $0B, $0B, $00, $00

CannonPoof_XOffs:

FourWay_CPXOff:	.byte $08, $18, $1C, $18, $08, $F8, $F4, $F8

Cannons_CPXOff:
	.byte -$0C	; CFIRE_ULCANNON
	.byte -$0C	; CFIRE_URCANNON
	.byte -$08	; CFIRE_LLCANNON
	.byte  $08	; CFIRE_LRCANNON
	.byte -$08	; CFIRE_HLCANNON2
	.byte  $08	; CFIRE_ULCANNON2
	.byte  $00	; CFIRE_URCANNON2
	.byte  $00	; CFIRE_LLCANNON2
	.byte  $00	; CFIRE_HRCANNON
	.byte  $00	; Not used?
	.byte  $0C	; CFIRE_LBOBOMBS
	.byte  $0C	; CFIRE_RBOBOMBS


Bill_CPXOff:	.byte $0C, -$0C		; Bullet/Missile Bill


CannonPoof_YOffs:

FourWay_CPYOff:	.byte $F3, $F7, $07, $17, $1B, $17, $07, $F7

Cannons_CPYOff:
	.byte  $00	; CFIRE_ULCANNON
	.byte  $08	; CFIRE_URCANNON
	.byte -$08	; CFIRE_LLCANNON
	.byte -$08	; CFIRE_LRCANNON
	.byte  $08	; CFIRE_HLCANNON2
	.byte  $08	; CFIRE_ULCANNON2
	.byte  $00	; CFIRE_URCANNON2
	.byte  $00	; CFIRE_LLCANNON2
	.byte  $00	; CFIRE_HRCANNON
	.byte  $00	; Not used?
	.byte  $00	; CFIRE_LBOBOMBS
	.byte  $00	; CFIRE_RBOBOMBS

Bill_CPYOff:	.byte $00, $00		; Bullet/Missile Bill


CFire_4Way:

	; Load graphics for 4-Way cannon
	LDA #$36
	STA PatTable_BankSel+4

	LDA CannonFire_Timer2,X
	BNE PRG007_BE1C	 ; If timer2 has not expired, jump to PRG007_BE1C (RTS)

	; Reset timer2 = $3D
	LDA #$3d
	STA CannonFire_Timer2,X

	LDA CannonFire_Y,X
	CMP Level_VertScroll
	LDA CannonFire_YHi,X
	SBC Level_VertScrollH
	BNE PRG007_BE42	 ; If the 4-Way cannon is vertically off-screen, jump to PRG007_BE42 (RTS)

	LDA CannonFire_X,X
	CMP <Horz_Scroll
	LDA CannonFire_XHi,X
	SBC <Horz_Scroll_Hi
	BNE PRG007_BE42	 ; If the 4-Way cannon is horizontally off-screen, jump to PRG007_BE42 (RTS)

	LDA CannonFire_X,X
	SUB <Horz_Scroll
	ADD #32
	CMP #40
	BLT PRG007_BE42	 ; If the 4-Way cannon is too far left off-screen, jump to PRG007_BE42 (RTS)

	; Reset cannon timer to $20
	LDA #$20
	STA CannonFire_Timer,X

	INC CannonFire_Var,X	 ; CannonFire_Var++

PRG007_BE1C:
	LDA CannonFire_Timer,X
	BEQ PRG007_BE42	 ; If timer expired, jump to PRG007_BE42 (RTS)

	CMP #$1d
	BNE PRG007_BE43	 ; If timer <> $1D, jump to PRG007_BE43

	LDA #CHNGTILE_4WAYCANNON
	STA Level_ChgTileEvent

	; Set coordinates of change
	LDA CannonFire_Y,X
	STA Level_BlockChgYLo

	LDA CannonFire_YHi,X
	STA Level_BlockChgYHi

	LDA CannonFire_X,X
	STA Level_BlockChgXLo

	LDA CannonFire_XHi,X
	STA Level_BlockChgXHi

PRG007_BE42:
	RTS		 ; Return

PRG007_BE43:
	CMP #$01
	BNE PRG007_BEAA	 ; If timer <> 1, jump to PRG007_BEAA

	LDA CannonFire_Var,X
	AND #$07
	STA <Temp_Var1	; Temp_Var1 = 0 to 7

	JSR FireCannonBall	 ; Fire cannon ball
 
	LDA CannonFire_Var,X
	ADD #$04
	AND #$07	 ; +4 wrap around (fire the cannonball on the opposite side)

PRG007_BE59:
	STA <Temp_Var1
	
	; Load cannonball graphics
	LDA #$36
	STA PatTable_BankSel+4
	
	JMP FireCannonBall	 ; Fire the cannonball!

FireCannonBall:
	LDY #$05	 ; Y = 5

PRG007_BE60:
	LDA SpecialObj_ID,Y
	BEQ PRG007_BE69	 ; If this special object slot is free, jump to PRG007_BE69

	DEY		 ; Y--
	BPL PRG007_BE60	 ; While Y >= 0, loop!

	RTS		 ; Return

PRG007_BE69:

	; Set this as a cannon ball!
	LDA #SOBJ_CANNONBALL
	STA SpecialObj_ID,Y

	; Set cannonball X
	LDA CannonFire_X,X
	CLC
	LDX <Temp_Var1		; X = 0 to 7
	ADC CannonPoof_XOffs,X
	STA SpecialObj_XLo,Y

	; Set cannonball Y velocity
	LDA FourWay_CannonballYVel,X
	STA SpecialObj_YVel,Y

	; Set cannonball X velocity
	LDA FourWay_CannonballXVel,X
	STA SpecialObj_XVel,Y

	; Temp_Var3 = 0 (16-bit sign extension)
	LDA #$00
	STA <Temp_Var3

	LDA CannonPoof_YOffs,X
	BPL PRG007_BE91	 ; If Y offset is not negative, jump to PRG007_BE91

	DEC <Temp_Var3	 ; Temp_Var3 = $FF (16-bit sign extension)

PRG007_BE91:
	CLC
	LDX <SlotIndexBackup	 ; X = Cannon Fire slot index
	ADC CannonFire_Y,X
	STA SpecialObj_YLo,Y
	LDA CannonFire_YHi,X
	ADC <Temp_Var3		; 16-bit sign extension
	STA SpecialObj_YHi,Y	

	; Data = 0
	LDA #$00
	STA SpecialObj_Data,Y

	JMP CannonFire_NoiseAndSmoke	 ; Play cannon fire noise and make smoke

PRG007_BEAA:
	RTS		 ; Return

	; Produces the smoke resulting from cannon fire; specify X/Y offset
	; from Cannon Fire's position by Temp_Var1 which indexes CannonPoof_X/YOffs
CannonFire_NoiseAndSmoke:
	; Cannon firing noise
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	JSR BrickBust_MoveOver	 ; Make room in first "brick bust" slot for poof

	; Brick bust, poof style
	LDA #$01
	STA BrickBust_En

	; Set poof X
	LDA CannonFire_X,X	; Get Cannon Fire X
	CLC
	LDX <Temp_Var1		; X = Temp_Var1 holds the index into CannonPoof_XOffs
	ADC CannonPoof_XOffs,X	; + CannonPoof_XOffs[Temp_Var1]
	SUB <Horz_Scroll	; Make relative to horizontal scroll
	STA BrickBust_X		; Set X

	LDA CannonPoof_YOffs,X	 ; A = CannonPoof_YOffs[Temp_Var1]

	LDX <SlotIndexBackup	 ; X = Cannon Fire slot index

	ADD CannonFire_Y,X	 ; + Cannon Fire Y
	SUB Level_VertScroll	 ; Make relative to vertical scroll
	STA BrickBust_YUpr	 ; Set Y

	; Set poof counter
	LDA #$1f
	STA BrickBust_HEn

	RTS		 ; Return


Rocky_InitAttr:	.byte SPR_HFLIP | SPR_BEHINDBG, SPR_BEHINDBG

CFire_RockyWrench:
	JMP_THUNKC 30, CFire_RockyWrench30

Bill_XVelTowardsPlayer:	.byte $18, -$18
Bill_FlipTowardsPlayer:	.byte SPR_HFLIP, $00
Bill_Var4TowardsPlayer:	.byte $01, $00

PRG007_BF28:
	RTS	

CFire_BulletBill:
	LDA CannonFire_Timer,X
	BNE PRG007_BF28	 ; If timer not expired, jump to PRG007_BF28 (RTS)

	LDA CannonFire_Y,X
	CMP Level_VertScroll
	LDA CannonFire_YHi,X
	SBC Level_VertScrollH
	BNE PRG007_BF28		; If Cannon Fire has fallen off screen vertically, jump to PRG007_BF28 (RTS)

	LDA CannonFire_X,X
	CMP <Horz_Scroll
	LDA CannonFire_XHi,X
	SBC <Horz_Scroll_Hi
	BNE PRG007_BF28		; If Cannon Fire has fallen off screen horizontally, jump to PRG007_BF28 (RTS)

	; Reset Cannon Fire timer to $80-$9F, random
	LDA RandomN,X
	AND #$1f
	ORA #$80
	STA CannonFire_Timer,X

	LDA CannonFire_X,X
	SUB <Horz_Scroll
	ADD #16
	CMP #32
	BLT PRG007_BF28		; If Cannon Fire X + 16 is less than 32 pixels from screen edge, jump to PRG007_BF28 (RTS)

	LDA <Player_X
	SBC CannonFire_X,X
	ADD #17
	CMP #34
	BLT PRG007_BF28		; If Player is standing on Bullet Bill cannon, jump to PRG007_BF28 (RTS)

	JSR PrepareNewObjectOrAbort

	LDY <SlotIndexBackup	 ; Y = Cannon Fire object slot

	LDA CannonFire_ID,Y
	LSR A		; Selects which Bill type

	LDA #OBJ_BULLETBILL

	BCS PRG007_BF80	 ; If carry set, jump to PRG007_BF80

	LDA #OBJ_BULLETBILLHOMING

PRG007_BF80:
	STA Level_ObjectID,X	 ; Store Bill's ID

	; Set Bill's palette
	LDA #SPR_PAL3
	STA Objects_SprAttr,X

	; Set Bill's Y
	LDA CannonFire_Y,Y
	SUB #$01
	STA <Objects_Y,X
	LDA CannonFire_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	; Set Bill's X
	LDA CannonFire_XHi,Y
	STA <Objects_XHi,X
	LDA CannonFire_X,Y
	STA <Objects_X,X
	STA Objects_Var13,X	; original X hold

	; Bill's timer = $0C
	LDA #$0c
	STA Objects_Timer,X

	; Bill's Var3 = $20
	LDA #$20
	STA Objects_Var3,X

	JSR Level_ObjCalcXDiffs

	; Bill fires towards Player
	LDA Bill_XVelTowardsPlayer,Y
	STA <Objects_XVel,X

	; Bill faces Player
	LDA Bill_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	; Set Bill's direction flag
	LDA Bill_Var4TowardsPlayer,Y
	STA <Objects_Var4,X

	LDX <SlotIndexBackup	; X = Cannon Fire slot index

	TYA		; 0 or 1
	ADD #(Bill_CPXOff - CannonPoof_XOffs)
	STA <Temp_Var1	; -> Temp_Var1

	JSR CannonFire_NoiseAndSmoke	 ; Play cannon fire noise and make smoke

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ActionSwitch_Do
;
; Performs the effect of the action switch per 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ActionSwitch_Do:
	LDA Level_ActSwAction
	BEQ ActSwitch_DoNothing	 ; If Level_ActSwAction = 0 (switch not hit), jump to ActSwitch_DoNothing (RTS)

	JMP_THUNKC 30, ActionSwitch_Do30

ActSwitch_DoNothing:
	RTS

