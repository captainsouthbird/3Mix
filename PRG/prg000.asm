; Source generated by DCC6502 version v1.4
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: ../rip/prg000.bin, File Size: 8193, ORG: Level_SlopeSetByQuad
;     -> NES mode enabled
;---------------------------------------------------------------------------
	; Indexed per top 2 bits of tile ($00, $40, $80, $C0)
	; Defines the shape of a slope tile for slope levels (Hills style and underground)
	; Values used for Player_Slopes:
	;	1) A tile is retrieved in Player_GetTileAndAttr
	;	2) Pick the proper table start by tile "quadrant" ($00, $40, $80, $C0)
	;	3) The relevant value from Tile_AttrTable (a series of values-per-quad
	;	   loaded by tileset) is grabbed; the tile retrieved in #1 is used as
	;	   a base value.  Hills/Underground style attr table: $25, $5F, $99, $E2
	;	4) If the tile is beneath the base this data is not used 
	;	   (e.g. using the above Hills example, if we got tile $16 -- this is 
	;	   quad $00, and the quad $00 base tile is $25, so this is not valid)
	;	5) If tile is in range, it is subtracted, so using the Hills example:
	;	   Tile $25 -- first table, index 0.  Tile $26 -- first table, index 1.
	;	   Tile $5F -- second table, index 0.  Etc...
Level_SlopeSetByQuad:
	.word Level_SlopeQuad00	; Tile quad $00
	.word Level_SlopeQuad40	; Tile quad $40
	.word Level_SlopeQuad80	; Tile quad $80
	.word Level_SlopeQuadC0	; Tile quad $C0

	; These tables are rooted by the base value for each tile quad by the only two
	; tilesets to support slopes, 3 (Hills) and 14 (Underground)
	; For reference, that attribute set is: $25, $5F, $99, $E2
	;
	; The value in the next four LUTs reference a "slope shape" as defined in the
	; Slope_LUT table that follows...

Level_SlopeQuad00:
	; Tile $1C+ (SB: Used to be $25)
	.byte $03, $03, $08, $05, $06, $11, $12, $13, $14		; <-- Only took 25 years to put these in!
	.byte $01, $07, $02, $0C, $0D, $0E, $0F, $07, $03, $03, $03, $03, $03, $03, $07, $04
	.byte $07, $04, $04, $03, $03, $03, $03, $03, $07, $04, $07, $04, $04, $04, $04, $04

Level_SlopeQuad40:
	; Tile $5F+
	.byte $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03
	.byte $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03

Level_SlopeQuad80:
	; Tile $99+
	.byte $01, $07, $02, $0C, $0D, $0E, $0F, $05, $06, $11, $12, $13, $14, $08, $07, $04
	.byte $07, $04, $04, $08, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03, $03
	.byte $03, $03, $03, $03, $03, $03, $08

Level_SlopeQuadC0:
	; Tile $E2+
	.byte $01, $07, $02, $0C, $0D, $0E, $0F, $05, $06, $11, $12, $13, $14, $07, $03, $03
	.byte $03, $03, $08, $07, $04, $07, $04, $04, $08, $08, $04
	
Slope_LUT:
	; Lower 4 bits are the ground slope height
	; Upper 4 bits are the ceiling slope height

	; 16 entries for each pixel across the 16x16 tile
	; <---                                --- X ---                                  -->
	.byte $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10	; $00 (used as "no slope", i.e. BG tile)
	.byte $0F, $0E, $0D, $0C, $0B, $0A, $09, $08, $07, $06, $05, $04, $03, $02, $01, $00	; $01
	.byte $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $0A, $0B, $0C, $0D, $0E, $0F	; $02
	.byte $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0	; $03 (all solid square tiles)
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00	; $04 (wall, see PRG008_B9F4)
	.byte $00, $10, $20, $30, $40, $50, $60, $70, $80, $90, $A0, $B0, $C0, $D0, $E0, $F0	; $05
	.byte $F0, $E0, $D0, $C0, $B0, $A0, $90, $80, $70, $60, $50, $40, $30, $20, $10, $00	; $06
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00	; $07 (unsloped ground, see PRG008_B9F4)
	.byte $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0	; $08 (unsloped ceiling, see PRG008_B9F4)
	.byte $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0	; $09
	.byte $02, $02, $02, $02, $03, $03, $03, $03, $04, $04, $04, $04, $03, $03, $03, $02	; $0A
	.byte $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $F0	; $0B
	.byte $0F, $0E, $0E, $0D, $0D, $0D, $0C, $0C, $0B, $0B, $0A, $0A, $09, $09, $08, $08	; $0C
	.byte $07, $06, $06, $05, $05, $05, $04, $04, $03, $03, $02, $02, $01, $01, $00, $00	; $0D
	.byte $00, $00, $01, $01, $02, $02, $03, $03, $04, $04, $05, $05, $05, $06, $06, $07	; $0E
	.byte $08, $08, $09, $09, $0A, $0A, $0B, $0B, $0C, $0C, $0D, $0D, $0D, $0E, $0E, $0F	; $0F
	.byte $0E, $0D, $0B, $0A, $09, $09, $08, $08, $08, $08, $08, $09, $09, $0A, $0B, $0D	; $10
	.byte $00, $00, $10, $10, $20, $20, $30, $30, $40, $40, $50, $50, $50, $60, $60, $70	; $11
	.byte $80, $80, $90, $90, $A0, $A0, $B0, $B0, $C0, $C0, $D0, $D0, $D0, $E0, $E0, $F0	; $12
	.byte $F0, $E0, $E0, $D0, $D0, $D0, $C0, $C0, $B0, $B0, $A0, $A0, $90, $90, $80, $80	; $13
	.byte $70, $60, $60, $50, $50, $50, $40, $40, $30, $30, $20, $20, $10, $10, $00, $00	; $14

	; Effect on Player's velocity per slope "shape" index (Slope_LUT above)
Slope_PlayerVel_Effect:
	.byte $00, -$03,  $03,  $00,  $00, -$03,  $03,  $00	; $00-$07
	.byte $00,  $00,  $00,  $00, -$02, -$02,  $02,  $02	; $08-$0F
	.byte $00, -$02, -$02,  $02,  $02			; $10-$14

	; Effect on Object's velocity per slope "shape" index (Slope_LUT above)
	; NOTE: Incomplete -- probably avoids concering with certain ceiling slopes 
Slope_ObjectVel_Effect:
	; $80 disables response to this slope
	.byte $00, -$02,  $02,  $00,  $00, -$02,  $02,  $00	; $00-$07
	.byte $00,  $80,  $00,  $80, -$01, -$01,  $01,  $01	; $08-$0F
	.byte $00, -$01, -$01,  $01,  $01			; $10-$14 (SB: These were missing in native SMB3!)

	; This defines 4 values per Level_Tileset, with each of those values
	; belonging to a tile "quadrant" (i.e. tiles beginning at $00, $40,
	; $80, and $C0), and defines the beginning tile which should be 
	; classified as "underwater" (Minimum Tile Under Water By Quad)
	; A value of $FF is used to indicate that no tile in that quadrant
	; is underwater (and for the first three quads is unreachable!)
Level_MinTileUWByQuad:
	; 4 values per Level_TilesetIdx, which is basically (Level_Tileset - 1)
	; Listing by valid Level_Tileset values for consistency...
	.byte $FF, $FF, $FF, $DA	;  1 Plains style
	.byte $FF, $FF, $FF, $DA	;  2 Mini Fortress style
	.byte $FF, $FF, $FF, $C1	;  3 Hills style
	.byte $FF, $FF, $FF, $DA	;  4 High-Up style
	.byte $FF, $FF, $FF, $DB	;  5 Ghost House
	.byte $02, $3F, $8A, $C0	;  6 water world
	.byte $FF, $FF, $FF, $DA	;  7 Toad House
	.byte $FF, $FF, $8A, $DA	;  8 Vertical pipe maze
	.byte $FF, $FF, $FF, $DA	;  9 desert levels
	.byte $FF, $FF, $FF, $DA	; 10 Airship
	.byte $FF, $FF, $FF, $DA	; 11 Giant World
	.byte $FF, $FF, $FF, $DA	; 12 Ice level
	.byte $FF, $FF, $FF, $DA	; 13 Sky level
	.byte $FF, $FF, $FF, $C1	; 14 Underground
	.byte $FF, $FF, $FF, $DB	; 15 ext


	; Objects detect using a specific offset from this list
	; Which "group" they use is specified by the respective value in ObjectGroup_Attributes2
Object_TileDetectOffsets:

	; YR = Y offset when reverse gravity (SB)
	; YN = Y offset when normal gravity (SB)
	; X = X offset

	; For groups:
	; Row 1: Object Y Velocity >= 0 (on ground or moving downward)
	; Row 2: Object Y Velocity < 0 (moving upward)
	; Row 3: Object X velocity < 0 (moving leftward) 
	; Row 4: Object X velocity >= 0 (moving rightward)

	; Group 0
	;       YR   YN   X
	.byte $00, $10, $03	; At feet
	.byte $10, $00, $03	; At head
	.byte $06, $0A, $01	; Wall to left
	.byte $06, $0A, $07	; Wall to right

	; Group 1
	; NOTE! See "ONLY HAPPENS WITH GROUP 1 ROW 1 AND SLOPES ENABLED"
	; In a sloped level using this group, alternate offsets (below
	; Group 12) are used for left/right wall detection!
	;	       YR   YN   X
OTDO_G1R1:	.byte $00, $10, $08	; At feet
		.byte $10, $00, $08	; At head
		.byte $07, $09, $00	; Wall to left
		.byte $07, $09, $0F	; Wall to right

	; Group 2
	;       YR   YN   X
	.byte $0C, $20, $08	; At feet
	.byte $20, $0C, $08	; At head
	.byte $0B, $15, $00	; Wall to left
	.byte $0B, $15, $0F	; Wall to right

	; Group 3
	;       YR   YN   X
	.byte $00, $00, $00	; At feet
	.byte $00, $00, $00	; At head
	.byte $00, $00, $00	; Wall to left
	.byte $00, $00, $00	; Wall to right

	; Group 4
	;       YR   YN   X
	.byte $00, $10, $08	; At feet
	.byte $10, $00, $08	; At head
	.byte $08, $08, $01	; Wall to left
	.byte $08, $08, $0E	; Wall to right

	; Group 5
	;       YR   YN   X
	.byte $00, $10, $0C	; At feet
	.byte $10, $00, $0C	; At head
	.byte $06, $0A, $01	; Wall to left
	.byte $06, $0A, $17	; Wall to right

	; Group 6
	;       YR   YN   X
	.byte $00, $20, $0C	; At feet
	.byte $20, $00, $0C	; At head
	.byte $0F, $11, $01	; Wall to left
	.byte $0F, $11, $17	; Wall to right

	; Group 7
	;       YR   YN   X
	.byte $00, $10, $08	; At feet
	.byte $10, $00, $08	; At head
	.byte $08, $08, $08	; Wall to left
	.byte $08, $08, $08	; Wall to right

	; Group 8
	;       YR   YN   X
	.byte $10, $20, $08	; At feet
	.byte $20, $10, $08	; At head
	.byte $08, $18, $01	; Wall to left
	.byte $08, $18, $0E	; Wall to right

	; Group 9
	;       YR   YN   X
	.byte $04, $04, $14	; At feet
	.byte $04, $04, $1C	; At head
	.byte $0C, $0C, $14	; Wall to left
	.byte $0C, $0C, $1C	; Wall to right

	; Group 10
	;       YR   YN   X
	.byte $00, $10, $08	; At feet
	.byte $10, $00, $08	; At head
	.byte $06, $0A, $00	; Wall to left
	.byte $06, $0A, $1F	; Wall to right

	; Group 11
	;       YR   YN   X
	.byte $00, $30, $08	; At feet
	.byte $30, $00, $08	; At head
	.byte $20, $10, $01	; Wall to left
	.byte $20, $10, $0E	; Wall to right

	; Group 12
	;       YR   YN   X
	.byte $00, $30, $08	; At feet
	.byte $30, $00, $08	; At head
	.byte $0D, $23, $01	; Wall to left
	.byte $0D, $23, $0E	; Wall to right

	; Alternate offsets used when object utilizes "Group 1" in sloped levels
	; See "ONLY HAPPENS WITH GROUP 1 ROW 1 AND SLOPES ENABLED"
	;       	YR   YN   X
OTDO_G1Alt:	.byte $0E, $02, $01	; Wall to left
		.byte $0E, $02, $0E	; Wall to right

	; Offsets used for detection of water tiles
	;       	YR   YN   X
OTDO_Water:	.byte $04, $04, $08


	; Defines the "bounding box" 
	; Selected by Object_AttrFlags lower 4 bits
Object_BoundBox:
	;    Left Right Bot Top - offsets applied to sprite X/Y
	.byte  2,   4,   2,   8	;  0
	.byte  1,  13,   2,   8	;  1
	.byte  2,  12,   2,  24	;  2
	.byte 10,  27,  -2,  18	;  3
	.byte  8,  56,   8,  56	;  4 HUGE for Big Boo
	.byte  2,  31,  -2,  18	;  5 
	.byte  2,  27,  -2,  34	;  6
	.byte  2,  20,   2,  12	;  7
	.byte  2,  43,  -2,  18	;  8
	.byte  2,  20,   2,  28	;  9
	.byte  2,  12,   2,  20	; 10
	.byte  0,  31,  -1,  14	; 11
	.byte  1,  14,  -2,  13	; 12
	.byte  4,  17,  10,  19	; 13
	.byte  4,   8,   5,  40	; 14
	.byte  2,  43,   2,  12	; 15

Object_AttrFlags:
	; Defines flags which set attributes of objects
	.byte OAT_BOUNDBOX00	; Object $00
	.byte OAT_BOUNDBOX02 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $01 - OBJ_PIPERAISE1
	.byte OAT_BOUNDBOX02 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $02 - OBJ_PIPERAISE2
	.byte OAT_BOUNDBOX02 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $03 - OBJ_PIPERAISE3 
	.byte OAT_BOUNDBOX02 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $04 - OBJ_PIPERAISE4
	.byte OAT_BOUNDBOX13	; Object $05 - OBJ_BOSS_BOWSER2
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS | OAT_FIREIMMUNITY	; Object $07 - OBJ_PARADRYBONES
	.byte OAT_BOUNDBOX00 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $08 - OBJ_PSWITCHDOOR
	.byte OAT_BOUNDBOX13	; Object $09 - OBJ_BOSS_BOWSERFINAL
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $0A - OBJ_EERIE
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $0B - OBJ_POWERUP_1UP
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OAT_BOUNDBOX11 | OAT_FIREIMMUNITY	; Object $0E - OBJ_TOPMANIC
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $0F - OBJ_RGREENTROOPA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $10 - OBJ_RREDTROOPA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $11 - OBJ_RPARATROOPAGREENHOP
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $12 - OBJ_RFLYINGREDPARATROOPA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS | OAT_FIREIMMUNITY	; Object $13 - OBJ_RBUZZYBEATLE
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $14 - OBJ_RSPINY
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $15 - OBJ_RGOOMBA
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $16 - OBJ_TOPMAN
	.byte OAT_BOUNDBOX01	; Object $17 - OBJ_SPINYCHEEP
	.byte OAT_BOUNDBOX13	; Object $18 - OBJ_BOSS_BOWSER
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $1A - OBJ_CHECKPOINT_FORCE
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OAT_BOUNDBOX02	; Object $1C - OBJ_GREENPIRANHA_FIRE_X
	.byte OAT_BOUNDBOX01	; Object $1D - OBJ_GREENSHELL
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OAT_BOUNDBOX00 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $1F - OBJ_GROWINGVINE
	.byte OAT_BOUNDBOX00 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $20 - OBJ_COINSNAKE
	.byte OAT_BOUNDBOX11 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $21 - OBJ_LAUNCHSTAR
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $22 - OBJ_MUSICSET
	.byte OAT_BOUNDBOX11 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $23 - OBJ_CHECKPOINT
	.byte OAT_BOUNDBOX05 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $24 - OBJ_ALBATOSS
	.byte OAT_BOUNDBOX00 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $25 - OBJ_PIPEWAYCONTROLLER
	.byte OAT_BOUNDBOX08 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OAT_BOUNDBOX08 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $27 - OBJ_OSCILLATING_H
	.byte OAT_BOUNDBOX08 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $28 - OBJ_OSCILLATING_V
	.byte OAT_BOUNDBOX01	; Object $29 - OBJ_SPIKE
	.byte OAT_BOUNDBOX02	; Object $2A - OBJ_PATOOIE
	.byte OAT_BOUNDBOX02	; Object $2B - OBJ_REX
	.byte OAT_BOUNDBOX08 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OAT_BOUNDBOX07	; Object $2D - OBJ_BIGBERTHA
	.byte OAT_BOUNDBOX11 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $2E - OBJ_INVISIBLELIFT
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $2F - OBJ_BOO
	.byte OAT_BOUNDBOX00 | OAT_FIREIMMUNITY	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OAT_BOUNDBOX02 | OAT_BOUNCEOFFOTHERS	; Object $31 - OBJ_GOBLIN
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY	; Object $32 - OBJ_BIRDOEGG
	.byte OAT_BOUNDBOX01	; Object $33 - OBJ_NIPPER
	.byte OAT_BOUNDBOX02 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $34 - OBJ_TOAD
	.byte OAT_BOUNDBOX02 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $35 - OBJ_PRINCESS
	.byte OAT_BOUNDBOX08 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $36 - OBJ_WOODENPLATFORM
	.byte OAT_BOUNDBOX08 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $37 - OBJ_OSCILLATING_HS
	.byte OAT_BOUNDBOX08 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $38 - OBJ_OSCILLATING_VS
	.byte OAT_BOUNDBOX01	; Object $39 - OBJ_NIPPERHOPPING
	.byte OAT_BOUNDBOX03 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OAT_BOUNDBOX01	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OAT_BOUNDBOX08 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OAT_BOUNDBOX01	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OAT_BOUNDBOX08 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS | OAT_FIREIMMUNITY	; Object $3F - OBJ_DRYBONES
	.byte OAT_BOUNDBOX03 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $40 - OBJ_DESERTBONES
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $41 - OBJ_ENDLEVELCARD
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $42 - OBJ_REX_PARTLYSQUASHED
	.byte OAT_BOUNDBOX01	; Object $43
	.byte OAT_BOUNDBOX08 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OAT_BOUNDBOX00 | OAT_FIREIMMUNITY	; Object $45 - OBJ_HOTFOOT
	.byte OAT_BOUNDBOX02	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OAT_BOUNDBOX06 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $47 - OBJ_GIANTBLOCKCTL
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $48 - OBJ_DARKNESSCTL
	.byte OAT_BOUNDBOX01	; Object $49 - OBJ_ICESNAKE
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte OAT_BOUNDBOX13	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte OAT_BOUNDBOX13	; Object $4C - OBJ_BOOMBOOMFLY
	.byte OAT_BOUNDBOX00	; Object $4D
	.byte OAT_BOUNDBOX02	; Object $4E - OBJ_BOSSBIRDO
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $4F
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $51 - OBJ_BOOLOOP
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $52 - OBJ_TREASUREBOX
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $53 - OBJ_PODOBOOCEILING
	.byte OAT_BOUNDBOX12 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $55 - OBJ_BOBOMB
	.byte OAT_BOUNDBOX07	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OAT_BOUNDBOX07	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OAT_BOUNDBOX01	; Object $58 - OBJ_FIRECHOMP
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $59 - OBJ_FIRESNAKE
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $5A - OBJ_THWOMP
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $5B - OBJ_THWOMPLEFTSLIDE
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $5C - OBJ_THWOMPRIGHTSLIDE
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $5D - OBJ_THWOMPUPDOWN
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $5E - OBJ_THWOMPDIAGONALUL
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $5F - OBJ_THWOMPDIAGONALDL
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $60 - OBJ_ICEBLOCK
	.byte OAT_BOUNDBOX01	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OAT_BOUNDBOX01	; Object $62 - OBJ_BLOOPER
	.byte OAT_BOUNDBOX13	; Object $63 - OBJ_BIGBERTHABIRTHER
	.byte OAT_BOUNDBOX01	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OAT_BOUNDBOX00 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OAT_BOUNDBOX00 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $67 - OBJ_LAVALOTUS
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OAT_BOUNDBOX01	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OAT_BOUNDBOX01	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte OAT_BOUNDBOX12 | OAT_FIREIMMUNITY	; Object $6B - OBJ_PILEDRIVER
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $6C - OBJ_GREENTROOPA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $6D - OBJ_REDTROOPA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS | OAT_FIREIMMUNITY	; Object $70 - OBJ_BUZZYBEATLE
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $71 - OBJ_SPINY
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $72 - OBJ_GOOMBA
	.byte OAT_BOUNDBOX01	; Object $73 - OBJ_PARAGOOMBA
	.byte OAT_BOUNDBOX01	; Object $74 - OBJ_PARAGOOMBAWITHMICROS
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $75 - OBJ_BOSSATTACK
	.byte OAT_BOUNDBOX01	; Object $76 - OBJ_JUMPINGCHEEPCHEEP
	.byte OAT_BOUNDBOX01	; Object $77 - OBJ_GREENCHEEP
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $78 - OBJ_BULLETBILL
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $79 - OBJ_BULLETBILLHOMING
	.byte OAT_BOUNDBOX13 | OAT_BOUNCEOFFOTHERS	; Object $7A - OBJ_BIGGREENTROOPA
	.byte OAT_BOUNDBOX13 | OAT_BOUNCEOFFOTHERS	; Object $7B - OBJ_BIGREDTROOPA
	.byte OAT_BOUNDBOX13 | OAT_BOUNCEOFFOTHERS	; Object $7C - OBJ_BIGGOOMBA
	.byte OAT_BOUNDBOX13	; Object $7D - OBJ_BIGGREENPIRANHA
	.byte OAT_BOUNDBOX13 | OAT_BOUNCEOFFOTHERS	; Object $7E - OBJ_BIGGREENHOPPER
	.byte OAT_BOUNDBOX13	; Object $7F - OBJ_BIGREDPIRANHA
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte OAT_BOUNDBOX02	; Object $81 - OBJ_HAMMERBRO
	.byte OAT_BOUNDBOX02	; Object $82 - OBJ_BOOMERANGBRO
	.byte OAT_BOUNDBOX01	; Object $83 - OBJ_LAKITU
	.byte OAT_BOUNDBOX01	; Object $84 - OBJ_SPINYEGG
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $85 - OBJ_OCTOGOOMBA
	.byte OAT_BOUNDBOX13	; Object $86 - OBJ_HEAVYBRO
	.byte OAT_BOUNDBOX02	; Object $87 - OBJ_FIREBRO
	.byte OAT_BOUNDBOX01	; Object $88 - OBJ_ORANGECHEEP
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $89 - OBJ_CHAINCHOMP
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $8A - OBJ_SHYGUY_GREEN
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $8B - OBJ_SHYGUY_RED
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $8C - OBJ_NINJI
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $8D - OBJ_FAZZYCRAB
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $8E - OBJ_FLAREUP
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $8F - OBJ_FISHBONE
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $90 - OBJ_TILTINGPLATFORM
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $91 - OBJ_TWIRLINGPLATCWNS
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $92 - OBJ_TWIRLINGPLATCW
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $93 - OBJ_TWIRLINGPERIODIC
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $94 - OBJ_SPARK_CW
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $95 - OBJ_SPARK_CCW
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $96 - OBJ_SPARK_CW_FAST
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $97 - OBJ_SPARK_CCW_FAST
	.byte OAT_BOUNDBOX02	; Object $98 - OBJ_CLIMBINGKOOPA_G
	.byte OAT_BOUNDBOX02	; Object $99 - OBJ_CLIMBINGKOOPA_R
	.byte OAT_BOUNDBOX02	; Object $9A - OBJ_CLIMBINGKOOPA_GB
	.byte OAT_BOUNDBOX02	; Object $9B - OBJ_CLIMBINGKOOPA_RB
	.byte OAT_BOUNDBOX00	; Object $9C
	.byte OAT_BOUNDBOX14 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $9E - OBJ_PODOBOO
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $9F - OBJ_PARABEETLE
	.byte OAT_BOUNDBOX02	; Object $A0 - OBJ_GREENPIRANHA
	.byte OAT_BOUNDBOX02	; Object $A1 - OBJ_GREENPIRANHA_FLIPPED
	.byte OAT_BOUNDBOX10	; Object $A2 - OBJ_REDPIRANHA
	.byte OAT_BOUNDBOX10	; Object $A3 - OBJ_REDPIRANHA_FLIPPED
	.byte OAT_BOUNDBOX02	; Object $A4 - OBJ_GREENPIRANHA_FIRE
	.byte OAT_BOUNDBOX02	; Object $A5 - OBJ_GREENPIRANHA_FIREC
	.byte OAT_BOUNDBOX10	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OAT_BOUNDBOX10	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OAT_BOUNDBOX11 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $A8 - OBJ_UPARROW
	.byte OAT_BOUNDBOX11 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $A9 - OBJ_MANYARROW
	.byte OAT_BOUNDBOX00 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $AA
	.byte OAT_BOUNDBOX00 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $AB
	.byte OAT_BOUNDBOX15 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $AC - OBJ_FIREJET_LEFT
	.byte OAT_BOUNDBOX12	; Object $AD - OBJ_ROCKYWRENCH
	.byte OAT_BOUNDBOX11 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $AE - OBJ_BOLTLIFT
	.byte OAT_BOUNDBOX01 | OAT_FIREIMMUNITY	; Object $AF - OBJ_ENEMYSUN
	.byte OAT_BOUNDBOX13 | OAT_FIREIMMUNITY	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OAT_BOUNDBOX15 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OAT_BOUNDBOX14 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OAT_BOUNDBOX01	; Object $B3

	; SB: NEW extended objects BEGIN!
Object_AttrFlags_Ext:
	.byte OAT_BOUNDBOX09 | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $E0 - OBJ_BOSS_MOUSER
	.byte OAT_BOUNDBOX09 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY	; Object $E1 - OBJ_BOSS_BOWSERJR
	.byte OAT_BOUNDBOX06 | OAT_FIREIMMUNITY	; Object $E2 - OBJ_BOSS_WART
	.byte OAT_BOUNDBOX04 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY	; Object $E3 - OBJ_BOSS_BIGBOO1
	.byte OAT_BOUNDBOX04 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY	; Object $E4 - OBJ_BOSS_BIGBOO2
	.byte OAT_BOUNDBOX04 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY	; Object $E5 - OBJ_BOSS_BIGBOO3
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $E6 - OBJ_YOSHI
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $E7 - OBJ_BOSS_BOOMER
	.byte OAT_BOUNDBOX05 | OAT_WEAPONIMMUNITY | OAT_HITNOTKILL	; Object $E8 - OBJ_BOSS_REZNOR (Bounding box actually for platform more than Reznor, but both use it)
	.byte OAT_BOUNDBOX09	; Object $E9 - OBJ_URCHIN_V
	.byte OAT_BOUNDBOX09	; Object $EA - OBJ_URCHIN_H
	.byte OAT_BOUNDBOX01	; Object $EB - OBJ_GAO
	.byte OAT_BOUNDBOX01 | OAT_BOUNCEOFFOTHERS	; Object $EC - OBJ_POKEY
	.byte OAT_BOUNDBOX00 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $ED - OBJ_SANDFILL_CTL
	.byte OAT_BOUNDBOX13	; Object $EE - OBJ_BOSS_TOTOMESU
	.byte OAT_BOUNDBOX13	; Object $EF - OBJ_BOSS_CLYDE
	.byte OAT_BOUNDBOX02 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $F0 - OBJ_DELFINOSLOTS
	.byte OAT_BOUNDBOX02 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $F1 - OBJ_PINATA
	.byte OAT_BOUNDBOX06	; Object $F2 - OBJ_BOSS_PETEY
	.byte OAT_BOUNDBOX02	; Object $F3 - OBJ_MAGIBLOT
	.byte OAT_BOUNDBOX00 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $F4 - OBJ_ARENA_CTL
	.byte OAT_BOUNDBOX06 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $F5 - OBJ_BOSS_BLECK
	.byte OAT_BOUNDBOX01 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $F6 - OBJ_BLECK_PROJ
	.byte OAT_BOUNDBOX00 | OAT_WEAPONIMMUNITY | OAT_FIREIMMUNITY | OAT_HITNOTKILL	; Object $F7 - OBJ_BATTLE_CTL
	.byte OAT_BOUNDBOX00	; Object $F8
	.byte OAT_BOUNDBOX00	; Object $F9
	.byte OAT_BOUNDBOX00	; Object $FA
	.byte OAT_BOUNDBOX00	; Object $FB
	.byte OAT_BOUNDBOX00	; Object $FC
	.byte OAT_BOUNDBOX00	; Object $FD
	.byte OAT_BOUNDBOX00	; Object $FE
	.byte OAT_BOUNDBOX00	; Object $FF


	; Offsets into Sprite_RAM used by objects
SprRamOffsets:
	; The specified Sprite_RAM offset is calculated by object's index
	; added to Counter_7to0 (i.e. a value 0 to 7) so as to evenly
	; distribute the drawing of objects over available sprites and
	; help cope with the sprites-per-scanline drawing limits.
	;
	; Basically, on different frames, different objects will have 
	; different sprite priority, so while there may be flicker, at 
	; least everything is somewhat visible
	.byte $40, $E8, $58, $D0, $70, $B8, $88, $A0, $40, $E8, $58, $D0, $70, $B8, $88

	; SB: Required because extended objects don't immediately follow the others
Object_CalcAttrFlagOff:
	LDY Level_ObjectID,X	 ; Y = Object ID 
	CPY #OBJ_EXTBANK_BEGIN
	BLT Object_CalcAttrFlagOff_Done	; If not an extended object, jump to Object_CalcAttrFlagOff_Done

	; There's a gap between the last valid "regular" object and the special objects;
	; This intends to offset the gap...
	TYA		; 'Y' (object ID) -> 'A'
	SUB #(OBJ_EXTBANK_BEGIN - (Object_AttrFlags_Ext - Object_AttrFlags))	; Offset to line up with ID gap
	TAY		; -> 'Y'
	
Object_CalcAttrFlagOff_Done:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DoTimeBonus
;
; Converts your time remaining to score bonus, but only if there
; is no BGM playing!  Also resets 'X' to object slot index.
; "BEQ" branches after this function if the clock is at 000.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TimeBonus_Score:
	.byte 50, 5	; 500 and 50

; $C412 
DoTimeBonus:
	LDA SndCur_Music1	 
	BNE PRG000_C446	 ; If any music playing, jump to PRG000_C446 (RTS)

	JMP_THUNKC 30, TimeBonus_Score30

PRG000_C446:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SpecialObj_FindEmptyAbort
; SpecialObj_FindEmptyAbortY
;
; Finds an empty special object slot (returned in 'Y') or "aborts" 
; if no slot is open OR if the object has any invisible sprites.
; "abort" = will not return to caller...
;
; SpecialObj_FindEmptyAbortY just allows a specified range
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $C447
SpecialObj_FindEmptyAbort:
	LDY #$05
SpecialObj_FindEmptyAbortY:
	LDA SpecialObj_ID,Y
	BEQ PRG000_C454	 ; If object slot is dead/empty, jump to PRG000_C454 
	DEY		 ; Y--
	BPL SpecialObj_FindEmptyAbortY	 ; While Y >= 0, loop!

PRG000_C451:
	; Do not return to caller!!
	PLA
	PLA
	RTS

PRG000_C454:
	JSR Object_AnySprOffscreen

	BNE PRG000_C451	 ; If any sprites are off-screen, jump to PRG000_C451

	; Clear viz flags
	LDA #0
	STA SpecialObj_VisFlags,Y

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PrepareNewObjectOrAbort
;
; Finds an empty object slot (returned in 'X') and prepares it or
; "aborts"  if no slot is open
; "abort" = will not return to caller...
;
; Moved out of PRG007 to make some room for modifications...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Provides a newly prepared object or does not return to caller!
PrepareNewObjectOrAbort:
	LDX #$04	  ; X = 4
PRG000_XFCF:
	LDA Objects_State,X
	BEQ PRG000_XFDC	 ; If this object state = 0 (Dead/Empty), jump to PRG000_BFDC

	DEX		 ; X--
	BPL PRG000_XFCF	 ; While X >= 0, loop!

	; No object slots available; do not return to caller!!
	PLA
	PLA

	LDX <SlotIndexBackup	 ; Restore 'X' to its slot index value

	RTS		 ; Return

PRG000_XFDC:
	JSR Level_PrepareNewObject	 ; Prepare this new object

	; Set to normal state
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	RTS		 ; Return


	; Goes into Score_Get100PlusPts, but object index is stored in 'Y'
	; NOTE: Overwrites 'X' anyway, so be careful!
Score_Get100PlusPtsY:
	PHA		 ; Save 'A'
	TYA
	TAX		 ; 'X' = 'Y'
	PLA		 ; Restore 'A'

	; Get at least 100 pts based on value in 'A'
Score_Get100PlusPts:
	ADD #$05	; Base at 100 points
	JSR Score_PopUp
	LDX <SlotIndexBackup	 ; X = object slot index
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Score_PopUp
;
; Pops up a score value (e.g. from a killed enemy)
;
; A = score value
; X = index of on-screen object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Score_PopUp:
; $C467
	PHA		 	; Save input value
	STY <Temp_Var15	 	; Backup 'Y' -> Temp_Var15

	JSR Score_FindFreeSlot	; Get free Scores_Value slot

	PLA		 	; Restore input value
	STA Scores_Value,Y	; Store input value

	LDA Objects_SpriteY,X
	SUB #16
	CMP #192
	BLT PRG000_C47D	 ; If (sprite's Y - 16) < 192, jump to PRG000_C47D

	LDA #$05	 	 ; A = 5

PRG000_C47D:
	STA Scores_Y,Y	 ; Set score Y

	; Set score X to spawning object
	LDA Objects_SpriteX,X	
	STA Scores_X,Y	 

	; Set score counter to $30
	LDA #$30
	STA Scores_Counter,Y

	LDY <Temp_Var15	; Restore 'Y'

	RTS		 ; Return





	; Find a free slot to display the score in
Score_FindFreeSlot:
	LDY #$04	 ; Y = 4
PRG000_C490:
	LDA Scores_Value,Y
	BEQ PRG000_C49A	 ; If Scores_Value[Y] = 0, jump to PRG000_C49A (RTS)

	DEY		 ; Y--
	BPL PRG000_C490	 ; While Y >= 0, loop

	LDY #$04	 ; Y = 4

PRG000_C49A:
	RTS		 ; Return

PRG000_C49B:

	; Common init point for "power up" coins (coins that emerge from bricks and blocks)

	; Temp_Var1 = Y Lo
	; Temp_Var2 = X lo

	LDY #$03	 ; Y = 3

PRG000_C49D:
	LDA CoinPUp_State,Y
	BEQ PRG000_C4A7	 ; If this coin slot state = 0, it's free, go use it!
	DEY		 ; Y--
	BPL PRG000_C49D	 ; While Y >= 0, loop!

	; If all else fails, just overwrite the oldest slot!
	LDY #$03	 ; Y = 3

PRG000_C4A7:

	; Play coin sound
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1

	LDA #$01
	STA CoinPUp_State,Y	; Set coin state to 1

	LDA <Temp_Var1		; Get input Y
	SUB Level_VertScroll	; Make relative to vertical scroll
	SBC #24	 		; Subtract 24
	STA CoinPUp_Y,Y	 	; Store as coin's Y

	LDA <Temp_Var2		; Get input X
	SUB <Horz_Scroll	; Make relative to horizontal scroll
	STA CoinPUp_X,Y	 	; Store as coin's X

	LDA #-5	 
	STA CoinPUp_YVel,Y	; Set Y Vel = -5

	LDA #$01	 
	STA CoinPUp_Counter,Y	; Set counter to 1

	RTS		 ; Return


Conveyor_CarryX:	.byte -$01, $01	; Left, Right
Conveyor_CarryXHi:	.byte $FF, $00	; 16-bit sign extension

	; Checks for and handles object touching conveyor belt by carrying object
; $C4D6
Object_HandleConveyorCarry:
	LDA <Objects_DetStat,X
	AND #$03
	BNE PRG000_C4F5	 ; If object has hit a wall, jump to PRG000_C4F5 (RTS)

	LDA Object_TileFeet2
	SUB #TILE2_CONVEYORL
	CMP #$02
	BGE PRG000_C4F5	 ; If object is not standing on a conveyor belt, jump to PRG000_C4F5 (RTS)

	TAY		 ; Conveyor tile relative index -> 'Y'

	LDA <Objects_X,X
	ADC Conveyor_CarryX,Y
	STA <Objects_X,X

	LDA <Objects_XHi,X
	ADC Conveyor_CarryXHi,Y
	STA <Objects_XHi,X

PRG000_C4F5:
	RTS		 ; Return


	; Checks for and handles object touching conveyor belt, storing result into LRBounce_Vel
; $CF46
Object_HandleConveyorBounceVel:
	LDA Level_PSwitchCnt
	BNE PRG000_C4F5	 ; If P-Switch is active, jump to PRG000_C4F5

	LDA Object_TileFeet2
	SUB #TILE2_CONVEYORL
	CMP #$02
	BGE PRG000_C4F5	 ; If object is not standing on a conveyor belt, jump to PRG000_C4F5 (RTS)
 
	TAY		 ; Conveyor tile relative index -> 'Y'

	LDA Conveyor_CarryX,Y

	LDY #-$01	 ; Y = -$01

	EOR <Objects_XVel,X	 ; Check if object is not going with conveyor
	BMI PRG000_C511	 ; If the signs differ (going against conveyor), jump to PRG000_C511

	LDY #$01	 ; Y = $01

PRG000_C511:
	STY LRBounce_Vel ; -> LRBounce_Vel

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_HitGround
;
; When object hits the ground, this aligns it properly to a tile
; 
; X = index of on-screen object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $C515
Object_HitGround:
	LDA <Objects_DetStat,X
	BPL PRG000_C533	 	; If object is NOT touching the "32 pixel partition" floor, jump to PRG000_C533

	; Object is touching the "32 pixel partition" floor...

	LDA <Objects_Y,X
	SUB Level_VertScroll
	AND #$f0
	ADD #$01
	ADD Level_VertScroll
	STA <Objects_Y,X	 ; Aligns to grid and adds 1

	LDA #$00	 
	ADC #$00	 
	STA <Objects_YHi,X	 ; Apply carry

	JMP PRG000_C53D	 ; Jump to PRG000_C53D

PRG000_C533:
	LDA Objects_ReverseGrav,X
	BNE Object_HitGround_Rev	; If object has reversed gravity, jump to Object_HitGround_Rev

	LDA <Objects_Y,X
	AND #$f0
	ADD Object_SlopeHeight
	STA <Objects_Y,X	 ; Align to tile and apply slope

PRG000_C53D:
	LDA #$00
	STA <Objects_YVel,X	 ; Halt vertical movement

	RTS		 ; Return

Object_HitGround_Rev:
	LDA <Objects_Y,X
	AND #$f0
	ADD Object_SlopeHeight
	STA <Objects_Y,X	 ; Align to tile and apply slope

	JMP PRG000_C53D	; Jump to PRG000_C53D

	; The only difference amongst the Object_WorldDetect[x] entries
	; are the input value, which specifies the limit that an object
	; should acknowledge a floor tile.  E.g., Object_WorldDetect4
	; means the object will not detect a floor if it is more than
	; 4 pixels vertically down in to it.  "N1" (Negative one) is
	; thus basically to never use that limit because the object
	; can't be at a depth of "-1 pixels into the tile"

; $C542
Object_WorldDetectN1:
	LDA #$ff	; Use A = $FF
	BNE PRG000_C54C	; Jump (technically always) to PRG000_C54C

; $C546 
Object_WorldDetect8:
	LDA #$08	; Use A = 8
	BNE PRG000_C54C	; Jump (technically always) to PRG000_C54C

; $C54A
Object_WorldDetect4:
	LDA #$04	; Use A = 4

PRG000_C54C:
	PHA		 ; Save input value (not used until PRG000_C649)

	CPX #$05
	BNE PRG000_C559	 ; If object slot is NOT 5, jump to PRG000_C559

	LDA ObjSplash_DisTimer,X
	BEQ PRG000_C559	 ; If ObjSplash_DisTimer = 0, jump to PRG000_C559

	DEC ObjSplash_DisTimer,X	 ; ObjSplash_DisTimer --

PRG000_C559:
	LDA <Objects_DetStat,X
	STA Temp_VarNP0	 ; Object's detection status -> Temp_VarNP0

	LDA #$00
	STA <Objects_DetStat,X	; Clear Object's detection status
	STA Object_SlopeHeight	; Clear Object's slope height
	STA LRBounce_Vel	; Clear left/right bounce power

	LDA Objects_ReverseGrav,X
	BEQ Objects_WDetect_NoRevSlopeH

	; In reverse gravity, default Object_SlopeHeight to 15
	LDA #15
	STA Object_SlopeHeight

Objects_WDetect_NoRevSlopeH:

	JSR Object_GetAttrAndMoveTiles	 ; Fill in values for Object_TileFeet/Quad and Object_TileWall/Quad

	PLA		 ; Restore input value
	STA <Temp_Var1	 ; Store into Temp_Var1

	LDY Object_AttrWall	; Y = detected quadrant of potential wall tile
	LDA Object_TileWall	; A = detected tile index
	CMP Tile_AttrTable+4,Y
	BLT PRG000_C584	 	; If the tile's index < the beginning wall/ceiling solid tile for this quad, jump to PRG000_C584

	; Object is touching solid wall tile

	LDA #$01		; A = 1

	LDY <Objects_XVel,X
	BPL PRG000_C580	 ; If object's X velocity >= 0 (still or moving rightward), jump to PRG000_C580

	; Negative X vel...
	ASL A		 	; A = 2

PRG000_C580:
	ORA <Objects_DetStat,X	; Set bit 0 or 1
	STA <Objects_DetStat,X	 ; Update Objects_DetStat

PRG000_C584:
	LDY Object_AttrFeet	 ; Y = detected quadrant of tile

	LDA <Objects_YVel,X
	BPL PRG000_C5A9	 	; If object's Y velocity >= 0 (still or moving downward), jump to PRG000_C5A9

	; Object moving upwards... (ceiling detection)

	LDA Level_SlopeEn
	BEQ PRG000_C59A	 	; If slopes are not enabled here, jump to PRG000_C59A

	; Slope detection (not specific)
	
	LDA Object_TileFeet
	CMP Tile_AttrTable,Y
	BLT PRG000_C5A8	 ; If tile is not within range of tiles solid at ceiling, jump to PRG000_C5A8 (RTS)
	BGE PRG000_C5A2	 ; Otherwise, jump to PRG000_C5A2

PRG000_C59A:

	; Non-slope detection

	LDA Object_TileFeet
	CMP Tile_AttrTable+4,Y
	BLT PRG000_C5A8	 ; If tile is not within range of tiles solid at ceiling, jump to PRG000_C5A8 (RTS)

PRG000_C5A2:
	; Flag ceiling impact
	LDA <Objects_DetStat,X
	ORA #$08
	STA <Objects_DetStat,X

PRG000_C5A8:
	RTS		 ; Return

PRG000_C5A9:

	; Object moving downwards (floor detection)

	LDA Object_TileFeet
	CMP Tile_AttrTable,Y
	BGE PRG000_C5B4	 ; If tile is within range of the starting solid tile, jump to PRG000_C5B4
	JMP PRG000_C65D	 ; Otherwise, jump to PRG000_C65D

PRG000_C5B4:
	LDY Level_SlopeEn
	BNE PRG000_C5BC	 ; If slopes are enabled, jump to PRG000_C5BC
	JMP PRG000_C649	 ; Jump to PRG000_C649

PRG000_C5BC:

	; Slopes...

	; Any of the following tiles, jump to Object_SlopeFlat_Correct
	CMP #TILE3_VERTGROUNDL
	BEQ Object_SlopeFlat_CorrectJmp	

	CMP #TILE3_VERTGROUNDR
	BEQ Object_SlopeFlat_CorrectJmp

	CMP #TILE14_ABOVE_MIDGROUND
	BEQ Object_SlopeFlat_CorrectJmp

	CMP #TILE3_MIDGROUND
	BEQ Object_SlopeFlat_CorrectJmp

	CMP #TILE3_WMIDGROUND
	BNE PRG000_C5D3	

Object_SlopeFlat_CorrectJmp:

	JMP Object_SlopeFlat_Correct	 ; Jump to Object_SlopeFlat_Correct


PRG000_C5D3:

	; Slopes enabled, not touching one of the flat solids

	LDA <Objects_Y,X

	LDY <Objects_DetStat,X
	BPL OWD_Not32PP	 	; If object is NOT touching the "32 pixel partition" floor, jump to OWD_Not32PP

	SUB Level_VertScroll

OWD_Not32PP:
	AND #$0f
	STA <Temp_Var1	; Temp_Var1 = object's tile-relative vertical position

	LDA <Temp_Var16	; Temp_Var16 right now is ObjTile_DetXLo
	AND #$0f
	STA <Temp_Var16	; Temp_Var16 = object's tile-relative horizontal position

	LDY Level_Tile_Slope	 ; Y = object's detected slope
	LDA Slope_ObjectVel_Effect,Y	 ; Get value by slope
	CMP #$80
	BNE PRG000_C5EC	 ; If value <> $80, jump to PRG000_C5EC

	JMP PRG000_C65D	 ; Otherwise, jump to PRG000_C65D

PRG000_C5EC:
	; Slope response

	; SB: Retooling to work more like Player's retrieval of slopes so enemies
	; can properly utilize ceiling slopes $10+
	LDA #LOW(Slope_LUT)
	STA <Level_GndLUT_L

	; Tile "shape" index values $1x will add 1 to Level_GndLUT_H
	; Because of 16 entries per tile in Slope_LUT
	TYA	; Slope shape index -> 'A'
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ADD #HIGH(Slope_LUT)
	STA <Level_GndLUT_H

	TYA	; Slope shape index -> 'A'
	ASL A
	ASL A
	ASL A
	ASL A	; multiply by 16, since there's 16 entries per slope
	ADD <Temp_Var16	 ; Add the tile-relative horizontal position (offset to pixel specific height on this slope)
	TAY

	LDA Objects_ReverseGrav,X
	BEQ Object_WorldDetect_SlopeNoRev	; If object is NOT under reverse gravity, jump to Object_WorldDetect_SlopeNoRev

	; SB: Reverse gravity slope calculation
	LDA [Level_GndLUT_L],Y
	LSR A
	LSR A
	LSR A
	LSR A	
	STA <Temp_Var2	 ; Upper 4 bits of slope (the "ceiling" slope height) -> Temp_Var2

	LDA <Temp_Var1	
	CMP #4
	BLT PRG000_C606	 ; If object's tile-relative Y position < 4, jump to PRG000_C606

	CMP <Temp_Var2
	BEQ PRG000_C606
	BLT PRG000_C606	 ; If object's tile-relative Y position < calculated slope height, jump to PRG000_C606

	BGE PRG000_C65D	 ; Otherwise, jump to PRG000_C65D
	
Object_WorldDetect_SlopeNoRev:
	LDA [Level_GndLUT_L],Y
 
	AND #$0f	
	STA <Temp_Var2	 ; Lower 4 bits of slope (the "floor" slope height) -> Temp_Var2

	LDA <Temp_Var1	
	CMP #12
	BGE PRG000_C606	 ; If object's tile-relative Y position >= 12, jump to PRG000_C606

	CMP <Temp_Var2
	BLT PRG000_C65D	 ; If object's tile-relative Y position < calculated slope height, jump to PRG000_C65D

PRG000_C606:
	LDA <Temp_Var2		
	STA Object_SlopeHeight	 ; Store Object_SlopeHeight

	; Set "hit ground" flag
	LDA <Objects_DetStat,X
	ORA #$04
	STA <Objects_DetStat,X

	LDY Level_Tile_Slope	 ; Y = object's detected slope

	LDA <Objects_XVel,X
	LSR A
	LSR A
	LSR A
	LSR A		; A = "whole" part of Object's X Velocity
	BNE PRG000_C61E	 ; If not zero, jump to PRG000_C61E

	LDA #$01	 ; Otherwise, use A = 1

PRG000_C61E:
	CMP #$08	 
	BLT PRG000_C624	 ; If object's X velocity < 8, jump to PRG000_C624

	ORA #$f0	 ; Sign extend

PRG000_C624:
	LDX Slope_ObjectVel_Effect,Y ; X = value from Slope_ObjectVel_Effect
	CPX #$00	
	BNE PRG000_C62E	 ; If value <> 0, jump to PRG000_C62E

	; Otherwise...
	LDX #$00	 ; X = 0
	TXA		 ; A = 0

PRG000_C62E:
	CPX #$00	 
	BPL PRG000_C635	 ; If X is not negative, jump to PRG000_C635

	JSR Negate	 ; Otherwise, negate (absolute value)

PRG000_C635:
	STX <Temp_Var1	 ; -> Temp_Var1

	LDX <SlotIndexBackup	 ; X = object slot index
	STA Objects_Slope,X	 ; Absolute value slope

	LDA <Temp_Var1		 ; A = value from Slope_ObjectVel_Effect

	LDY <Objects_XVel,X
	BPL PRG000_C645	 ; If X Velocity >= 0, jump to PRG000_C645

	; X velocity < 0 ...
	JSR Negate	 ; Negate value

PRG000_C645:
	STA LRBounce_Vel ; Store the "power" of the left/right bouncer

	RTS		 ; Return


PRG000_C649:
	LDA Player_PartDetEn
	BNE PRG000_C656	 ; If Player_PartDetEn is set (the object hit the visual ground), jump to PRG000_C656

	; The original input value finally winds up here.  This limits when an object will actually 
	; acknowledge "hitting ground."  Basically, if the object is more than [input value] pixels
	; down in to the tile, it will not count as having hit the floor.

	; If gravity is reversed, must use an inverted check!
	LDA Objects_ReverseGrav,X
	BNE Object_WorldDetect_FHChkRev

	LDA <Objects_Y,X
	AND #$0f	 ; Object's tile-relative vertical position
	CMP <Temp_Var1	
	BGE PRG000_C65C	 ; If object is too far down in to the tile, jump to PRG000_C65C (RTS)
 
PRG000_C656:

	; Flag object as "hit ground"
	LDA <Objects_DetStat,X
	ORA #$04
	STA <Objects_DetStat,X

PRG000_C65C:
	RTS		 ; Return


PRG000_C65D:
	LDA Level_SlopeEn
	BEQ PRG000_C67E	 ; If slopes are not enabled in this level, jump to PRG000_C67E

	; This is a correction applied for when an enemy steps over the edge of a slope:
	;   ___
	;  /   \  <-- like when he walks across the top, down the side
	; Helps keep the enemy following the curve downward, especially enemies like red
	; shell koopa troopas that otherwise turn away at an edge...

	LDY #$00	 ; Y = 0

	LDA Objects_ReverseGrav,X
	BEQ Object_WDetSlopeFix_NoRev

	; Reverse gravity, reverse magnitude of slope correction
	LDA Objects_Slope,X
	JSR Negate
	JMP Object_WDetSlopeFix_Cont

Object_WDetSlopeFix_NoRev:
	LDA Objects_Slope,X

Object_WDetSlopeFix_Cont:
	BEQ PRG000_C67E	 ; If slope value = 0, jump to PRG000_C67E
	BPL PRG000_C66C	 ; If slope is positive, jump to PRG000_C66C

	DEY		 ; Otherwise, Y = $FF

PRG000_C66C:
	ADD <Objects_Y,X
	STA <Objects_Y,X ; Update Y

	TYA		 ; A = $00/$FF, sign extension

	ADC <Objects_YHi,X
	STA <Objects_YHi,X ; Apply to Y Hi

	LDA #$00	 
	STA Objects_Slope,X ; Clear slope value

	JMP Object_WorldDetectN1	 ; Jump to Object_WorldDetectN1

PRG000_C67E:
	RTS		 ; Return


	; SB: Reversed object floor limit check
Object_WorldDetect_FHChkRev:
	LDA <Objects_Y,X
	AND #$0f	 ; Object's tile-relative vertical position
	STA <Temp_Var2	 ; -> Temp_Var2
	
	LDA #16
	SUB <Temp_Var1	 ; Calculate an inverted limit
	CMP <Temp_Var2
	BGE PRG000_C65C	 ; If object is too far up in to the tile, jump to PRG000_C65C (RTS)
	BLT PRG000_C656	 ; Otherwise, jump to PRG000_C656	


Object_SlopeFlat_Correct:

	; Flat ground tiles in a sloped world

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG000_C69C	 ; If object is killed, jump to PRG000_C69C (RTS)

	CMP #OBJSTATE_HELD
	BEQ PRG000_C69C	 ; If object is being held, jump to PRG000_C69C (RTS)


	LDY Objects_ReverseGrav,X
	BNE Object_SlopeFlats_Rev	; If object has reversed gravity, jump to Object_SlopeFlats_Rev


	LDA <Objects_Y,X
	AND #$f0
	SUB #$01
	STA <Objects_Y,X	; Align object to one pixel above the tile

	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X	; Set the Y Hi

	JMP Object_WorldDetectN1	; Jump to Object_WorldDetectN1

PRG000_C69C:
	RTS		 ; Return


Object_SlopeFlats_Rev:

	; SB: Corrections for inverted world
	LDA <Objects_Y,X
	AND #$f0
	ADD #16
	STA <Objects_Y,X	; Align object to one pixel above the tile

	LDA <Objects_YHi,X
	ADC #$00
	STA <Objects_YHi,X	; Set the Y Hi

	JMP Object_WorldDetectN1	; Jump to Object_WorldDetectN1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_GetAttrAndMoveTiles
;
; Gets tiles for an object based on its attribute settings and
; current state of movement.  Handles entering/leaving water.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_GetAttrAndMoveTiles:

	LDY #(OTDO_Water - Object_TileDetectOffsets)	; Special offsets used for checking for water tiles
	JSR Object_DetectTile	; Get tile here

	ASL A
	ROL A
	ROL A		 ; Upper 2 bits shift right 6, effectively
	AND #%00000011	 ; Keep these bits, i.e. "tile quadrant"
	STA <Temp_Var1	 ; -> Temp_Var1
	TAY		 ; -> 'Y'

	LDA <Level_Tile
	CMP Tile_AttrTable,Y
	BGE PRG000_C6FD	 ; If this tile >= this attribute tile, jump to PRG000_C6FD (may be solid)

	LDX #$00	 ; X = 0 (object is NOT underwater)

	; If this tile is TILEA_PSWITCH_PRESSED, TILE1_WFALLTOP, or PRG000_C6D0, jump to PRG000_C6D0
	; Object's apparently aren't in-water in a waterfall?
	CMP #TILEA_PSWITCH_PRESSED
	BEQ PRG000_C6D0
	CMP #TILE1_WFALLTOP
	BEQ PRG000_C6D0
	CMP #TILE1_WFALLMID
	BEQ PRG000_C6D0

	; SB: Ghost house override; no tiles in $E2+ will be "underwater"
	LDA Level_TilesetIdx
	CMP #4
	BNE Object_NotGHUWChk	; If this is not a Ghost House, jump to Object_NotGHUWChk

	; Check for any $E2+ range tiles
	LDA <Level_Tile
	CMP #$E2
	BGE PRG000_C6D0	; If tile is $E2+, jump to PRG000_C6D0 (object not in water)

Object_NotGHUWChk:
	LDA Level_TilesetIdx
	ASL A	
	ASL A		 ; Offset to beginning of underwater-by-quad table
	ADD <Temp_Var1	 ; Add quadrant offset
	TAY		 ; -> 'Y' 
	LDA Level_MinTileUWByQuad,Y	; Get the starting underwater tile
	CMP <Level_Tile	
	BGE PRG000_C6D0	 ; If starting underwater tile is >= the detected tile, jump to PRG000_C6D0

	INX		 ; X = 1 (object is underwater)

PRG000_C6D0:
	TXA		 ; X -> A

	LDX <SlotIndexBackup	; Restore 'X' as object slot index

	CMP Objects_InWater,X	
	BEQ PRG000_C6FA	 	; If object is either still in water / out of water (hasn't changed), jump to PRG000_C6FA

	PHA		 	; Save underwater flag

	LDA <Level_Tile		 ; A = tile index
	LDY <Temp_Var1		 ; Y = tile quadrant
	CMP Tile_AttrTable,Y

	PLA		 	; Restore underwater flag

	BGE PRG000_C6FA	 	; If tile index >= the attribute tile, solid tile, jump to PRG000_C6FA

	PHA		 	; Save underwater flag

	LDA Objects_LastTile,X
	PHA		 	; Save Objects_LastTile

	ASL A		 
	ROL A		 
	ROL A		 ; Upper 2 bits shift right 6, effectively
	AND #%00000011	 ; Keep these bits, i.e. "tile quadrant"
	TAY		 ; Y = quadrant of last detected tile

	PLA		 ; Restore the last detected tile

	CMP Tile_AttrTable,Y

	PLA		 ; Restore the underwater flag

	BGE PRG000_C6FA	 ; If last detected tile >= the starting underwater tile, jump to PRG000_C6FA

	PHA		 ; Save underwater flag

	JSR Object_WaterSplash	 ; Hit water; splash!

	PLA		 ; Restore underwater flag

PRG000_C6FA:
	STA Objects_InWater,X	 ; Set object's in-water flag

PRG000_C6FD:
	LDA <Level_Tile
	STA Objects_LastTile,X	 ; Set last tile this object detected

	LDY ObjGroupRel_Idx	 ; Y = object's group-relative index

	LDA ObjectGroup_Attributes2,Y	; Get attributes set 2 for this object
	AND #OA2_TDOGRPMASK	 
	LSR A		; Upper 4 bits of attributes set 2 shifted right 1 (value * 8)

	STA <Temp_Var1
	LSR A		; Value * 4
	ADD <Temp_Var1	; Value * 12 (SB: Adding additional reverse gravity offsets)

	PHA		; Save it
	TAY		; -> 'Y' (use respective Object_TileDetectOffsets group Row 1)

	LDA <Objects_YVel,X
	BPL PRG000_C713	 ; If object Y velocity is >= 0 (stopped or moving downward), jump to PRG000_C713

Object_GAAMT_RevDone:
	INY
	INY
	INY		 ; If object moving upward, Y += 3 (use respective Object_TileDetectOffsets group Row 2)

PRG000_C713:
	JSR Object_DetectTile	 ; Get tile
 
	; Store into tile index holders
	STA Object_TileFeet2
	STA Object_TileFeet

	PHA		 ; Save tile


	LDY Level_TilesetIdx
	LDA QuicksandEnable,Y
	BEQ PRG000_C736	 ; If value is zero, jump to PRG000_C736

	; Otherwise...
	SUB <Level_Tile	 ; Subtract value we just retrieved 
	CMP #$02	 
	BGE PRG000_C736	 ; If tile is >= 2, this is not a quicksand tile, jump to PRG000_C736

	INC Objects_QSandCtr,X	; Increment the quicksand counter

	LDA #OBJSTATE_KILLED
	STA Objects_State,X	; killed by quicksand

PRG000_C736:
	PLA		 ; Restore tile

	ASL A
	ROL A
	ROL A		 ; Upper 2 bits shift right 6, effectively
	AND #%00000011	 ; Keep these bits, i.e. "tile quadrant"
	STA Object_AttrFeet ; Store quadrant value
	TAY		 ; -> 'Y'

	LDA ObjTile_DetXLo
	STA <Temp_Var16	 ; Temp_Var16 = ObjTile_DetXLo

	LDA Level_SlopeEn
	BEQ PRG000_C76C	 ; If slopes are not enabled here, jump to PRG000_C76C

	LDA <Level_Tile
	CMP Tile_AttrTable,Y
	BLT PRG000_C76C	 ; If detected tile < starting solidity tile, jump to PRG000_C76C

	PHA		 ; Save tile

	TYA		 ; Quadrant value -> 'A'
	ASL A		 ; Shifted left 1 (2 byte index)
	TAX		 ; -> 'X'

	; Temp_Var3/4 point to array of slope values for this quadrant
	LDA Level_SlopeSetByQuad,X
	STA <Temp_Var3
	LDA Level_SlopeSetByQuad+1,X
	STA <Temp_Var4

	PLA		 ; Restore tile

	SUB Tile_AttrTable,Y	; Subtract the root tile value
	TAY		 	; -> 'Y'
	LDA [Temp_Var3],Y	; Get slope value
	STA Level_Tile_Slope	; -> Level_Tile_Slope

	LDX <SlotIndexBackup	; Restore X as object slot index

PRG000_C76C:
	LDA #$00
	STA Object_TileWall2	 ; Object_TileWall2 = 0

	PLA		 ; Restore Object_TileDetectOffsets index

	CMP #(OTDO_G1R1 - Object_TileDetectOffsets)
	BNE PRG000_C78C	 ; If not using Group 1 Row 1, jump to PRG000_C78C

	LDY Level_SlopeEn
	BEQ PRG000_C78C	 ; If slopes are not enabled, jump to PRG000_C78C

	;;;;;;;;;;;;;;;;;; ONLY HAPPENS WITH GROUP 1 ROW 1 AND SLOPES ENABLED

	PHA		 ; Save Object_TileDetectOffsets index

	LDA Temp_VarNP0	 ; Retrieve object's in-air status
	AND #$04	 ; Bit 2 is set to indicate object is "on solid ground"
	TAY		 ; -> 'Y' (0 or 4)

	PLA		 ; Restore Object_TileDetectOffsets index

	CPY #$00
	BEQ PRG000_C78C	 ; If Y = 0 (object not on solid ground), jump to PRG000_C78C

	LDY #(OTDO_G1Alt - Object_TileDetectOffsets)	 ; Otherwise, use alternate wall detection offsets
	JMP PRG000_C791	 ; Jump to PRG000_C791

	;;;;;;;;;;;;;;;;;; END

PRG000_C78C:
	ADD #6		 ; Move down two rows in Object_TileDetectOffsets
	TAY		 ; Object_TileDetectOffsets index -> 'Y'

PRG000_C791:
	LDA <Objects_XVel,X
	BMI PRG000_C797	 ; If object's X velocity < 0 (moving leftward), jump to PRG000_C797

	INY
	INY
	INY		 ; Y += 3 (move down one Row in Object_TileDetectOffsets)

PRG000_C797:
	JSR Object_DetectTile	 ; Get tile here

	; Store into tile index holders
	STA Object_TileWall2
	STA Object_TileWall

	ASL A
	ROL A
	ROL A		 ; Upper 2 bits shift right 6, effectively
	AND #%00000011	 ; Keep these bits, i.e. "tile quadrant"
	STA Object_AttrWall ; Store quadrant value

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DetectTile
;
; Gets tile based on offset of object; the offset is set by the
; 'Y' register which indexes Object_TileDetectOffsets for the
; Y/X offset pair.  Seems kind of a limited way to go, but hey..
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $C7A9
Object_DetectTile:
	LDA Level_7Vertical	 
	BEQ PRG000_C7B1	 ; If level is NOT vertical, jump to PRG000_C7B1

	JMP PRG000_C85C	 ; Jump to PRG000_C85C

PRG000_C7B1:
	LDA Player_PartDetEn
	BEQ PRG000_C7D9	 ; If Player_PartDetEn is not set, jump to PRG000_C7D9

	BPL Object_DetectTile_NoFixedFC	; SB: If fixed ceiling mode is NOT enabled on Player_PartDetEn, jump to Object_DetectTile_NoFixedFC

	LDA <Objects_Y,X	 
	ADD Object_TileDetectOffsets+1,Y	; Adding tile detection offset to Object's Y
	SUB Level_VertScroll	; Make relative to scroll
	CMP #32
	BGE Object_DetectTile_NoFixedFC

	LDA #$00
	STA ObjTile_DetYHi	 ; ObjTile_DetYHi = 0

	JMP PRG000_C7F1	 ; Jump to PRG000_C7F1

Object_DetectTile_NoFixedFC:
	; The 32 pixel partition floor is enabled
	; Any object Y >= 160 must detect the bottom two tile rows instead!

	LDA <Objects_Y,X	 
	ADD Object_TileDetectOffsets+1,Y	; Adding tile detection offset to Object's Y
	SUB Level_VertScroll	; Make relative to scroll
	CMP #160
	BLT PRG000_C7D9	 	; If Y < 160, jump to PRG000_C7D9

	; Object is low enough to the visual floor...

	SBC #16		 ; Subtract 16
	AND #$f0	 ; Align to grid
	STA ObjTile_DetYLo	 ; -> ObjTile_DetYLo

	; Flag object as touching "32 pixel partition" floor
	LDA <Objects_DetStat,X
	ORA #$80
	STA <Objects_DetStat,X

	LDA #$01
	STA ObjTile_DetYHi	 ; ObjTile_DetYHi = 1

	JMP PRG000_C7F1	 ; Jump to PRG000_C7F1

PRG000_C7D9:

	LDA Objects_ReverseGrav,X
	BEQ Object_ODT_NoRev	; If object's gravity is not reversed, jump to Object_DetectTile_NoRev

	; SB: Under reverse gravity, use reverse gravity Y offset
	LDA <Objects_Y,X
	ADD Object_TileDetectOffsets,Y		; Adding tile detection Y offset to Object's Y

	JMP Object_ODT_Cont

Object_ODT_NoRev:
	LDA <Objects_Y,X
	ADD Object_TileDetectOffsets+1,Y	; Adding tile detection Y offset to Object's Y

Object_ODT_Cont:
	AND #$f0		; Align to grid
	STA ObjTile_DetYLo 	; -> ObjTile_DetYLo (low)

	LDA <Objects_YHi,X
	ADC #$00	 	; Apply carry
	STA ObjTile_DetYHi 	; -> ObjTile_DetYHi (high)

	BEQ PRG000_C7FA	 	; If no carry, jump to PRG000_C7FA

	; In a non-vertical level, a high value of 2 or greater is way beyond the bottom
	CMP #$02
	BGE PRG000_C832	 ; If the Y Hi >= 2, jump to PRG000_C832

PRG000_C7F1:
	PHA		 ; Save high part

	LDA ObjTile_DetYLo
	CMP #$b0

	PLA		 ; Restore high part

	BGE PRG000_C832	 ; If the Y lo part is greater than $B0 (the bottom of the screen), jump to PRG000_C832

PRG000_C7FA:
	AND #$01
	STA <Temp_Var3	 ; Temp_Var3 = 0 or 1 / Y Hi

	LDA <Objects_X,X
	ADC Object_TileDetectOffsets+2,Y	; Adding tile detection X offset to Object's X
	STA ObjTile_DetXLo 	; -> ObjTile_DetXLo (low)

	LDA <Objects_XHi,X
	ADC #$00	 	; Apply carry
	STA ObjTile_DetXHi 	; -> ObjTile_DetXHi (high)

	CMP #$10
	BGE PRG000_C832	 ; If the high part is more than $10 (biggest possible within other limits), jump to PRG000_C832

	PHA

	LDA <Objects_DetStat,X
	BPL Object_32PP_NoBump	; If object is not on 32-pixel-partition floor, jump to Object_32PP_NoBump

	LDA <Temp_Var3
	PHA

	JSR_THUNKC 30, Object_32PP_BumpCheck

	PLA
	STA <Temp_Var3
	
Object_32PP_NoBump:
	PLA

ODT_Manual_Entry:
	ASL A		 ; Change high part into 2 byte index to select the screen
	TAY		 ; -> 'Y'

	; Calculate Temp_Var2/1 (tile address)
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1
	LDA Tile_Mem_Addr+1,Y
	ADC <Temp_Var3	
	STA <Temp_Var2	

	; Calculate tile offset within screen
	LDA ObjTile_DetXLo
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ORA ObjTile_DetYLo

	TAY		 	; -> 'Y'

PRG000_C82A:
	LDA [Temp_Var1],Y	; Get tile
 
	JSR PSwitch_SubstTileAndAttr	 ; Substitute tile if P-Switch is active

	JMP PRG000_C834	 ; Jump to PRG000_C834

PRG000_C832:
	LDA #$00	; No tile detected

PRG000_C834:
	STA <Level_Tile	; Store tile index detected

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DetectTileManual
;
; Chains into Object_DetectTile, but allows custom tile detection
; coordinates.  To use, supply values into ObjTile_DetXLo/Hi and
; ObjTile_DetYLo/Hi; limits still enforced
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $C7A9
Object_DetectTileManual:
	LDA Level_7Vertical	 
	BNE ODTM_Vertical	; If level is vertical, jump to ODTM_Vertical

	LDA ObjTile_DetYHi
	CMP #$02
	BGE PRG000_C832	 ; If the Y Hi >= 2, jump to PRG000_C832
	
	AND #$01
	STA <Temp_Var3	 ; Temp_Var3 = 0 or 1 / Y Hi
	BEQ ODTM_NotHigh	; If not high, jump to ODTM_NotHigh

	LDA ObjTile_DetYLo
	CMP #$b0
	BGE PRG000_C832	 ; If the Y lo part is greater than $B0 (the bottom of the screen), jump to PRG000_C832
	
ODTM_NotHigh:
	LDA ObjTile_DetYLo
	AND #$f0		; Align to grid
	STA ObjTile_DetYLo

	LDA ObjTile_DetXHi
	CMP #$10
	BGE PRG000_C832	 ; If the high part is more than $10 (biggest possible within other limits), jump to PRG000_C832
	BLT ODT_Manual_Entry	; Otherwise, jump to ODT_Manual_Entry
	
ODTM_Vertical:	

	LDA ObjTile_DetYLo
	AND #$f0		; Align to grid
	STA ObjTile_DetYLo
	STA <Temp_Var3		; -> Temp_Var3
	
	LDA ObjTile_DetYHi
	CMP #$10
	BGE PRG000_C832	 ; If object is detecting way too low (out of range), jump to PRG000_C832 (no tile detected)
	
	ADC #$60		; +$60
	STA <Temp_Var2		 ; -> Temp_Var2
	
	LDA ObjTile_DetXLo
	JMP ODT_Manual_EntryV

PRG000_C85C:

	; Vertical level object detect tile

	LDA Objects_ReverseGrav,X
	BEQ Object_ODTV_NoRev	; If object's gravity is not reversed, jump to Object_DetectTile_NoRev

	; SB: Under reverse gravity, use reverse gravity Y offset
	LDA <Objects_Y,X
	ADD Object_TileDetectOffsets,Y		; Adding tile detection Y offset to Object's Y

	JMP Object_ODTV_Cont

Object_ODTV_NoRev:
	LDA <Objects_Y,X
	ADD Object_TileDetectOffsets+1,Y	; Adding tile detection Y offset to Object's Y

Object_ODTV_Cont:
	AND #$f0		; Align to grid
	STA ObjTile_DetYLo 	; -> ObjTile_DetYLo (low)
	STA <Temp_Var3		 ; -> Temp_Var3

	LDA <Objects_YHi,X
	ADC #$00	 	; Apply carry
	STA ObjTile_DetYHi 	; -> ObjTile_DetYHi (high)

	CMP #$10
	BGE PRG000_C832	 ; If object is detecting way too low (out of range), jump to PRG000_C832 (no tile detected)

	ADC #$60		; +$60
	STA <Temp_Var2		 ; -> Temp_Var2

	; ObjTile_DetXHi = Objects_XHi (should be zero)
	LDA <Objects_XHi,X
	STA ObjTile_DetXHi

	LDA <Objects_X,X
	ADD Object_TileDetectOffsets+2,Y	; Adding tile detection X offset to Object's X
	STA ObjTile_DetXLo 	; -> ObjTile_DetXLo (low)

ODT_Manual_EntryV:
	; Calculate tile offset within screen
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ORA <Temp_Var3
	STA <Temp_Var1	 ; -> Temp_Var1 

	LDY #$00	 ; Y = 0 (additional offset not used)

	JMP PRG000_C82A	 ; Jump to PRG000_C82A


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PSwitch_SubstTileAndAttr
;
; P-Switch substitution function for tiles which it effects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Parallel arrays which for a given tile in the accumulator,
	; if it matches one of the ones in PrePSwitchTile is replaced
	; with the attribute and tile from the other arrays...
PrePSwitchTile:		.byte TILEA_COIN,	TILEA_BRICK, 	TILEA_MUNCHER,	TILEA_PSWITCHCOIN	; P-Switch inactive
PostPSwitchTile:	.byte TILEA_BRICK,	TILEA_COIN, 	TILEA_COIN, 	TILEA_COIN			; P-Switch active
PostPSwitchAttr:	.byte $03, 			$00, 			$00, 			$00

PSwitch_SubstTileAndAttr:
	LDY Level_PSwitchCnt	; Y = Level_PSwitchCnt
	BEQ PRG000_C85B	 	; If P-Switch not active, jump to PRG000_C85B (RTS)

	LDY #(PostPSwitchTile - PrePSwitchTile - 1)
PRG000_C84A:
	CMP PrePSwitchTile,Y
	BNE PRG000_C858	 	; If this is not a match, jump to PRG000_C858

	LDA PostPSwitchAttr,Y	; Get replacement attribute
	STA <Player_Slopes	; Store into Player_Slopes

	LDA PostPSwitchTile,Y	; Get replacement tile
	RTS		 ; Return

PRG000_C858:
	DEY		 ; Y--
	BPL PRG000_C84A	 ; While Y >= 0, loop!

PRG000_C85B:
	RTS		 ; Return


	; When Object hits water, splash!
Object_WaterSplash:
	LDA #$02

Podoboo_Splash:
	STA <Temp_Var1	 ; Temp_Var1 = 2

	LDA ObjSplash_DisTimer,X
	BNE PRG000_C914	 ; If splashes are disabled, jump to PRG000_C914 (RTS)

	LDA Level_ObjectID,X
	CMP #OBJ_GROWINGVINE
	BEQ PRG000_C914	 ; If object is a growing vine, jump to PRG000_C914 (RTS)

	LDA <Objects_YVel,X
	BMI PRG000_C8BE	 ; If Object's Y velocity is negative (moving upward), jump to PRG000_C8BE

	; If object is some kind of blooper, jump to PRG000_C914 (RTS)
	LDA Level_ObjectID,X
	CMP #OBJ_BLOOPER
	BEQ PRG000_C914
	CMP #OBJ_BLOOPERCHILDSHOOT
	BEQ PRG000_C914
	CMP #OBJ_BLOOPERWITHKIDS
	BEQ PRG000_C914

	LDA #$00
	STA <Objects_YVel,X	; Object's Y velocity is zeroed at impact of water

PRG000_C8BE:

	; Basically looking not to do a splash effect if object is falling off-screen

	JSR Object_AnySprOffscreen
	BNE PRG000_C914	 ; If any sprites are off-screen, jump to PRG000_C914 (RTS)

	LDY #$02	 ; Y = 2 (this is immediately overwritten and thus not used)

	; Alternate between splash slot 1 and 2
	INC Object_SplashAlt	 ; Object_SplashAlt++
	LDA Object_SplashAlt
	AND #$01	 ; Keep just bit 0
	TAY		 ; -> 'Y'

	INY		 ; Y = 1 or 2

	LDA #$01	
	STA Splash_Counter,Y	 ; Splash counter = 1 (begin splash)

	LSR A		 
	STA Splash_NoScrollY,Y	 ; Splash_NoScrollY = 0 (splash is relative to vertical scroll)

	; Set appropriate splash Y
	LDA <Objects_Y,X
	SUB #$04
	AND #$f0
	ADD <Temp_Var1
	STA Splash_Y,Y

	; Set appropriate splash X
	LDA <Objects_X,X
	STA Splash_X,Y

PRG000_C914:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Objects_Update
;
; THE function which spawns objects as they appear on screen and 
; calls updates on all objects based on their state etc.  Also
; updates the timers.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Objects_HandleScrollAndUpdate:
	JMP PRG000_C927	 ; Jump to PRG000_C927

PRG000_C918:
	.byte $35, $F0, $0C

PRG000_C927:
	LDA Splash_DisTimer
	BEQ PRG000_C92F	 ; If Splash_DisTimer > 0, jump to PRG000_C92F

	DEC Splash_DisTimer	 ; Splash_DisTimer--

PRG000_C92F:
	LDA <Player_Suit
	CMP #PLAYERSUIT_HAMMER
	BNE PRG000_C93A	 ; If Player suit is NOT hammer suit, jump to PRG000_C93A

	; Otherwise...
	LDA #$4f
	STA PatTable_BankSel+5	 ; Sixth pattern table bank = $4F

PRG000_C93A:
	LDA <Player_IsDying
	CMP #$03
	BNE PRG000_C948	 ; If Player is NOT dying due to TIME UP, jump to PRG000_C948

	; Otherwise...
	LDA PatTable_BankSel+2
	CMP #$52
	BNE PRG000_C948	 ; If third pattern table bank has not been set to $52, jump to PRG000_C948
	RTS		 ; Return

PRG000_C948:
	LDA Player_IsHolding
	STA Player_ISHolding_OLD ; Player_ISHolding_OLD = Player_ISHolding

	LDA #$00
	STA Player_IsHolding	 ; Clear Player_IsHolding
	STA ArrowPlat_IsActive 	; Clear ArrowPlat_IsActive

	LDA #$ff
	STA LRBounce_Y	 ; LRBounce_Y = $FF 

	; Set page @ A000 to 5
	LDA #$05
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR LevelEvent_Do 		; Perform event as set by Level_Event
	JSR Level_SpawnObjsAndBounce	; Handle if Player bounced off block and spawn new objects as screen scrolls

	DEC Counter_7to0 ; Counter_7to0--
	BPL PRG000_C973	 ; If Counter_7to0 >= 0, jump to PRG000_C973

	LDA #$07
	STA Counter_7to0 ; Otherwise, reset Counter_7to0 to 7

PRG000_C973:
	LDX #$07	 

PRG000_C975:
	STX <SlotIndexBackup	 ; Backup current object index -> SlotIndexBackup

	LDA <Player_HaltGame		; If gameplay is halted ...
	ORA Objects_FrozenTimer,X	; ... or object is frozen (SB)
	BNE PRG000_C9B6	 			; ... jump to PRG000_C9B6

	LDA Objects_Timer,X
	BEQ PRG000_C983	 ; If this timer is already at zero, jump to PRG000_C983

	DEC Objects_Timer,X	 ; Otherwise, decrement it

PRG000_C983:

	LDA Objects_Timer2,X
	BEQ PRG000_C98B	 ; If this timer is already at zero, jump to PRG000_C98B

	DEC Objects_Timer2,X	; Otherwise, decrement it

PRG000_C98B:

	CPX #$05
	BGE PRG000_C9B6	 ; If object slot index >= 5, jump to PRG000_C9B6

	; Non-special objects in slots 0 to 4...

	LDA Objects_Timer4,X

	BEQ PRG000_C997	 ; If this timer is already at zero, jump to PRG000_C997

	DEC Objects_Timer4,X	; Otherwise, decrement it

PRG000_C997:
	LDA Objects_Timer3,X
	BEQ PRG000_C9B6	 ; If timer is zero, jump to PRG000_C9B6

	CMP #$60	 
	BLT PRG000_C9B3	 ; If timer value is < $60, jump to PRG000_C9B3

	LDA #$01	 ; A = 1

	LDY Objects_State,X
	CPY #OBJSTATE_NORMAL
	BEQ PRG000_C9B3	 ; If object's state is Normal, jump to PRG000_C9B3

	CPY #$04	 
	BNE PRG000_C9AF	 ; If object's state is NOT 4 (being held), jump to PRG000_C9AF

	; Object being held...

	LDA #$03	 ; A = 3
PRG000_C9AF:
	AND <Counter_1
	BNE PRG000_C9B6	 ; Every A:A+1 ticks, jump to PRG000_C9B6

PRG000_C9B3:
	DEC Objects_Timer3,X	 ; Every 4 ticks, decrement Objects_Timer3

PRG000_C9B6:
	TXA		 ; Object index -> 'A'
	ADD Counter_7to0 ; Add current value of Counter_7to0
	TAY		 ; -> 'Y' (anywhere from 0 to 14)

	LDA SprRamOffsets,Y
	STA Object_SprRAM,X	 ; Store this object's Sprite_RAM offset

	JSR Object_DoStateAction 	; Do whatever's required by this object by its current state
	JSR Object_HitByTailOrBouncer	; Test and respond if object was hit by Player tail attack or left/right bouncer

	LDA Objects_State,X
	BNE PRG000_C9D2	 ; If object's state is not 0 (dead/empty), jump to PRG000_C9D2

	; Remove object's associated spawn index
	LDA #$ff
	STA Objects_SpawnIdx,X

PRG000_C9D2:
	DEX		 ; X--
	BPL PRG000_C975	 ; While X >= 0, loop!

	LDA Cine_ToadKing
	BEQ PRG000_C9E5	 ; If Toad & King Cinematic is NOT going on, jump to PRG000_C9E5

	; Set page @ A000 to 24
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Cinematic_ToadAndKing	; Do the Toad & King Cinematic logic

PRG000_C9E5:
	LDA Player_Flip
	BEQ PRG000_C9FB	 ; If Player is NOT somersaulting, jump to PRG000_C9FB

	LDA Player_InWater
	ORA Player_SandSink
	BNE PRG000_C9F6	 ; If Player is in water or sinking in sand, jump to PRG000_C9F6

	LDA <Player_InAir
	BNE PRG000_C9FB	 ; If Player is mid-air, jump to PRG000_C9FB

PRG000_C9F6:
	; A would-be somersaulting Player is either in water or sand, 
	; or is not mid-air; disable it!
	LDA #$00
	STA Player_Flip

PRG000_C9FB:
	LDA Level_ChgTileEvent
	BNE PRG000_CA33	 ; If a change tile event is called for, jump to PRG000_CA33

	; Check each block bump slot to see if it needs to occur
	LDY #$00
	LDA Level_BlkBump,Y
	BNE PRG000_CA13

	INY	
	LDA Level_BlkBump,Y
	BNE PRG000_CA13

	INY	
	LDA Level_BlkBump,Y
	BEQ PRG000_CA33	

PRG000_CA13:
	STA Level_ChgTileEvent	 ; Set the block bump change event

	; Set relevant parameters
	LDA Level_BlkBump_XHi,Y
	STA Level_BlockChgXHi

	LDA Level_BlkBump_XLo,Y
	STA Level_BlockChgXLo

	LDA Level_BlkBump_YHi,Y
	STA Level_BlockChgYHi

	LDA Level_BlkBump_YLo,Y
	STA Level_BlockChgYLo

	; Clear this block bump!
	LDA #$00
	STA Level_BlkBump,Y

PRG000_CA33:
	LDA Level_JctCtl
	BEQ PRG000_CA40	 ; If no level junction is occurring, jump to PRG000_CA40

	STA LevelPartialInit	; Flag that we need a level partial initialization

	; Clear the "Get Wand" cinematic state
	LDA #$00
	STA Level_GetWandState

PRG000_CA40:
	RTS		 ; Return

	; Breaks up every 36 object IDs to make smaller jump tables
	; SB: Does not handle new extended bank objects @ $E0+
ObjectID_BaseVals:
	.byte $00, $24, $48, $6C, $90


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DoStateAction
;
; Do whatever is required by the current Objects_State value
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_DoStateAction:
	LDA Objects_State,X
	BEQ PRG000_CA40	 ; If this object is "dead/empty", jump to PRG000_CA40

	CMP #$08
	BEQ PRG000_CA81	 ; If this object's state = 8 ("Poof" Dying), jump to PRG000_CA81

	; SB: NEW extended bank objects!
	LDA Level_ObjectID,X	; Get object ID
	CMP #OBJ_EXTBANK_BEGIN
	BLT Object_DoStateAction_NotExt	; If this ID is not high enough to be one of the extended bank objects, jump to Object_DoStateAction_NotExt

	; Extended bank object!  Make assumptions!
	SUB #OBJ_EXTBANK_BEGIN	; Calculate the ObjGroupRel_Idx value
	
	LDY #41		; Extended bank is 41
	BNE ODSA_ExtSetup	; Jump (technically always) to ODSA_ExtSetup

Object_DoStateAction_NotExt:
	LDY #$04	 ; Y = 4

	; Try to locate the group that this object ID belongs to
	; Groups are defined by ObjectID_BaseVals, every 36 values.
PRG000_CA51:
	LDA Level_ObjectID,X	; Get object ID
	CMP ObjectID_BaseVals,Y	; Compare to this base value
	BGE PRG000_CA5C	 ; If this object ID >= the base value, jump to PRG000_CA5C

	; Object ID is smaller, thus not this group...

	DEY		 ; Y--
	BNE PRG000_CA51	 ; If Y > 0, loop!

PRG000_CA5C:

	; Y contains index to the base value for this group of object IDs
	; A contains the object's ID

	INY		 ; Y++
	SUB ObjectID_BaseVals-1,Y ; Subtract next group's ID to make this object's ID relative to group

ODSA_ExtSetup:
	STA ObjGroupRel_Idx ; Set ObjGroupRel_Idx to this group-relative index value

	; Y is now a value of 1 to 5, and that value dictates the page 
	; where this object's code can be found...
	STY PAGE_A000	 ; Set new page
	TAY		; Object group-relative index -> 'Y'
		 
	JSR PRGROM_Change_A000	 ; Set page @ A000 to appropriate object page...

	LDA Objects_DisPatChng,X
	BNE PRG000_CA81	 ; If pattern bank enforcement is disabled, jump to PRG000_CA81

	; Object's can request a particular pattern set to be available to them.
	; They may set either the fifth or sixth bank of CHRROM, which is specified
	; by bit 7.  

	LDX #$00	 ; X = 0 (fifth CHRROM bank)
	LDA ObjectGroup_PatTableSel,Y	 ; Load CHRROM bank request for this object, if any
	BEQ PRG000_CA7F	 ; If CHRROM bank request is zero, no change, jump to PRG000_CA7F
	BPL PRG000_CA7A	 ; If CHRROM bank request does not have bit 7 set, jump to PRG000_CA7A
	INX		 ; Otherwise, X = 1 (sixth CHRROM bank)

PRG000_CA7A:
	AND #$7f	 ; Bit 7 is used to specify which bank, so filter it here
	STA PatTable_BankSel+4,X	 ; Store pattern bank

PRG000_CA7F:
	LDX <SlotIndexBackup		 ; Restore X as the object slot index

PRG000_CA81:
	JSR AScrlURDiag_CheckWrapping	; Handle diagonal autoscroll's scroll wrappping
	JSR Object_DetermineVertVis	; Set flags based on which sprites of this object are vertically visible
	JSR Object_DetermineHorzVis	; Set flags based on which sprites of this object are horizontally visible

	LDA Objects_State,X	 ; Get object state...
	CMP #OBJSTATE_INIT
	BEQ ObjState_DoState	; Initialization state must NOT be "frozen"!

	LDA Objects_FrozenTimer,X
	BEQ ObjState_DoState	; If object is not frozen, jump to ObjState_DoNotFrozen

	JMP ObjState_Frozen

ObjState_DoState:
	LDA Objects_State,X	 ; Get object state...
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word ObjState_DeadEmpty	; 0 - Dead/Empty
	.word ObjState_Initializing	; 1 - Initializing
	.word ObjState_Normal		; 2 - Normal operation
	.word ObjState_Shelled		; 3 - Shelled
	.word ObjState_Held			; 4 - Held by Player
	.word ObjState_Kicked		; 5 - Kicked
	.word ObjState_Killed		; 6 - Killed
	.word ObjState_Squashed		; 7 - Object was squashed (NOTE: Really only intended for Goomba/Giant Goomba)
	.word ObjState_PoofDying	; 8 - "Poof" Dying

	; Patterns selected by "poof" death frame
PoofDeath_Pats:
	.byte $47, $45, $41, $43

ObjState_PoofDying:
	LDA Objects_Timer,X
	BNE PRG000_CAAE	 ; If object timer is not expired, jump to PRG000_CAAE

	JMP PRG000_D068	 ; Jump to PRG000_D068 (Object_SetDeadEmpty)

PRG000_CAAE:
	JSR Object_AnySprOffscreen
	BNE PRG000_CAF0	 ; If any sprite is off-screen, jump to PRG000_CAF0 (RTS)

	; Set the "poof" pixel positions
	JSR Object_CalcSpriteXY_NoHi
	LDY Object_SprRAM,X
	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$00,Y	
	STA Sprite_RAM+$04,Y	
	LDA <Objects_SpriteX,X	
	STA Sprite_RAM+$03,Y	
	ADD #$08	 
	STA Sprite_RAM+$07,Y

	LDA Objects_Timer,X
	LSR A
	LSR A
	LSR A
	TAX		 ; X = "poof" frame

	; Set "poof" death patterns
	LDA PoofDeath_Pats,X
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	; Set the attributes
	LDA Level_NoStopCnt
	LSR A
	LSR A
	ROR A
	AND #$80
	ORA #$01
	STA Sprite_RAM+$02,Y

	EOR #$c0
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup	 ; X = object slot index

PRG000_CAF0:
	RTS		 ; Return

	; In units of $10 ticks by timer 3...
PRG000_CAF1:
	.byte %00000010, %00000010, %00000100, %00001000, %00010000, %00010000

	; Some objects have "feet" when they are waking up, 
	; this offsets their Y depending on whether v-flipped
ObjWakeUp_FeetYOff:	.byte 10, -10

	; Called for an object in state 3 to do its "shelled" routine
ObjState_Shelled:
	LDY ObjGroupRel_Idx	; Y = object's group-relative index

	LDA ObjectGroup_Attributes3,Y 
	AND #OA3_SQUASH
	BEQ PRG000_CB10	 ; If OA3_SQUASH is NOT set (stomp does not "shell" this object), jump to PRG000_CB10  

	; Attribute set 3 bit 4 is set...

	; Go to "stomped" state

	; Timer 3 = $10
	LDA #$10 
	STA Objects_Timer3,X 

	; Set object state to Squashed
	LDA #OBJSTATE_SQUASHED
	STA Objects_State,X
 
	JMP Object_ShakeAndDraw	 ; Draw object and don't come back... 

PRG000_CB10:

	; Attribute set 3 bit 4 is NOT set... (object is "shelled" when stomped)

	LDA <Player_HaltGame	 
	BNE PRG000_CB5B	 ; If gameplay is halted, jump to PRG000_CB5B
 
	JSR Object_ShellDoWakeUp	 ; Handle waking up (MAY not return here, if object "wakes up"!) 
	JSR Object_Move	 		; Perform standard object movements
 
	LDA <Objects_DetStat,X 
	AND #$04 
	BEQ PRG000_CB45	 ; If object hit floor, jump to PRG000_CB45 

	LDA <Objects_YVel,X 
	BMI PRG000_CB45	 ; If object is moving upward, jump to PRG000_CB45 

	; Object has NOT hit floor and is NOT moving upward...

	PHA		 ; Save Y velocity

	JSR Object_HitGround	 ; Align with ground
 
	LDA <Objects_XVel,X	 ; Get X velocity
 
	PHP		 ; Save CPU state

	; Get absolute value of X velocity
	BPL PRG000_CB30 
	JSR Negate
PRG000_CB30:

	LSR A		 ; Divide by 2 
	PLP		 ; Restore CPU state

	; If needed to negate before, negate again
	BPL PRG000_CB37 
	JSR Negate
PRG000_CB37: 
	STA <Objects_XVel,X	 ; Set as X velocity 

	PLA		 ; Restore Y velocity
 
	; Divide by 4
	LSR A 
	LSR A 
	JSR Negate	 ; Negate it 
	CMP #-$02 
	BGE PRG000_CB45	 ; If object only lightly moving upward, jump to PRG000_CB45
 
	STA <Objects_YVel,X	 ; Set object Y velocity

PRG000_CB45: 
	LDA <Objects_DetStat,X 
	AND #$08 
	BEQ PRG000_CB4F	 ; If object has NOT hit ceiling, jump to PRG000_CB4F
 
	; Set object Y velocity to $10 (rebound off ceiling)
	LDA #$10 
	STA <Objects_YVel,X 

PRG000_CB4F:
	LDA <Objects_DetStat,X 
	AND #$03 
	BEQ PRG000_CB58	 ; If object has NOT hit wall, jump to PRG000_CB58 
 
	JSR Object_AboutFace	 ; Turn around... 

PRG000_CB58:
	JSR Object_HandleBumpUnderneath	 ; Handle object getting hit from underside 

PRG000_CB5B:
	JSR Object_BumpOffOthers	 ; Bump off and turn away from other objects 

PRG000_CB5E:
	JSR Object_DeleteOffScreen	 ; Delete object if it goes off-screen 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DrawShelled
;
; Draw object in "shelled" state
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $CB61
Object_DrawShelled:
	; Set object frame to 2
	LDA #$02	 
	STA Objects_Frame,X

	LDA Objects_IsGiant,X
	BEQ PRG000_CB7B	 ; If object is NOT giant, jump to PRG000_CB7B

	; Call special "giant" object draw routine (giant objects assume a JMP instruction @ ObjectGroup_PatternSets)
	JSR ObjectGroup_PatternSets

Object_SetShakeAwakeTimer:

	; Set timer for object to wake up from

	LDA Objects_Timer3,X
	CMP #$60	 
	BGE PRG000_CB7A	 ; If timer 3 >= $60, jump to PRG000_CB7A

	AND #$07
	STA Objects_Timer4,X	; Timer 4 = 0-7, based on timer3

PRG000_CB7A:
	RTS		 ; Return


PRG000_CB7B:

	LDA Level_ObjectID,X

	CMP #OBJ_BOBOMBEXPLODE
	BEQ PRG000_CB86		; If this is a Bob-omb exploding, jump to PRG000_CB86

	CMP #OBJ_BOBOMB
	BNE PRG000_CB8E		; If this is not a Bob-omb of any sort, jump to PRG000_CB8E

PRG000_CB86:

	; Have object flip same way as Player
	LDA <Player_FlipBits
	STA Objects_FlipBits,X

	JMP Object_ShakeAndDraw	 ; Draw object and never come back!

PRG000_CB8E:
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite

	JSR Object_CalcAttrFlagOff
	CPY #OBJ_ICEBLOCK
	BEQ PRG000_CBB3	 ; If object is an Iceblock, jump to PRG000_CBB3 (RTS)

	JSR Object_SetShakeAwakeTimer	 ; Set the "shake awake" timers

	CPY #OBJ_BUZZYBEATLE
	BNE PRG000_CBB4	 ; If object is NOT a Buzzy Beatle, jump to PRG000_CBB4

	; Buzzy Beatle

	LDY Objects_FlipBits,X
	BMI PRG000_CBB3	 ; If Buzzy is vertically flipped, jump to PRG000_CBB3 (RTS)

	LDY Object_SprRAM,X	 ; Y = object's Sprite_RAM offset

	; +1 to Y to sprite if not flipped
	LDA Sprite_RAM+$00,Y
	ADD #$01
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

PRG000_CBB3:
	RTS		 ; Return

PRG000_CBB4:

	; NOT a Buzzy Beatle

	CPY #OBJ_SPINY
	BEQ PRG000_CBB3	 ; If Object is a Spiny, jump to PRG000_CBB3

	; "Shake awake" speed

	LDA Objects_Timer3,X
	CMP #$50
	BGE PRG000_CC23	 ; If timer 3 >= $50, jump to PRG000_CC23

	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = index into PRG000_CAF1 (proper bit mask for shaking speed)

	; Various speed shake by timer 3
	LDA Objects_Timer3,X
	AND PRG000_CAF1,Y
	BEQ PRG000_CC23	 ; If not shaking on this bit, jump to PRG000_CC23

	LDA #$01	 ; A = 1 (object not vertically flipped)

	LDY Objects_FlipBits,X	 
	BMI PRG000_CBD4	 ; If object is vertically flipped, jump to PRG000_CBD4

	LSR A		 ; A = 0 (object vertically flipped)

PRG000_CBD4:
	LDY Object_SprRAM,X	 ; Y = object's Sprite_RAM offset

	TAX		 ; X = 0 or 1 (proper Y offset for foot)

	; One foot
	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG000_CBEA	 ; If sprite Y = $F8, jump to PRG000_CBEA

	ADD ObjWakeUp_FeetYOff,X ; Add the foot offset
	CMP #$c5
	BGE PRG000_CBF8	 ; If the offset >= $C5, jump to PRG000_CBF8

	STA Sprite_RAM+$08,Y	 ; Foot Y

PRG000_CBEA:

	; Other foot
	LDA Sprite_RAM+$04,Y
	CMP #$f8
	BEQ PRG000_CBF8	 ; If sprite Y = $F8, jump to PRG000_CBF8

	ADD ObjWakeUp_FeetYOff,X ; Add the foot offset
	STA Sprite_RAM+$0C,Y	 ; Other foot Y

PRG000_CBF8:

	; Foot Xs
	LDA Sprite_RAM+$03,Y
	SUB #$03
	STA Sprite_RAM+$0B,Y

	LDA Sprite_RAM+$07,Y
	ADD #$03
	STA Sprite_RAM+$0F,Y

	; Foot attributes
	LDA Sprite_RAM+$02,Y
	AND #$80
	ORA #$03
	STA Sprite_RAM+$0A,Y

	; Flip the other foot
	ORA #$40
	STA Sprite_RAM+$0E,Y

	; Feet pattern
	LDA #$f9
	STA Sprite_RAM+$09,Y
	STA Sprite_RAM+$0D,Y

	LDX <SlotIndexBackup ; Restore 'X' as object index

PRG000_CC23:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_BumpOffOthers
;
; Detects all objects "prior" to this one and determines if the
; objects have collided, at which point they "bump off eachother"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_BumpOffOthers:
	TXA	; A = object slot index		  
	ADD <Counter_1 
	LSR A 
	BCS PRG000_CC6B	 ; Semi-randomly jump to PRG000_CC6B (RTS)
  
	JSR Object_AnySprOffscreen
	BNE PRG000_CC6B	 ; If any sprite is off-screen, jump to PRG000_CC6B (RTS) 

	JSR Object_CalcBoundBox2 
	TXA	
	BEQ PRG000_CC6B	 ; If object slot is zero, jump to PRG000_CC6B (RTS)
 
	DEX		 ; X-- (consider the previous object)

PRG000_CC37:
	JSR Object_CalcAttrFlagOff	 ; Y = Object ID 

	LDA Object_AttrFlags,Y 
	AND #OAT_BOUNCEOFFOTHERS
	BEQ PRG000_CC66	 ; If OAT_BOUNCEOFFOTHERS is NOT set, jump to PRG000_CC66

	LDA Objects_State,X 
	CMP #OBJSTATE_NORMAL
	BNE PRG000_CC66	 ; If Object state is NOT Normal, jump to PRG000_CC66
 
	JSR Object_AnySprOffscreen
	BNE PRG000_CC66	 ; If any sprite of object is off-screen, jump to PRG000_CC66
 
	JSR Object_CalcBoundBox 
	JSR ObjectObject_Intersect 
	BCC PRG000_CC66	 ; If object did not intersect with prior object, jump to PRG000_CC66
 
	LDY <SlotIndexBackup	 ; Y = object slot index
 
	LDA <Objects_SpriteX,X 
	CMP Objects_SpriteX,Y 
	LDY #$00	 ; Y = 0 
	BLT PRG000_CC62	 ; If this object's sprite X < the OTHER object's sprite X, jump to PRG000_CC62 
	LDY #$40	 ; Otherwise, Y = $40

PRG000_CC62:
	TYA 
	STA Objects_FlipBits,X	 ; Object turns around if it hit another object 

PRG000_CC66:
	DEX		 ; X-- 
	BPL PRG000_CC37	 ; While X >= 0, loop! 

	LDX <SlotIndexBackup		 ; X = object slot index 

PRG000_CC6B:
	RTS		 ; Return


ObjKickXvel:	.byte $18, -$18

ObjState_Kicked:
	LDA <Player_HaltGame 
	BEQ PRG000_CC75	 ; If gameplay is NOT halted, jump to PRG000_CC75
 
	JMP PRG000_CD46	 ; Jump to PRG000_CD46 

PRG000_CC75:
	JSR Object_Move	 ; Perform standard object movements
	JSR Object_DetermineHorzVis	 ; Determine horizontally visible sprites
 
	LDA <Objects_DetStat,X 
	AND #$04 
	BEQ PRG000_CC94	 ; If object has hit ground, jump to PRG000_CC94
 
	LDA <Objects_XVel,X 
	BNE PRG000_CC8D	 ; If object is moving horizontally, jump to PRG000_CC8D
 
	; Object not moving horizontally...
	JSR Level_ObjCalcXDiffs 
	LDA ObjKickXvel,Y 
	STA <Objects_XVel,X	 ; Set X velocity based on which side of Player the object is on 

PRG000_CC8D:
	JSR Object_HitGround	; Align to floor
 
	; Y Velocity = $0C (begin drop)
	LDA #$0c 
	STA <Objects_YVel,X 

PRG000_CC94:
	LDA <Objects_DetStat,X 
	AND #$03 
	BNE PRG000_CC9D	 ; If object has hit a wall, jump to PRG000_CC9D
 
	JMP PRG000_CCF7	 ; Otherwise, jump to PRG000_CCF7

PRG000_CC9D:
	LDA Objects_SpriteX,X 

	LDY <Objects_XVel,X 
	BPL PRG000_CCAA	 ; If object is not moving to the left, jump to PRG000_CCAA
 
	CMP #$06 
	BLT PRG000_CCE2	 ; If object's sprite X < 6, jump to PRG000_CCAA 
	BGE PRG000_CCAE	 ; Otherwise, jump to PRG000_CCAE 

PRG000_CCAA:
	CMP #228 
	BGE PRG000_CCE2	 ; If object's sprite X < 228, jump to PRG000_CCE2

PRG000_CCAE:
	JSR Object_AnySprOffscreen
	BNE PRG000_CCE2	 ; If any sprite is off-screen, jump to PRG000_CCE2
 
	LDA PAGE_A000 
	PHA		 ; Save current PAGE_A000 page 

	; Set page @ A000 to 8
	LDA #$08 
	STA PAGE_A000 
	JSR PRGROM_Change_A000
 
	; Temp_Var13 = Object tile detect Y Hi
	LDA ObjTile_DetYHi 
	STA <Temp_Var13	 

	; Temp_Var13 = Object tile detect Y Hi
	LDA ObjTile_DetYLo 
	STA <Temp_Var14	 

	; Temp_Var15 = Object tile detect X Hi
	LDA ObjTile_DetXHi 
	STA <Temp_Var15	 

	; Temp_Var16 = Object tile detect X Lo
	LDA ObjTile_DetXLo 
	STA <Temp_Var16	 

	; Handle object bouncing off blocks
	LDA Object_TileWall2
	JSR Object_BumpOffBlocks 

	LDX <SlotIndexBackup	 ; X = object slot index
 
	; Restore page @ A000 to previous value
	PLA 
	STA PAGE_A000 
	JSR PRGROM_Change_A000 

PRG000_CCE2:

	; Play bump sound
	LDA Sound_QPlayer 
	ORA #SND_PLAYERBUMP 
	STA Sound_QPlayer
 
	LDA Objects_FrozenTimer,X
	BNE Kicked_FrozenSmash		; If object is frozen, jump to Kicked_FrozenSmash
 
	LDA Level_ObjectID,X 
	CMP #OBJ_ICEBLOCK 
	BNE PRG000_CCF4	 ; If this object is NOT an Ice Block, jump to PRG000_CCF4
 
 Kicked_FrozenSmash:
	JMP PRG000_D295	 ; Jump to PRG000_D295 (set Ice Block to "killed" state) 

PRG000_CCF4:
	JSR Object_AboutFace	 ; Bounced off block, turn around

PRG000_CCF7: 
	JSR Object_HandleBumpUnderneath	 ; Handle the kicked shelled object getting hit from underneath
 
	TXA 
	ADD <Counter_1 
	LSR A 
	BCC PRG000_CD46	 ; Semi-randomly jump to PRG000_CD46

	LDA Objects_ColorCycle,Y 
	BNE PRG000_CD46	; SB: New feature; if color cycling, object is invincible to this, and jump to PRG000_CD46

Object_ShellAction:
	JSR ObjectToObject_HitTest 
	BCC PRG000_CD46	 ; If object has not hit another object, jump to PRG000_CD46

	; Play object-to-object collision sound 
	LDA Sound_QPlayer 
	ORA #SND_PLAYERKICK 
	STA Sound_QPlayer
 
	; Knock object in same general direction as the kicked shell object
	LDA <Objects_XVel,X 
	ASL A 
	LDA #$10	 ; A = $10
	BCC PRG000_CD17 
	LDA #-$10	 ; A = -$10
PRG000_CD17: 
	STA Objects_XVel,Y
 
	LDA Objects_State,Y 
	CMP #OBJSTATE_KICKED
	BNE PRG000_CD36	 ; If the impacted object's state is not Kicked, jump to PRG000_CD36

	; Another kicked object on the way... (slam and kill eachother)

	LDA Objects_KillTally,Y
 	JSR Score_Get100PlusPts	 ; Get the total score this OTHER kicked shell object earned
	JSR ObjectKill_SetShellKillVars	 ; Kill our kicked object and set ShellKill variables

	; Set X Velocity of our kicked object in the direction of the impacted object
	LDA Objects_XVel,Y
	ASL A	
	LDA #$10
	BCS PRG000_CD34
	LDA #-$10	
PRG000_CD34:
	STA <Objects_XVel,X

PRG000_CD36:
	TYA
	TAX		 ; X = the other object we just hit
	JSR ObjectKill_SetShellKillVars	 ; Kill the impacted object and set ShellKill variables

	LDX <SlotIndexBackup		 ; X = object slot index (our kicked object)
	LDA Objects_KillTally,X	
	INC Objects_KillTally,X		; Increase our kicked object's kill tally...
	JSR Score_Get100PlusPtsY	; Get points by the kill tally!  (Incidentally, Score_Get100PlusPts would work too)

PRG000_CD46:
	JSR Object_DeleteOffScreen	 ; Delete the kicked shell object if it goes off-screen

	LDA Objects_FrozenTimer,X
	BNE ObjectFrozen_NoDraw		; If object is frozen, jump to ObjectFrozen_NoDraw (object handles drawing itself)

	LDA Level_ObjectID,X
	CMP #OBJ_ICEBLOCK
	BEQ PRG000_CD77	 ; If the kicked object is an ice block, jump to PRG000_CD77

	; Object is NOT an ice block...

	JSR Object_IsSMB2Obj
	BEQ PRG000_CD74		; If this is an SMB2 object, jump to PRG000_CD74

	; NOTE: I really, really wish Nintendo used a consistent check here!
	; Other code checks Objects_IsGiant before taking this route...
	;CMP #OBJ_BIGGREENTROOPA
	;BGE PRG000_CD80	 ; If the object ID >= OBJ_BIGGREENTROOPA (why not use Objects_IsGiant?!), jump to PRG000_CD80
	LDA Objects_IsGiant,X
	BNE PRG000_CD80		; SB: Fixed ;)

	LDA Level_NoStopCnt
	LSR A	
	AND #$03
	TAY		 ; Y = 0 to 3, by counter

	LDA Objects_FlipBits,X
	AND #~SPR_HFLIP		; Keep all FlipBits except horizontal flips
	ORA ObjShell_AnimFlipBits,Y	 
	STA Objects_FlipBits,X	 ; Apply flip as appropriate

	; Set animation frame as appropriate
	LDA ObjShell_AnimFrame,Y
	STA Objects_Frame,X

	TYA
	AND #$01
	BNE PRG000_CD74	 ; Every other tick, jump to PRG000_CD74

	JMP Object_ShakeAndDrawMirrored	; Draw sprite and don't come back

PRG000_CD74:
	JMP Object_ShakeAndDraw	 ; Update sprite data, draw sprite, and don't come back

PRG000_CD77:

	; Ice block only...

	LDA <Counter_1
	LSR A	
	STA Objects_ColorCycle,X	 ; Cycle colors
	JMP Object_ShakeAndDrawMirrored	 ; Draw sprite and don't come back!

PRG000_CD80:
	JMP ObjectGroup_PatternSets	 ; Jump to ObjectGroup_PatternSets (giant object special shelled draw routine)


ObjectKill_SetShellKillVars:
	; Set object state to Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; Bounce up a bit
	LDA #-$30
	STA <Objects_YVel,X

	; Set ShellKillFlash vars
	LDA <Objects_Y,X
	STA ShellKillFlash_Y
	LDA <Objects_X,X
	STA ShellKillFlash_X
	LDA #$0a	 
	STA ShellKillFlash_Cnt

ObjectFrozen_NoDraw:
	RTS		 ; Return
	
	; Kicked shell object animation frames and flips
ObjShell_AnimFlipBits:	.byte $00, $00, $00, $40
ObjShell_AnimFrame:	.byte $04, $06, $05, $06

	; Copies all brick bust data over to the second bust slots
	; (So up to 2 bricks may be scattering debris at once)
BrickBust_MoveOver:
	LDA BrickBust_En
	STA BrickBust_En+1

	LDA BrickBust_YUpr
	STA BrickBust_YUpr+1

	LDA BrickBust_YLwr
	STA BrickBust_YLwr+1

	LDA BrickBust_X
	STA BrickBust_X+1

	LDA BrickBust_YVel
	STA BrickBust_YVel+1

	LDA BrickBust_XDist
	STA BrickBust_XDist+1

	LDA BrickBust_HEn
	STA BrickBust_HEn+1

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_BumpBlocks
;
; Provides an arbitrary object with the ability to hit objects
; with its "head"; used by Boom Boom, though Boom Boom never 
; gets a chance to employ that in the game...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $CDD2
Object_BumpBlocks:
	STA <Temp_Var8	; Store detected tile -> Temp_Var8

	; Backup current PAGE_A000 bank
	LDA PAGE_A000
	PHA	

	; Change page @ A000 to 8
	LDA #$08
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; Transfer tile detection 

	LDA ObjTile_DetYHi
	STA <Temp_Var13	

	LDA ObjTile_DetYLo
	STA <Temp_Var14	

	LDA ObjTile_DetXHi
	STA <Temp_Var15	

	LDA ObjTile_DetXLo
	STA <Temp_Var16	

	; Send detected tile over to check if object has hit any blocks
	; that respond to being hit with head
	LDA <Temp_Var8
	JSR Object_BumpOffBlocks

	LDX <SlotIndexBackup	; X = object slot index

	; Restore page @ A000 to previous page
	PLA
	STA PAGE_A000
	JSR PRGROM_Change_A000

	RTS		 ; Return


	; X velocities depending on kick direction, added to by half of Player's X velocity
ObjectKickXVelMoving:	.byte -$30, $30

	; Set appropriate flip bits based on object's relative position to Player
PlayerKickFlipBits:	.byte $00, $40

	; X velocities depending on kick direction
BobombKickXVel:	.byte -$28, $28

	; Different X and X Hi offsets applied to object being held by Player
	; Changes whether not doing anything special, in pipe, etc.
ObjectHoldXOff:		.byte $0B, -$0B, $04, -$04, $04, $0B, -$13, $04, -$08, $04, $00
ObjectHoldXHiOff:	.byte $00,  $FF, $00,  $FF, $00, $00,  $FF, $00,  $FF, $00, $00

	; Object-to-object hit resultant X velocity
ObjectToObject_HitXVel:	.byte -$08, $08

ObjState_Held:
	LDA <Player_IsDying 
	BEQ PRG000_CE28	 ; If Player is NOT dying, jump to PRG000_CE28
 
	JMP PRG000_CF98	 ; Jump to PRG000_CF98 (just draw held object) 

PRG000_CE28:
	JSR Object_ShellDoWakeUp ; Wake up while Player is holding object... 

	BIT <Pad_Holding 
	BVC Player_KickObject	 ; If Player is NOT holding B button, jump to Player_KickObject  

PRG000_CE2F:
	JMP PRG000_CEEF	 ; Jump to PRG000_CEEF


Player_KickObject:
	LDA Level_PipeMove	 
	BNE PRG000_CE2F	 ; If Player is moving through pipes, jump to PRG000_CE2F (PRG000_CEEF)

	; Play kick sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; Have Player do kick frame
	LDA #$0c
	STA Player_Kick

	; Set object timer 2 to $10
	LDA #$10
	STA Objects_Timer2,X

	LDA Level_ObjectID,X

	CMP #OBJ_BOBOMBEXPLODE
	BEQ PRG000_CE54	 ; If this is a Bob-omb ready to explode, jump to PRG000_CE54




	CMP #OBJ_BOBOMB	 
	BNE PRG000_CE79	 ; If this is NOT a Bob-omb, jump to PRG000_CE79

PRG000_CE54:

	; Bob-ombs only...

	; State remains "normal"
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Set Y vel to -$20 (bounce up)
	LDA #-$20
	STA <Objects_YVel,X

	; Set X Velocity appropriately based on kick direction
	JSR Level_ObjCalcXDiffs
	LDA BobombKickXVel,Y
	STA <Objects_XVel,X

	EOR <Player_XVel
	BMI PRG000_CE76	 ; If the Bob-omb's X velocity is the opposite sign of the Player's, jump to PRG000_CE76

	LDA <Player_XVel
	STA <Temp_Var1		; -> Temp_Var1 (yyyy xxxx)
	ASL <Temp_Var1		; Shift 1 bit left (bit 7 into carry) (y yyyx xxx0)
	ROR A			; A is now arithmatically shifted to the right (yyyyy xxx) (signed division by 2)
	ADD ObjectKickXVelMoving,Y	 ; Add base "moving" X velocity of Bob-omb
	STA <Objects_XVel,X	 ; Set this as Bob-omb's X Velocity

PRG000_CE76:
	JMP Object_ShakeAndDraw	 ; Draw Bob-omb and don't come back!

PRG000_CE79:

	; Anything besides a Bob-omb...

	; Clear Objects_KillTally 
	LDA #$00	
	STA Objects_KillTally,X

	LDA Objects_State,X
	CMP #OBJSTATE_HELD
	BNE PRG000_CEBE	 ; If object's state is not Held, jump to PRG000_CEBE

	; This object is being held by Player...

	LDA Level_ObjectID,X
	CMP #OBJ_ICEBLOCK
	BEQ PRG000_CEB4	 ; If this is an ice block, jump to PRG000_CEB4

	LDY #1	 ; Y = 1

	LDA <Player_FlipBits
	BNE PRG000_CE94	 ; If Player is not turned around, jump to PRG000_CE94

	LDY #-1	 ; Y = -1

PRG000_CE94:
	STY <Objects_XVel,X	 ; Set minimum X velocity on object (to enable wall hit detection)

	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$03	
	BEQ PRG000_CEB4	 ; If object has not hit a wall, jump to PRG000_CEB4

	; KICK OBJECT INTO WALL LOGIC

	; Flat 100 points
	LDA #$05
	JSR Score_PopUp

	; Object state is Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; Set object Y velocity to -$40 (fly up a bit)
	LDA #-$40
	STA <Objects_YVel,X

	; Remove that minimum X velocity
	LDA #$00
	STA <Objects_XVel,X

	JMP PRG000_CF98	 ; Jump to PRG000_CF98

PRG000_CEB4:

	; Object kicked not against wall...

	LDY #0	 	; Y = 0

	LDA <Player_FlipBits
	BEQ PRG000_CEBB	; If Player has not turned around, jump to PRG000_CEBB

	INY		; Y = 1

PRG000_CEBB:
	JMP PRG000_CEC6	; Jump to PRG000_CEC6

PRG000_CEBE:

	; Object kicked, was not held

	; Make sure Player is facing object he's kicking
	JSR Level_ObjCalcXDiffs
	LDA PlayerKickFlipBits,Y
	STA <Player_FlipBits

PRG000_CEC6:
	LDA ObjectKickXVelMoving,Y	 ; Get appropriate base X velocity for kick
	STA <Objects_XVel,X	 	; -> Object's X velocity

	EOR <Player_XVel
	BMI PRG000_CEDC	 ; If the object's X velocity is the opposite sign of the Player's, jump to PRG000_CEDC

	LDA <Player_XVel 	; Get the Player's X velocity
	STA <Temp_Var1		; -> Temp_Var1 (yyyy xxxx)
	ASL <Temp_Var1		; Shift 1 bit left (bit 7 into carry) (y yyyx xxx0)
	ROR A			; A is now arithmatically shifted to the right (yyyyy xxx) (signed division by 2)
	ADD ObjectKickXVelMoving,Y	 ; Add base "moving" X velocity of object
	STA <Objects_XVel,X	 ; Set as object's X velocity

PRG000_CEDC:
	; If object's state is not Killed, jump to PRG000_CEE8
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG000_CEE8

	; Set object state to 5 (Kicked)
	LDA #OBJSTATE_KICKED
	STA Objects_State,X

PRG000_CEE8:

	; Set object's Y velocity to zero
	LDA #$00
	STA <Objects_YVel,X

	JMP PRG000_CF98	 ; Jump to PRG000_CF98

PRG000_CEEF:

	; Player moving through pipes... 

	; Player keeps on holding through the pipes!!
	LDA #$01
	STA Player_IsHolding

	LDA Level_PipeMove
	BEQ PRG000_CEFD	 ; If Player is NOT moving through pipes, jump to PRG000_CEFD

	LDY #$0a	 ; Y = 10
	BNE PRG000_CF1A	 ; Jump (technically always) to PRG000_CF1A

PRG000_CEFD:
	LDY #$00	 ; Y = 0

	LDA <Player_FlipBits
	BNE PRG000_CF04	 ; If Player is turned around, jump to PRG000_CF04

	INY		 ; Y = 1

PRG000_CF04:
	LDA Objects_IsGiant,X
	BEQ PRG000_CF0E	 ; If object is not giant, jump to PRG000_CF0E

	; Y += 5
	INY
	INY
	INY
	INY
	INY

PRG000_CF0E:
	LDA Player_PipeFace
	BEQ PRG000_CF1F	 ; If Player is NOT "pipe facing" (facing forward in pipe), jump to PRG000_CF1F

	; Y += 2
	INY
	INY

	CMP #$05	
	BLT PRG000_CF1A	 ; If less than 5 ticks remaining on the "pipe face", jump to PRG000_CF1A

	INY		 ; Otherwise, Y++

PRG000_CF1A:

	; Set object to occupy Sprite_RAM offset $10
	LDA #$10
	STA Object_SprRAM,X

PRG000_CF1F:

	; Set held object's proper X position
	LDA <Player_X	
	ADD ObjectHoldXOff,Y
	STA <Objects_X,X	

	LDA <Player_XHi	
	ADC ObjectHoldXHiOff,Y
	STA <Objects_XHi,X	

	LDY #0		; Y = 0

	LDA Objects_IsGiant,X
	BNE PRG000_CF3D	 ; If object is giant, jump to PRG000_CF3D

	INY		; Y = 1

	LDA <Player_Suit
	BNE PRG000_CF3D	 ; If Player is not small, jump to PRG000_CF3D

	INY		; Y = 2

PRG000_CF3D:
	LDA Player_ReverseGrav
	BEQ PlayerHold_YOffNoRev	; If Player is not under reverse gravity, jump to PlayerHold_YOffNoRev

	; Use other offsets
	INY
	INY
	INY

PlayerHold_YOffNoRev:
	LDA ObjectHeld_YOff,Y	; Get proper Y offset
	PHA		 ; Save 'A'

	; Set Y offset to object being held
	ADD <Player_Y
	STA <Objects_Y,X

	LDY #$00	 ; Y = 0

	PLA		 ; Restore 'A'

	BPL PRG000_CF49	 ; If A >= 0 (negative when object was giant), jump to PRG000_CF49

	DEY		 ; Y = -1

PRG000_CF49:
	TYA		 ; A = 0 or -1

	; Apply carry
	ADC <Player_YHi
	STA <Objects_YHi,X

	; While held, object's velocities match Player's
	LDA <Player_XVel
	STA <Objects_XVel,X
	LDA <Player_YVel
	STA <Objects_YVel,X

	; SB: Match Player's gravity setting too
	LDA Player_ReverseGrav
	CMP Objects_ReverseGrav,X
	BEQ ObjectHeld_GravMatch

	; Match gravity
	STA Objects_ReverseGrav,X

	; If gravities mismatch, vertically flip object!
	LDA Objects_FlipBits,X
	EOR #SPR_VFLIP
	STA Objects_FlipBits,X

ObjectHeld_GravMatch:
	JSR Object_WorldDetectN1	; Detect against world
	JSR Object_CalcSpriteXY_NoHi	; Calculate low parts of sprite X/Y (never off-screen when held by Player!)
	JSR ObjectToObject_HitTest	; Test if this object has collided with another object
	BCC PRG000_CF98		 ; If this object did not collide with any other objects, jump to PRG000_CF98

	LDA Objects_Timer2,X
	ORA Level_PipeMove
	BNE PRG000_CF98	 	; If timer 2 is not expired or Player is moving through pipes, jump to PRG000_CF98

	; Object colliding sound!
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; Object which was held is dead!
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; Y velocity = -$30 (fly up a bit)
	LDA #-$30
	STA <Objects_YVel,X

	; Object that got hit is dead!
	LDA #OBJSTATE_KILLED
	STA Objects_State,Y

	; Y velocity = -$30 (fly up a bit)
	LDA #-$30
	STA Objects_YVel,Y

	; Get 100 pts for the hit!
	LDA #$00
	JSR Score_Get100PlusPts

	; Object will not collide again for 16 ticks (dampener I guess)
	LDA #16
	STA Objects_Timer2,X

	TYA
	TAX
	JSR Level_ObjCalcXDiffs	 ; Determine which side the OTHER object is on

	; Set the OTHER object's X velocity appropriately
	LDA ObjectToObject_HitXVel,Y
	STA <Objects_XVel,X

PRG000_CF98:
	LDX <SlotIndexBackup	 ; Restore 'X' to the object slot index

	LDA <Player_IsDying
	BNE PRG000_CFA5	 ; If Player is dying, jump to PRG000_CFA5

	; Player is NOT dying...

	LDA Sprite_RAM+$28

	CMP #$f8
	BEQ PRG000_CFA8	 ; ?? If Sprite_RAM+$28 (10th sprite) Y coordinate = $F8 (unused), jump to PRG000_CFA8 ??

PRG000_CFA5:

	; SMB2 type objects don't draw shelled style!
	LDA Level_ObjectID,X
	JSR Object_IsSMB2Obj
	BEQ PRG000_CFA8		; If object is an SMB2 object, don't draw shell style!

	JSR Object_DrawShelled	 ; Draw shelled object

PRG000_CFA8:
	RTS		 ; Return

	; Assumes load from Level_ObjectID,X before entering!
	; Use "BEQ" for match, "BNE" for not a match
Object_IsSMB2Obj:
	CMP #OBJ_SHYGUY_GREEN
	BEQ Object_IsSMB2Obj_Exit
	CMP #OBJ_SHYGUY_RED
	BEQ Object_IsSMB2Obj_Exit
	CMP #OBJ_NINJI
	BEQ Object_IsSMB2Obj_Exit
	CMP #OBJ_BIRDOEGG
	BEQ Object_IsSMB2Obj_Exit

	; Not a match here...
Object_IsSMB2Obj_Exit:
	RTS


ObjectHeld_YOff: 
	.byte -$02, $0D, $0F	; Giant enemy, not small, small
	.byte  $02, $02, $02	; Same, reverse gravity

ObjState_Killed:
	JSR Object_FallAndDelete	; Have object fall and delete if it gets too low (at which point we don't return)

	LDY ObjGroupRel_Idx	 ; Y = object's group relative index

	LDA ObjectGroup_Attributes4,Y
	AND #OA4_KA_MASK
	BEQ Object_DoKillAction	 ; If kill action is zero, jump to Object_DoKillAction (i.e. do NOT set frame 2)

	CPX #$05	 
	BGE Object_DoKillAction	 ; If object slot >= 5 (i.e. not a "general" objects), jump to Object_DoKillAction (i.e. do NOT set frame 2)

	PHA		 ; Save kill action

	LDA #$02
	STA Objects_Frame,X	 ; Set frame to 2

	PLA		 ; Restore kill action

	; Do the kill action
Object_DoKillAction:
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Object_StandardKill	; 0: Standard kill (does not set frame 2)
	.word Object_CalcAndDrawKilled	; 1: Standard sprite draw and kill
	.word Object_DrawMirroredKilled	; 2: Draw mirrored sprite
	.word Object_Draw16x32Killed	; 3: Draw tall sprite
	.word Object_DrawTallHFlipped	; 4: Draw tall object horizontally flipped
	.word Object_NormalAndKilled	; 5: Do "Normal" state and killed action (sinking/vert flip)
	.word Object_GiantKilled	; 6: Giant enemy death
	.word Object_PoofDie		; 7: Do "poof" dying state while killed
	.word Object_DrawAndMoveNotHalt	; 8: Draw and do movements unless gameplay halted
	.word Object_NormalWhileKilled	; 9: Just do "Normal" state while killed

Object_StandardKill:
	JSR Object_DoHaltedAction
	JMP Object_DoKilledAction

Object_NormalAndKilled:
	JSR Object_DoNormal
	JMP Object_DoKilledAction

Object_NormalWhileKilled:
	JMP Object_DoNormal

Object_GiantKilled:
	JSR ObjectGroup_PatternSets	 ; Do special draw routine used by "giant" enemies
	JMP Object_DoKilledAction

Object_PoofDie:
	; Set object state to 8 ("Poof" Dying)
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State,X

	; Set timer to $1F 
	LDA #$1f
	STA Objects_Timer,X
 
	RTS		 ; Return

Object_DrawAndMoveNotHalt:
	JSR Object_ShakeAndDraw	
	JMP Object_MoveNotHalted

Object_DrawTallHFlipped:
	JSR Object_DrawTallAndHFlip
	JMP Object_DoKilledAction

Object_Draw16x32Killed:
	JSR Object_Draw16x32Sprite
	JMP Object_DoKilledAction

Object_DrawMirroredKilled:
	JSR Object_ShakeAndDrawMirrored
	JMP Object_DoKilledAction

Object_CalcAndDrawKilled:
	JSR Object_ShakeAndDraw

	; If object was killed by sinking in quicksand or just killed, do this...
Object_DoKilledAction:
	LDA <Player_HaltGame
	BNE PRG000_D054	 ; If gameplay is halted, jump to PRG000_D054

	LDA Objects_QSandCtr,X
	BEQ PRG000_D045	 	; If object is not sinking in quicksand, jump to PRG000_D045

	INC Objects_QSandCtr,X	; Objects_QSandCtr++ 

	CMP #$90
	BNE PRG000_D02E	 	; If Objects_QSandCtr <> $90, jump to PRG000_D02E

	; Otherwise, object has sunk long enough; delete it...
	JMP Object_Delete	; Jump to Object_Delete

PRG000_D02E:

	; Slow object descent
	LDA #$04
	STA <Objects_YVel,X

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	; Set sprite priority 
	LDA Objects_FlipBits,X
	ORA #SPR_BEHINDBG
	STA Objects_FlipBits,X

	CPX #$05
	BLT PRG000_D044	 ; If object index < 5 (object is a "general" object), jump to PRG000_D044 (RTS)

	JMP Object_HitTestRespond	 ; Special object, do hit test/respond

PRG000_D044:
	RTS		 ; Return

PRG000_D045:

	; Dead object, not sinking in quicksand

	; Vertically flip
	LDA Objects_FlipBits,X
	ORA #SPR_VFLIP
	STA Objects_FlipBits,X

Object_MoveNotHalted:
	LDA <Player_HaltGame
	BNE PRG000_D054	 ; If gameplay halted, jump to PRG000_D054 (RTS)

	JSR Object_Move	 ; Perform standard object movements

PRG000_D054:
	RTS		 ; Return


	; If killed object falls too low, delete it
Object_FallAndDelete:
	LDA Level_7Vertical
	BEQ PRG000_D060	 ; If level is NOT vertical, jump to PRG000_D060

	; In vertical level...
	LDA <Objects_SpriteY,X
	CMP #200
	BLT PRG000_D054	 ; If object Y < 200, jump to PRG000_D054 (RTS)

PRG000_D060:
	LDA <Objects_YHi,X
	CMP #$02
	BLS PRG000_D054	 ; If object Y Hi < 2 (way low), jump to PRG000_D054

	; Do NOT return to caller!
	PLA
	PLA

PRG000_D068:
	JMP Object_SetDeadEmpty	 ; Jump to Object_SetDeadEmpty

ObjState_Squashed:
	LDA Objects_Timer3,X 
	BEQ PRG000_D090	 ; If timer 3 is expired, jump to PRG000_D090

	JSR Object_Move	 ; Perform standard object movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG000_D07E	 ; If object did NOT hit ground, jump to PRG000_D07E

	JSR Object_HitGround	 ; Align to ground
	STA <Objects_XVel,X	 ; Clear X velocity

PRG000_D07E:

	; Set object frame to 3
	LDA #$03
	STA Objects_Frame,X

	LDA Objects_IsGiant,X
	BNE PRG000_D08D	 ; If object is giant, jump to PRG000_D08D (ObjectGroup_PatternSets, i.e. the "giant" enemy alternative)

	JMP Object_ShakeAndDrawMirrored	 ; Draw goomba as mirrored sprite and don't come back

PRG000_D08D:
	JMP ObjectGroup_PatternSets	 ; Do the giant enemy draw routine and don't come back

PRG000_D090:
	JMP Object_SetDeadEmpty	 ; Jump to Object_SetDeadEmpty (mark object as dead/empty)

Object_MaxFalls:
	.byte OBJECT_MAXFALL, OBJECT_MAXFALLINWATER

	; Gravity of object 
Object_Gravity:
	.byte OBJECT_FALLRATE, OBJECT_FALLRATEINWATER

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_Move
;
; Links all code together to move an object with velocity
; including intersecting with the world etc.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D097
Object_Move:
	LDA <Objects_XVel,X	; Get Object's X velocity
	PHA		 	; Save it

	LDY Objects_InWater,X
	BEQ PRG000_D0A9	 	; If object is not in water, jump to PRG000_D0A9

	LDY Objects_State,X	
	CPY #OBJSTATE_NORMAL
	BEQ PRG000_D0A9	 	; If object's state is Normal, jump to PRG000_D0A9

	; This is basically an pseudo-ASR, a right shift preserving the sign
	ASL A			; Bit 7 pushed into carry
	ROR <Objects_XVel,X	; X velocity rotated right (divided by 2) and proper sign of bit 7 in place

PRG000_D0A9:
	JSR Object_ApplyXVel	 ; Applies object's X velocity

	PLA		 ; Restore Object's X velocity

	STA <Objects_XVel,X	 ; Undoes Object_ApplyXVel

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity without limit

	; SB: Kicked SMB2 objects should ignore detecting world
	LDA Objects_State,X	
	CMP #OBJSTATE_KICKED
	BNE Move_NotKicked	; If not kicked, jump to Move_NotKicked

	LDA Level_ObjectID,X
	JSR Object_IsSMB2Obj
	BEQ Move_DetectBypass	; If an SMB2 object, jump to Move_DetectBypass

Move_NotKicked:
	JSR Object_WorldDetect4	 ; Detect against the world

Move_DetectBypass:
	LDY Objects_InWater,X	; Y = whether in-water

	LDA <Objects_YVel,X
	BPL PRG000_D0CA	 	; If object is object is still or moving downward, jump to PRG000_D0CA

	; Object is moving upward...

	CPY #$00
	BEQ PRG000_D0CA	 ; If object is NOT in water, jump to PRG000_D0CA

	CMP #OBJECT_MAXWATERUPWARD
	BGE PRG000_D0CA	 ; If object's Y velocity is between OBJECT_MAXWATERUPWARD and 0, jump to PRG000_D0CA

	LDA #OBJECT_MAXWATERUPWARD	 
	STA <Objects_YVel,X ; Otherwise, cut off velocity at OBJECT_MAXWATERUPWARD

	BNE PRG000_D0CA	 ; Jump (technically always) to PRG000_D0CA (uhh... pointless, heh)

PRG000_D0CA:
	LDA <Objects_YVel,X
	ADD Object_Gravity,Y
	STA <Objects_YVel,X	; Apply gravity to object

	BMI PRG000_D0DE	 	; If Y velocity is negative, jump to PRG000_D0DE (RTS)

	CMP Object_MaxFalls,Y
	BLT PRG000_D0DE	 	; If object is not falling at the max rate, jump to PRG000_D0DE (RTS)

	LDA Object_MaxFalls,Y
	STA <Objects_YVel,X	; Cap fall at max rate

PRG000_D0DE:
	RTS		 ; Return

ObjectHeld_WakeUpDir:	.byte $40, $00 

	; Handle shelled object "waking up" from a shelled state, if timer 3 expired...
Object_ShellDoWakeUp:

	LDA Level_ObjectID,X	  

	; If object is a SMB2 type object, just do normal state
	JSR Object_IsSMB2Obj
	BEQ SMB2Object_DoNormal

	; If object is a Bob-omb, jump to PRG000_D0EC, otherwise jump to PRG000_D101

	CMP #OBJ_BOBOMBEXPLODE 
	BEQ PRG000_D0EC 
	CMP #OBJ_BOBOMB 
	BNE PRG000_D101

PRG000_D0EC: 

	; A Bob-omb only...

	LDA Objects_Timer,X 
	BNE PRG000_D0F9	 ; If timer is not expired, jump to PRG000_D0F9 


	; Timer expired, change to state 2 (Normal)
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X 
	JMP BobOmb_Explode	 ; Jump to BobOmb_Explode and don't come back!

PRG000_D0F9:
	CMP #$40
	BGE PRG000_D100	 ; If timer ticks >= $40, jump to PRG000_D100 (RTS)
 
	STA Objects_ColorCycle,X	 ; In the last timer ticks, flash colors!

PRG000_D100:
	RTS		 ; Return

SMB2Object_DoNormal:
	JMP ObjState_Normal

PRG000_D101:

	; Anything besides a Bob-omb...

	CMP #OBJ_ICEBLOCK
	BNE PRG000_D120	 ; If object is NOT an Ice Block, jump to PRG000_D120

	; Object is an ice block...  

	LDA Objects_Timer3,X 
	BNE PRG000_D10D	 ; If timer 3 is not expired, jump to PRG000_D10D 

	; Timer 3 expired... 

	JMP Object_PoofDie	 ; Jump to Object_PoofDie (Set state to 8 ["Poof" Dying] and set timer) 


	; Basically from here to the RTS, color cycle the ice block as it begins to "melt"
	; at different rates depending on where the timer is exactly...
PRG000_D10D:
	CMP #$60 
	BGE PRG000_D11C	 ; If timer 3 ticks >= $60, jump to PRG000_D11C  

	CMP #$30 
	BGE PRG000_D11B	 ; If timer 3 ticks >= $30, jump to PRG000_D11B

	CMP #$10 
	BGE PRG000_D11A	 ; If timer 3 ticks >= $10, jump to PRG000_D11A
 
	LSR A

PRG000_D11A:
	LSR A

PRG000_D11B:
	LSR A

PRG000_D11C:
	STA Objects_ColorCycle,X	 ; Set color cycle value
 
	RTS		 ; Return


PRG000_D120:

	; Object is not a Bob-omb and not an Ice Block... 

	LDA Objects_Timer3,X 
	BNE PRG000_D15A	 ; If timer 3 is not expired, jump to PRG000_D15A (RTS) 

	LDA Objects_State,X 
	CMP #OBJSTATE_HELD
	BNE PRG000_D147	 ; If object is not currently being held, jump to PRG000_D147

	; Object is being held... 

	JSR Object_WorldDetectN1 
	LDA <Objects_DetStat,X 
	BEQ PRG000_D147	 ; If held object did not impact anything, jump to PRG000_D147 

	; Held object impacted...
 
	; Get 100 points
	LDA #$05 
	JSR Score_PopUp

	; Set object state to Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,X
 
	; Set object Y velocity to -$40 (fly up after death)
	LDA #-$40 
	STA <Objects_YVel,X
 
	; Halt horizontal movement
	LDA #$00 
	STA <Objects_XVel,X
 
	BEQ PRG000_D155	 ; Jump (technically always) to PRG000_D155

PRG000_D147: 

	; Held object did NOT impact... (time to wake up!)

	; Set object state to Normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X
 
	; Have object "wake up" towards Player!
	JSR Level_ObjCalcXDiffs	 
	LDA ObjectHeld_WakeUpDir,Y 
	STA Objects_FlipBits,X

PRG000_D155:

	; Do NOT return to caller! 
	PLA 
	PLA 

	JMP PRG000_CB5E	 ; Jump to PRG000_CB5E (essentially JSR Object_DeleteOffScreen) 

PRG000_D15A:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_AboutFace
;
; Object reverses travel and facing direction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D15B 
Object_AboutFace:
	LDA <Objects_XVel,X	 
	JSR Negate
	STA <Objects_XVel,X	 ; Negate object's X velocity

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_FlipFace
;
; Object reverses facing direction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D162
Object_FlipFace:
	LDA Objects_FlipBits,X
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Flip left/right flag

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_HandleBumpUnderneath
;
; Handles an object getting killed or shelled when hit from under
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D16D
Object_HandleBumpUnderneath:
	JSR Object_AnySprOffscreen
	BNE PRG000_D1C4	 ; If any sprite is off-screen, jump to PRG000_D1C4 (RTS)
 
	LDA Object_TileFeet2 
	CMP #TILEA_BLOCKBUMP_CLEAR 
	BNE Player_HitEnemy	 ; If object did not detect a block bump clear tile, jump to Player_HitEnemy 

	; Object detected a block bump tile (object got bumped)

	; Set Y Vel to -$30 (bounce dead) 
	LDA #-$30 
	STA <Objects_YVel,X
 
	JSR Level_ObjCalcXDiffs	; Detect which side object is on versus Player 

	; Store proper X velocity
	LDA PRG000_D834,Y 
	STA <Objects_XVel,X

	; Vertically flip object 
	LDA #SPR_VFLIP
	STA Objects_FlipBits,X
 
	LDY ObjGroupRel_Idx 
	LDA ObjectGroup_Attributes3,Y 
	AND #OA3_DIESHELLED
	BNE PRG000_D19E	 ; If OA3_DIESHELLED is SET (object may use special routine), jump to PRG000_D19E 

	; Object killed, get 100 pts

	LDA #OBJSTATE_KILLED
	STA Objects_State,X 

	LDA #$00 
	JMP Score_Get100PlusPts ; Jump to Score_Get100PlusPts and don't come back! 

PRG000_D19E:
	LDA ObjGroupRel_Idx 
	ASL A 
	TAY		 ; Y = 2-byte index into CollideJumpTable
 

	LDA ObjectGroup_CollideJumpTable+1,Y	 ; Get the CollideJumpTable upper byte
	AND #%11111000
	CMP #%00001000
	BNE PRG000_D1B7	 ; If the upper byte is not ($08xx - $0Fxx), jump to PRG000_D1B7

	; SPECIAL JUMP TABLE VALUE ($08xx - $0Fxx): Change to alternate object

	; Change to alternate ObjectID in low byte
	LDA ObjectGroup_CollideJumpTable,Y
	STA Level_ObjectID,X

	; Get 100 pts
	LDA #$00 
	JSR Score_Get100PlusPts 

PRG000_D1B7:
	JMP Object_SetShellState	 ; Jump to Object_SetShellState ("dies" into shelled state) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_HitEnemy
;
; General routine for how the object responds to a Player 
; colliding with it (good and bad)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D1BA
Player_HitEnemy:
	JSR Object_HitTest	; Check for collision

	; Clear hit status bits
	LDA #$00
	STA Objects_PlayerHitStat,X

	BCS PRG000_D1C5	 ; If collision occurred, jump to PRG000_D1C5

PRG000_D1C4:
	RTS		 ; Return

PRG000_D1C5:

	LDA Objects_Timer2,X
	BNE PRG000_D1C4	 ; If timer 2 hasn't expired, jump to PRG000_D1C4 (RTS)

	; Timer 2 has expired...

	LDA Player_Slide
	BNE PRG000_D1DB	 ; If Player is sliding, jump to PRG000_D1DB

	; Player is not sliding...

	LDY ObjGroupRel_Idx	 ; Y = object group relative index
	LDA ObjectGroup_Attributes2,Y	 ; Get attributes set 2
	AND #OA2_GNDPLAYERMOD
	BEQ PRG000_D218	 ; If OA2_GNDPLAYERMOD not set, jump to PRG000_D218
	BNE PRG000_D205	 ; Otherwise, jump to PRG000_D205

PRG000_D1DB:

	; Player is sliding...

	JSR PRG000_D218	 ; Also include code like attribute set 2 bit 1 is set

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG000_D204	 ; If object state is Normal, jump to PRG000_D204 (RTS)

	STA <Temp_Var4	 ; Otherwise, store current state into Temp_Var4

	JSR Enemy_Kill	 ; Kill enemy

	LDA RandomN,X
	AND #$1f	 ; Cap 0-31
	ADC #-$4C	 
	STA <Objects_YVel,X	 ; Object Y Vel = -$2D to -$4C

	; Set object state to Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	LDA <Player_XVel	; Get Player X velocity
	STA <Temp_Var1		; -> Temp_Var1 (yyyy xxxx)
	ASL <Temp_Var1		; Shift 1 bit left (bit 7 into carry) (y yyyx xxx0)
	ROR A			; A is now arithmatically shifted to the right (yyyyy xxx) (signed division by 2)
	ADD <Objects_XVel,X	; Add the existing velocity to this (so object velocity is influenced by half Player velocity)
	STA <Objects_XVel,X	; -> Object's X velocity

PRG000_D204:
	RTS		 ; Return


PRG000_D205:

	; Object attribute set 2 bit 1 is set...

	; What does this do?
	; First off, Player must be on solid ground
	; Then, either the object is falling faster than $0A OR the object is on the ground
	; In those cases, we jump to Object_HoldKickOrHurtPlayer

	; The only real apparent function here is that a fast-falling or grounded object
	; will force into the "Hold, Kick, or Hurt Player" routine without doing the
	; the other checks, but with the Player being on the ground, it's hard for him
	; not to get hit anyway.  As such, I can't really for sure tell what the 
	; intention of this code was really supposed to be??

	; Otherwise it is PRG000_D218

	LDA <Player_InAir
	BNE PRG000_D218	 ; If Player is mid air, jump to PRG000_D218

	; Player is on solid ground...

	LDA <Objects_YVel,X
	CMP #$0a	 
	BLS PRG000_D212	 ; If Object's Y velocity < $0A, jump to PRG000_D212
Jmp_HoldKickOrHurtPlayer:

	JMP Object_HoldKickOrHurtPlayer	 ; Otherwise, jump to Object_HoldKickOrHurtPlayer


PRG000_D212:

	; Object's Y velocity < $0A ...

	LDA <Objects_DetStat,X
	AND #$04	 
	BNE Jmp_HoldKickOrHurtPlayer	 ; If object has hit ground, jump to Jmp_HoldKickOrHurtPlayer (to Object_HoldKickOrHurtPlayer)

PRG000_D218:

	; Object attribute set 2 bit 1 not set...
	; OR Player is mid-air...
	; OR Player is sliding...

	; SB: If Player and object gravities mismatch, you just can't stomp them, sorry!
	LDA Objects_ReverseGrav,X
	EOR Player_ReverseGrav
	BNE Jmp_HoldKickOrHurtPlayer

	; Remember, this is after the bounding boxes have already been used
	; to determine there's some kind of collision; we're just find tuning
	; if this is a successful "stomp" or not...
	;
	; 'Y' represents the "height" of the object for collision detection
	; The way to think about this is we're going to reference Objects_Y
	; which in SMB3 is generally the "top" of the enemy, or in any case
	; point at which "stomp" should occur.  (Of note, Koopa Troopa's 
	; "top" is their shell; the head is drawn as a negative coordinate 
	; from that point.)  The judgement is based on Player_Y, which is the
	; "top" of the Player (note for "Super" Mario, that's near the hat,
	; but for "small" Mario, that's roughly 16 pixels above.)
	;
	; G = Goomba (for example)
	;
	; . <-- This would be 19 (for this example) pixels above 
	; |
	; G <-- top of 'Goomba' is Objects_Y
	;
	; .   m <-- Top of Player must be beneath the 19 pixel offset
	; |   M
	; G
	;
	; ... if the above is true, that's considered "stompable" range.

	LDY #17	 ; Y = 17 (the following two objects)

	LDA Level_ObjectID,X
	CMP #OBJ_PILEDRIVER
	BEQ PRG000_D22E	 ; If object is a pile driver microgoomba, jump to PRG000_D22E

	CMP #OBJ_CHEEPCHEEPHOPPER
	BEQ PRG000_D22E	 ; If object is a hopping Cheep Cheep jump to PRG000_D22E

	LDY #19		 ; Y = 19 (anything else, unless object is giant)

	LDA Objects_IsGiant,X
	BEQ PRG000_D22E	 ; If object is not giant, jump to PRG000_D22E

	LDY #8	 	; Y = 8 (not the first two, if object is giant set)

PRG000_D22E:
	STY <Temp_Var2		 ; -> Temp_Var2 (height above object considered "stompable" range)

	LDA Objects_ReverseGrav,X
	BNE ObjStomp_Rev	; If object gravity is reversed, jump to ObjStomp_Rev

	LDA <Objects_Y,X	 ; Get object's Y
	SUB <Temp_Var2		 ; Subtract Temp_Var2 (height above object considered "stompable" range)
	ROL <Temp_Var1		 ; Stores the carry bit into Temp_Var1 bit 0
	CMP <Player_Y

	PHP		 ; Save CPU state (the comparison)

	LSR <Temp_Var1		; Restore the carry bit
	LDA <Objects_YHi,X	
	SBC #$00	 	; Apply the carry bit to the Objects_YHi as needed for the height subtraction

	PLP		 ; Restore CPU state (the comparison)

	SBC <Player_YHi		; Get the difference against the Player_YHi
	BMI Jmp_HoldKickOrHurtPlayer	 	; If negative (Player_YHi > Objects_YHi, Player is lower), jump to Jmp_HoldKickOrHurtPlayer (Object_HoldKickOrHurtPlayer)

ObjStomp_Cont:
	LDA <Player_YVel	
	BPL PRG000_D253	 	; If Player's Y Velocity >= 0 (stationary or moving downward), jump to PRG000_D253

	; Player is moving upward...

	LDA Player_FlyTime
	BNE PRG000_D253	 	; If Player is flying, jump to PRG000_D253

	; Player moving upward, not flying...

	LDA Kill_Tally	 
	BEQ Jmp_HoldKickOrHurtPlayer	 	; If Player hasn't killed anything yet, jump to Jmp_HoldKickOrHurtPlayer (Object_HoldKickOrHurtPlayer)

PRG000_D253:

	; Player hit from top bit
	LDA #$01
	STA Objects_PlayerHitStat,X

	LDA Player_InWater
	BNE PRG000_D267	 ; If Player is in water, jump to PRG000_D267

	LDY ObjGroupRel_Idx	 ; Y = group relative index
	LDA ObjectGroup_Attributes3,Y	 ; Get object's attribute 3 setting
	AND #OA3_NOTSTOMPABLE	 
	BEQ PRG000_D272	 ; If OA3_NOTSTOMPABLE NOT set (Object is stompable), jump to PRG000_D272

PRG000_D267:

	; Player is in water (can't stomp in water) OR attribute 3 bit 5 is set (can't stomp anyway)...

	LDA Player_Kuribo
	ORA Player_Statue
	BNE PRG000_D272	 ; If in Kuribo's shoe or transformed into statue, ignore this and jump to PRG000_D272

	JMP PRG000_D355	 ; Jump to PRG000_D355 (hurt Player!)

ObjStomp_Rev:

	LDA <Objects_Y,X	; Get object Y
	ADD #16			; +16 as an approximate bottom (works for most ground troops)
	ADD <Temp_Var2		; Add detection height
	STA <Temp_Var2		; -> Temp_Var2

	LDA <Objects_YHi,X	; Get object Y Hi
	ADC #0			; Apply carry
	STA <Temp_Var1		; Object Y High offset -> Temp_Var1

	LDA <Player_Y		; Get Player Y
	SUB #22			; Subtract 22 (approximate Player height)
	STA <Temp_Var4		; -> Temp_Var 4

	LDA <Player_YHi		; Get Player Y Hi
	SBC #0			; Apply carry
	STA <Temp_Var3		; -> Temp_Var3

	LDA <Temp_Var1
	CMP <Temp_Var3
	BEQ ObjStomp_RevRefine	; If Y His are the same, not enough to go on, jump to ObjStomp_RevRefine
	BGE ObjStomp_Cont	; If Player Y Hi > Object Y Hi, definitely stomping range, jump to ObjStomp_Cont
	BLT Jmp_HoldKickOrHurtPlayer_fix	; Otherwise, jump to Jmp_HoldKickOrHurtPlayer

ObjStomp_RevRefine:
	LDA <Temp_Var2
	CMP <Temp_Var4
	BGE ObjStomp_Cont	; If Player Y >= Object Y, jump to ObjStomp_Cont
		
Jmp_HoldKickOrHurtPlayer_fix:	
	JMP Jmp_HoldKickOrHurtPlayer

PRG000_D272:

	; Enemy got stomped!

	LDY ObjGroupRel_Idx	 ; Y = group relative index
	LDA ObjectGroup_Attributes2,Y	 ; Get object attribute set 2
	AND #OA2_STOMPDONTCARE	 
	BNE PRG000_D2B3	 	; If OA2_STOMPDONTCARE is set (object is indifferent about stomping), jump to PRG000_D2B3 (RTS)

	LDA Objects_StompDisable,X
	BNE PRG000_D2B3	 	; If Objects_StompDisable is set (object is indifferent about stomping), jump to PRG000_D2B3 (RTS)

	; Attribute set 2 bit 2 NOT set... (object cares about being stomped)

	LDA Player_Statue
	ORA Player_Kuribo
	BEQ PRG000_D29B	 	; If Player is NOT a statue and NOT in a Kuribo's shoe, jump to PRG000_D29B

	; Yoshi override; get damaged anyway if set!
	LDA ObjectGroup_Attributes4,Y
	AND #OA4_YOSHIIMMUNE
	BEQ Object_NotYoshiImmune
	
	JMP PRG000_D355	; Damage Player!

Object_NotYoshiImmune:
	; Player is a statue or in a Kuribo's shoe...

	JSR PRG000_D2B4	 ; Handle stomp!

	LDY ObjGroupRel_Idx	 ; Y = object group relative index
	LDA ObjectGroup_Attributes3,Y	 ; Get attribute set 3
	AND #OA3_SQUASH
	BEQ PRG000_D295	 ; If OA3_SQUASH NOT set, jump to PRG000_D295 (kill it)

	; When stomped by statue/Kuribo, if the enemy was going to get squashed anyway
	; then go ahead into "shelled" state which redirects to "stomped" state.

	LDA #OBJSTATE_SHELLED	 ; Otherwise, state is Shelled
	BNE PRG000_D297	 ; Jump (technically always) to PRG000_D297

PRG000_D295:

	; When stomped by statue/Kuribo, if the enemy was going to actually going to
	; become shelled, kill it instead...

	LDA #OBJSTATE_KILLED	 ; State is Killed

PRG000_D297:
	STA Objects_State,X	 ; Set appropriate object state

	RTS		 ; Return


PRG000_D29B:

	; Player NOT a statue and NOT in a Kuribo's shoe stomp code

	LDA Objects_State,X
	CMP #OBJSTATE_SHELLED
	BNE PRG000_D2B4	 ; If object state is not shelled, jump to PRG000_D2B4 (typical stomp)

PRG000_D2A2:

	; Enemy is in a shell...

	LDA Kill_Tally	 
	INC Kill_Tally	 ; Use Kill_Tally +1
	JSR Score_Get100PlusPts	 ; Get points for the kick
	JSR Player_KickObject	 ; Player kicks the enemy!

	; Clear Player kick
	LDA #$00
	STA Player_Kick

PRG000_D2B3:
	; Clear Objects_StompDisable (if it was used)
	LDA #0
	STA Objects_StompDisable,X
	RTS		 ; Return


PRG000_D2B4:

	; Set timer 2 to 8
	LDA #$08	 
	STA Objects_Timer2,X

	; Set Player's Y velocity to -$40 (bounce!)
	LDA #-$40
	STA <Player_YVel

	; Play squish sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	DEC Objects_HitCount,X	; HitCount--
	BPL PRG000_D2B3	 ; If hits remain, jump to PRG000_D2B3 (RTS)

	LDA ObjGroupRel_Idx	 ; A = object group relative index
	ASL A		 ; Shift left 1 (2 byte index)
	PHA		 ; Save this


	TAY		 ; -> 'Y'
	LDA ObjectGroup_CollideJumpTable+1,Y	 ; Get the CollideJumpTable upper byte

	AND #%11110100
	CMP #%00000100
	BNE PRG000_D2E1	 ; If the upper byte is not ($04xx - $07xx), jump to PRG000_D2E1

	; SPECIAL JUMP TABLE VALUE ($04xx - $07xx): High scoring

	; In this case, Kill_Tally will be boosted by 4 (+1) instead of just +1
	LDA Kill_Tally
	ADD #$04	
	BNE PRG000_D2E4	

PRG000_D2E1:
	LDA Kill_Tally	 ; Otherwise, just get Kill_Tally

PRG000_D2E4:
	INC Kill_Tally	 ; Kill_Tally++
	JSR Score_Get100PlusPts	 ; Get proper score award

	PLA		 ; Restore index into CollideJumpTable
	TAY		 ; -> 'Y'

	LDA ObjectGroup_CollideJumpTable+1,Y	 ; Get the CollideJumpTable upper byte
	AND #%11111000

	CMP #%00001000
	BNE PRG000_D301	 ; If the upper byte is not ($08xx - $0Fxx), jump to PRG000_D301

	; SPECIAL JUMP TABLE VALUE ($08xx - $0Fxx): Change to alternate object

	; Change to alternate ObjectID in low byte
	LDA ObjectGroup_CollideJumpTable,Y
	STA Level_ObjectID,X

	INC Objects_HitCount,X	 ; Give hit back (restore to zero)
	JMP PRG000_D31E	 ; Jump to PRG000_D31E

PRG000_D301:
	LDY ObjGroupRel_Idx	 ; Y = object group relative index
	LDA ObjectGroup_Attributes2,Y	 ; Get object attributes set 2
	AND #OA2_NOSHELLORSQUASH	 
	BEQ PRG000_D323	 	; If OA2_NOSHELLORSQUASH is NOT set (shelled enemy), jump to PRG000_D323

	; Cancel the "Squish" sound, use the "kick" sound instead!
	LDA Sound_QPlayer
	AND #~SND_PLAYERSWIM
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; Set object state to 6 (killed)
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG000_D31E:
	; Halt vertical movement
	LDA #$00
	STA <Objects_YVel,X

	RTS		 ; Return

PRG000_D323:
	INC Objects_HitCount,X	 ; Give hit back (restore to zero)

Object_SetShellState:
	; Set Objects_State to Shelled
	LDA #OBJSTATE_SHELLED
	STA Objects_State,X

	; Set timer 3 = $FF (wake up timer)
	LDA #$ff
	STA Objects_Timer3,X

	LDA Objects_ReverseGrav,X
	BEQ Object_SetShell_NoRev

	; SB: If object is under reverse gravity, set vertical flip on the object
	LDA Objects_FlipBits,X
	ORA #SPR_VFLIP
	STA Objects_FlipBits,X

Object_SetShell_NoRev:
	RTS		 ; Return


Object_HoldKickOrHurtPlayer:

	LDA Objects_State,X
	CMP #OBJSTATE_SHELLED
	BNE PRG000_D355	 ; If object state is not Shelled, jump to PRG000_D355 (hurt Player!)

	LDA Player_Kuribo
	ORA Player_Statue
	BEQ PRG000_D343	 ; If Player is NOT in Kuribo's shoe and NOT in a statue, jump to PRG000_D343
	JMP PRG000_D2A2	 ; Otherwise, jump to PRG000_D2A2

PRG000_D343:
	LDA Player_ISHolding_OLD
	BNE PRG000_D39F	 ; If Player WAS holding something, jump to PRG000_D39F (RTS)

	BIT <Pad_Holding
	BVS PRG000_D34F	 	; If Player is holding B, jump to PRG000_D34F
	JMP Player_KickObject	 ; Kick away the object and don't come back!

PRG000_D34F:

	; Keep held object in state 4 (Held)
	LDA #OBJSTATE_HELD
	STA Objects_State,X

	RTS		 ; Return


PRG000_D355:

	; Player potentially gonna get hurt!

	LDA Player_FlashInv	; If Player is flashing from getting hit recently...
	ORA Player_Statue	; ... or Player is a statue ...
	ORA Objects_Timer2,X	; ... or this object's timer2 is not expired ...
	ORA Player_StarInv	; ... or Player is invincible by Star Man ...
	BNE PRG000_D39F	 	; ... then jump to PRG000_D39F (RTS)

	LDA Objects_State,X
	CMP #OBJSTATE_KICKED
	BNE PRG000_D382	 	; If object's state is not Kicked, jump to PRG000_D382

	LDY #$00	 ; Y = 0

	LDA <Player_XVel
	BEQ PRG000_D382	 ; If Player is not moving horizontally, jump to PRG000_D382
	BPL PRG000_D373	 ; If Player is moving to the right, jump to PRG000_D373

	INY		 ; Otherwise, Y = 1

PRG000_D373:
	STY <Temp_Var1		 ; Temp_Var1 = 0 (Player moving left) or 1 (Player moving right)

	EOR <Objects_XVel,X	 ; Check for X velocity sign difference between Player and object
	BMI PRG000_D382	 	; If there's a difference in sign, jump to PRG000_D382

	; Object and Player are moving in the same horizontal direction...

	JSR Level_ObjCalcXDiffs	
	CPY <Temp_Var1
	BNE PRG000_D39F	 ; If Player is moving away from object, jump to PRG000_D39F
	BEQ PRG000_D39C	 ; Otherwise, jump to PRG000_D39C

PRG000_D382:
	JSR Object_CalcAttrFlagOff	; Y = object's ID

	LDA Object_AttrFlags,Y
	AND #OAT_BOUNCEOFFOTHERS
	BEQ PRG000_D39C	 ; If OAT_BOUNCEOFFOTHERS is NOT set (turn around when hit), jump to PRG000_D39C

	JSR Level_ObjCalcXDiffs

	LDA Objects_FlipBits,X
	AND #~SPR_HFLIP	 ; Clear horizontal flip
	DEY		 
	BEQ PRG000_D399
	ORA #SPR_HFLIP	 ; Set horizontal flip
PRG000_D399:
	STA Objects_FlipBits,X	 ; Update object flip bits as necessary

PRG000_D39C:
	JMP Player_GetHurt	; Hurt Player and don't come back!

PRG000_D39F:
	RTS		 ; Return

	; A very popular RTS @ $D3A0
ObjState_DeadEmpty:
ObjInit_DoNothing:
ObjNorm_DoNothing:
ObjHit_DoNothing:
ObjHalt_DoNothing:
LevelEvent_DoNothing:
	RTS		 ; Return

	; SB: Jump point for initializing reverse gravity ground troops and other things that change ID at init
ObjState_InitPageMismatch:
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JMP ObjState_Initializing_Call	; Jump to ObjState_Initializing_Call

	; Called for an object in state 1 to perform initialization logic
ObjState_Initializing:
	JSR Level_PrepareNewObject ; Prepare the object

	INC Objects_State,X	 	; Set object state to 2 (Normal run)

	; SB: Exposing this so I can have my reverse-gravity enemies chain initialize
ObjState_Initializing_Call:
	JSR Object_SetPaletteFromAttr	; Set object's palette

	LDA ObjGroupRel_Idx	 ; Get object's group relative index
	ASL A		 ; Shift left 1 (2 byte index)
	TAY		 ; -> Y

	; Get jump address specific to this object
	LDA ObjectGroup_InitJumpTable,Y
	STA <Temp_Var1
	LDA ObjectGroup_InitJumpTable+1,Y
	STA <Temp_Var2
	JMP [Temp_Var1]	 ; Dynamically jump to object's init routine 

	; Set object's palette value
; $D3BC
Object_SetPaletteFromAttr:
	LDY ObjGroupRel_Idx	 	; Y = object's relative group index
	LDA ObjectGroup_Attributes,Y	; Get attributes
	AND #OA1_PALMASK 		; Keep only bits 0 and 1 (palette)
	STA Objects_SprAttr,X	 	; Set this object's palette
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DeleteOffScreen
;
; The routine that removes objects if they go off-screen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Vertical level
PRG000_D3C8:	.byte $40, $B0	; Lo
PRG000_D3CA:	.byte $01, $FF	; Hi

	; Non-vertical level -- selectable remove sizes
PRG000_D3CC:	.byte $20, $D0, 	$80, $80, 	$40, $B0	; Lo
PRG000_D3D2:	.byte $01, $FF, 	$01, $FF, 	$01, $FF	; Hi

	; The different "N" varieties specify how wide before the deletion occurs

	; $D3D8
Object_DeleteOffScreen_N4:
	LDA #$04	 ; A = 4
	BNE PRG000_D3EF	 ; Jump (technically always) to PRG000_D3EF

	; $D3DC
Object_DeleteOffScreen_N2:
	LDA #$02	 ; A = 2
	BNE PRG000_D3EF	 ; Jump (technically always) to PRG000_D3EF

	; $D3E0
Object_DeleteOffScreen:
	LDA #$00	 ; A = 0

PRG000_D3EF:
	STA <Temp_Var1	 ; Temp_Var1 = 0, 2, or 4 

	JSR Object_AnySprOffscreen
	BEQ PRG000_D463	 ; If any sprites are off-screen, jump to PRG000_D463

	LDA Level_7Vertical
	BNE PRG000_D464	 ; If level is vertical, jump to PRG000_D464


	; LEVEL NOT VERTICAL

	LDA <Objects_YHi,X
	CMP #$02	 
	BPL Object_Delete	 ; If object Y Hi >= 2 (way off screen), jump to Object_Delete

	; Semi-randomly jump to PRG000_D463 (RTS)
	; That is, only occasionally actually do the off-screen check
	; Keeps down on CPU cycles spent wondering about the object
	TXA		 
	ADD <Counter_1	
	LSR A		 ; A = (object index + Counter_1) >> 1
	BCS PRG000_D463	 ; If carry set, jump to PRG000_D463 (RTS)

	AND #$01
	STA <Temp_Var2	 ; Temp_Var2 stores bit 0 from above; thus 0 or 1

	ADC <Temp_Var1	 ; So value is now 0-5
	TAY		 ; -> 'Y'

	LDA <Horz_Scroll
	ADD PRG000_D3CC,Y	 ; Horizontal scroll plus offset

	ROL <Temp_Var1		 ; Temp_Var1 is 0/1, 4/5

	CMP <Objects_X,X	 ; Compare to object X
	PHP		 	; Save CPU state

	LDA <Horz_Scroll_Hi	 
	LSR <Temp_Var1		 
	ADC PRG000_D3D2,Y	 ; Add high part of offset





	PLP		 	; Restore CPU state

	SBC <Objects_XHi,X	 
	STA <Temp_Var1		 ; Temp_Var1 is X Hi difference

	LDY <Temp_Var2		 ; Y = Temp_Var2
	BEQ PRG000_D42E	 	; If zero, jump to PRG000_D42E

	EOR #$80	 	
	STA <Temp_Var1		; Temp_Var1 ^= $80

PRG000_D42E:
	LDA <Temp_Var1	
	BPL PRG000_D463	 ; If positive, jump to PRG000_D463 (RTS)

	; Deletes object, marks it so it will reappear next time it comes on-screen
Object_Delete:
	LDA Level_ObjectID,X

	; If object ID is OBJ_FIRECHOMP, OBJ_CHAINCHOMPFREE, OBJ_BLOOPERCHILDSHOOT, 
	; OBJ_BLOOPERWITHKIDS, or OBJ_FIRESNAKE, jump to PRG000_D449	
	; These objects are hardcoded to release their X/Y Buffer allocations!
	CMP #OBJ_FIRECHOMP
	BEQ PRG000_D449

	CMP #OBJ_BLOOPERCHILDSHOOT
	BEQ PRG000_D449

	CMP #OBJ_BLOOPERWITHKIDS
	BEQ PRG000_D449

	CMP #OBJ_FIRESNAKE
	BNE Object_SetDeadAndNotSpawned	 

PRG000_D449:

	; One of the above five objects ONLY!

	LDY Objects_Var6,X ; Y = Var6 (should be 0 or 1, the buffer slot the object occupies)

	; Clear the occupation of the X/Y Buffer
	LDA #$00
	STA Buffer_Occupied,Y

Object_SetDeadAndNotSpawned:
	LDY Objects_SpawnIdx,X	 ; Get the spawn index of this object
	BMI Object_SetDeadEmpty	 ; If object is spawned, jump to Object_SetDeadEmpty

	; Clear object spawn flag
	LDA Level_ObjectsSpawned,Y
	AND #$7f
	STA Level_ObjectsSpawned,Y

Object_SetDeadEmpty: 
	; Mark object as dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

PRG000_D463:
	RTS		 ; Return


PRG000_D464:
	; LEVEL IS VERTICAL

	LDA <Counter_1
	LSR A		 
	BCS PRG000_D463	 ; Every other tick, jump to PRG000_D463 (RTS)

	AND #$01
	STA <Temp_Var2	 ; Temp_Var2 = 0 or 1
	TAY		 ; -> 'Y'

	LDA Level_VertScroll
	ADD PRG000_D3C8,Y
	ROL <Temp_Var1		 ; 0/1 or 4/5

	CMP <Objects_Y,X	 ; Compare to object Y

PRG000_D479:
	PHP		 ; Save CPU state

	LDA Level_VertScrollH
	LSR <Temp_Var1	
	ADC PRG000_D3CA,Y

	PLP		 ; Restore CPU state

	SBC <Objects_YHi,X
	STA <Temp_Var1	
	LDY <Temp_Var2	
	BEQ PRG000_D48F	 

	EOR #$80	
	STA <Temp_Var1	

PRG000_D48F:
	LDA <Temp_Var1
	BPL PRG000_D463	
	BMI Object_Delete	
	BPL PRG000_D497	 

PRG000_D497:
	BEQ PRG000_D479	


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_PrepareNewObject
;
; Prepares a new object by initializing all of the many object
; variables to zero...
;
; X = index of on-screen object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D499
Level_PrepareNewObject:

	; Clear various object variables
	LDA #$00
	STA Objects_Var1,X
	STA Objects_Var2,X
	STA <Objects_SpriteX,X
	STA Objects_Timer,X
	STA Objects_Timer2,X
	STA <Objects_XVel,X
	STA <Objects_YVel,X
	STA Objects_FlipBits,X
	STA Objects_Frame,X	
	STA Objects_ColorCycle,X
	STA Objects_ReverseGrav,X	; SB
	STA Objects_FrozenTimer,X	; SB
	STA Objects_IsBehind,X		; SB
	STA Objects_StompDisable,X	; SB
	STA <Objects_DetStat,X	
	STA Objects_PlayerHitStat,X
	STA Objects_Var7,X
	STA <Objects_Var5,X

	CPX #$06
	BGE PRG000_D4C8	 ; If using slot index >= 6, jump to PRG000_D4C8 (skip variables available only to slots 0 to 5)

	; Clear some more variables (object slots 0 to 5 ONLY)
	STA Objects_DisPatChng,X
	STA ObjSplash_DisTimer,X
	STA Objects_QSandCtr,X
	STA Objects_InWater,X

PRG000_D4C8:
	CPX #$05
	BGE PRG000_D506	 ; If using slot index >= 5, jump to PRG000_D506 (skip variables available only to slots 0 to 4)

	; Clear even more variables (object slots 0 to 4 [major objects] ONLY!!)
	STA <Objects_Var4,X
	STA Objects_Timer4,X
	STA Objects_Timer3,X
	STA Objects_Slope,X
	STA Objects_Var3,X	
	STA Objects_Var6,X	 
	STA Objects_TargetingXVal,X
	STA Objects_TargetingYVal,X
	STA Objects_IsGiant,X
	STA Objects_HitCount,X
	STA Objects_DisPatChng,X
	STA Objects_Var10,X
	STA Objects_Var11,X
	STA Objects_Var12,X
	STA Objects_Var13,X
	STA Objects_Var14,X

PRG000_D506:
	RTS		 ; Return


	; Called for an object in state 2 to do its "normal" routine
ObjState_Normal:

	LDA <Player_HaltGame
	BEQ Object_DoNormal	 ; If gameplay is NOT halted by the Player, jump to Object_DoNormal

	JMP Object_DoHaltedAction	 ; Jump to Object_DoHaltedAction

Object_DoNormal:
	LDA ObjGroupRel_Idx
	ASL A		 
	TAY		 ; Y = object's group relative index * 2 (2 byte index for jump table)

	; Get jump address specific to this object
	LDA ObjectGroup_NormalJumpTable,Y
	STA <Temp_Var1
	LDA ObjectGroup_NormalJumpTable+1,Y
	STA <Temp_Var2
	JMP [Temp_Var1]	 ; Dynamically jump to object's "normal" routine 


Object_DoHaltedAction:

	; Gameplay is halted, determine what needs to happen with this object...

	LDY ObjGroupRel_Idx	 ; Y = group relative index 

	LDA ObjectGroup_Attributes3,Y	; Get attribute set 3 bits
	AND #OA3_HALT_MASK 		; Keep only the lowest 4
	JSR DynJump	 

	; WARNING: Read comment; some of these are specific to object banks!

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bank2_HotFootHaltAction		; 0: Bank2/Hotfoot ONLY
	.word Object_ShakeAndDraw		; 1: Standard draw
	.word Object_Draw16x32Sprite		; 2: Draw tall sprite
	.word Bank2_SpikeHaltAction		; 3: Bank2/Spike ONLY
	.word ObjHalt_DoNothing			; 4: Do nothing
	.word ObjHalt_DoNothingNotNormal	; 5: If object is in "normal" state, do its normal routine, otherwise do nothing (COMMON)
	.word Object_DrawWide			; 6: Draw wide sprite
	.word ObjHalt_DoNothing			; 7: Do nothing
	.word $0000			; 8: UNUSED
	.word ObjHalt_DoNothing			; 9: Do nothing
	.word Object_ShakeAndDrawMirrored	; 10: Draw mirrored sprite
	.word EndLevelCard_Draw			; 11: Bank2/End Level Card ONLY
	.word ObjHalt_DoNothing			; 12: Do nothing
	.word $0000	; 13: UNUSED
	.word Bank2_PiranhaSpikeHaltAction	; 14: Bank2/Piranha Spike Ball ONLY

ObjHalt_DoNothingNotNormal:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG000_D553	 ; If object's state is not Normal, jump to PRG000_D553

	JMP Object_DoNormal	 ; Otherwise, jump to Object_DoNormal (jump into object's "Normal" routine)

PRG000_D553:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_CalcSpriteXY_NoHi
;
; Calculate SpriteX/Y without considering the "High" parts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D554
Object_CalcSpriteXY_NoHi:
	LDA <Objects_Y,X
	SUB Level_VertScroll
	STA <Objects_SpriteY,X

	LDA <Objects_X,X
	SUB <Horz_Scroll
	STA <Objects_SpriteX,X

	RTS		 ; Return


; $D564
Fish_FixedY_ExceptHitFloor:
	LDA <Objects_DetStat,X
	AND #$04
	BNE PRG000_D588	 ; If object has hit floor, jump to PRG000_D588

; $D56A
Fish_FixedYIfAppro:
	LDA Level_AScrlConfig
	BEQ PRG000_D588	 ; If no auto scroll effect active (assuming fixed height water level), jump to PRG000_D588 (RTS)

	LDA Level_FreeVertScroll
	CMP #$01
	BEQ PRG000_D588	 ; If this level has free vertical scrolling, jump to PRG000_D588

	LDY #$00	 ; Y = 0 (16-bit carry)

	LDA Level_ScrollDiffV
	BPL PRG000_D57E	 ; If desired vertical scroll is not negative, jump to PRG000_D57E

	DEY 		; Y = $FF (16-bit carry)

PRG000_D57E:

	; In fixed-height, locked scrolling water levels, Big Bertha's
	; Object_Y position offsets from the scroll position
	ADD <Objects_Y,X
	STA <Objects_Y,X
	TYA
	ADC <Objects_YHi,X
	STA <Objects_YHi,X

PRG000_D588:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_ShakeAndCalcSprite
;
; The routine for a held object to "shake awake" (shelled enemies)
; and calculates sprite related info
;
; X = index of on-screen object
;
; Returns lots of stuff:
; Temp_Var1 = Object sprite Y
; Temp_Var2 = Object sprite X
; Temp_Var3 = Object's LR flag
; Temp_Var4 = Object's attributes
; Temp_Var5 = Objects_SprVVis
; Temp_Var6 = Object's starting tiles index (and -> 'X')
; Temp_Var7 = Object's Sprite_RAM offset (and -> 'Y')
; Temp_Var8 = Objects_SprHVis
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D589
Object_ShakeAndCalcSprite:
	LDA <Objects_Y,X	; Get object's Y
	SUB Level_VertScroll	; Make relative

	STA <Objects_SpriteY,X	; Store as sprite Y
	STA <Temp_Var1		; Also -> Temp_Var1

	; This is the object "shakin' awake" routine!  (Enemies in shell etc.)
 
	SEC		 ; Set carry (remember, this is the default for not applying carry to subtraction)

	LDA Objects_Timer4,X

	BEQ PRG000_D5A0	 ; If Timer4 = 0, jump to PRG000_D5A0

	CMP #$40
	BLT PRG000_D59F	 ; If Timer4 < $40, jump to PRG000_D59F

	LSR A

	LSR A

PRG000_D59F:
	LSR A	; Shift right 1 (if Timer4 < $40) or 3 (basically applies a carry sort of sporadically for "shakin' awake")

PRG000_D5A0:
	LDA <Objects_X,X	; Get object's X
	SBC <Horz_Scroll	; Make relative
	STA <Objects_SpriteX,X	; Store as sprite X
	STA <Temp_Var2		; Also -> Temp_Var2

	LDA Objects_FlipBits,X
	STA <Temp_Var3		; Temp_Var3 = object's LR flag

	LDY ObjGroupRel_Idx	; Y = object's group relative index

	LDA Objects_ColorCycle,X
	BEQ PRG000_D5BC	 	; If Objects_ColorCycle = 0, jump to PRG000_D5BC

	DEC Objects_ColorCycle,X	; Objects_ColorCycle--
	AND #$03	 
	BPL PRG000_D5BF	 	; Jump (technically always) to PRG000_D5BF

PRG000_D5BC:
	LDA Objects_SprAttr,X	; Otherwise, just get the normal attributes

PRG000_D5BF:
	STA <Temp_Var4		; Decided attributes -> Temp_Var4

	LDA Objects_SprVVis,X
	STA <Temp_Var5		; Temp_Var5 = Objects_SprVVis

	LDA Objects_SprHVis,X
	STA <Temp_Var8		; Temp_Var8 = Objects_SprVVis

	; Each "frame" value moves up two bytes to the next pair
	LDA Objects_Frame,X
	ASL A	
	STA <Temp_Var6		; Temp_Var6 = Objects_Frame << 1

	LDA ObjectGroup_PatternStarts,Y
	ADD <Temp_Var6	
	STA <Temp_Var6		; Temp_Var6 += ObjectGroup_PatternStarts[Y] (set base tile index)

	TAX		 	; -> 'X' 

	LDY <SlotIndexBackup	; Y = object slot index

	LDA Object_SprRAM,Y
	STA <Temp_Var7		; Temp_Var7 = Object_SprRAM[Y] 

	TAY		 	; -> 'Y' 

	RTS		 ; Return

PRG000_D5E3:
	.byte $08, $04, $02, $01

	; Object "shaking awake" and draw its sprite
; $D5E7
Object_ShakeAndDraw:
	JSR Object_ShakeAndCalcSprite
	JSR Object_Draw16x16Sprite

	LDX <SlotIndexBackup
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_ShakeAndDrawMirrored
;
; Used to draw 16x16 mirrored object sprites.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D5F0
Object_ShakeAndDrawMirrored:
	JSR Object_ShakeAndDraw	; Draw object and "shake awake"

	; Keep all attributes except horizontal flip
	LDA Sprite_RAM+$02,Y
	AND #%10111111	 
	STA Sprite_RAM+$02,Y

	; Flip opposite sprite
	ORA #$40
	STA Sprite_RAM+$06,Y

	RTS		 ; Return

; $D601
Object_DrawTallAndHFlip:
	JSR Object_Draw16x32Sprite	 ; Draw tall sprite

	; Reverse sprites
	LDA Sprite_RAM-$06,Y
	AND #%10111111
	STA Sprite_RAM-$06,Y

	STA Sprite_RAM+$02,Y

	ORA #$40
	STA Sprite_RAM-$02,Y

	STA Sprite_RAM+$06,Y

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_Draw16x32Sprite
;
; Used to draw 16x32 object sprites.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D618
Object_Draw16x32Sprite:
	JSR Object_ShakeAndCalcSprite

Object_Draw16x32SpriteCS:	; Alternate entry point assuming Object_ShakeAndCalcSprite called
	LDX <SlotIndexBackup	; X = object slot index

	LDA Objects_Frame,X
	ASL A		 
	ADD <Temp_Var6	
	STA <Temp_Var6	 ; Temp_Var6 += object's frame
	TAX		 ; -> 'X'

	LDA <Temp_Var3	 ; Objects_FlipBits
	BPL PRG000_D62D	 ; If Objects_FlipBits bit 7 is NOT set, jump to PRG000_D62D

	; Otherwise...
	INX
	INX		 ; X += 2

PRG000_D62D:
	JSR Object_Draw16x16Sprite	 ; Draw sprite

	LSR <Temp_Var5	 ; Objects_SprVVis

	; 'Y' += 8 (Sprite RAM 2 sprites over)
	TYA
	ADD #$08
	TAY	

	LDX <Temp_Var6	 ; X = Temp_Var6 (starting tile)

	LDA <Temp_Var3	 ; Objects_FlipBits
	BMI PRG000_D63F	 ; If Objects_FlipBits bit 7 set, jump to PRG000_D63F

	; Otherwise...
	INX
	INX		 ; X += 2

PRG000_D63F:
	LDA #16
	ADD <Temp_Var1	 ; Sprite Y
	STA <Temp_Var1	 ; Temp_Var1 += 16

	JSR Object_Draw16x16Sprite	 ; Draw sprite

	LDX <SlotIndexBackup		 ; X = object slot index

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DrawWide
;
; Draws a wide 24x16 object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_DrawWide:
	JSR Object_ShakeAndCalcSprite

	LDX <SlotIndexBackup	; X = object's slot index

	; Calculate offset into the ObjectGroup_PatternSets table
	LDA Objects_Frame,X
	ADD <Temp_Var6	
	STA <Temp_Var6		; Temp_Var6 += object's frame
	TAX		 	; -> 'X'
	JSR Object_Draw24x16Sprite	; Draw wide sprite

	LDX <SlotIndexBackup	 ; X = object's slot index
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_ToggleFrameBySpd
;
; Sets object's frame alternating 0 or 1 at a rate which 
; increases in speed (X velocity)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D660
Object_ToggleFrameBySpd:
	LDA <Objects_XVel,X	 
	BNE PRG000_D665	 ; If object is moving horizontally, jump to PRG000_D665

	; Otherwise, do nothing
	RTS		 ; Return

PRG000_D665:

	; Absolute value of X Velocity
	BPL PRG000_D66A	 
	JSR Negate
PRG000_D66A:

	AND #$f0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAY		 ; Y = "whole" part of X Velocity only

	LDA PRG000_D5E3,Y	 ; Get masking value

	LDY #$00	 ; Y = 0

	AND <Counter_1	
	BEQ PRG000_D67B	 ; If Counter_1 masked by value is zero, jump to PRG000_D67B

	INY		 ; Otherwise, Y = 1

PRG000_D67B:
	TYA		 
	STA Objects_Frame,X	 ; Set as frame 0 or 1
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_Draw16x16Sprite
;
; Used to draw 16x16 object sprites.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D680
Object_Draw16x16Sprite:
; Temp_Var1 = Object sprite Y
; Temp_Var2 = Object sprite X
; Temp_Var3 = Object's LR flag
; Temp_Var4 = Object's attributes
; Temp_Var5 = Objects_SprVVis
; Temp_Var6 = Object's starting tiles index (and -> 'X')
; Temp_Var7 = Object's Sprite_RAM offset (and -> 'Y')
; Temp_Var8 = Objects_SprHVis
	LDA <Temp_Var5	; Check sprite vertical visibility
	LSR A		; Shift right (checking lowest bit)
	BCS PRG000_D6C6	; If this bit is set, this sprite piece is invisible, jump to PRG000_D6C6 (RTS)

	LDA <Temp_Var1	; Get sprite Y

	BIT <Temp_Var8	; Testing bit 7 of horizontal sprite visibility
	BMI PRG000_D68E	; If bit 7 is set (this sprite is horizontally off-screen), jump to PRG000_D68E

	STA Sprite_RAM+$00,Y	 ; Otherwise, OK to set sprite Y

PRG000_D68E:
	BVS PRG000_D693	 ; If bit 6 is set, jump to PRG000_D693

	STA Sprite_RAM+$04,Y	 ; Otherwise, OK set second sprite Y

PRG000_D693:
	LDA <Temp_Var2		; Get sprite X
	STA Sprite_RAM+$03,Y	; Store into Sprite RAM

	ADD #$08	 	; +8 for next sprite over
	STA Sprite_RAM+$07,Y	; Store into second sprite

	LDA ObjectGroup_PatternSets,X	; Get first sprite pattern index
	STA Sprite_RAM+$01,Y	; -> Sprite RAM

	LDA ObjectGroup_PatternSets+1,X	; Get second sprite pattern index
	STA Sprite_RAM+$05,Y	; -> Sprite RAM

	LDA <Temp_Var3		 
	ORA <Temp_Var4		 ; Joins base attributes to H-flip flag
	STA Sprite_RAM+$02,Y	 ; Store into both sprite's attributes
	STA Sprite_RAM+$06,Y	 ; Store into both sprite's attributes

	BIT <Temp_Var3		
	BVC PRG000_D6C6	 ; If sprite is not horizontally flipped, jump to PRG000_D6C6 (RTS)

	; If flipped, swap sprite attributes
	LDA Sprite_RAM+$01,Y
	PHA		
	LDA Sprite_RAM+$05,Y
	STA Sprite_RAM+$01,Y
	PLA
	STA Sprite_RAM+$05,Y

PRG000_D6C6:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_Draw24x16Sprite
;
; Used to draw 24x16 object sprites.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D6C7
Object_Draw24x16Sprite:
	LDA <Temp_Var5	; Check sprite vertical visibility
	LSR A		
	BCS PRG000_D726	; If this sprite is off-screen, jump to PRG000_D726 (RTS)

	LDA <Temp_Var8	; Check horizontal sprite visibility
	ASL A		; Left shift flags value
	STA <Temp_Var10	; -> Temp_Var10

	LDA <Temp_Var1	; Sprite Y
	BCS PRG000_D6D8	; If sprite is horizontally off-screen, jump to PRG000_D6D8

	STA Sprite_RAM+$00,Y	 ; Set sprite Y in RAM

PRG000_D6D8:
	BIT <Temp_Var10	 
	BMI PRG000_D6DF	 ; If this sprite is off-screen, jump to PRG000_D6DF

	STA Sprite_RAM+$04,Y	 ; Set sprite Y in RAM

PRG000_D6DF:
	BVS PRG000_D6E4	 ; If this sprite is off-screen, jump to PRG000_D6E4

	STA Sprite_RAM+$08,Y	 ; Set sprite Y in RAM

PRG000_D6E4:
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y	 ; Set sprite X in RAM
	ADD #$08
	STA Sprite_RAM+$07,Y	 ; Set sprite X in RAM (+8)
	ADD #$08
	STA Sprite_RAM+$0B,Y	 ; Set sprite X in RAM (+16)

	; Set each of the sprite's patterns
	LDA ObjectGroup_PatternSets,X
	STA Sprite_RAM+$01,Y
	LDA ObjectGroup_PatternSets+1,X
	STA Sprite_RAM+$05,Y
	LDA ObjectGroup_PatternSets+2,X
	STA Sprite_RAM+$09,Y

	; Set each sprite's attributes
	LDA <Temp_Var3
	ORA <Temp_Var4		 ; Combine attributes
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y
	STA Sprite_RAM+$0A,Y

	BIT <Temp_Var3
	BVC PRG000_D6C6	 ; If sprite is not horizontally flipped, jump to PRG000_D6C6 (RTS)

	; Swap end sprites patterns
	LDA Sprite_RAM+$01,Y
	PHA	
	LDA Sprite_RAM+$09,Y
	STA Sprite_RAM+$01,Y
	PLA	
	STA Sprite_RAM+$09,Y

PRG000_D726:
	RTS		 ; Return
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_GetRandNearUnusedSpr
;
; Gets a semi-random "near by" sprite as appropriate for an
; object; it's a "friendly" way of getting an additional sprite
; for an object that's going over the normal limit.
;
; X = index of on-screen object
;
; Returns:
;	Temp_Var7 = offset to the blank sprite (also in 'Y')
;	Temp_Var8 = 5 or 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Selection table for the 5/1... doesn't seem like the
	; values actually mean anything, it just checks > 5?
	; Kept in Temp_Var9 anyway...
PRG000_D727:
	.byte $00, $01, $02, $03, $04, $05, $03, $07, $00, $01, $02, $03, $04, $05, $02

; $D736
Object_GetRandNearUnusedSpr:
	TXA
	PHA		 ; Save object index

	LDY #$07	 ; Y = 7
PRG000_D73A:
	STY <Temp_Var7	 ; Update Temp_Var7

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA RandomN,X
	AND #$07	
	ADD <Temp_Var7	
	TAY		 ; Y = (Random 0-7) + Temp_Var7

	LDA PRG000_D727,Y
	TAY		
	STY <Temp_Var9	 ; Temp_Var9 = PRG000_D727[Y]

	LDA Objects_State,Y
	BEQ PRG000_D763	 ; If object state = 0 (dead/empty), jump to PRG000_D763

PRG000_D752:
	LDY <Temp_Var7	 ; Y = Temp_Var7
	DEY		 ; Y--
	BPL PRG000_D73A	 ; While Y > 0, loop!

	LDX #$20	 ; X = $20

	LDA RandomN
	BPL PRG000_D760	 ; 50/50, jump to PRG000_D760

	LDX #$24	 ; Otherwise, X = $24

PRG000_D760:
	JMP PRG000_D789	 ; Jump to PRG000_D789

PRG000_D763:

	; Object slot is dead/empty...

	TYA
	ADD Counter_7to0
	TAY		; Y = object slot + (0-7)

	LDX SprRamOffsets,Y	 ; X = Sprite_RAM offset

	LDY #$05	 ; Y = 5

	LDA <Temp_Var9
	CMP #$05	
	BLT PRG000_D776	 ; If Temp_Var9 < 5, jump to PRG000_D776

	LDY #$01	 ; Y = 1

PRG000_D776:
	STY <Temp_Var8	 ; Temp_Var8 = 5 or 1

	LDA Sprite_RAM+$00,X
	CMP #$f8
	BEQ PRG000_D789	 ; If this sprite Y is impossibly low (blank sprite), jump to PRG000_D789

	INX
	INX
	INX
	INX		 ; X += 4 (next sprite)

	DEY		 ; Y--
	BPL PRG000_D776	 ; While Y >= 0, loop!

	JMP PRG000_D752	 ; Jump to PRG000_D752

PRG000_D789:
	STX <Temp_Var7	 ; Temp_Var7 = offset to blank sprite

	TXA
	TAY		; Y = same offset

	PLA
	TAX		 ; Restore 'X'

	LDA <Temp_Var8	 ; A = 5 or 1

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_StealAdjSprite (SB)
;
; SMB3 standard dictates that each of the first five object slots 
; total maximum of 6 8x16 sprites.  This function is "mean", unlike 
; Object_GetRandNearUnusedSpr, since we're going to take sprites 
; from the other object slots.  In any case, careful consideration
; must be made not to interfere with actual intended objects etc.
;
; The index provided in the accumulator is taken as an additional
; offset to the in-context object's index.  So if provided with
; an input of zero, we are using the sprite offset base from the
; next object, e.g.:
;
; With object 2 in-context:
; With input 0, object 2 is given the offset to object 3's sprites.
; With input 1, object 2 is given the offset to object 4's sprites.
;
; This function will perform a modulus, meaning object 5 starts by
; taking object 0's sprites, etc.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Provides an effective modulus for sprite distribution
	;     0  1  2  3  4  
Object_Steal_IndexMod:	.byte 1, 2, 3, 4, 0, 1, 2, 3, 4

Object_StealAdjSprite:
	ADD <SlotIndexBackup
	TAY

Object_StealAdjSpriteY:
	; Now get the "next" object slot (Object_Steal_IndexMod provides a psuedo MOD 5)
	LDA Object_Steal_IndexMod,Y

	; Use the standard formula to find out what this object's Sprite_RAM offset would be
Object_StealAdjSprite_DS:	; Delfino Slot entry point, used as convenience...
	ADD Counter_7to0 	; Add current value of Counter_7to0
	TAY	
	LDA SprRamOffsets,Y
	TAY		; -> 'Y'
	
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DetermineHorzVis
; Object_DetermineHorzVisY
;
; Determines how many of each horizontal sprite of an object are
; invisible (off-screen), based on size of object
;
; X = index of on-screen object
; Y = width of object; 0-5 or 8, 16, 24, 32, 40, 48 respectively (Object_DetermineHorzVisY only)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Pixel width minus 8 of objects
Object_Widths:
	.byte  0	; 0
	.byte  8	; 1
	.byte 16	; 2
	.byte 24	; 3
	.byte 32	; 4
	.byte 40	; 5

	; Respective bit to set per width checked
Object_WidthFlags:
	.byte %10000000	; 0
	.byte %01000000	; 1
	.byte %00100000	; 2
	.byte %00010000	; 3
	.byte %00001000	; 4
	.byte %00000100	; 5

; $D79E
Object_DetermineHorzVis:
	LDY ObjGroupRel_Idx	 	; Y = object group relative index
	LDA ObjectGroup_Attributes,Y	; Get object's attributes
	AND #OA1_WIDTHMASK	 ; Keep only bits 4-6
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 ; shift right 4
	TAY		 ; Y = Width of object (0-5 or 0, 8, 16, 24, 32, or 40, -8)

Object_DetermineHorzVisY:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BGS PRG000_D7B8	 ; If this object's state >= OBJSTATE_NORMAL (not dead or initializing), jump to PRG000_D7B8

	; If object is dead/empty or initializing, mark all sprites as invisible
	LDA #%11111100
	STA Objects_SprHVis,X

	RTS		 ; Return

PRG000_D7B8:
	LDA #$00
	STA Objects_SprHVis,X	 ; Clear until determined

PRG000_D7BD:
	LDA <Objects_X,X
	ADD Object_Widths,Y
	STA <Temp_Var15		; Temp_Var15 = object's X + ??

	LDA <Objects_XHi,X
	ADC #$00	 
	STA <Temp_Var16		; Temp_Var16 = Object's X Hi with carry applied

	LDA <Temp_Var15
	CMP <Horz_Scroll
	LDA <Temp_Var16	
	SBC <Horz_Scroll_Hi
	BEQ PRG000_D7DE	 ; If sprite is not horizontally off-screen, jump to PRG000_D7DE

	; This sprite is off left/right of screen...
	LDA Objects_SprHVis,X	 ; Get appropriate invisibility bit
	ORA Object_WidthFlags,Y	 ; OR it
	STA Objects_SprHVis,X	 ; Store it

PRG000_D7DE:
	DEY		 ; Y--
	BPL PRG000_D7BD	 ; While Y >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_DetermineVertVis
; Object_DetermineVertVisY
;
; Determines how many of each vertical sprite of an object are
; invisible (off-screen), based on size of object
;
; X = index of on-screen object
; Y = height of object; 0-3 or 16, 32, 48, 64 respectively (Object_DetermineVertVisY only)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D7E2
Object_DetermineVertVis:
	LDY ObjGroupRel_Idx	 	; Y = object group relative index
	LDA ObjectGroup_Attributes,Y	; Get object's attributes
	AND #OA1_HEIGHTMASK	 ; keep only bits 2 and 3
	LSR A		 
	LSR A		 ; shift right 2
	TAY		 ; Y = size of object (0-3 or 16, 32, 48, 64)

Object_DetermineVertVisY:
	LDA #$01
	STA <Temp_Var3	 ; Temp_Var3 = 1

	LDA #$00
	STA Objects_SprVVis,X	 ; Clear until determined

	; Copy object's Y Hi/Lo -> Temp_Var1/2
	LDA <Objects_YHi,X
	STA <Temp_Var1	
	LDA <Objects_Y,X
	STA <Temp_Var2	

PRG000_D7FE:

	; Add 16 to copy of object's Y (bottom of this sprite)
	LDA <Temp_Var2
	ADD #16
	STA <Temp_Var2

	BCC PRG000_D809	 ; If no carry, jump to Objects_SprVVis

	INC <Temp_Var1		 ; Otherwise, apply carry

PRG000_D809:
	LDA <Temp_Var2		
	SUB Level_VertScroll
	STA <Temp_Var4		 ; Temp_Var4 = screen-relative Y

	LDA <Temp_Var1		
	SBC Level_VertScrollH	
	BNE PRG000_D81E	 ; If relative position is off-screen, jump to PRG000_D81E

	; Otherwise...
	LDA <Temp_Var4
	CMP #240
	BLT PRG000_D826	 ; If object sprite is higher than 240 (not off bottom of screen), jump to PRG000_D826

PRG000_D81E:

	; This sprite is off top/bottom of screen...
	LDA <Temp_Var3		 ; Get current set bit
	ORA Objects_SprVVis,X	 
	STA Objects_SprVVis,X	 ; Mark this part as invisible

PRG000_D826:
	ASL <Temp_Var3	 ; Temp_Var3 <<= 1
	DEY		 ; Y--
	BPL PRG000_D7FE	 ; While Y >= 0, loop!

PRG000_D82B:
	RTS		 ; Return

	; Defines the "bounding box" around the Player
	; Temp_Var1 - upper left of bounding box
	; Temp_Var2 - offset to right bounding box (width)
	; Temp_Var5 - top of bounding box
	; Temp_Var6 - offset to bottom bounding box (height)
Player_BoundBox:
	;    Left Right  Bot Top - offsets applied to sprite X/Y
	.byte 4,  8, 17, 13	; small/ducking
	.byte 3, 10,  5, 25	; otherwise

	; SB: New reverse gravity offsets
	.byte 4,  8,  0, 13	; small/ducking
	.byte 3, 10,  0, 25	; otherwise


PRG000_D834:
	.byte -8, 8
	


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Object_HitTest
; Object_HitTestRespond
;
; Tests if Player has collided with another object
; If using "Object_HitTestRespond", then if the Player has touched
; the object, it will call appropriate ObjectGroup_CollideJumpTable
; routine after a successful intersection.
;

; In any case, carry is set if there was a collision, or clear
; if the Player did not collide with the object!
;
; X is object's slot
; Y is group relative object index
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D836
Object_HitTest:
	LDA #$01	 ; Test only, do NOT perform "collide" routine
	BNE PRG000_D83D	 ; Jump to PRG000_D83D

; $D83B
Object_HitTestRespond:
	LDA #$00	; Test and do "collide" routine

PRG000_D83D:
	STA <Temp_Var16	 ; Temp_Var16 = 0 or 1, depending on entry point

	; Clear the Player hit status bits
	LDA Objects_PlayerHitStat,X
	AND #%11111100
	STA Objects_PlayerHitStat,X

	CLC	; Carry flag will be used as a result

	LDA <Player_IsDying	; If Player is dying...
	ORA Player_OffScreen	; ... off-screen ...
	;ORA Player_Behind_En	; ... or behind the scenes ...
	BNE PRG000_D82B	 	; ... jump to PRG000_D82B (RTS)

	; Advanced Player behind check to support behind-fence enemies
	LDA Objects_IsBehind,X	; Get if object is or isn't behind the scenes
	EOR Player_Behind_En	; Get if Player is or isn't behind the scenes
	BNE PRG000_D82B	 	; If mismatched, jump to PRG000_D82B (RTS)

	JSR Object_CalcBoundBox	; Calculate object's bounding box

	LDA <Player_Suit
	BEQ PRG000_D862	 ; If Player is small, jump to PRG000_D862

	LDA #$00	 ; A = 0 when small or ducking

	LDY Player_IsDucking	 
	BNE PRG000_D862	 ; If Player is ducking, jump to PRG000_D862

	LDA #$01	 ; A = 1 otherwise

PRG000_D862:

	; SB: If gravity is reversed, use new offsets
	LDY Player_ReverseGrav
	BEQ Player_BBox_NoRev

	; Use new offsets
	ADD #2

Player_BBox_NoRev:
	ASL A
	ASL A		 ; Multiply by 4
	TAY		 ; Y = 0 (small/ducking) or 4 (otherwise)

	; Calculate upper left of bounding box and lower right offsets of Player
	LDA <Player_SpriteX
	ADD Player_BoundBox,Y
	STA <Temp_Var3	

	LDA <Player_SpriteY
	ADD Player_BoundBox+2,Y
	STA <Temp_Var7	

	LDA Player_BoundBox+1,Y
	STA <Temp_Var4	

	LDA Player_BoundBox+3,Y
	STA <Temp_Var8	

	JSR ObjectObject_Intersect	; Returns carry SET if object and Player intersected
	BCC PRG000_D82B	 	; If carry clear, object and Player did not intersect, jump to PRG000_D82B (RTS)

	; Intersection occurred by 8-bit values that represent "screen relative" positions,
	; but this is not a complete check as Player or object may be at different "High/Low"
	; positions (full 16-bit coordinate check)

	STA <Temp_Var1		 ; Store Player's bounding box top offset -> Temp_Var1

	LDA Level_7Vertical
	BNE PRG000_D8B1	 ; If level is vertical, jump to PRG000_D8B1

	; Calculate full 16-bit X difference of object -> Temp_Var14/15
	LDA <Player_X
	SUB <Objects_X,X
	STA <Temp_Var15	

	LDA <Player_XHi
	SBC <Objects_XHi,X
	STA <Temp_Var14	

	BPL PRG000_D8A9	 ; If overall result is positive, jump to PRG000_D8A9

	; Otherwise, 16-bit negate Temp_Var14/15
	LDA <Temp_Var15
	JSR Negate	
	STA <Temp_Var15	

	LDA <Temp_Var14
	EOR #$ff	
	ADC #$00	
	STA <Temp_Var14	

PRG000_D8A9:

	LDA <Temp_Var14
	BNE PRG000_D920	 ; If Temp_Var14 is not zero, there's a difference in the "High" component of the Player/Object, so no intersect!  Jump to PRG000_D920

	LDA <Temp_Var15
	BMI PRG000_D920	 ; If Temp_Var15 is negative, no intersect, jump to PRG000_D920

PRG000_D8B1:

	; The above check is not needed on a vertical level...
	; no chance of being on horizontally different screens!

	; Calculate full 16-bit Y difference of object -> Temp_Var14/15
	LDA <Player_Y
	SUB <Objects_Y,X
	STA <Temp_Var15	

	LDA <Player_YHi	
	SBC <Objects_YHi,X
	STA <Temp_Var14	

	BPL PRG000_D8CF	 ; If overall result is positive, jump to PRG000_D8CF

	; Otherwise, 16-bit negate Temp_Var14/15
	LDA <Temp_Var15
	JSR Negate
	STA <Temp_Var15

	LDA <Temp_Var14
	EOR #$ff	
	ADC #$00	
	STA <Temp_Var14	

PRG000_D8CF:
	LDA <Temp_Var14
	BNE PRG000_D920	 ; If Temp_Var14 is not zero, there's a difference in the "High" component of the Player/Object, so no intersect!  Jump to PRG000_D920

	LDA <Temp_Var15
	BMI PRG000_D920	 ; If Temp_Var15 is negative, no intersect, jump to PRG000_D920

	; Temp_Var12 holds specific info:
	;	Bit 0 - Set if Player's bbox bottom is HIGHER than object's bbox bottom
	;	Bit 1 - Set if Player's bbox left edge is to the LEFT of object's bbox left edge

	LDA <Temp_Var12
	LSR A		
	BCC PRG000_D8EB	 ; If Player's bbox bottom is NOT higher than object's, jump to PRG000_D8EB

	LDA <Temp_Var1	 ; Get Player's bounding box top offset
	SUB <Temp_Var11	 ; Get vertical difference between Player and Object's bounding box bottoms
	CMP #$08	 
	BLS PRG000_D8EB	 ; If the result < 8, jump to PRG000_D8EB

	; Otherwise, flip the remaining bit of Temp_Var12
	LDA <Temp_Var12	
	EOR #$01
	STA <Temp_Var12	

PRG000_D8EB:

	; Set into status bits for this objcet
	LDA <Temp_Var12	
	ORA Objects_PlayerHitStat,X
	STA Objects_PlayerHitStat,X

	LDA Player_StarInv
	BEQ PRG000_D922	 ; If Player is NOT invincible, jump to PRG000_D922

	; Player is invincible...

	JSR Object_CalcAttrFlagOff	 ; Get object's ID -> Y
	LDA Object_AttrFlags,Y	 ; Get this object's attribute flags
	AND #OAT_HITNOTKILL	 
	BNE PRG000_D922	 	 ; If OAT_HITNOTKILL is set, jump to PRG000_D922

	; For all objects where bit 7 is not set in their attributes...

	LDA #OBJSTATE_KILLED
	STA Objects_State,X	 ; Set object state to Killed

	LDA #-$38	
	STA <Objects_YVel,X	 ; Set Y Velocity to -$38

	; "Kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; 100+ points pop up
	; SB: SMW tally up behavior!
	LDA Kill_Tally
	INC Kill_Tally
	ADD #$05
	JSR Score_PopUp

	JSR Level_ObjCalcXDiffs	 ; 'Y' is set to 0 if Player is to the right of object, 1 if to the left

	LDA PRG000_D834,Y
	STA <Objects_XVel,X	 ; Set X velocity

PRG000_D920:
	CLC		 ; Clear carry
	RTS		 ; Return


PRG000_D922:

	; For all objects where bit 7 is set in their attributes...

	LDA <Temp_Var16	 ; Returns 0 or 1, depending on original entry point
	BNE PRG000_D929	 ; If it was 1 (do not respond to hit), jump to PRG000_D929

	; Do hit routine
	JSR Object_DoCollision ; Otherwise...

PRG000_D929:
	SEC		 ; Set carry
	RTS		 ; Return


	; Calculates the upper-left and returns the lower-right offsets
	; of this object's bounding box...
	; Temp_Var1 - upper left of bounding box
	; Temp_Var2 - offset to right bounding box
	; Temp_Var5 - bottom of bounding box
	; Temp_Var6 - offset to top bounding box
; $D92F
Object_CalcBoundBox:
	; X is object's slot
	; Y is group relative object index

	JSR Object_CalcAttrFlagOff	 ; Get this object's ID -> Y
	LDA Object_AttrFlags,Y	 ; Get this object's attribute flags
	AND #OAT_BOUNDBOXMASK	; Mask off the bounding box
	ASL A		 
	ASL A		 ; Shift left 2
	TAY		 ; -> Y (selected bounding box for this object)

	; Calculate upper left of bounding box and lower right offsets
	LDA <Objects_SpriteX,X
	ADD Object_BoundBox,Y	
	STA <Temp_Var1		 ; Temp_Var1 object's sprite X with offset

	LDA <Objects_SpriteY,X
	ADD Object_BoundBox+2,Y	
	STA <Temp_Var5		 ; Temp_Var5 object's sprite Y with offset

	LDA Object_BoundBox+1,Y
	STA <Temp_Var2		 ; Temp_Var2 has the right offset

	LDA Object_BoundBox+3,Y	
	STA <Temp_Var6		 ; Temp_Var6 has the bottom offset

	RTS		 ; Return


	; Calculates the upper-left and returns the lower-right offsets
	; of this object's bounding box...
	; Temp_Var3 - upper left of bounding box
	; Temp_Var4 - offset to right bounding box
	; Temp_Var7 - bottom of bounding box
	; Temp_Var8 - offset to top bounding box
; $D955
Object_CalcBoundBox2:	; Same as Object_CalcBoundBox in spirit, just different outputs, used for object-to-object collision
	; X is object's slot
	; Y is group relative object index

	JSR Object_CalcAttrFlagOff	 ; Get this object's ID -> Y
	LDA Object_AttrFlags,Y	 ; Get this object's attribute flags
	AND #OAT_BOUNDBOXMASK	 ; Mask off the bounding box
	ASL A		 
	ASL A		 ; Shift left 2
	TAY		 ; -> Y (selected bounding box for this object)

	; Calculate upper left of bounding box and lower right offsets
	LDA <Objects_SpriteX,X
	ADD Object_BoundBox,Y	
	STA <Temp_Var3		 ; Temp_Var3 object's sprite X with offset

	LDA <Objects_SpriteY,X
	ADD Object_BoundBox+2,Y	
	STA <Temp_Var7		 ; Temp_Var7 object's sprite Y with offset

	LDA Object_BoundBox+1,Y
	STA <Temp_Var4		 ; Temp_Var4 has the right offset

	LDA Object_BoundBox+3,Y	
	STA <Temp_Var8		 ; Temp_Var8 has the bottom offset

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ObjectObject_Intersect
;
; Determines if the Player/Object and the OTHER Object indexed
; by 'X' have intersected according to the bounding box data
;
; X = index of on-screen object
;
; Returns carry SET if Player/Object and Object intersected
; Temp_Var12 holds specific info:
;	Bit 0 - Set if Player/Object's bbox bottom is HIGHER than 
;	        object's bbox bottom
;	Bit 1 - Set if Player/Object's bbox left edge is to the LEFT of
;	        object's bbox left edge
;
; Note that this is performed by the "sprite" (or screen-relative)
; positions of the Player/Object and the OTHER Object, and may not 
; be accurate (because it's not a full 16-bit coordinate check) and 
; more logic is needed after this to determine completely if there 
; should be an actual collision.  See use of ObjectObject_Intersect 
; to get an idea what else needs to be done...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $D97B
ObjectObject_Intersect:
	LDY #$00	 ; Y = 0
	STY <Temp_Var12	 ; Temp_Var12 = 0 (Player's bbox is to the RIGHT of the object's left edge, until determined otherwise)


	; Right now we're considering the left edges of the Player and Object
	; we're detecting against

	LDA <Temp_Var3		 ; Left of Player's bounding box
	SUB <Temp_Var1		 ; Left of object's bound box
	STA <Temp_Var11		 ; Difference between the two -> Temp_Var11

	ASL A			 ; Sets carry if it was a negative result
 
	LDA <Temp_Var2		 ; Get the object's right edge bounding box offset

	BCC PRG000_D997	 	 ; If the calculated difference was NOT negative (Player's bbox left edge is to the RIGHT of object's bbox left edge), jump to PRG000_D997

	; Player's box left edge is to the LEFT of the object's left edge

	; Negate Temp_Var11 (the difference), making it positive
	LDA <Temp_Var11
	EOR #$ff
	STA <Temp_Var11		 
	INC <Temp_Var11	

	INC <Temp_Var12		 ; Temp_Var12 = 1 (Player's bbox is to the LEFT of object's left edge)

	LDA <Temp_Var4		 ; Get the Player's right edge bounding box offset

PRG000_D997:
	CMP <Temp_Var11
	BLT PRG000_D9B7	 	 ; If the left edge offset is less than the right edge offset (CARRY CLEAR), jump to PRG000_D9B7 (RTS)


	; That didn't happen...

	ASL <Temp_Var12		 ; Push result bit up

	LDA <Temp_Var7		 ; Player's bounding box bottom
	SUB <Temp_Var5		 ; Object's bouncing box bottom
	STA <Temp_Var11		 ; Store difference -> Temp_Var11

	ASL A		 	 ; Sets carry if it was a negative result

	LDA <Temp_Var6		 ; Get object's bounding box top edge offset

	BCC PRG000_D9B5	 	 ; If the calculated difference was NOT negative (Player's bbox bottom is LOWER than object's bbox bottom), jump to PRG000_D9B5

	; Negate Temp_Var11 (the difference), making it positive
	LDA <Temp_Var11
	EOR #$ff	
	STA <Temp_Var11	
	INC <Temp_Var11	

	INC <Temp_Var12		 ; Set bit 0 of Temp_Var12

	LDA <Temp_Var8		 ; Get Player's bounding box top edge offset

PRG000_D9B5:
	CMP <Temp_Var11		 ; Set final carry bit to determine if we intersected or not

PRG000_D9B7:

	; Most importantly, status of the carry flag is returned
	; If carry is CLEAR, we did not intersect Player to Object

	; Temp_Var12 holds specific info:
	;	Bit 0 - Set if Player's bbox bottom is HIGHER than object's bbox bottom
	;	Bit 1 - Set if Player's bbox left edge is to the LEFT of object's bbox left edge

	RTS		 ; Return


	; Proper Collision routine for this object
; $D9BB
Object_DoCollision:
	LDX <SlotIndexBackup	; X = the current object slot

	LDA ObjGroupRel_Idx	; Get the object's group relative index
	ASL A		 	; Shift left 1 (2 byte index)
	TAY		 	; -> Y

	; Get address from ObjectGroup_CollideJumpTable...
	LDA ObjectGroup_CollideJumpTable,Y
	STA <Temp_Var1	
	LDA ObjectGroup_CollideJumpTable+1,Y
	STA <Temp_Var2	
	JMP [Temp_Var1]	 ; Jump to the acquired address!


; $D9D3
Player_GetHurt:
	; If Player is...
	LDA Player_FlashInv		; ... flashing invincible ...
	ORA Player_Statue		; ... a statue ...
	ORA Player_StarInv		; ... invincible by star ...
	ORA Player_SuitLost		; ... just lost a power-up suit ...
	ORA <Player_HaltGame		; ... gameplay halted ...
	ORA Player_HaltTick		; ... Player halted ...
	ORA Player_DebugNoHitFlag	; ... debug invincibility flag is set (unused) ...
	ORA Player_EndLevel
	BNE PRG000_D9B7	 ; ... then jump to PRG000_D9B7 (RTS)

	LDA Player_Kuribo
	BNE PRG000_DA32	 ; If Player is in Kuribo's shoe, jump to PRG000_DA32

	LDA <Player_Suit
	CMP #PLAYERSUIT_FIRE		; SB: Change this to "PLAYERSUIT_SUPERSUITBEGIN" and you restore Japanese version's "always shrink" code!!
	BLS PRG000_DA4E	 ; If Player is Big or small, jump to PRG000_DA4E

	; Higher level power-up suits...
	LDA <Player_Suit
	STA <Player_OldSuit
	LDA #$30
	STA Player_Grow

	; Play Power up lost sound
	LDA Sound_QLevel1
	ORA #SND_PLAYERPIPE
	STA Sound_QPlayer

	LDA #$02	; Return to Big (SB: Would be small in Japanese version!!)
	JMP PRG000_DA44	 ; Jump to PRG000_DA44

PRG000_DA32:
	TAY		; Yoshi index -> 'Y'
	DEY		; Index correction
	
	; Need to verify we didn't just get hit by our tounge caught enemy, because that'd be silly
	LDA Objects_Var6,Y
	BMI YoshiHit_NoTounge

	; Is this the tounge hit?
	CMP <SlotIndexBackup
	BNE YoshiHit_NoTounge
	
	; Don't get hurt by tounged object!
	RTS

YoshiHit_NoTounge:
	; Play "shoe lost" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELSHOE
	STA Sound_QLevel1

	LDX Player_Kuribo
	DEX
		
	; Set Yoshi to panic init state
	LDA #3
	STA <Objects_Var4,X
	
	LDX <SlotIndexBackup
	
	JMP PRG000_DA47	 ; Jump to PRG000_DA47

PRG000_DA44:
	STA Player_QueueSuit	 ; Queue power-up change

PRG000_DA47:
	LDA #$00	 
	STA Player_Kuribo	 ; Player no longer has Kuribo's shoe (if he even did a moment ago)
	BEQ PRG000_DA6D	 ; Jump (technically always) to PRG000_DA6D

PRG000_DA4E:

	; Player is only big or small...

	LDA <Player_Suit
	BEQ PRG000_DA7A	 ; If Player is small, jump to PRG000_DA7A (gonna die!!)

	LDA #$02
	STA Player_QueueSuit	 ; Return to Big

	; Play shrinking sound!!
	LDA Sound_QPlayer
	ORA #SND_PLAYERPIPE
	STA Sound_QPlayer

	LDA #$2f	
	STA Player_Grow	 	; Player_Grow = $2f (shrinking!)
	DEC Player_QueueSuit	; Get small!

PRG000_DA6D: 
	LDA #$71
	STA Player_FlashInv	 ; Player_FlashInv = $71

	LDA #$00
	STA Player_Flip	 ; Player not somersaulting

	BEQ PRG000_DAAE	 ; Jump (technically always) to PRG000_DAAE (cosmetic bugfix?)

	RTS		 ; Return

PRG000_DA7A:
	LDX <SlotIndexBackup	 ; X = SlotIndexBackup


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Die
;
; Simple and to the point: Starts the death song,
; resets a bunch of variables that get in the way,
; changes to small, etc.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Die:
	; Queue death song
	LDA Sound_QMusic1
	ORA #MUS1_PLAYERDEATH
	STA Sound_QMusic1

	; Clear a bunch of stuff at time of death
	LDA #$00
	STA <Player_XVel
	STA Player_Flip	
	STA Player_FlashInv
	STA Player_Kuribo
	STA Player_StarInv
	STA Player_Statue
	STA Level_PSwitchCnt

	LDA #$01
	STA Player_QueueSuit	 ; Queue change to "small"

	LDA #-64
	STA <Player_YVel ; Player_YVel = -64

	LDA #$30	 
	STA Event_Countdown ; Event_Countdown = $30 (ticks until dropped back to map)

	TXA
	PHA
	
	LDX Player_Current
	LDA Player_Lives,X
	BNE Die_NotGameover

	LDA #$04
	STA <Player_IsDying	 ; Player_IsDying = 4
	
	; Used for GAME OVER raise-up
	LDA #$FF
	STA <Pipe_PlayerX
	STA <Pipe_PlayerY

	LDA #MUS1_GAMEOVER
	STA Sound_QMusic1
	
	PLA
	TAX
	
	JMP PRG000_DAAE

Die_NotGameover:
	PLA
	TAX

	LDA #$01
	STA <Player_IsDying	 ; Player_IsDying = 1

PRG000_DAAE:
	; Ensure Player_FlipBits is correct?
	; SB: May be a cosmetic bugfix for player coming out of a somersault
	; (see jump to PRG000_DAAE) and getting hit, but I'm not really sure...
	LDA <Player_FlipBits
	AND #$7f
	STA <Player_FlipBits

	RTS		 ; Return


	; X velocities as appropriate based on which direction 
	; Player was when he killed the enemy
EnemyKill_XVels:	.byte -$08, $08

	; Tail attack X offset, based on Player's facing direction
Player_TailAttackXOff:	.byte $11, -$0A


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_HitByTailOrBouncer
;
; Test if object is getting hit by Player's tail attack
; or a left/right bouncing block
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_HitByTailOrBouncer:
	; Clear the "Tail Attacked" bit
	LDA Objects_PlayerHitStat,X
	AND #%11110111
	STA Objects_PlayerHitStat,X

	JSR Object_RespondToTailAttack	; Get hit by tail attack if appropriate

	; Handle a left/right bouncer if it impacts an object
	LDA LRBounce_Y
	CMP #$ff
	BEQ PRG000_DB16	 ; If LRBounce_Y = $FF, jump to PRG000_DB16 (RTS)
	STA <Temp_Var7	 ; Temp_Var7 = LRBounce_Y

	LDA #$0f
	STA <Temp_Var8	 ; Temp_Var8 = $0F

	LDA LRBounce_X
	STA <Temp_Var3	 ; Temp_Var3 = LRBounce_X

	LDA #$0f
	STA <Temp_Var4	 ; Temp_Var4 = $0F

	JSR Player_TailAttackDo	; Perform tail attack type action

PRG000_DB16:
	RTS		 ; Return


PRG000_DB17:	.byte $10, -$10


Object_RespondToTailAttack:
	LDA Player_TailAttack
	BEQ PRG000_DB16	 ; If Player is not tail attacking, jump to PRG000_DB16 (RTS)

	; Tail attack only kicks at counter values $09 and $0C
	CMP #$0c
	BEQ PRG000_DB26	 ; If tail attack counter = $0C, jump to PRG000_DB26
	CMP #$09
	BNE PRG000_DB16	 ; If tail attack counter <> $09, jump to PRG000_DB16 (RTS)

PRG000_DB26:
	LDA <Player_FlipBits
	AND #$40
	TAY		 ; Y = $00 or $40, whether Player is flipped
	BEQ PRG000_DB2F	 ; If 'Y' = 0, jump to PRG000_DB2F

	LDY #$01	 ; Y = 1

PRG000_DB2F:
	LDA Player_TailAttackXOff,Y
	ADD <Player_SpriteX
	STA <Temp_Var3	 ; Temp_Var3 = appropriate X offset for tail attack

	LDA #$0a
	STA <Temp_Var4	 ; Temp_Var4 = $0A

	LDA <Player_SpriteY
	ADD #$10
	STA <Temp_Var7	 ; Temp_Var7 = tail attack offset

	LDA #$0f
	STA <Temp_Var8	 ; Temp_Var8 = $0F

Player_TailAttackDo:
	LDY Objects_State,X	; Y = object's current state

	LDA Obj2Obj_EnByState,Y
	BNE PRG000_DB16	 ; If object is not hit tested in this state, jump to PRG000_DB16 (RTS)

	JSR Object_AnySprOffscreen
	BNE PRG000_DB16	 ; If any sprite of the object is off-screen, jump to PRG000_DB16 (RTS)

	JSR Object_CalcBoundBox
	JSR ObjectObject_Intersect
	BCC PRG000_DB16	 ; If Player and object are not intersecting, jump to PRG000_DB16 (RTS)

	; Set "Tail Attacked" bit
	LDA Objects_PlayerHitStat,X
	ORA #%00001000
	STA Objects_PlayerHitStat,X

	LDY ObjGroupRel_Idx	 ; Y = object's group-relative index

	LDA ObjectGroup_Attributes3,Y
	AND #OA3_TAILATKIMMUNE
	BNE PRG000_DB16	 ; If OA3_TAILATKIMMUNE is SET (Object cannot be tail-attacked), jump to PRG000_DB16 (RTS)

	LDA <Temp_Var4
	CMP #$0f
	BEQ Enemy_Kill

	LDY #$00	 ; Y = 0

	LDA <Player_FlipBits
	BEQ PRG000_DB7A	 ; If Player is not turned around, jump to PRG000_DB7A

	INY		 ; Y = 1

PRG000_DB7A:

	; Set ShellKillFlash vars
	LDA PRG000_DB17,Y
	ADD <Player_X	
	STA ShellKillFlash_X

	LDA <Player_Y
	ADD #$10
	STA ShellKillFlash_Y

	LDA #$0a
	STA ShellKillFlash_Cnt


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Enemy_Kill
;
; Kills an enemy; flips them over, plays the "kick" sound
; If attribute 3, bit 6 is SET, there's some special
; behavior described below (using CollideJumpTable as a
; value rather than address, alternate dead state 3, etc.)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Enemy_Kill:

	; Set timer 2 to 12
	LDA #12
	STA Objects_Timer2,X

	; "Kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	LDY ObjGroupRel_Idx	 	; Y = object group relative index
	LDA ObjectGroup_Attributes3,Y	; Get this object's attribute set 3
	AND #OA3_DIESHELLED
	BNE PRG000_DBB6	 		; If OA3_DIESHELLED is set, jump to PRG000_DBB6

	; OA3_DIESHELLED is not set...

	LDA Player_Slide
	BNE PRG000_DBB2	 	; If Player is sliding, jump to PRG000_DBB2

	LDA Kill_Tally	 	; Get current kill tally
	JSR Score_Get100PlusPts	; Get appropriate score based on kill tally

PRG000_DBB2:
	LDA #$06	 ; A = 6 (object state 6, killed)
	BNE PRG000_DBCF	 ; Jump (technically always) to PRG000_DBCF


PRG000_DBB6:

	; Attribute set 3 bit 6 is set...

	; Y *= 2 (2 byte index)
	TYA	
	ASL A	
	TAY	

	LDA ObjectGroup_CollideJumpTable+1,Y	; Get upper byte of collision jump entry
	AND #%11111000
	CMP #%00001000	; If only bit 3 is set and 4-7 are clear, this is a new object ID to change to
	BNE PRG000_DBC8	 ; If the above is not the case, jump to PRG000_DBC8

	; SPECIAL CASE: Collide Jump table lower byte specifies a new object ID

	LDA ObjectGroup_CollideJumpTable,Y 	; Get the new ID
	STA Level_ObjectID,X			; Set the new ID

PRG000_DBC8:
	; Timer 3 set to $FF
	LDA #$ff
	STA Objects_Timer3,X

	LDA #OBJSTATE_SHELLED	 ; A = Shelled

PRG000_DBCF:
	STA Objects_State,X	 ; Set new object state

	LDA #-$30	 ; A = -$30

	LDY <Temp_Var4

	CPY #$0f	
	BEQ PRG000_DBDC	 ; If Temp_Var4 = $0F, jump to PRG000_DBDC

	LDA #-$50	 ; A = -$50

PRG000_DBDC:
	STA <Objects_YVel,X	 ; Set Y velocity appropriately

	; Set appropriate X Velocity based on facing direction of 
	; Player when he killed the enemy
	JSR Level_ObjCalcXDiffs
	LDA EnemyKill_XVels,Y
	STA <Objects_XVel,X

	; Set vertical flip on the object
	LDA Objects_FlipBits,X
	ORA #SPR_VFLIP

	STA Objects_FlipBits,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ObjectToObject_HitTest
;

; Determines if the object specified in 'X' has collided
; with any of the other active objects not including
; Player (see Object_HitTest/Object_HitTestRespond)
;
; If the object has collided with another object:
;  Carry flag is SET
;  'Y' = index of the collided-with object 
;  'A' = ObjectID of the collided-with object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Enable object-to-object by state (0 = Enabled, 1 = Disabled)
Obj2Obj_EnByState:
	.byte $01	; State 0: Dead/Empty
	.byte $01	; State 1: Initializing
	.byte $00	; State 2: Normal
	.byte $00	; State 3: Shelled
	.byte $00	; State 4: Held
	.byte $00	; State 5: Kicked
	.byte $01	; State 6: Killed
	.byte $01	; State 7: Squashed
	.byte $01	; State 8: Dying

	; $DBF8
ObjectToObject_HitTest:
	LDA Objects_SprVVis,X
	BNE PRG000_DC54	 ; If any sprites are vertically off-screen, jump to PRG000_DC54

	; No sprites are vertically off-screen...

	LDA Objects_SprHVis,X
	AND #%11000000
	CMP #%11000000
	BEQ PRG000_DC54	 ; If both of the end sprite are horizontally off-screen, jump to PRG000_DC54

	JSR Object_CalcBoundBox2	; Calculate THIS object's bounding box

PRG000_DC09:
	LDX #$04	 ; X = 4
PRG000_DC0B:
	CPX <SlotIndexBackup
	BEQ PRG000_DC51	 ; If this object slot is the current object, jump to PRG000_DC51 (don't do anything to self)

	LDY Objects_State,X
	LDA Obj2Obj_EnByState,Y
	BNE PRG000_DC51	 ; If the state this object is in does not do object-to-object detection, jump to PRG000_DC51 (do nothing)

	LDA Objects_SprVVis,X
	BNE PRG000_DC51	 ; If sprites are vertically off-screen, jump to PRG000_DC51 (do nothing)

	LDA Objects_SprHVis,X
	AND #%11000000	
	CMP #%11000000	
	BEQ PRG000_DC51	 ; If two sprites are horizontally off-screen, jump to PRG000_DC51 (do nothing)

	JSR Object_CalcBoundBox	 ; Calculate OTHER object's bounding box
	JSR ObjectObject_Intersect	 ; Returns carry SET if object and OTHER object intersected
	BCC PRG000_DC51	 	; If object did NOT intersect the OTHER object, jump to PRG000_DC51 (do nothing)

	; These two objects have collided...!

	LDY <SlotIndexBackup	 ; Y = object slot index

	LDA <Objects_X,X
	SUB Objects_X,Y		; Difference between the object and the OTHER object's X
	PHA		 	; Save the difference

	LDA <Objects_XHi,X
	SBC Objects_XHi,Y	 ; Difference between the object and the OTHER object's X Hi
	STA <Temp_Var1		 ; -> Temp_Var1

	PLA		 ; Restore the lower X difference

	; Don't quite understand the logic, but this determines if the 
	; objects are actually on the same screen instead of just
	; seeming to due to the low accuracy of sprite coordinates
	ADC #$80	
	LDA <Temp_Var1	
	ADC #$00	
	BNE PRG000_DC51	 ; If the objects did not actually collide, jump to PRG000_DC51 (do nothing)

	JSR Object_CalcAttrFlagOff	 ; Y = OTHER object's ID

	SEC		 ; Object's collided!  Set carry!

	LDA Object_AttrFlags,Y
	AND #OAT_HITNOTKILL
	BEQ PRG000_DC57	 ; If this object is NOT a "Hit-Not-Kill" type, jump to PRG000_DC57

	; Object is OAT_HITNOTKILL...
	LDA Obj2Obj_FlagNoHitChk
	BEQ PRG000_DC51		; If the Obj2Obj_FlagNoHitChk flag is NOT set, jump to PRG000_DC51
	
	; We're allowing a bypass!
	SEC				; Set carry again (collision occurred, override)
	BCS PRG000_DC57	; Jump (technically always) to PRG000_DC57

PRG000_DC51:
	DEX		 ; X--
	BPL PRG000_DC0B	 ; While X >= 0, loop!

PRG000_DC54:
	CLC		 ; Clear carry (collided with no other object)
	BCC PRG000_DC5C	 ; Jump (technically always) to PRG000_DC5C

PRG000_DC57:
	TXA		 
	TAY		 ; Index of the OTHER object that this object collided with -> 'Y'
	LDA Level_ObjectID,Y	 ; A = the ID of the OTHER object

PRG000_DC5C:
	LDX <SlotIndexBackup	 ; Restore 'X' as the object slot index
	RTS		 ; Return



	; This changes a tile based on Temp_Var13-16 coordinates:
	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo
Level_ChangeTile_ByTempVars:

	PHA		 ; Save 'A'
	LDA Level_7Vertical
	BEQ PRG000_DC7B	 ; If level is NOT vertical, jump to PRG000_DC7B

	LDY <Temp_Var13
	LDA <Temp_Var14
	JSR LevelJct_GetVScreenH	; Adjust coordinates for vertical

	PHA		 ; Save 'A' (Y Lo)

	; Set tile grid modify address
	LDA Tile_Mem_AddrVL,Y
	STA <Temp_Var1	
	LDA Tile_Mem_AddrVH,Y
	STA <Temp_Var2	

	PLA		 ; Restore 'A' (Y Lo)

	JMP PRG000_DC91	 ; Jump to PRG000_DC91

PRG000_DC7B:
	LDA <Temp_Var15
	ASL A		
	TAY		 ; Y = Temp_Var15 (X Hi) shifted left 1 (2 bytes index per screen for Tile_Mem_Addr)

	; Set tile grid modify address
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1	
	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var2

	LDA <Temp_Var13	
	BEQ PRG000_DC8F	 ; If Y Hi = 0, jump to PRG000_DC8F

	INC <Temp_Var2	 ; Otherwise, offset to lower screen area

PRG000_DC8F:
	LDA <Temp_Var14	 ; A = Y lo

PRG000_DC91:
	AND #$f0
	STA <Temp_Var3	; Tile aligned "low" (makes row)

	LDA <Temp_Var16
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ORA <Temp_Var3	; Makes column

	TAY		 ; Y = offset to specific tile

	PLA		 ; Restore 'A' (tile index)

	STA [Temp_Var1],Y ; Change tile as appropriate

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_CalcCoarseXDiff
;
; Calculates a "coarse" X difference with the Player,
; returning a one byte value that determines the
; difference in X/XHi coordinates in units of 4 pixels
; in Temp_Var15.  Temp_Var16 is set to $40 and the
; carry flag is set if the difference was negative.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DCA2 
Object_CalcCoarseXDiff:
	LDA <Objects_X,X	 
	SUB <Player_X	
	STA <Temp_Var15		; Temp_Var15 = difference between Object and Player X

	LDA <Objects_XHi,X
	SBC <Player_XHi		; Calc diff between X His

	LSR A			; Push low bit of "hi" difference -> carry
	ROR <Temp_Var15		; Cycle carry into Temp_Var15 at high bit; will be discarding low bit
	LSR A			; Push low bit of "hi" difference -> carry
	ROR <Temp_Var15		; Cycle carry into Temp_Var15 at high bit; will be discarding low bit

	; Temp_Var15 now holds a difference between the Object and Player
	;  X coordinates in units of 4 pixels (works up to two screen
	; widths; anything greater and object was probably removed anyway)

	; Note the following only works because there is no way that bit 5 and 7
	; could be a part of the actual difference, just the sign factor, since
	; a level cannot be more than 10 screens in width.
	ASL A			; Shift remaining difference left 1; carry set means negative difference
	AND #$40
	STA <Temp_Var16		; Temp_Var16 being $40 also means negative difference

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_CalcCoarseYDiff
;
; Calculates a "coarse" Y difference with the Player,
; returning a one byte value that determines the
; difference in Y/YHi coordinates in units of 8 pixels.
; Returns Temp_Var15 in the format of a crude signed
; value for Y Hi in bit 6 and 7 
; [00 -> Y Hi = 0, 01 -> Y Hi = 1, 11 -> Y Hi = negative]
; and the base Y difference in the bits 0 - 5 (so units 
; of 8 pixels.)
; Temp_Var16 holds the raw difference in "Y Hi"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DCB9
Object_CalcCoarseYDiff
	LDA <Objects_Y,X
	SUB <Player_Y	
	STA <Temp_Var15		 ; Temp_Var15 = difference between object's Y and Player's Y

	LDA <Objects_YHi,X
	SBC <Player_YHi	
	STA <Temp_Var16		 ; Temp_Var16 = difference between object's Y Hi and Player's Y Hi

	LSR A		 	; least significant bit of Y Hi -> carry

	ROR <Temp_Var15		; Temp_Var15 takes on the "Hi" value in its most significant bit

	LSR A			; next least significant bit of Y Hi -> carry

	ROR <Temp_Var15		; The new Temp_Var15's least significant bit is pushed into its bit 7

	; So now Temp_Var15 holds the main Y difference in its first 5 bits
	; Bit 6 and 7 form a signed portion of the "hi" value -- 00 -> Y Hi = 0, 01 -> Y Hi = 1, 11 -> Y Hi = negative

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_ApplyYVel
; Object_ApplyYVel_NoLimit
;
; Adds the 4.4FP Y velocity to object and prevents object
; from falling faster than OBJECT_MAXFALL (unless using
; Object_ApplyYVel_NoLimit which does not enforce this)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DCCD
Object_ApplyYVel:
	LDA <Objects_YVel,X	 
	BMI Object_ApplyYVel_NoLimit	 ; If Object's Y Vel < 0 (moving upward), jump to Object_ApplyYVel_NoLimit

	CMP #OBJECT_MAXFALL	 
	BLS Object_ApplyYVel_NoLimit	 ; If Object's Y Vel < OBJECT_MAXFALL, jump to Object_ApplyYVel_NoLimit

	LDA #OBJECT_MAXFALL	 
	STA <Objects_YVel,X	 ; Cap Y Velocity to OBJECT_MAXFALL

; $DCD9
Object_ApplyYVel_NoLimit:
	TXA		 
	ADD #(Objects_YVel - Objects_XVel)
	TAX		 ; Offset to Y velocities

	LDY #(Objects_YVel - Objects_XVel)	; SB: For offsetting Object_[X/Y]VelCarry

	LDA Objects_ReverseGrav - (Objects_YVel - Objects_XVel),X
	BEQ Object_ApplyYVel_NoRev	; If this object is not under reverse gravity, jump to Object_ApplyYVel_NoRev

	; Object has reversed gravity...
	JSR Object_AddVelFrac_Rev	 ; Apply the reversed velocity to the object's position
	JMP Object_ApplyYVel_Done	; Jump to Object_ApplyYVel_Done

Object_ApplyYVel_NoRev:
	JSR Object_AddVelFrac	 ; Apply the velocity to the object's position
	STA Object_YVelCarry	 ; Set to '1' if fractional part rolled over

Object_ApplyYVel_Done:
	LDX <SlotIndexBackup	 ; Restore X as Object slot index

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_ApplyXVel
;
; Adds the 4.4FP X velocity to object and will disable
; X Hi's application if the object wants it that way..
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DCE4
Object_ApplyXVel:
	LDY #0	; SB: For offsetting Object_[X/Y]VelCarry
	JSR Object_AddVelFrac
	STA Object_XVelCarry	 ; Set to '1' if fractional part rolled over

	LDY Level_7Vertical
	BEQ PRG000_DCFA	 ; If Level is NOT vertical, jump to PRG000_DCFA

	; Non-vertical levels...

	PHA		 ; Save rollover value

	LDY ObjGroupRel_Idx	; Get object's relative index
	LDA ObjectGroup_Attributes2,Y	 ; Get object's 2nd attribute
	AND #OA2_USE16BITX	 	 
	BNE PRG000_DCF9	 	; If OA2_USE16BITX is set, jump to PRG000_DCF9

	STA <Objects_XHi,X	; Otherwise, Object's X Hi is zeroed

PRG000_DCF9:
	PLA		 ; Restore rollover value

PRG000_DCFA:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_AddVelFrac
;
; Adds the 4.4FP velocity to X or Y of object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_AddVelFrac_Rev:	; SB: For reverse gravity
	LDA <Objects_XVel,X	; Get (Y) Velocity
	PHA			; Save it
	JSR Negate		; Negate 
	STA <Objects_XVel,X	; Set reversed (Y) Velocity

	JSR Object_AddVelFrac	; Add velocity in reverse
	STA Object_YVelCarry	; Set to '1' if fractional part rolled over (SB: Assuming 'Y' because this is reverse gravity, reverse on Y axis)

	PLA			; Restore prior velocity
	STA <Objects_XVel,X	; Get (Y) Velocity
	RTS

Object_AddVelFrac:
	LDA <Objects_XVel,X	; Get Velocity
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 	; Fractional part shifted up
	ADD Objects_XVelFrac,X	 
	STA Objects_XVelFrac,X	; Add to object's vel fractional accumulator

	PHP		 ; Save CPU state
	PHP		 ; Save CPU state

	LDY #$00	 ; Y = 0 (positive high part)

	LDA <Objects_XVel,X	; Get Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 ; Whole part shifted down (integer)
	CMP #%00001000	 ; Check the sign bit
	BLT PRG000_DD19	 ; If the value was not negatively signed, jump to PRG000_DD19
	ORA #%11110000	 ; Otherwise, apply a sign extension
	DEY		 ; Y = $FF (negative high part)
PRG000_DD19:
	PLP		 ; Restore CPU state

	PHA		 ; Save integer of velocity

	ADC <Objects_X,X 
	STA <Objects_X,X ; Add with carry

	TYA		 ; A = $00 or $FF as appropriate

	ADC <Objects_XHi,X
	STA <Objects_XHi,X ; Add to the high part

	PLA		 ; Restore integer of Velocity

	PLP		 ; Restore CPU state

	ADC #$00
	
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_ObjCalcXDiffs
;
; For a given object slot in 'X'...
; Returns: Temp_Var16 as pixel difference between Player and object X coordinates

; 	   And 'Y' is set to 0 if Player is to the right of object, 1 if to the left
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DD2C
Level_ObjCalcXDiffs:
	LDA <Player_X
	SUB <Objects_X,X
	STA <Temp_Var16	 ; Temp_Var16 = difference between Player's X and object's X

	LDY #$00	 ; Y = 0
	LDA <Player_XHi	 
	SBC <Objects_XHi,X
	BPL PRG000_DD3C	 ; If Player's X Hi >= Object's X Hi, jump to PRG000_DD3C (RTS)

	INY		 ; Otherwise Y = 1

PRG000_DD3C:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_ObjCalcYDiffs
;
; For a given object slot in 'X'...
; Returns: Temp_Var16 as pixel difference between Player and object Y coordinates
; 	   And 'Y' is set to 0 if Player is lower than object, 1 if higher
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DD3D
Level_ObjCalcYDiffs:
	LDA <Player_Y
	SUB <Objects_Y,X
	STA <Temp_Var16		 ; Temp_Var16 = difference between Player's Y and object's Y

	LDY #$00	 ; Y = 0
	LDA <Player_YHi	
	SBC <Objects_YHi,X
	BPL PRG000_DD4D	 ; If Player's Y Hi >= Object's Y Hi, jump to PRG000_DD4D (RTS)

	INY		 ; Ohterwise Y = 1

PRG000_DD4D:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Negate
;
; "NEG" is not REALLY an opcode of its own
; This makes it a subroutine, though...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DD4E
Negate:
	NEG
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_AnySprOffscreen
;
; Returns non-zero if any flags are set on Objects_SprHVis or Objects_SprVVis
; (i.e. if any sprites are off-screen)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $DD54
Object_AnySprOffscreen:
	LDA Objects_SprHVis,X
	ORA Objects_SprVVis,X
	RTS		 ; Return


	; Initializes a "block bump" effect, if one of the 2 slots is open...
BlockBump_Init:
	LDY #$00	 ; Y = 0
	LDA Level_BlkBump,Y
	BEQ PRG000_DDB2	 ; If block bump slot 1 is empty, jump to PRG000_DDB2

	INY		 ; Y = 1
	LDA Level_BlkBump,Y	 
	BNE PRG000_DDCB	 ; If block bump slot 2 is not empty, jump to PRG000_DDCB (RTS)

PRG000_DDB2:
	LDA <Temp_Var12	
	STA Level_BlkBump,Y	 ; Store tile-behind effect

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	LDA <Temp_Var15	
	STA Level_BlkBump_XHi,Y

	LDA <Temp_Var16
	STA Level_BlkBump_XLo,Y

	LDA <Temp_Var13
	STA Level_BlkBump_YHi,Y

	LDA <Temp_Var14
	STA Level_BlkBump_YLo,Y

PRG000_DDCB:
	RTS		 ; Return


	

AScrlURDiag_HandleWrap:
	LDA AScrlURDiag_WrapState
	STA AScrlURDiag_WrapState_Copy	 ; AScrlURDiag_WrapState_Copy = AScrlURDiag_WrapState
	JSR AScrlURDiag_NoWrapAbort	; Will not return here if AScrlURDiag_WrapState_Copy not set or gameplay halted!

	LDY #$00	 ; Y = 0
 
	LDA Level_AScrlVVelCarry
	LSR A		
	BCC PRG000_DE53	 ; If Level_AScrlVVelCarry = 0, jump to PRG000_DE53

	INY		 ; Y = 1
	DEC Level_ScrollDiffH	 ; Level_ScrollDiffH--

PRG000_DE53:
	LDA Level_ScrollDiffH
	STA AScrlURDiag_OffsetX	 ; AScrlURDiag_OffsetX = Level_ScrollDiffH

	STY Level_ScrollDiffH	; Level_ScrollDiffH = 0 or 1

	ADD <Player_X
	STA <Player_X	 ; Player_X += Level_ScrollDiffH
	BCC PRG000_DE65	 ; If no carry, jump to PRG000_DE65

	INC <Player_XHi	 ; Otherwise, apply carry

PRG000_DE65:
	LDY #$00	 ; Y = 0

	LDA Level_AScrlVVelCarry
	LSR A		
	BCC PRG000_DE71	 ; If no autoscroll vertical velocity carry, jump to PRG000_DE71

	DEY		 ; Y = -1
	INC Level_ScrollDiffV

PRG000_DE71:
	LDA Level_ScrollDiffV
	STA AScrlURDiag_OffsetY	 ; AScrlURDiag_OffsetY = Level_ScrollDiffV

	STY Level_ScrollDiffV	 ; Level_ScrollDiffV = 0 or -1

	LDY <Player_InAir
	BEQ PRG000_DE89	 ; If Player is not mid air, jump to PRG000_DE89

	LDY #$00	 ; Y = 0

	ADD Level_ScrollDiffV	 ; Level_ScrollDiffV is 0 or -1 right now
	CMP #$ff
	BNE PRG000_DE89
	DEY		 ; Y = -1 

PRG000_DE89:
	ADD <Player_Y
	STA <Player_Y
	TYA		
	ADC <Player_YHi	
	STA <Player_YHi	

	RTS		 ; Return

AScrlURDiag_CheckWrapping:
	JSR AScrlURDiag_NoWrapAbort	 ; Will not return here if AScrlURDiag_WrapState_Copy is not set or gameplay halted!

	LDA <Objects_X,X
	ADD AScrlURDiag_OffsetX	
	STA <Objects_X,X
	BCC PRG000_DEA3	 ; If no carry, jump to PRG000_DEA3
	INC <Objects_XHi,X	 ; Otherwise, apply carry
PRG000_DEA3:

	LDA <Objects_Y,X
	ADD AScrlURDiag_OffsetY	
	STA <Objects_Y,X
	BCC PRG000_DEAF	 ; If no carry, jump to PRG000_DEAF
	INC <Objects_YHi,X	 ; Otherwise, apply carry 

PRG000_DEAF:
	RTS		 ; Return


AScrlURDiag_NoWrapAbort:
	LDA AScrlURDiag_WrapState_Copy
	BEQ PRG000_DEB9	 ; If diagonal autoscroller is not wrapping, jump to PRG000_DEB9

	LDA <Player_HaltGame
	BEQ PRG000_DEBB	 ; If gameplay is not halted, jump to PRG000_DEBB (RTS)

PRG000_DEB9:
	; If NOT AScrlURDiag_WrapState_Copy or if gameplay is halted, do not return to caller!!
	PLA
	PLA		 ; Pull return address

PRG000_DEBB:
	RTS		 ; Return


ObjState_Frozen:

	; Finish up on bank 30 (not enough room here :( )
	JMP_THUNKC 30, ObjState_Frozen30

