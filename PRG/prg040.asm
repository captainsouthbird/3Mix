; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: PRG036.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------


Tile_Layout_TS5:
	; This defines the individual 8x8 blocks used to construct one of the tiles
	; Referenced by Address_Per_Tileset, addressed by Level_Tileset
	; Stored by upper left, then lower left, then upper right, then lower right

	; Remember that palette is determined by the upper 2 bits of a TILE (not the PATTERN)
	; I.e. tiles starting at index $00, $40, $80, $C0 are each on that respective palette

	; Upper left 8x8 pattern per tile
	.byte $FC, $DC, $2C, $05, $05, $E8, $2E, $FC, $FC, $38, $05, $2D, $2D, $23, $05, $05 ; Tiles $00 - $0F
	.byte $00, $02, $04, $06, $20, $22, $24, $26, $40, $42, $44, $46, $60, $62, $64, $66 ; Tiles $10 - $1F
	.byte $07, $FD, $FD, $FD, $FD, $12, $12, $FF, $FF, $FF, $FF, $FF, $D0, $D0, $B8, $B8 ; Tiles $20 - $2F
	.byte $B8, $B8, $BC, $94, $B0, $B1, $FD, $FD, $12, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DC, $05, $7C, $7E, $05, $05, $05, $5A, $05, $05, $05, $0C, $2E, $05, $6F, $64 ; Tiles $40 - $4F
	.byte $05, $F4, $F4, $F4, $58, $14, $14, $0D, $24, $FE, $4F, $4F, $6C, $6E, $04, $D8 ; Tiles $50 - $5F
	.byte $98, $98, $98, $98, $98, $98, $92, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4 ; Tiles $60 - $6F
	.byte $B4, $B8, $98, $98, $98, $98, $A4, $EC, $E4, $C0, $D5, $B2, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $05, $14, $2E, $FC, $FE, $C4, $4A, $4E, $3A, $05, $05, $FD, $7A, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $88, $FE, $00, $49, $4E, $04, $4E, $49, $68, $6A, $72, $72 ; Tiles $90 - $9F
	.byte $60, $AE, $62, $AE, $8C, $4A, $8E, $9C, $6A, $9E, $AC, $FE, $AE, $8C, $8E, $8C ; Tiles $A0 - $AF
	.byte $8E, $8C, $8E, $8C, $8E, $52, $52, $50, $40, $42, $AC, $AE, $B8, $8C, $8E, $52 ; Tiles $B0 - $BF
	.byte $18, $1C, $30, $34, $34, $36, $26, $46, $54, $56, $56, $28, $62, $6A, $6A, $20 ; Tiles $C0 - $CF
	.byte $3C, $40, $41, $12, $2C, $3A, $05, $05, $12, $2C, $3A, $2C, $C5, $C7, $FE, $FE ; Tiles $D0 - $DF
	.byte $AA, $AB, $3A, $3A, $3A, $38, $38, $38, $05, $05, $38, $04, $10, $52, $53, $52 ; Tiles $E0 - $EF
	.byte $53, $D7, $E0, $05, $63, $0A, $28, $2A, $FF, $FF, $FF, $FF, $FF, $FF, $F8, $FF ; Tiles $F0 - $FF

	; Lower left 8x8 pattern per tile
	.byte $FC, $DD, $3C, $06, $D6, $E9, $3E, $38, $FC, $FC, $0E, $06, $06, $06, $48, $4A ; Tiles $00 - $0F
	.byte $10, $12, $14, $16, $30, $32, $34, $36, $50, $52, $54, $56, $70, $72, $74, $76 ; Tiles $10 - $1F
	.byte $07, $FD, $16, $FD, $5A, $22, $13, $FF, $FF, $FF, $FF, $FF, $D1, $D1, $B9, $B9 ; Tiles $20 - $2F
	.byte $B9, $B9, $BD, $95, $B1, $B0, $16, $5A, $13, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DD, $06, $7E, $7F, $06, $06, $06, $5B, $49, $6C, $6C, $0E, $0E, $6D, $06, $65 ; Tiles $40 - $4F
	.byte $06, $F5, $F5, $F5, $48, $15, $15, $FE, $34, $48, $13, $13, $7C, $7E, $14, $D9 ; Tiles $50 - $5F
	.byte $99, $99, $99, $99, $99, $99, $93, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5 ; Tiles $60 - $6F
	.byte $B5, $B9, $99, $99, $99, $99, $A5, $ED, $E4, $C1, $B2, $B2, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $06, $15, $0E, $FC, $FE, $C4, $4E, $4E, $28, $61, $60, $FD, $FD, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $89, $FE, $01, $59, $04, $04, $04, $59, $71, $71, $6C, $6E ; Tiles $90 - $9F
	.byte $61, $AE, $63, $AE, $58, $FE, $78, $AC, $FE, $AE, $AC, $FE, $AE, $9C, $9E, $9C ; Tiles $A0 - $AF
	.byte $9E, $9C, $9E, $9C, $9E, $53, $53, $51, $41, $43, $AC, $AE, $B9, $9C, $9E, $53 ; Tiles $B0 - $BF
	.byte $1A, $1E, $32, $34, $36, $36, $24, $44, $54, $54, $56, $2A, $60, $68, $68, $22 ; Tiles $C0 - $CF
	.byte $3E, $42, $43, $13, $2D, $3B, $06, $E6, $13, $2D, $3B, $3B, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $39, $2D, $39, $06, $06, $39, $39, $39, $39, $50, $51, $52, $51, $04 ; Tiles $E0 - $EF
	.byte $10, $06, $E1, $06, $18, $1A, $38, $3A, $FF, $FF, $FF, $FF, $FF, $FF, $F9, $FF ; Tiles $F0 - $FF

	; Upper right 8x8 pattern per tile	
	.byte $FC, $DE, $2D, $07, $07, $EA, $2F, $FC, $38, $FC, $06, $2E, $21, $2E, $07, $07 ; Tiles $00 - $0F
	.byte $01, $03, $05, $07, $21, $23, $25, $27, $41, $43, $45, $47, $61, $63, $65, $67 ; Tiles $10 - $1F
	.byte $07, $FD, $27, $10, $10, $FD, $FD, $FF, $FF, $FF, $FF, $FF, $D2, $D2, $BA, $BA ; Tiles $20 - $2F
	.byte $BA, $BA, $BE, $96, $B0, $B1, $27, $10, $FD, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DE, $07, $7D, $66, $07, $07, $07, $07, $07, $07, $07, $0D, $2F, $6D, $08, $07 ; Tiles $40 - $4F
	.byte $65, $F6, $F6, $F6, $59, $15, $15, $0E, $FE, $27, $4F, $4F, $6D, $6F, $68, $DA ; Tiles $50 - $5F
	.byte $9A, $9A, $9A, $9A, $9A, $9A, $CA, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6 ; Tiles $60 - $6F
	.byte $B6, $BA, $9A, $9A, $9A, $9A, $A6, $EE, $E5, $C2, $D5, $B2, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $07, $15, $2F, $FC, $FE, $C6, $4B, $4F, $18, $07, $60, $FD, $07, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $8A, $FE, $02, $49, $4F, $0D, $4F, $48, $69, $6B, $72, $72 ; Tiles $90 - $9F
	.byte $AD, $64, $AD, $66, $49, $4B, $8F, $69, $6B, $9F, $AD, $7B, $AF, $8D, $8F, $8D ; Tiles $A0 - $AF
	.byte $8F, $8D, $8F, $8D, $8F, $72, $72, $70, $40, $42, $AD, $AF, $BA, $8D, $8F, $72 ; Tiles $B0 - $BF
	.byte $19, $1D, $31, $35, $35, $37, $27, $47, $55, $57, $57, $29, $63, $6B, $6A, $21 ; Tiles $C0 - $CF
	.byte $3D, $41, $41, $13, $2D, $3B, $07, $07, $13, $2D, $3B, $2D, $C7, $D4, $FE, $FE ; Tiles $D0 - $DF
	.byte $AA, $AB, $3B, $3B, $3B, $39, $39, $39, $07, $39, $07, $09, $11, $53, $52, $53 ; Tiles $E0 - $EF
	.byte $52, $D7, $E2, $07, $09, $0B, $29, $2B, $FF, $FF, $FF, $FF, $FF, $FF, $FA, $FF ; Tiles $F0 - $FF

	; Lower right 8x8 pattern per tile
	.byte $FC, $DF, $3D, $08, $D6, $EB, $3F, $FC, $FC, $38, $0F, $08, $08, $08, $49, $4B ; Tiles $00 - $0F
	.byte $11, $13, $15, $17, $31, $33, $35, $37, $51, $53, $55, $57, $71, $73, $75, $77 ; Tiles $10 - $1F
	.byte $07, $FD, $17, $20, $11, $FD, $59, $FF, $FF, $FF, $FF, $FF, $D3, $D3, $BB, $BB ; Tiles $20 - $2F
	.byte $BB, $BB, $BF, $97, $B1, $B0, $17, $11, $59, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DF, $08, $66, $67, $08, $08, $08, $08, $6C, $6C, $6E, $0F, $0F, $6F, $09, $64 ; Tiles $40 - $4F
	.byte $08, $F7, $F7, $F7, $48, $14, $14, $27, $48, $37, $5F, $5F, $7D, $7F, $15, $DB ; Tiles $50 - $5F
	.byte $9B, $9B, $9B, $9B, $9B, $9B, $CB, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7 ; Tiles $60 - $6F
	.byte $B7, $BB, $9B, $9B, $9B, $9B, $A7, $EF, $E5, $C3, $B2, $B2, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $08, $14, $0F, $FC, $FE, $C6, $4F, $4F, $28, $62, $FD, $FD, $7A, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $8B, $FE, $03, $59, $0D, $0D, $0D, $58, $71, $71, $6D, $6F ; Tiles $90 - $9F
	.byte $AD, $65, $AD, $67, $59, $5B, $79, $AD, $7B, $AF, $AD, $7B, $AF, $9D, $9F, $9D ; Tiles $A0 - $AF
	.byte $9F, $9D, $9F, $9D, $9F, $73, $73, $71, $41, $43, $AD, $AF, $BB, $9D, $9F, $73 ; Tiles $B0 - $BF
	.byte $1B, $1F, $33, $35, $37, $37, $25, $45, $55, $55, $57, $2B, $61, $69, $68, $23 ; Tiles $C0 - $CF
	.byte $3F, $43, $43, $12, $12, $2C, $3A, $E7, $2C, $3A, $05, $3A, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $3A, $2C, $3B, $08, $38, $08, $38, $38, $38, $51, $50, $51, $52, $09 ; Tiles $E0 - $EF
	.byte $11, $08, $E3, $08, $19, $1B, $39, $3B, $FF, $FF, $FF, $FF, $FF, $FF, $FB, $FF ; Tiles $F0 - $FF

Tile_Attributes_TS5:
	.byte $21, $54, $96, $F1, $2E, $55, $96, $F1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS5
;
; Entry point for loading level layout data for Level_Tileset = 5
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS5:
	LDY #00

PRG036_A40A:
	LDA #TILE5_SKY 	; Clear everything to sky
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$f0
	BNE PRG036_A40A

	LDA #15
	STA <Temp_Var10

GhoseHouseBG_AllScreens:
	LDA <Temp_Var10
	TAY
	JSR LoadLevel_GhostHouseBG

	DEC <Temp_Var10
	BPL GhoseHouseBG_AllScreens

	JMP LevelLoad	; Begin actual level loading!



GHBG_LanternWoodArray:
	.byte $80, $80, $80, $80, $80, $E5, $80, $CA, $80, $E5, $CA, $80, $80, $80, $80, $80
	.byte $80, $80, $80, $80, $80, $E8, $E9, $C9, $E9, $EA, $C9, $E9, $EA, $80, $80, $80
	.byte $80, $80, $80, $80, $80, $E4, $E3, $C8, $E4, $E3, $C8, $E3, $E4, $80, $80, $80
	.byte $80, $80, $E9, $EA, $D5, $D4, $D3, $C7, $D3, $D3, $C7, $D8, $D9, $DA, $80, $80
	.byte $CE, $CE, $CE, $CE, $CD, $CC, $CB, $C6, $CF, $CF, $C6, $CF, $D0, $D1, $D2, $D2
	.byte $E8, $EA, $80, $D6, $D5, $D4, $D3, $C0, $D3, $D3, $C0, $D3, $D8, $D9, $DA, $80	; Lanterns
	.byte $CE, $CE, $CE, $CE, $CD, $CC, $CB, $C1, $CF, $CF, $C1, $CF, $D0, $D1, $D2, $D2
	.byte $80, $80, $E6, $E7, $D5, $D4, $D3, $C2, $D3, $D3, $C2, $D8, $D9, $DA, $80, $80
	.byte $EB, $EC, $80, $EB, $EC, $E2, $DB, $C3, $E2, $DB, $C3, $DB, $E2, $EB, $EC, $80
	.byte $ED, $EE, $E8, $ED, $EE, $E5, $E6, $C4, $E6, $E7, $C4, $E6, $E7, $ED, $EE, $80
	.byte $EF, $F0, $80, $EF, $F0, $E8, $80, $C5, $80, $E8, $C5, $80, $80, $EF, $F0, $80
GHBG_LanternWoodArray_End

GHBG_WallTiles:
	.byte TILE5_BGLBWOOD5, TILE5_BGLBWOOD5, TILE5_BGLBWOOD3, TILE5_BGLRWOOD4
GHBG_WallTiles_End

LoadLevel_GhostHouseBG:

	TYA
	ASL A
	TAY

	; Set default address at lantern row
	LDA Tile_Mem_Addr,Y
	STA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA Tile_Mem_Addr+1,Y
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	; Initial offset
	LDY #(16*11)

	LDX #0

GHBG_LoadLanternBG_NextRow:
	; Column counter
	LDA #15
	STA <Temp_Var3

GHBG_LoadLanternBG:

	; Get and store next tile
	LDA GHBG_LanternWoodArray,X
	STA [Map_Tile_AddrL],Y

	; Next tile/column
	INX
	INY

	; We've exhausted this row; are we done?
	CPX #(GHBG_LanternWoodArray_End - GHBG_LanternWoodArray)
	BEQ GHBG_Done	; If 'X' is at the end of the array, we're done!

	; Decrement Temp_Var3; if still positive, loop!  (Continue this row)
	DEC <Temp_Var3
	BPL GHBG_LoadLanternBG

	; Return to beginning of row
	DEY
	TYA
	AND #$F0
	TAY

	; Go to next row
	JSR LoadLevel_TileMemNextRow

	JMP GHBG_LoadLanternBG_NextRow

	; Around we go...	
GHBG_Done:

	; Now to add the background wall
	; GHBG_WallTiles

	; Starting on the lower part
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	ADD #1
	STA <Map_Tile_AddrH

	; Down below the windows
	LDY #(16*7)

	; For all tiles in the GHBG_WallTiles set...
	LDX #(GHBG_WallTiles_End - GHBG_WallTiles - 1)

GHBG_WallLoop:
	LDA GHBG_WallTiles,X
	STA [Map_Tile_AddrL],Y

	INY	; Next column

	TYA
	AND #$0F	; If the lower 4 bits of 'Y' are zero, we've reached a new row
	BNE GHBG_WallLoop	; If we haven't reached a new row, loop!

	DEX	; X-- (next wall tile)
	BPL GHBG_WallLoop	; If wall tiles to go, loop!

	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Generator_TS5
;
; Based on the values in Temp_Var15 and LL_ShapeDef, chooses an
; appropriate generator function to builds this piece of the
; level.  Tedious, but saves space and is paper-design friendly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG036_A42A:
	.byte 0, 15, 30, 45, 60, 75, 90, 105

LoadLevel_Generator_TS5:
	; From level loader function:
	; * Temp_Var15, Temp_Var16, and LL_ShapeDef are three bytes read from the data


	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = upper 3 bits of Temp_Var15 (0-7) (selects a multiple of 15 as the base)

	LDA LL_ShapeDef
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = upper 4 bits of LL_ShapeDef shifted down
	ADD PRG036_A42A,X	; Add multiple of 15
	TAX
	DEX
	TXA		 ; A = ((LL_ShapeDef >> 4) + PRG015_A419[X]) - 1


	; PRG036_A42A provides values well in excess of 51, but only 51
	; addresses are defined here; reserved for expansion...

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_Banister		;  0 - Banister
	.word LoadLevel_Post			;  1 - Long posts that extend beneath floor
	.word LoadLevel_StairRight		;  2 - Stairway going up to the right
	.word LoadLevel_StairLeft		;  3 - Stairway going up to the left
	.word LoadLevel_GhostFloor		;  4 - Ghost House Floor
	.word LoadLevel_GhostBrick		;  5 - Ghost House Wall/etc brick pattern
	.word LoadLevel_Diamond40		;  6 - Diamond rectangle 
	.word LoadLevel_ActionSwitch		; 7 - Action Switch
	.word LoadLevel_PipeRaiseHelper1	; 8 - Pipe Raise Helper 1
	.word LoadLevel_PipeRaiseHelper2	; 9 - Pipe Raise Helper 2
	.word LoadLevel_PipeRaiseHelper3	; 10 - Pipe Raise Helper 3
	.word LoadLevel_PipeRaiseHelper4	; 11 - Pipe Raise Helper 4
	.word $0000				; 12 - 
	.word $0000				; 13 - 
	.word $0000				; 14 - 
	.word LoadLevel_BlockRun		; 15 - Run of bricks
	.word LoadLevel_BlockRun		; 16 - Run of '?' blocks with a coin
	.word LoadLevel_BlockRun		; 17 - Run of bricks with a coin
	.word LoadLevel_BlockRun		; 18 - Run of wood blocks
	.word LoadLevel_BlockRun		; 19 - Run of green note blocks (?)
	.word LoadLevel_BlockRun		; 20 - Run of note blocks
	.word LoadLevel_BlockRun		; 21 - Run of bouncing wood blocks
	.word LoadLevel_BlockRun		; 22 - Run of coins
	.word LoadLevel_VGroundPipeRun		; 23 - Vertical ground pipe 1 (alt level)
	.word LoadLevel_VGroundPipeRun		; 24 - Vertical ground pipe 2 (Big [?] area)
	.word LoadLevel_VGroundPipeRun		; 25 - Vertical ground pipe 3 (no entrance)
	.word LoadLevel_VCeilingPipeRun		; 26 - Vertical ceiling pipe 1 (alt level)
	.word LoadLevel_VCeilingPipeRun		; 27 - Vertical ceiling pipe 2 (no entrance)
	.word LoadLevel_HRightWallPipeRun	; 28 - Horizontal right-hand wall pipe (alt level)
	.word LoadLevel_HRightWallPipeRun	; 29 - Horizontal right-hand wall pipe (no entrance)
	.word LoadLevel_HLeftWallPipeRun	; 30 - Horizontal left-hand wall pipe (alt level)
	.word LoadLevel_HLeftWallPipeRun	; 31 - Horizontal left-hand wall pipe (no entrance)
	.word LoadLevel_Cannon			; 32 - Bullet bill cannon
	.word LoadLevel_CCBridge		; 33 - Cheep-Cheep style 'oo' bridge
	.word LoadLevel_CCBridge		; 34 - Would result in empty tiles?  (form of 33)
	.word LoadLevel_TopDecoBlocks		; 35 - Top-Deco Rectangle Waterfall
	.word LoadLevel_TopDecoBlocks		; 36 - Top-Deco Rectangle Left waving water pool
	.word LoadLevel_TopDecoBlocks		; 37 - Top-Deco Rectangle No current waving water pool
	.word LoadLevel_TopDecoBlocks		; 38 - Top-Deco Rectangle Right waving water pool
	.word LoadLevel_TopDecoBlocks		; 39 - Top-Deco Rectangle Water wrong-way BG
	.word LoadLevel_TopDecoBlocks		; 40 - Top-Deco Rectangle Diamond blocks (not really any deco on top)
	.word LoadLevel_TopDecoBlocks		; 41 - Top-Deco Rectangle Sand ground 
	.word LoadLevel_TopDecoBlocks		; 42 - Top-Deco Rectangle orange block??
	.word $0000		; 43 - UNUSED
	.word LoadLevel_VTransitPipeRun		; 44 - Vertical in-level transit pipe
	.word $0000				; 45 - 
	.word $0000				; 46 - 
	.word $0000				; 47 - 
	.word $0000				; 48 - 
	.word LoadLevel_VGroundPipe5Run		; 49 - Vertical ground pipe 5 (exits to common end area)
	.word LoadLevel_HRightWallPipeRun3	; 50 - Horizontal right-hand wall pipe 3 (no entrance)
	.word LoadLevel_Lava			; 51 - Lava?  Not used in these modes I don't think... (it's green in Tileset 5/13!)
	.word LoadLevel_PurpleCoins		; 52 - Run of Purple coins
	.word LoadLevel_PurpleCoinR		; 53 - Rectangle of Purple Coins


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LeveLoad_FixedSizeGen_TS5
;
; Much simpler generators that are fixed-size, commonly used for 
; just single tile placement styles (although a couple relatively 
; complex ones exist in here as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LeveLoad_FixedSizeGen_TS5:
	; It is verified before calling this function that all of
	; the upper 4 bits of LL_ShapeDef are ZERO

	; So the upper 3 bits of Temp_Var15 serve as the most significant bits
	; to a value where LL_ShapeDef provide the 4 least significant bits

	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	ADD LL_ShapeDef	
	TAX		 	; Resultant index is put into 'X'
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_GhostHouseExit		;  0 - Generic Ghost House exit pre-fab
	.word LoadLevel_BigBoo				;  1 - Puts in the Big Boo tiles!
	.word $0000				;  2 - 
	.word $0000				;  3 - 
	.word LoadLevel_GhostDoor		;  4 - Ghost House door
	.word $0000				;  5 - 
	.word $0000				;  6 - 
	.word $0000				;  7 - 
	.word LoadLevel_StarCoin1		;  8 - Star Coin 1
	.word LoadLevel_StarCoin2		;  9 - Star Coin 2
	.word LoadLevel_StarCoin3		; 10 - Star Coin 3
	.word $0000				; 11 - 
	.word $0000				; 12 - 
	.word $0000				; 13 - 
	.word $0000				; 14 - 
	.word $0000				; 15 - 
	.word LoadLevel_PowerBlock		; 16 - ? block with flower
	.word LoadLevel_PowerBlock		; 17 - ? block with leaf 
	.word LoadLevel_PowerBlock		; 18 - ? block with star
	.word LoadLevel_PowerBlock		; 19 - ? block with coin OR star
	.word LoadLevel_PowerBlock		; 20 - ? block with coin (??)
	.word LoadLevel_PowerBlock		; 21 - Muncher Plant!
	.word LoadLevel_PowerBlock		; 22 - Brick with flower
	.word LoadLevel_PowerBlock		; 23 - Brick with leaf
	.word LoadLevel_PowerBlock		; 24 - Brick with star
	.word LoadLevel_PowerBlock		; 25 - Brick with coin OR star
	.word LoadLevel_PowerBlock		; 26 - Brick with 10-coin
	.word LoadLevel_PowerBlock		; 27 - Brick with 1-up
	.word LoadLevel_PowerBlock		; 28 - Brick with vine
	.word LoadLevel_PowerBlock		; 29 - Brick with P-Switch
	.word LoadLevel_PowerBlock		; 30 - Invisible coin
	.word LoadLevel_PowerBlock		; 31 - Invisible 1-up
	.word LoadLevel_PowerBlock		; 32 - Invisible note
	.word LoadLevel_PowerBlock		; 33 - Note block with flower
	.word LoadLevel_PowerBlock		; 34 - Note block with leaf
	.word LoadLevel_PowerBlock		; 35 - Note block with star
	.word LoadLevel_PowerBlock		; 36 - Wood block with flower
	.word LoadLevel_PowerBlock		; 37 - Wood block with leaf
	.word LoadLevel_PowerBlock		; 38 - Wood block with star
	.word LoadLevel_PowerBlock		; 39 - Invisible note to coin heaven
	.word LoadLevel_PowerBlock		; 40 - P-Switch
	.word LoadLevel_EndGoal			; 41 - The end goal


	; Goes to next row and updates backup variable Temp_Var2
LL36_ReturnTileAndNextRow:
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2	; Update Map_Tile_AddrH backup

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Banister
;
; Puts down 1-16 width of a Ghost House banister
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Banister:
	LDA LL_ShapeDef	
	AND #$0f	
	STA <Temp_Var3	; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)
	PHA		; Save it

	; Backup Map_Tile_AddrL/H -> Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDY TileAddr_Off ; Y = TileAddr_Off

	; Top of banister first
	LDA #TILE5_BANISTERL	 ; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column...

Banister_Loop:
	LDA #TILE5_BANISTERM	 ; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column...

	LDA #TILE5_BANISTERM	 ; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column...

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL Banister_Loop 	; While Temp_Var3 >= 0, loop!

	; End of top of banister
	LDA #TILE5_BANISTERR	 ; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column...

	; Restore width -> Temp_Var3
	PLA
	ADD #1		; +1 to take in banister beginning/end
	STA <Temp_Var3

	; Next row (bottom of banister)
	JSR LL36_ReturnTileAndNextRow

Banister_Loop2:
	; Add banister poles every other tile
	JSR LoadLevel_NextColumn ; Next column...

	LDA #TILE5_BANPOLE	 ; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column...

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL Banister_Loop2 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Post
;
; Puts down 1-16 height of a Ghost House post
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Post:
	LDA LL_ShapeDef	
	AND #$0f	
	STA <Temp_Var3	; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off ; Y = TileAddr_Off

	; Top of post first
	LDA #TILE5_POSTTOP
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_TileMemNextRow	; Next row...

GhostHousePost_Loop:
	; Add banister poles every other tile
	LDA #TILE5_POSTMID	 ; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_TileMemNextRow	; Next row...

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL GhostHousePost_Loop	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_StairRight
;
; Puts down 1-16 run of a Ghost House stairway to the right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_StairRight:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$00
	STA <Temp_Var3	; Temp_Var3 = 0 (only add STAIRR2 after initial)

	LDA LL_ShapeDef	 

	AND #$0f	 
	STA <Temp_Var4	 ; Temp_Var4 = lower 4 bits of LL_ShapeDef (diagonal length of stairway)


PRG036_D4DB:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 

	LDA #TILE5_STAIRR1	 ; Get stair tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG036_D4EF	 	; Jump to PRG036_D4EF

PRG036_D4EA:
	LDA #TILE5_STAIRR2	 ; Get stairway backing tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG036_D4EF:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5--
	BPL PRG036_D4EA	 	 ; While Temp_Var5 >= 0, loop!

	LDA #1
	STA <Temp_Var3		 ; Temp_Var3 = 1 (one stair 2)


	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 15 to tile offset (we're always one column too far..)
	LDA TileAddr_Off
	ADD #15
	TAY		 
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	TYA
	AND #$0f
	CMP #$0f	
	BNE PRG036_D534	 	; If we haven't wrapped the screen, jump to PRG036_D534

	; Move back one screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0	
	STA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	SBC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	; Jump to the right side
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

PRG036_D534:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	DEC <Temp_Var4		 ; Temp_Var4-- (diagonal length decrement)
	BPL PRG036_D4DB	 	; While Temp_Var4 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_StairLeft
;
; Puts down 1-16 run of a Ghost House stairway to the left
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_StairLeft:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$00
	STA <Temp_Var3	; Temp_Var3 = 0 (only add STAIRL2 after initial)

	LDA LL_ShapeDef	 

	AND #$0f	 
	STA <Temp_Var4	 ; Temp_Var4 = lower 4 bits of LL_ShapeDef (diagonal length of stairway)

PRG036_D482:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 
	BEQ PRG036_D497	 	; If Temp_Var3 is zero, we skip the middle ground addition

PRG036_D48B:
	LDA <Temp_Var5
	CMP #2
	BGE StairL2NotYet

	LDA #TILE5_STAIRL2	 ; Get stairway backing tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

StairL2NotYet:
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG036_D48B	 	 ; While Temp_Var5 > 0, loop! 

PRG036_D497:

	LDA #TILE5_STAIRL1	 ; Stairway tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	INC <Temp_Var3		 ; Temp_Var3++ (one more midground behind the stairway)
	DEC <Temp_Var4		 ; Temp_Var4-- (diagonal length decrement)
	BPL PRG036_D482	 	; While Temp_Var4 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GhostFloor
;
; Puts down 1-255 tiles worth of Ghost House floor.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_GhostFloor:
	LDY #$00	 ; Y = 0

	LDA [Level_LayPtr_AddrL],Y
	STA <Temp_Var3		 ; Get next byte from layout -> Temp_Var3 (width of run)

	; Level_LayPtr_Addr += 1
	LDA <Level_LayPtr_AddrL
	ADD #$01	 
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	LDY TileAddr_Off	; Y = TileAddr_Off

GhostHouse_FloorLoop:
	LDA #TILE5_FLOOR	 ; Get floor tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Go to next column

	DEC <Temp_Var3		 ; Temp_Var3--
	BNE GhostHouse_FloorLoop	 	 ; While Temp_Var5 <> 0, loop!


	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Diamond40
;
; Adds a rectangle (width 1-256 / height 1-16) of Diamond blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Diamond40:
	LDX #1
	BNE LLGB_Cont	; Jump (technically always) to LLGB_Cont

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GhostBrick
;
; Adds a rectangle (width 1-256 / height 1-16) of Ghost House brick
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_GhostBrick_Tile: .byte TILE5_BRICK, TILE5_DIAMOND

LoadLevel_GhostBrick:
	LDX #0		; Brick
	
LLGB_Cont:
	LDY #$00	 ; Y = 0

	LDA [Level_LayPtr_AddrL],Y
	STA <Temp_Var3		; Get next byte from layout -> Temp_Var3 (width of run)

	; Level_LayPtr_Addr += 1
	LDA <Level_LayPtr_AddrL
	ADD #$01	 
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	
	AND #$0f	
	STA <Temp_Var4	; Temp_Var4 = lower 4 bits of LL_ShapeDef (height of run)

	LDY TileAddr_Off	; Y = TileAddr_Off

GhostHouse_WallRowLoop:
	LDA <Temp_Var3
	STA <Temp_Var5		; Width of run -> Temp_Var5

GhostHouse_WallWidthLoop:
	LDA LL_GhostBrick_Tile,X	 ; Get brick tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Go to next column

	DEC <Temp_Var5		 ; Temp_Var5--
	BNE GhostHouse_WallWidthLoop	 	 ; While Temp_Var5 <> 0, loop!

	JSR LL36_ReturnTileAndNextRow	; Next row / return column

	DEC <Temp_Var4
	BPL GhostHouse_WallRowLoop	; While Temp_Var4 >= 0, loop!


PRG036_D398:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GhostDoor
;
; Uses both style door tiles to make a Ghost House special door
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_GhostDoor:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA #TILEA_DOOR1	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Move to next row by adding 16 to tile offset
	TYA		 
	ADD #16
	TAY		 
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA #TILEA_DOOR2	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GhostExit
;
; Pre-fab house exit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GHExitBG_HouseArray:
	.byte $81, $81, $82, $81, $81, $82
	.byte $EB, $EC, $82, $EB, $EC, $82
	.byte $ED, $EE, $82, $ED, $EE, $82
	.byte $EF, $F0, $82, $EF, $F0, $82
	.byte $CF, $CF, $CF, $CF, $CF, $82
	.byte $81, $81, $81, $81, $81, $82
	.byte $81, $EB, $EC, $81, $81, $82
	.byte $81, $EF, $F0, $81, $81, $82
	.byte $81, $83, $83, $81, $81, $82
	.byte $81, $83, $83, $81, $81, $82
	.byte $81, $83, $83, $81, $81, $82
GHExitBG_HouseArray_End:


LoadLevel_GhostHouseExit:

	; Ghost house exit only places at left edge where it belongs
	LDA Tile_Mem_Addr
	STA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA Tile_Mem_Addr+1
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	; Initial offset
	LDY #(16*15)

	LDX #0

GHEX_HouseExitBG_NextRow:
	; Column counter
	LDA #15
	STA <Temp_Var3

GHEX_HouseExitBG:

	LDA <Temp_Var3
	CMP #10
	BGE GHEX_FromArray

	; For column >= 6, use TILE5_EXITSKY tile
	LDA #TILE5_EXITSKY
	BNE GHEX_PutTile

GHEX_FromArray:

	; Get tile from array otherwise
	LDA GHExitBG_HouseArray,X
	INX

GHEX_PutTile:
	STA [Map_Tile_AddrL],Y

	; Next column
	INY

	; Decrement Temp_Var3; if still positive, loop!  (Continue this row)
	DEC <Temp_Var3
	BPL GHEX_HouseExitBG

	; We've exhausted this row; are we done?
	CPX #(GHExitBG_HouseArray_End - GHExitBG_HouseArray)
	BEQ GHEX_Done	; If 'X' is at the end of the array, we're done!

	; Return to beginning of row
	DEY
	TYA
	AND #$F0
	TAY

	; Go to next row
	JSR LoadLevel_TileMemNextRow

	JMP GHEX_HouseExitBG_NextRow

	; Around we go...	
GHEX_Done:

	; Go to next screen
	LDA Tile_Mem_Addr+2
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+3
	STA <Map_Tile_AddrH

	LDY #(16*15)	; Initial offset
	LDX #(11*16)	; Number of sky tiles to blast in
GHEX_SkyFill_Loop:
	LDA #TILE5_EXITSKY
	STA [Map_Tile_AddrL],Y

	INY
	BNE GHEX_SkyFill_NoNextRow

	; Next row...
	INC <Map_Tile_AddrH

GHEX_SkyFill_NoNextRow:
	DEX	; X--
	BNE GHEX_SkyFill_Loop	; While X > 0, loop!
	
	RTS


LoadLevel_BigBoo:

	; Big Boo tiles only place at left edge where they belong
	LDA Tile_Mem_Addr
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1
	STA <Map_Tile_AddrH

	; Big Boo is 64x64, which equates to 4x4 in tiles
	
	LDY #0	; Tile offset
	LDX #27	; Rows to do
	
LL_BB_Loop:

	TXA
	CMP #15
	BLT LL_BB_NotBoo
	CMP #19
	BGE LL_BB_NotBoo
	
	; Big Boo range...
	TYA
	AND #$0F
	CMP #$0C
	BLT LL_BB_NotBoo	; If not the last 4 columns, jump to LL_BB_NotBoo
	
	SUB #$0C
	STA <Temp_Var1	; Hold value, based 0 to 3
	
	TXA
	SUB #15		; Base row at 0 to 3
	EOR #3		; Reverse the count
	ASL A
	ASL A	; Multiply by 4
	ADD <Temp_Var1
	ADD #TILE5_BIGBOO1	; Base tile
	BNE LL_BB_BooTile	; Jump (technically always) to LL_BB_BooTile

LL_BB_NotBoo:
	LDA #TILE5_BIGBOO_CLEAR
	
LL_BB_BooTile:
	STA [Map_Tile_AddrL],Y

	INY		; Next tile...

	TYA
	AND #$0F
	BNE LL_BB_Loop		; If 'Y' lower bits are not zero, we're not on a new row, jump to LL_BB_NotNewRow
	
	; We're on a new row...

	TYA
	BNE LL_BB_NotLowerScreen	; If the overall value is not $00, we didn't wrap to lower screen, jump to LL_BB_NotLowerScreen

	; Lower screen!
	INC <Map_Tile_AddrH

LL_BB_NotLowerScreen:

	; New row!  Are we done?
	DEX		; One less row!
	BNE LL_BB_Loop	; If X != 0, we're not done, loop!


LL_BB_Done:
	RTS
	

	; Broken into another file for ease of integration in NoDice editor
	.include "PRG/levels/Ghost.asm"
	
