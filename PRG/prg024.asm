; Source generated by DCC6502 version v1.4
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg024.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------

; Some constants specific to title screen; they don't really match up with the gameplay
FALL_NORMAL		= 5	; Normal fall rate added to 'Y'
FALL_TAILWAG		= 1	; Adjusted fall rate for when wagging raccoon tail
FALL_OBJECT		= 4	; Fall rate for objects

FALLRATE_TAILWAGMAX	= 8	; Maximum Y velocity falling rate when wagging raccoon tail
FALLRATE_MAX		= $40	; Maximum Y velocity falling rate
FALLRATE_OBJECTMAX	= $60	; Maximum Y velocity falling rate of an object

Cinematic_ToadAndKing:
	LDA Cine_ToadKing
	LSR A
	BNE PRG024_A03A	 ; If Cine_ToadKing > 1, jump to PRG024_A03A

	LDX #$00	 ; X = 0

	JSR Level_PrepareNewObject

	; Disable timer and animations
	LDA #$81	 
	STA Level_TimerEn

	; CineKing_Timer = $20
	LDA #$20
	STA CineKing_Timer

	; Initialize VRAM address for Toad and King Cinematic Dialog Box
	LDA #$28
	STA ToadTalk_VH
	LDA #$86
	STA ToadTalk_VL

	; Initialize character counter
	LDA #$00
	STA ToadTalk_CPos

	LDA #168
	STA <Objects_X

	LDA #$60	 ; A = $60

	LDY World_Num	 ; Y = World_Num

	CPY #$01
	BNE PRG024_A033	 ; If World_Num <> 1 (World 2), jump to PRG024_A033

	LDA #$20	 ; A = $20

PRG024_A033:
	STA King_Y

	INC Cine_ToadKing ; Cine_ToadKing = 2
	RTS		 ; Return

PRG024_A03A:

	; Keep the Player halted
	LDA #$02
	STA Player_HaltTick

	LDA Player_HaltGame
	BNE PRG024_A04A	 ; If gameplay is halted, jump to PRG024_A04A

	JSR King_Animate  ; Do King's animation logic
	JSR King_DoDialog ; Do King's dialog

PRG024_A04A:
	JMP PRG024_A39D	 ; Jump to PRG024_A39D


King_DoDialog:
	; Load font patterns
	LDA #$5E
	STA PatTable_BankSel+1

	LDA <CineKing_DialogState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word TAndK_DrawDiagBox		; 0: Draw the dialog box
	.word TAndK_DoToadText		; 1: Do the text
	.word TAndK_WaitPlayerButtonA	; 2: Wait for Player to push 'A'

	; Patterns that make up the rows of the dialog box
DiagBox_R1:	.byte $94, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $96
DiagBox_R2:	.byte $92, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $93
DiagBox_R3:	.byte $95, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $97

DiagBox_RowOffs:
	.byte (DiagBox_R1 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1)
	.byte (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R3 - DiagBox_R1)
DiagBox_RowOffs_End

TAndK_DrawDiagBox:
	LDA CineKing_Timer 
	BNE PRG024_A119	 ; If CineKing_Timer has not expired, jump to PRG024_A119 (RTS)

	LDA King_Y
	CMP #90
	BLT PRG024_A119	 ; If King is higher than pixel line 90, jump to PRG024_A119 (RTS)

	LDX Graphics_BufCnt	 ; X = buffer count

	; Set current VRAM address 
	LDA ToadTalk_VH
	STA Graphics_Buffer,X
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,X

	; Jump to next video row
	ADD #$20	; 32 bytes to next row
	STA ToadTalk_VL
	BCC PRG024_A0CD
	INC ToadTalk_VH	 ; Apply carry
PRG024_A0CD:

	LDA #(DiagBox_R2 - DiagBox_R1)	; run count per row
	STA Graphics_Buffer+2,X
	STA <Temp_Var1		 ; -> Temp_Var1

	LDY ToadTalk_CPos	 ; Y = current dialog box row
	LDA DiagBox_RowOffs,Y
	TAY		 	; Y = offset to this row index

PRG024_A0DB:
	; Store next pattern in dialog box
	LDA DiagBox_R1,Y
	STA Graphics_Buffer+3,X

	INY		 ; Y++ (next pattern for dialog box)
	INX		 ; X++ (next index in graphics buffer)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG024_A0DB	 ; While Temp_Var1 > 0, loop!

	; Insert terminator
	LDA #$00
	STA Graphics_Buffer+3,X

	; X += 3
	INX
	INX
	INX
	STX Graphics_BufCnt

	INC ToadTalk_CPos	 ; Next row

	LDA ToadTalk_CPos
	CMP #(DiagBox_RowOffs_End - DiagBox_RowOffs)
	BLT PRG024_A119	 ; If row count < 8, jump to PRG024_A119

	; Dialog box is complete

	LDA #$00	 ; A = 0 ("The King has been transformed!")

	LDY Map_Objects_IDs
	BNE PRG024_A105	 ; If the "HELP!" bubble is still present (haven't been on airship yet), jump to PRG024_A105

	LDA #(KingHelpMsg2 - KingHelpMsg1)	 ; ("Get the magic wand back from little koopa!")

PRG024_A105:
	STA ToadTalk_CPos	 ; Set proper character position

	; Initialize VRAM address for Toad and King Cinematic Dialog Box Text
	LDA #$28
	STA ToadTalk_VH
	LDA #$a7
	STA ToadTalk_VL

	; CineKing_Timer = $10
	LDA #$10
	STA CineKing_Timer

	INC <CineKing_DialogState	; CineKing_DialogState = 1

PRG024_A119:
	RTS		 ; Return

	; English: "Oh,it's terrible!" / "The King has been" / "transformed!" / "Please find the" / "Magic Wand so we can" / "change him back"
KingHelpMsg1:
	;       O    h    ,    i    t    '    s         t    e    r    r    i    b    l    e    !
	.byte $BE, $D7, $9A, $D8, $CD, $AB, $CC, $FE, $CD, $D4, $CB, $CB, $D8, $D1, $DB, $D4, $EA, $FE, $FE, $FE

	;       T    h    e         K    i    n    g         h    a    s         b    e    e    n
	.byte $C3, $D7, $D4, $FE, $BA, $D8, $DD, $D6, $FE, $D7, $D0, $CC, $FE, $D1, $D4, $D4, $DD, $FE, $FE, $FE

	;       t    r    a    n    s    f    o    r    m    e    d    !
	.byte $CD, $CB, $D0, $DD, $CC, $D5, $DE, $CB, $DC, $D4, $D3, $EA, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;       P    l    e    a    s    e         f    i    n    d         t    h    e
	.byte $BF, $DB, $D4, $D0, $CC, $D4, $FE, $D5, $D8, $DD, $D3, $FE, $CD, $D7, $D4, $FE, $FE, $FE, $FE, $FE

	;       M    a    g    i    c         W    a    n    d         s    o         w    e         c    a    n
	.byte $BC, $D0, $D6, $D8, $D2, $FE, $C6, $D0, $DD, $D3, $FE, $CC, $DE, $FE, $81, $D4, $FE, $D2, $D0, $DD

	;       c    h    a    n    g    e         h    i    m         b    a    c    k    .
	.byte $D2, $D7, $D0, $DD, $D6, $D4, $FE, $D7, $D8, $DC, $FE, $D1, $D0, $D2, $DA, $E9, $FE, $FE, $FE, $FE

	; English: "Hurry! Hurry!" / "Get the Magic Wand" / "back from Little" / "Koopa."
KingHelpMsg2:
	;       H    u    r    r    y    !         H    u    r    r    y    !
	.byte $B7, $CE, $CB, $CB, $8C, $EA, $FE, $B7, $CE, $CB, $CB, $8C, $EA, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;       G    e    t         t    h    e         M    a    g    i    c         W    a    n    d
	.byte $B6, $D4, $CD, $FE, $CD, $D7, $D4, $FE, $BC, $D0, $D6, $D8, $D2, $FE, $C6, $D0, $DD, $D3, $FE, $FE

	;       b    a    c    k         f    r    o    m         L    i    t    t    l    e
	.byte $D1, $D0, $D2, $DA, $FE, $D5, $CB, $DE, $DC, $FE, $BB, $D8, $CD, $CD, $DB, $D4, $FE, $FE, $FE, $FE

	;       K    o    o    p    a    .
	.byte $BA, $DE, $DE, $DF, $D0, $E9, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

TAndK_DoToadText:
	LDA CineKing_Timer
	BNE PRG024_A260	 ; If the timer is not expired, jump to PRG024_A260

	LDY ToadTalk_CPos	 ; Y = dialog message character position

	LDA KingHelpMsg1,Y	 ; Get next character of message

	LDY Graphics_BufCnt	 ; Y = graphics buffer counter
	STA Graphics_Buffer+3,Y	 ; Store into buffer

	; Insert one character into graphics buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,Y	; address high
	LDA #$01	 
	STA Graphics_Buffer+2,Y	; run length
	LSR A
	STA Graphics_Buffer+4,Y	; terminator
	TYA
	ADD #$04
	STA Graphics_BufCnt	; count
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,Y	; address low

	INC ToadTalk_CPos	 ; Next character in message
	INC ToadTalk_VL	 ; Next VRAM byte
	AND #$1f	 	; Get current column
	CMP #$1a	 
	BNE PRG024_A25B	 	; If we're not in column 26, jump to PRG024_A25B

	; Line break!

	LDA ToadTalk_VL
	ADC #$0b		; Add enough bytes to get to next row
	STA ToadTalk_VL
	BCC PRG024_A250
	INC ToadTalk_VH	; Apply carry
PRG024_A250:

	CMP #$67	
	BNE PRG024_A25B	 ; If we haven't reached the last character, jump to PRG024_A25B

	INC <CineKing_DialogState		 ; CineKing_DialogState = 2

	LDA #$00
	STA ToadTalk_CPos

PRG024_A25B:
	; Reset tick counter for next character
	LDA #$04
	STA CineKing_Timer

PRG024_A260:
	RTS		 ; Return


TAndK_WaitPlayerButtonA:
	LDA <Pad_Input
	BPL PRG024_A282	 ; If Player is not pushing 'A', jump to PRG024_A282 (RTS)

	LDA Map_Objects_IDs
	BEQ PRG024_A27A	 ; If the "HELP!" bubble is gone, jump to PRG024_A27A

	; Level_JctCtl = 3 (switch to airship)
	;LDA #$03
	;STA Level_JctCtl

	; No more "HELP!" bubble...
	;LDA #MAPOBJ_EMPTY
	;STA Map_Objects_IDs

	; Airship is in town now!
	;LDA #MAPOBJ_AIRSHIP
	;STA Map_Objects_IDs+1

	RTS		 ; Return


PRG024_A27A:
	; Standard exit to map
	LDA #$00
	STA Map_ReturnStatus
	INC Level_ExitToMap

PRG024_A282:
	RTS		 ; Return

	; Sets PatTable_BankSel+5 by world 1-7
King_PatTableByWorld:
	.byte $27, $27, $27, $26, $26, $26, $27

	; Sets King's sprite palette select by world 1-7
King_PalByWorld:
	.byte SPR_PAL2, SPR_PAL2, SPR_PAL3, SPR_PAL2, SPR_PAL2, SPR_PAL2, SPR_PAL2

	; Number of King's patterns (sprites) by world 1-7
King_NumPatsByWorld:
	.byte (King_W1Pat0 - King_W1Pat1), (King_W2Pat1 - King_W2Pat0), (King_W3Pat0 - King_W3Pat1), (King_W4Pat0 - King_W4Pat1)
	.byte (King_W5Pat1 - King_W5Pat0), (King_W6Pat1 - King_W6Pat0), (King_W7Pat0 - King_W7Pat1)

	; King sprite data offset by world and frame (Left = 0, Right = 1)
King_SprDataOffByWorldAndFrame:
	.byte (King_W1YOff - King_SprDataYOff), (King_W1YOff - King_SprDataYOff)	; World 1
	.byte (King_W2YOff - King_SprDataYOff), (King_W2YOff - King_SprDataYOff)	; World 2
	.byte (King_W3YOff0 - King_SprDataYOff), (King_W3YOff1 - King_SprDataYOff)	; World 3
	.byte (King_W4YOff - King_SprDataYOff), (King_W4YOff - King_SprDataYOff)	; World 4
	.byte (King_W5YOff - King_SprDataYOff), (King_W5YOff - King_SprDataYOff)	; World 5
	.byte (King_W6YOff - King_SprDataYOff), (King_W6YOff - King_SprDataYOff)	; World 6
	.byte (King_W7YOff0 - King_SprDataYOff), (King_W7YOff1 - King_SprDataYOff)	; World 7

	; Y offset (from King_Y) per King sprite (must be parallel with King_SprDataX)
King_SprDataYOff:
King_W1YOff:	.byte $09, $10, $10, $10, $20, $20, $20
King_W7YOff1:	.byte $02, $10, $10, $20, $20
King_W7YOff0:	.byte $03, $10, $10, $20, $20
King_W6YOff:	.byte $00, $16, $16
King_W5YOff:	.byte $EA, $F0, $F0, $F0, $00, $00, $00
King_W4YOff:	.byte $0B, $10, $10, $10, $20, $20, $20
King_W2YOff:	.byte $00, $00, $00
King_W3YOff1:	.byte $0D, $10, $10, $20, $20, $20
King_W3YOff0:	.byte $0E, $10, $10, $20, $20, $20

	; X per King sprite (must be parallel with King_SprDataYOff)
King_SprDataX:
King_W1X:	.byte $D7, $CC, $D4, $DC, $CC, $D4, $DC
King_W7X1:	.byte $CC, $C8, $D0, $C8, $D0
King_W7X2:	.byte $CC, $C8, $D0, $C8, $D0
King_W6X:	.byte $C8, $C8, $D0
King_W5X:	.byte $D4, $D0, $D8, $E0, $D0, $D8, $E0
King_W4X:	.byte $D2, $D0, $D8, $E0, $D0, $D8, $E0
King_W2X:	.byte $CC, $C8, $D0
King_W3X1:	.byte $D3, $D0, $D8, $D0, $D8, $E0
King_W3X0:	.byte $D1, $D0, $D8, $D0, $D8, $E0

King_SprPatOffByWorldAndFrame:
	.byte (King_W1Pat0 - King_SprPats), (King_W1Pat1 - King_SprPats)	; World 1
	.byte (King_W2Pat0 - King_SprPats), (King_W2Pat1 - King_SprPats)	; World 2
	.byte (King_W3Pat0 - King_SprPats), (King_W3Pat1 - King_SprPats)	; World 3
	.byte (King_W4Pat0 - King_SprPats), (King_W4Pat1 - King_SprPats)	; World 4
	.byte (King_W5Pat0 - King_SprPats), (King_W5Pat1 - King_SprPats)	; World 5
	.byte (King_W6Pat0 - King_SprPats), (King_W6Pat1 - King_SprPats)	; World 6
	.byte (King_W7Pat0 - King_SprPats), (King_W7Pat1 - King_SprPats)	; World 7

King_SprPats:
King_W1Pat1:	.byte $E1, $E3, $E5, $E7, $E9, $EB
King_W1Pat0:	.byte $E1, $ED, $E5, $E7, $EF, $EB
King_W7Pat1:	.byte $F1, $F3, $F5, $F7
King_W7Pat0:	.byte $F9, $D5, $FD, $FF
King_W6Pat0:	.byte $C1, $C3
King_W6Pat1:	.byte $C5, $C7
King_W5Pat0:	.byte $DB, $DD, $DF, $E1, $E3, $E5
King_W5Pat1:	.byte $DB, $E7, $E9, $E1, $EB, $ED
King_W4Pat1:	.byte $D5, $CB, $CD, $D7, $D9, $D3
King_W4Pat0:	.byte $C9, $CB, $CD, $CF, $D1, $D3
King_W2Pat0:	.byte $D9, $DB
King_W2Pat1:	.byte $DD, $DF
King_W3Pat1:	.byte $CB, $CD, $CF, $D1, $D3
King_W3Pat0:	.byte $C1, $C3, $C5, $C7, $C9

	; World 6 King is a seal juggling a crown (indexed by CineKing_Frame2)
King_W6Crown_YOff:	.byte $06, $04, $0A, $09, $09, $02, $04, $06
King_W6Crown_Pattern:	.byte -5, -3, -3, -5, -3, -3, -5, -5
King_W6Crown_Attr:	
	.byte SPR_PAL3, SPR_PAL3, SPR_PAL3 | SPR_VFLIP, SPR_PAL3 | SPR_VFLIP, SPR_PAL3 | SPR_HFLIP | SPR_VFLIP
	.byte SPR_PAL3 | SPR_HFLIP, SPR_PAL3, SPR_PAL3

PRG024_A36C:
	.byte $30, $40, $50, $60

	; Sprites that make up the yelling Toad
KingToad_Sprites:
	.byte $80, $00, $01, $B8
	.byte $80, $00, $01, $B0
	.byte $80, $00, $01, $A8
	.byte $70, $00, $01, $B8
	.byte $70, $00, $01, $B0
	.byte $70, $00, $01, $A8
KingToad_Sprites_End

KingToad_Patterns:
ToadFrame0:	.byte $A1, $A3, $A5, $A7, $A9, $AB
ToadFrame1:	.byte $B9, $BB, $71, $BD, $BF, $71
ToadFrame2:	.byte $AD, $AF, $B1, $B3, $B5, $B7

KingToad_PatOffset:
	.byte (ToadFrame0 - KingToad_Patterns), (ToadFrame1 - KingToad_Patterns), (ToadFrame2 - KingToad_Patterns)

PRG024_A39D:
	; Load yelling Toad's graphics
	LDA #$2a
	STA PatTable_BankSel+4

	; Copy in the sprites for yelling Toad
	LDY #(KingToad_Sprites_End - KingToad_Sprites - 1)
PRG024_A3A4:
	LDA KingToad_Sprites,Y
	STA Sprite_RAM+$40,Y

	DEY		 ; Y--
	BPL PRG024_A3A4	 ; While Y >= 0, loop

	LDY Objects_Frame	; Y = yelling Toad's frame
	LDX KingToad_PatOffset,Y ; X = base offset into patterns for this frame

	; Patch the patterns on the yelling Toad for the current frame
	LDY #((KingToad_Sprites_End - KingToad_Sprites - 1) & ~3)
PRG024_A3B5:
	LDA KingToad_Patterns,X
	STA Sprite_RAM+$41,Y

	INX		 ; X++ (index to next patch pattern)

	; Y -= 4 (previous sprite)
	DEY
	DEY
	DEY
	DEY

	BPL PRG024_A3B5	; While Y >= 0, loop

	LDY World_Num	 ; Y = World_Num

	; Set King's pattern table
	LDA King_PatTableByWorld,Y
	STA PatTable_BankSel+5	

	; King's Y -> Temp_Var1
	LDA King_Y
	STA <Temp_Var1

	; King's palette select -> Temp_Var2
	LDA King_PalByWorld,Y
	STA <Temp_Var2

	; King's number of patterns (sprites) -> Temp_Var4 and 5
	LDA King_NumPatsByWorld,Y
	STA <Temp_Var4
	STA <Temp_Var5

	TYA		; A = Y (World_Num)
	ASL A		; A = World_Num * 2
	ORA CineKing_Frame	; OR'd King's frame (0 or 1)
	PHA		; Save value
	TAY		; -> 'Y'

	LDX King_SprDataOffByWorldAndFrame,Y	; X = root index of King Sprite data
	LDY #$60	; Y = $60
PRG024_A3E8:
	; Set King Sprite Y
	LDA <Temp_Var1
	ADD King_SprDataYOff,X
	STA Sprite_RAM,Y

	; Set King Sprite Attributes
	LDA <Temp_Var2
	STA Sprite_RAM+$02,Y

	; Set King Sprite X
	LDA King_SprDataX,X
	STA Sprite_RAM+$03,Y

	INX		 ; X++ (next King sprite data)

	; Y += 4 (Next King sprite)
	INY
	INY
	INY
	INY

	DEC <Temp_Var4	 ; Temp_Var4--
	BPL PRG024_A3E8	 ; While Temp_Var4 >= 0, loop

	PLA		 ; Restore A = (World_Num * 2) | CineKing_Frame
	TAY		 ; -> 'Y'

	; Copy in all the King sprite patterns
	LDX King_SprPatOffByWorldAndFrame,Y	; X = root index of King Sprite patterns
	LDY #$64	 ; Y = $64
PRG024_A40C:
	LDA King_SprPats,X
	STA Sprite_RAM+$01,Y

	INX		 ; X++ (next King Sprite pattern index)

	; Y += 4 (next King Sprite)
	INY
	INY
	INY
	INY

	DEC <Temp_Var5	 ; Temp_Var5--
	BNE PRG024_A40C	 ; While Temp_Var5 <> 0, loop

	LDY World_Num
	CPY #$05
	BEQ PRG024_A48A	 ; If World_Num = 5 (World 6), jump to PRG024_A48A

	; Not World 6...

	; Just put a stationary crown there
	LDA #$fb
	STA Sprite_RAM+$61
	LDA #$02
	STA Sprite_RAM+$62

	CPY #$06
	BNE PRG024_A439	 ; If World_Num <> 6 (World 7), jump to PRG024_A439

	; World 7 only...

	; Set piranha's body palette to 3
	LDA #SPR_PAL3
	STA Sprite_RAM+$6E
	STA Sprite_RAM+$72

	RTS		 ; Return

PRG024_A439:
	CPY #$01
	BNE PRG024_A4A1	 ; If World_Num <> 1 (World 2), jump to PRG024_A4A1 (RTS)

	; World 2 only...

	; Crown on the floor 
	LDA #$80
	STA Sprite_RAM+$60

	; Temp_Var4 = CineKing_DialogState
	LDA <CineKing_DialogState
	STA <Temp_Var4

	; Temp_Var3 = $10
	LDA #$10
	STA <Temp_Var3

	LDY #$80	 ; Y = $80
PRG024_A44C:
	LDA <Temp_Var4
	BEQ PRG024_A466	 ; If Temp_Var4 (CineKing_DialogState) = 0, jump to PRG024_A466

	LDX #$03	 ; X = 3

	CMP #$00
	BNE PRG024_A45B	 ; Jump (technically always) to PRG024_A45B

	LDA ToadTalk_CPos
	LSR A
	TAX		 ; X = ToadTalk_CPos / 2

PRG024_A45B:
	LDA <Temp_Var3
	CMP #$20
	BLT PRG024_A466	 ; If Temp_Var3 < $20, jump to PRG024_A466

	CMP PRG024_A36C,X
	BLT PRG024_A47E	 ; If Temp_Var3 < PRG024_A36C[X], jump to PRG024_A47E

PRG024_A466:

	; Set web sprite Y
	LDA <Temp_Var3
	STA Sprite_RAM,Y

	; Set web sprite pattern
	LDA #$d7
	STA Sprite_RAM+$01,Y

	; Set web sprite attribute
	LDA <Temp_Var2
	STA Sprite_RAM+$02,Y

	; Set web sprite X
	LDA #$d0
	STA Sprite_RAM+$03,Y

	; Y += 4 (next sprite)
	INY
	INY
	INY
	INY

PRG024_A47E:

	; Temp_Var3 += $10
	LDA <Temp_Var3
	ADD #$10
	STA <Temp_Var3

	CMP <Temp_Var1	
	BLT PRG024_A44C	 ; While Temp_Var3 < Temp_Var1, loop!

	RTS		 ; Return

PRG024_A48A:
	LDY <CineKing_Frame2

	; Set crown sprite Y
	LDA <Temp_Var1	; King Sprite Y
	ADD King_W6Crown_YOff,Y
	STA Sprite_RAM+$60

	; Set crown sprite pattern
	LDA King_W6Crown_Pattern,Y
	STA Sprite_RAM+$61

	; Set crown sprite attributes
	LDA King_W6Crown_Attr,Y
	STA Sprite_RAM+$62

PRG024_A4A1:
	RTS		 ; Return

	; Performs animation logic for the king
King_Animate:
	LDA <Counter_1
	AND #$07
	BNE PRG024_A4B2	 ; 6:7 ticks, jump to PRG024_A4B2

	; Loop the panicking Toad's frame 2 to 0
	DEC Objects_Frame
	BPL PRG024_A4B2
	LDA #$02
	STA Objects_Frame

PRG024_A4B2:
	LDA World_Num
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word King_W1347	; World 1 King (Dog scratching ear)
	.word King_W2		; World 2 King (Spider with crown on floor)
	.word King_W1347	; World 3 King (Hunched green creature)
	.word King_W1347	; World 4 King (Dinosaur)
	.word King_W5		; World 5 King (Albatross)
	.word King_W6		; World 6 King (Seal juggling crown)
	.word King_W1347	; World 7 King (Fire Piranha)

W6Seal_Frames:	.byte $01, $01, $01, $00, $00, $00, $00, $01
W6Crown_Frames:	.byte $00, $01, $02, $03, $04, $05, $00, $01

King_W6:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7 by counter

	; Set seal's frame
	LDA W6Seal_Frames,Y
	STA CineKing_Frame

	; Set seal juggled crown frame
	LDA W6Crown_Frames,Y
	STA <CineKing_Frame2

	RTS		 ; Return

King_YDelta:	.byte $01, -$01, $01
King_W2_YLimit:	.byte $70, $68

King_W2:
	JSR King_W1347	 ; Do animation like other kings

	LDA King_Y
	CMP #$68
	BGE PRG024_A4FD	 ; If King_Y >= $68, jump to PRG024_A4FD 

	INC King_Y 	 ; King_Y++

	RTS		 ; Return

PRG024_A4FD:
	LDA <Counter_1
	AND #$03	
	BNE PRG024_A519	 ; 3:4 ticks, jump to PRG024_A519

	LDY <CineKing_Var	 ; Y = CineKing_Var (0/1 as spider walks up and down)

	; King spider moves up or down
	LDA King_Y
	ADD King_YDelta,Y
	STA King_Y

	CMP King_W2_YLimit,Y
	BNE PRG024_A519	 ; If King has not hit Y limit in this direction, jump to PRG024_A519

	; Reverse direction
	TYA
	EOR #$01
	STA <CineKing_Var

PRG024_A519:
	RTS		 ; Return

PRG024_A51A:
	.byte %00100100	; World 1
	.byte %00001000	; World 2
	.byte %00101000	; World 3
	.byte %00101000	; World 4
	.byte %00010000	; World 5
	.byte %00000000	; World 6
	.byte %00010000	; World 7
	
King_W1347:
	LDY World_Num	; Y = World_Num

	LDA <Counter_1
	AND PRG024_A51A,Y ; Mask counter by value from PRG024_A51A
	BEQ PRG024_A52D	 ; If this is the tick to fire on, jump to PRG024_A52D

	LDA #$01	 ; A = 1 (frame)

PRG024_A52D:
	STA CineKing_Frame	 ; Set king frame

	RTS		 ; Return

King_W5:
	JSR King_W1347	 ; Do animation like other kings

	TAY		 ; Y = King frame

	LDA <Counter_1
	AND #$03	
	BNE PRG024_A545	 ; 3:4 ticks, jump to PRG024_A545

	LDA King_Y
	ADD King_YDelta+1,Y
	STA King_Y

PRG024_A545:
	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GraphicsBuf_Prep_And_WaitVSyn2
;
; This subroutine takes Graphics_Queue and loads and address
; from Video_Upd_Table2 into the Video_Upd_Addr, then waits for
; a VBlank cycle to occur via reading the VBlank_Tick after
; force-setting it to zero.  This gets the system into a state
; where it can actually apply the update!
;
; See also GraphicsBuf_Prep_And_WaitVSync in PRG030
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GraphicsBuf_Prep_And_WaitVSyn2:
	LDA <Graphics_Queue
	ASL A		 	
	TAY		 	; Y = Graphics_Queue << 1

	; Get the address where the video update data is
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH	

	LDA #$01	
	STA <VBlank_TickEn	 ; Enable the VBlank tick
	LDA #$00	 
	STA <VBlank_Tick	 ; Force VBlank_Tick = 0, so we know when a VBlank has occurred

	; Waiting for VBlank...
PRG024_A81C:
	LDA <VBlank_Tick
	BPL PRG024_A81C

	LDA #$00	 
	STA <VBlank_TickEn	 ; Disable the VBlank

	CLI		 ; Enable further masked interrupts
	RTS		 ; Return


IntIRQ_TitleEnding:
	STA MMC3_IRQENABLE

	; Some kind of delay loop?
	LDX #$04	 ; X = 4
PRG024_A82B:
	NOP		 ; ?
	DEX		 ; X--
	BNE PRG024_A82B	 ; While X > 0, loop

	LDA PPU_STAT

	LDY #$0b
	LDA #$00
	STY PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR

	LDA PPU_VRAM_DATA

	LDA <PPU_CTL1_Copy	
	ORA <PPU_CTL1_Mod	; Combine bits from PPU_CTL1_Copy into PPU_CTL1_Mod
	STA PPU_CTL1	 ; Stored to the register!

	LDA PPU_STAT

	; RAS: Horz scroll!
	LDA <Title_HorzScroll
	STA PPU_SCROLL

	; V-Scroll locked at $EF
	LDA #$ef
	STA PPU_SCROLL

	STA MMC3_IRQDISABLE

	JMP IntIRQ_Finish_NoDis	 ; Jump to IntIRQ_Finish_NoDis

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; Video_Misc_Updates2
;
; This routine is responsible for arbitrary video updates
;
; Loads data as specified from table Video_Upd_Table2 in PRG024 (see Video_Upd_Table in PRG030 for format!)
; Cloned in its entirety in PRG026 (i.e. Video_Misc_Updates)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Video_Misc_Updates2:
	LDY #$00	 	; Start at offset 0
	LDA [Video_Upd_AddrL],Y	; Get next byte from data
	BNE PRG024_A860	 	; If not $00 (terminator), process it @ PRG024_A860
	RTS		 ; Return

PRG024_A860:
	LDX PPU_STAT	 	; Flush video

	STA PPU_VRAM_ADDR	; Store byte into video address high
	INY		 	; Y++
	LDA [Video_Upd_AddrL],Y	; Get next byte
	STA PPU_VRAM_ADDR	; Store byte into video address low

	INY		 	; Y++
	LDA [Video_Upd_AddrL],Y	; Get next byte...

	ASL A		 	; Its uppermost bit dictates whether to use horizontal (1B) or vertical (32B) advancement
	PHA		 	; Save A

	LDA <PPU_CTL1_Copy	; Get PPU_CTL1 settings
	ORA #$04	 	; Set PPU update vertical (each write advances by 32)
	BCS PRG024_A879		; If bit 7 was set, jump to PRG026_B2B2
	AND #$fb		; Otherwise, use horizontal updates! (clears vertical bit)

PRG024_A879:
	STA PPU_CTL1		; Update PPU_CTL1
	STA <PPU_CTL1_Copy	; Update PPU_CTL1_Copy

	PLA		; Restore A

	ASL A		 ; Check next bit...
	BCC PRG024_A885	 ; If not set, jump to PRG026_B2BE
	ORA #$02	 ; Otherwise, remaining value gets bit 1 set (forces skip of first increment)
	INY		 ; Y++ 

PRG024_A885:
	; Restore remainder of byte read (6-bits for value)
	LSR A
	LSR A
	TAX		 ; Keep it in X

	; The following will continuously write bytes from the stream
	; directly into the PPU 'X+1' times
PRG024_A888:
	BCS PRG024_A88B	 ; If carry set, jump to PRG026_B2C4
	INY		 ; Y++

PRG024_A88B:
	LDA [Video_Upd_AddrL],Y	; Get next byte
	STA PPU_VRAM_DATA	; Store into PPU
	DEX		 	; X--
	BNE PRG024_A888	 	; While X <> 0, loop! 

	; This advances the current position of the pointer so 'Y' can go
	; back to zero and we begin again...
	INY		 ; Y++
	TYA		 ; A = Y
	ADD <Video_Upd_AddrL
	STA <Video_Upd_AddrL
	LDA <Video_Upd_AddrH
	ADC #$00	 
	STA <Video_Upd_AddrH	; Entire video address value has 'Y' added to it
	JMP Video_Misc_Updates2	; Jump back to start to process next command or terminate!

Do_Title_Screen:	; $A8AF
	JSR Sprite_RAM_Clear		; Clear Sprite RAM Copy
	JSR Reset_PPU_Clear_Nametables

	; Basically just hiding everything
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2

	; Clear the first 245 bytes of RAM
	LDX #$f5	 ; X = 245
PRG024_A8BF:
	LDA #$00	 	; A = $00
	STA <Temp_Var1,X	; Clear this byte
	DEX		 	; X--
	BNE PRG024_A8BF	 	; Loop...


	; Clearing memory used by various title screen objects
	LDX #(Title_ObjFrame - Title_MLAccelCnt + 6)
PRG024_A8C8:
	LDA #$00	 ; A = 0
	STA Title_MLAccelCnt,X	 ; Clear this byte
	DEX		 ; X--
	BPL PRG024_A8C8	 ; Loop while X >= 0...

	; Set Mario and Luigi's lives to 4
	LDA #$04
	STA Player_Lives
	STA Player_Lives+1


	LDA #$88
	STA Random_Pool		; Seed the randomizer

	LDA #%00101000
	STA PPU_CTL1		; use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Sync with PPU_CTL1_Copy

	; Load the palette and checkerboard floor pattern
	LDA #$01	 ; A = 1
	ASL A		 ; A = 2
	TAY		 ; Y = 2 (Palette + Checkerboard floor)
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH
	JSR Video_Misc_Updates2

	; Some kind of hardware thing perhaps
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10	
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$00	
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10	 
	STA PPU_VRAM_ADDR	
	STA PPU_VRAM_ADDR	

	; Wait for V-Blank to end
PRG024_A930:
	LDA PPU_STAT
	AND #$80	
	BNE PRG024_A930	

	LDA #%10101000
	STA PPU_CTL1	 	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA #%00011110
	STA <PPU_CTL2_Copy	; Setup for: No BG or sprite clipping, show BG and sprites

	;LDA #53
	;STA <Title_Ticker	; Set Title_Ticker = 53 (initial delay prior to curtain raise)

;PRG024_A946:
	; Used for VSync
	;JSR GraphicsBuf_Prep_And_WaitVSyn2

	;DEC <Title_Ticker	; Decrement title tick counter
	;BPL PRG024_A946	 	; If >= 0, loop...

PRG024_A959:
	; Title_Ticker = 0...

	; Used for VSync
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	JSR Title_DoState	; Do whatever this state of the title screen does

	LDA <Title_State
	CMP #$0B
	BNE PRG024_A959	 ; If Title_State <> 11, jump to PRG024_A959

	; When Title_State = 8, we're about to finish and go off to the map!

	; Performs a clearing loop starting from World_Map_Y + $80 ($F5) down and through
	LDX #$80	 ; Clearing $80 bytes
	LDA #$00	 ; Clear value
PRG024_A98A:
	STA <World_Map_Y,X	; Clear this byte
	DEX		 	; X--
	BPL PRG024_A98A	 	; X >= 0, loop!

	; FIXME: This should ONLY be executed on NEW games!

	INC Map_SetBothPlayers
	
	; Clear check points
	LDA #$FF
	STA LevCP_ID
	STA LevCP_ID2

	RTS		 ; Return



Title_DoState:

	; Clear the queues for Mario/Luigi
	LDA #$00
	STA <Title_ObjMLQueue
	STA <Title_ObjMLQueue+1

	LDA <Title_State
	JSR DynJump	 	; Dynamically jump based on Title_State...

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Title_Init				; 00 - Load up graphics
	.word Title_FadeIn				; 01 - Fade in palette
	.word Title_WaitStart			; 02 - Waits for Player to press START
	.word Title_InitSaveMenu		; 03 - Initialize save menu
	.word Title_DoSaveMenu			; 04 - Save menu
	.word Title_FadeOut				; 05 - Fade out palette
	.word Title_PrepConfigMenu		; 06 - Prepare config menu
	.word Title_FadeIn				; 07 - Fade in palette
	.word Title_WaitForHeroes		; 08 - Waiting for everybody to get in place
	.word Title_ConfigMenu			; 09 - Config menu
	.word Title_PrepForWorldMap		; 10 - Final data initialization before going to world map
	.word Title_DoNothing			; 11 - just RTS, bootstraps world map
	.word Title_FadeOut				; 12 - Fade out palette for debug menu
	.word Title_InitDebugMenu		; 13 - Clear title screen, prep for debug menu
	.word Title_DoDebugMenu		; 14 - Put menu stuff in

Title_DoNothing:
	RTS

Title_Init:
	LDA #0
	STA <Vert_Scroll ; Vert_Scroll = 0

	; Disable display a second
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2
	STA <PPU_CTL2_Copy	; Show BG + sprites

	; This will load the title graphics in reverse, $22 to $8
	LDA #$22	
	STA <Title_EventGrafX	; Title_EventGrafX = $22 (TitleScreen_Part27)

PRG024_AB04:
	LDA <Title_EventGrafX
	ASL A		 
	TAY		 	; Y = Title_EventGrafX << 1 (2 byte index)

	; Get address, store into [Video_Upd_AddrH][Video_Upd_AddrL]
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL	
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH	

	JSR Video_Misc_Updates2	; Load those graphics!

	DEC <Title_EventGrafX	; Title_EventGrafX--

	LDA <Title_EventGrafX
	CMP #$08
	BGE PRG024_AB04	 	; If Title_EventGrafX >= 8, loop!

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG + sprites

	; RAS: Queue title song!
	JSR TitleMusic_Queue

	LDA #$03
	STA <Title_EventGrafX
	
	INC <Title_State	; Title_State = 1 (fade in)
	
	RTS		 ; Return

Title_FadeIn:

	LDA <Counter_1
	AND #$03
	BNE Title_FadeInNothing

	LDA <Title_EventGrafX
	STA <Graphics_Queue
	INC <Title_EventGrafX

	CMP #$4A
	BGE Title_FadeCurtainChk

	CMP #$06
	BLT Title_FadeInNothing	; Fade not complete title, jump to Title_FadeInNothing

Title_FadeInDone:
	INC <Title_State	; Next state

	LDA #0
	STA <Title_DebugCursor
	STA <Title_DebugSTest
	STA <Title_DebugComet
	STA <Title_ComplWorld
	STA <Title_WorldEnd
	STA <Title_InitSaveMCnt

Title_FadeInNothing:
	RTS

Title_FadeCurtainChk:
	CMP #$4D
	BLT Title_FadeInNothing
	BGE Title_FadeInDone

Title_FadeOut:

	LDA <Counter_1
	AND #$03
	BNE Title_FadeOutNothing

	LDA <Title_EventGrafX
	STA <Graphics_Queue
	DEC <Title_EventGrafX

	CMP #$03
	BGE Title_FadeOutNothing

	INC <Title_State	; Next state

Title_FadeOutNothing:
	RTS


Title_PrepConfigMenu:

	LDA #$00	 
	STA <Vert_Scroll ; Vert_Scroll = 0

	; Disable display a second
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2
	STA <PPU_CTL2_Copy	; Show BG + sprites

	JSR Sprite_RAM_Clear		; Clear Sprite RAM Copy


	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Raster_Effect = $80
	LDA #$80
	STA Raster_Effect

	; This will load the title graphics in reverse, $4A to $2a
	LDA #$4A
	STA <Title_EventGrafX	; Title_EventGrafX = $4A

PrepConfigMenu_Loop:
	LDA <Title_EventGrafX
	ASL A		 
	TAY		 	; Y = Title_EventGrafX << 1 (2 byte index)

	; Get address, store into [Video_Upd_AddrH][Video_Upd_AddrL]
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL	
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH	

	JSR Video_Misc_Updates2	; Load those graphics!

	DEC <Title_EventGrafX	; Title_EventGrafX--

	LDA <Title_EventGrafX
	CMP #$2a
	BGE PrepConfigMenu_Loop	 	; If Title_EventGrafX >= $2a, loop!

	LDA #%00011110
	STA <PPU_CTL2_Copy	; Show BG + sprites

	; RAS: Queue title song!
	JSR TitleMusic_Queue

	; Load curtain graphics
	LDA #$00
	STA PatTable_BankSel
	LDA #$02
	STA PatTable_BankSel+1
	
	; Fade-in for curtain starts at $4A
	LDA #$4A
	STA <Title_EventGrafX

	; Default character selections
	LDA #0
	STA Player_Character	; 1P on Mario
	STA Total_Players		; Only 1P by default
	STA <Title_CM_EvFlags	; Reset event flags
	LDA #1
	STA Player_Character+1	; 2P on Luigi

	LDA #$10
	STA <Title_ObjX+0		; Mario starts at 0

	LDA #$08
	STA <Title_ObjX+1		; Luigi starts at 0

	LDA #$00
	STA <Title_ObjX+2		; Toad starts at 0

	; Set default hero positions
	LDA #$80
	STA <Title_ObjY,X
	STA <Title_ObjY+1,X
	STA <Title_ObjY+2,X
	
	INC <Title_State
	
	LDA #MUS2A_BONUSGAME
	STA Sound_QMusic2
		
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Title_LoadGraphics
;
; Loads several items from Video_Upd_Table2 in PRG025
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Title_LoadGraphics:
	LDA #$08
	STA <Title_EventGrafX ; Title_EventGrafX = $08 (first item to load from Video_Upd_Table2 in PRG025, up to item $23; see Title_LoadSMB3)

	INC <Title_State ; Next title state...

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Title_3Glow
;
; Constantly pushes a palette adjustment into the
; graphics buffer to enable the big '3' on the title
; screen to glow...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Title_3Glow:
	DEC <Title_Ticker	; Title_Ticker--
	BPL PRG024_AAA9	 	; If Title_Ticker >= 0, jump to PRG024_AAA9 (RTS)

	LDA #$04	 	
	STA <Title_Ticker	; Title_Ticker = 4

	LDY <Title_3GlowIndex	; Y = current 3glow index
	LDA Title_3GlowColors,Y	; Get the cooresponding color

	STA Graphics_Buffer+3	; Put that into the graphics buffer

	; Address the palette
	LDA #$3f	 
	STA Graphics_Buffer
	LDA #$0e	 
	STA Graphics_Buffer+1

	; 1 byte and terminator
	LDA #$01	 	
	STA Graphics_Buffer+2	
	LDA #$00	 	
	STA Graphics_Buffer+4	

	; Title_3GlowIndex goes from 0 - 7, round and round
	INC <Title_3GlowIndex
	LDA <Title_3GlowIndex
	AND #$07	
	STA <Title_3GlowIndex

PRG024_AAA9:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Title_DrawHeroWalk
;
; Draw the heroes proudly marching onward!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Title_DrawHeroWalk:
	LDX #0
HeroWalk_Loop:
	LDA IntroChar_SprOff,X
	STA <Title_ObjMLSprRAMOff,X
	
	LDA IntroChar_X,X
	STA <Title_ObjX,X

	;LDA <Title_State
	;CMP #6
	;BNE HeroWalk_NotClearing	; If Title_State != 6 (prepping config menu, i.e. clear them off), jump to HeroWalk_NotClearing

	;LDA #$F8
	;BNE HeroWalk_Clearing	; Jump (technically always) to HeroWalk_Clearing
	
;HeroWalk_NotClearing:
	LDA #$A2
	
HeroWalk_Clearing:
	STA <Title_ObjY,X

	LDA #1
	STA Title_ObjMLPower,X	

	TXA
	STA <Title_CurMLIndex

	LDA #(SPR_HFLIP | SPR_BEHINDBG)
	STA <Title_ObjMLFlags,X

	TXA
	ASL A
	ADD <Counter_1
	AND #3
	BNE HeroWalk_NotExpired

	LDA <Title_ObjMLFrame,X
	ADD #1
	AND #3
	STA <Title_ObjMLFrame,X

HeroWalk_NotExpired:
	JSR Title_DrawMarioLuigi
	
	INX
	CPX #3
	BLT HeroWalk_Loop
	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Title_DrawCharacterSelect
;
; Draw the heroes waiting selection
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SelectChar_X:		.byte $50, $78, $A0

Title_DrawCharacterSelect:
	LDA #%00000100
	STA <Temp_Var8	; Bit to check in Title_CM_EvFlags

	LDA #0
	STA <Temp_Var2	; This flags whether all heroes are in position for selection or not (zero = yes)

	LDX #2
CharSelect_Loop:
	LDA IntroChar_SprOff,X
	STA <Title_ObjMLSprRAMOff,X
	
	LDA #1
	STA Title_ObjMLPower,X	

	TXA
	STA <Title_CurMLIndex

	LDA #(SPR_HFLIP | SPR_BEHINDBG)
	STA <Title_ObjMLFlags,X

	LDA <Title_ObjYVel,X
	BEQ Title_DCS_NotJumping

	; Hero is mid-jump...
	JSR Title_MLYAccel

	LDA <Title_ObjYVel,X
	ADD #$07
	STA <Title_ObjYVel,X
	
	LDA <Title_ObjY,X
	CMP #$80
	PHP	; save flags
	
	LDA #5	; Use jump frame
	
	; Out of position, set Temp_Var2
	INC <Temp_Var2
	
	PLP	; restore flags
	BLT Title_DCS_OutPositionUpdFrame
	
	; Player has hit floor!
	LDA #0
	STA <Title_ObjYVel,X
	
	; Flag Player as running off...
	LDA Title_CM_EvFlags
	ORA <Temp_Var8
	STA Title_CM_EvFlags

Title_DCS_NotJumping:
	LDA Title_CM_EvFlags
	AND <Temp_Var8
	BEQ Title_DCS_UseCharPos	; If bit not set, hero is not running off yet, jump to Title_DCS_UseCharPos
	
	; Hero is running off... use extreme right!
	LDA #$F0
	BNE Title_DCS_CheckXBound

Title_DCS_UseCharPos:
	LDA SelectChar_X,X
	
	
Title_DCS_CheckXBound:
	CMP <Title_ObjX,X
	BEQ Title_DCS_InPosition	; If the hero is in position, jump to Title_DCS_InPosition

	; Move over...
	LDA <Title_ObjX,X
	ADD #2
	STA <Title_ObjX,X

	; Out of position, set Temp_Var2
	INC <Temp_Var2

	LDA <Counter_1
	AND #1
	BNE Title_DCS_OutPosition
	
	; Walk into position...
	LDA <Title_ObjMLFrame,X
	ADD #1
	AND #3
	STA <Title_ObjMLFrame,X

	JMP Title_DCS_OutPositionUpdFrame
	
Title_DCS_InPosition:
	LDA #4

Title_DCS_OutPositionUpdFrame:
	STA <Title_ObjMLFrame,X

Title_DCS_OutPosition:	
	; Shift Temp_Var1 for next character
	LSR <Temp_Var8
		
	JSR Title_DrawMarioLuigi
	
	DEX
	BPL CharSelect_Loop
	
	LDA <Temp_Var2
	RTS


	; These are the color values used by Title_3Glow for the big '3'
Title_3GlowColors:
	.byte $27, $17, $07, $17, $27, $37, $37, $27

IntroChar_X:		.byte $C0, $80, $40
IntroChar_SprOff:	.byte $00, $18, $30

Title_DebugCodePattern:	.byte PAD_UP, PAD_UP, PAD_DOWN, PAD_DOWN, PAD_LEFT, PAD_RIGHT, PAD_LEFT, PAD_RIGHT, PAD_B, PAD_A, $FF

Title_CommonHeroWalk:
	JSR Title_DrawHeroWalk
	
	INC <Title_HorzScroll
	JMP Title_3Glow
	

Title_WaitStart:
	JSR Title_CommonHeroWalk
	
	LDA <Pad_Input
	AND #PAD_START
	BEQ TitleWaitStart_NotHit	 	; If Player is not pressing START, jump to TitleWaitStart_NotHit

	INC <Title_State ; Next title state...
	
TitleWaitStart_NotHit:
	
	; Debug code...
	LDA <Pad_Input
	BEQ Title_CheatEntered
	
	LDY Title_CheatIndex
	LDA Title_DebugCodePattern,Y
	CMP #$FF
	BEQ Title_CheatEntered	; If cheat already entered, jump to Title_CheatEntered
	
	CMP <Pad_Input
	BEQ Title_CheatNext		; If Player hit exactly the right button, jump to Title_CheatNext
	
	; Wrong button!
	LDA #0
	STA Title_CheatIndex
	BEQ Title_CheatEntered	; Jump (technically always) to Title_CheatEntered
	
Title_CheatNext:
	INC Title_CheatIndex
	INY
	
	LDA Title_DebugCodePattern,Y
	CMP #$FF
	BNE Title_CheatEntered	; If haven't hit end of cheat code, jump to Title_CheatEntered
	
	; Cheat entered!
	LDA #SND_LEVEL1UP
	STA Sound_QLevel1

	; Set Mario and Luigi's lives to 50
	LDA #50
	STA Player_Lives
	STA Player_Lives+1
	
	LDA #$80
	STA Debug_Flag
	
Title_CheatEntered:
	RTS		 ; Return


Title_InitSaveMenu:
	JSR Title_CommonHeroWalk
	
	LDA Title_InitSaveMCnt
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word TISM_ClearLine1	; 0: Clear "PRESS START"
	.word TISM_PrintSave	; 1: Print save slot 1
	.word TISM_PrintSave	; 2: Print save slot 2
	.word TISM_PrintSave	; 3: Print save slot 3
	.word TISM_Continue		; 4: Go to next state

TISM_SaveLineTemplate:
	;vaddr $2220
	
	.byte $20
	.byte $FC, $FC, $FC, $FC, $FC, $FC, $FC, $FC, $FC, $12, $00, $15, $04, $FC, $FF, $FC, $04, $0C, $0F, $13, $18, $FC, $FC, $FC, $FC, $FC, $FC, $FC, $FC, $FC, $FC, $FC

	; Terminator
	.byte $00
TISM_SaveLineTemplate_End

TISM_ClearLine1:
	LDA #7
	STA <Graphics_Queue

	JSR GraphicsBuf_Prep_And_WaitVSyn2

	INC <Title_InitSaveMCnt
	RTS

TISM_PrintSave:

	; Patch in address
	LDA #$22
	STA Graphics_Buffer

	LDA <Title_InitSaveMCnt
	SUB #1
	LSR A
	ROR A
	ROR A
	ROR A	; $20, $40, $60
	STA Graphics_Buffer+1

	; Copy template data into Graphics_Buffer
	LDY #(TISM_SaveLineTemplate_End - TISM_SaveLineTemplate - 1)
TISM_PrintSave_GBufCopyLoop:
	LDA TISM_SaveLineTemplate,Y
	STA Graphics_Buffer+2,Y		; +2 because we needed to patch address

	DEY
	BPL TISM_PrintSave_GBufCopyLoop

	LDA <Title_InitSaveMCnt
	ADD #$1A
	STA Graphics_Buffer+17

	JSR TISM_FillSaveSlotData

	LDA #(TISM_SaveLineTemplate_End - TISM_SaveLineTemplate)
	STA Graphics_BufCnt

	LDA #$57
	STA <Graphics_Queue
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	INC <Title_InitSaveMCnt
	RTS

TISM_Continue:
	INC <Title_State
	RTS
	
TISM_FillSaveSlotData:
	; +19

	; Calculate the checksum for this slot
	LDA <Title_InitSaveMCnt
	SUB #1
	JSR Save_CalcChecksum	; -> Temp_Var3/4
	
	; Check the stored checksum versus the needed checksum;
	; if there's a mismatch, this slot is invalid.
	LDY #(SAVE_SLOT_SIZE - 2)
	LDA [Temp_Var1],Y
	STA <Temp_Var5
	INY
	LDA [Temp_Var1],Y
	STA <Temp_Var6
	INY
	
	; Compare checksum to what is expected
	LDA <Temp_Var3
	CMP <Temp_Var5
	BNE TISM_SlotEmpty
	LDA <Temp_Var4
	CMP <Temp_Var6
	BNE TISM_SlotEmpty
	
	; Wx *yyy
	
	; W
	LDA #$16
	STA Graphics_Buffer+19

	LDY #0
	LDA [Temp_Var1],Y	; Get World
	INY
	CMP #9
	BNE TISM_PrintWorldZero
	
	LDA #-1
	
TISM_PrintWorldZero:
	ADD #$1B
	STA Graphics_Buffer+20
	
	LDA #$FC 
	STA Graphics_Buffer+21

	; *
	LDA #$8C
	STA Graphics_Buffer+22

	LDA [Temp_Var1],Y	; Get Star Low
	INY
	PHA
	LDA [Temp_Var1],Y	; Get Star High
	INY
	PHA
	
	PLA
	STA <Temp_Var2
	PLA
	STA <Temp_Var1

	JMP Save_Print3Digits

TISM_SlotEmpty:

	; Empty slot; set checksum to $0000
	LDA #$00
	LDY #(SAVE_SLOT_SIZE-2)
	STA [Temp_Var1],Y
	INY
	STA [Temp_Var1],Y
	RTS

PRG024_B166:	.byte $00, $00, $00
PRG024_B16C:	.byte $01, $0A, $64
PRG024_B172:	.byte $0F, $42, $3F 

Save_Print3Digits:
	; To print 3 digits ... stole it from the status bar code! Just less digits.

	LDY #0
	LDX #$02	 ; X = 2 (3 digits remain)
PRG024_B19A:
	LDA <Temp_Var1	 ; Get LSD -> A

	; I haven't taken time yet to discern this magic yet
	SUB PRG024_B16C,X
	STA <Temp_Var1	
	LDA <Temp_Var2	
	SBC PRG024_B166,X
	STA <Temp_Var2	

	BCC PRG024_B1B8	 	; If the subtraction didn't go negative, jump to PRG024_B1B8

	INC Score_Temp	 ; Score_Temp++

	JMP PRG024_B19A	 ; Jump to PRG024_B19A

PRG024_B1B8:
	LDA <Temp_Var1

	; I haven't taken time yet to discern this magic yet
	ADD PRG024_B16C,X
	STA <Temp_Var1	
	LDA <Temp_Var2	
	ADC PRG024_B166,X
	STA <Temp_Var2	

	LDA Score_Temp	 
	ADD #$1A	 	; A = Score_Temp + $F0 (tile to display)
	STA Graphics_Buffer+23,Y	; Store it as next digit

	LDA #$00	 	; A = 0
	STA Score_Temp	 	; Score_Temp = 0

	INY		 	; Y++
	DEX		 	; X--
	BPL PRG024_B19A	 	; While digits remain, loop!

	RTS		 ; Return


Title_DoSaveMenu:
	LDA SaveData_Index
	ASL A
	ASL A
	ASL A
	ADD #127
	STA Sprite_RAM+$FC
	LDA #$F9
	STA Sprite_RAM+$FD
	LDA #SPR_PAL0
	STA Sprite_RAM+$FE
	LDA #62
	STA Sprite_RAM+$FF

	JSR Title_CommonHeroWalk
	
	LDA <Pad_Input
	AND #(PAD_UP | PAD_DOWN)
	BEQ TDSM_NotUpDown
	
	LSR A
	LSR A
	LSR A	; 0 = down, 1 = up
	TAY

	LDA SaveData_Index
	ADD ConfigMenu_SelLR,Y
	BPL TDSM_CursorNotNeg
	
	; Went negative!
	LDA #2
	
TDSM_CursorNotNeg:
	CMP #3
	BLT TDSM_CursorNotHigh
	
	LDA #0

TDSM_CursorNotHigh
	STA SaveData_Index

	LDA #SND_MAPPATHMOVE
	STA Sound_QMap

TDSM_NotUpDown:
	LDA <Title_ResetCnt
	BNE TitleWaitStart_Cnt	; If counter is running, jump to TitleWaitStart_Cnt

	; Counter not running...

	LDA <Pad_Input
	AND #PAD_START
	BEQ TitleDoSaveMenu_NotHit	 	; If Player is not pressing START, jump to TitleWaitStart_NotHit

	; If holding A+B, this is an erase operation!
	LDA <Pad_Holding
	AND #(PAD_A | PAD_B)
	CMP #(PAD_A | PAD_B)
	BEQ TDSM_ClearSave

	LDA #SND_LEVELCOIN	 
	STA Sound_QLevel1	; Play coin sound (in this case, selected and begin!)
	
	LDA #64
	STA <Title_ResetCnt	
	BNE TitleDoSaveMenu_NotHit

TitleWaitStart_Cnt:

	DEC <Title_ResetCnt			; Title_ResetCnt--
	BNE TitleDoSaveMenu_NotHit	; If Title_ResetCnt > 0, jump to TitleWaitStart_NotHit

	LDA #6
	STA <Title_EventGrafX
	
	LDA Debug_Flag
	CMP #$80
	BNE Title_NormalStart

	LDA <Pad_Holding
	AND #PAD_A
	BEQ Title_NormalStart

	; Init debug menu!
	LDA #12
	STA Title_State
	BNE TitleDoSaveMenu_NotHit
	
Title_NormalStart
	INC <Title_State ; Next title state...
	
TitleDoSaveMenu_NotHit:	
	RTS		 ; Return


	; $2210, $2230, $2250
TDSM_ClearSaveTemplate:
	.byte 7
	.byte $04, $0C, $0F, $13, $18, $FC, $FC

	; Terminator
	.byte $00
TDSM_ClearSaveTemplate_End

Save_TestChecksum:
	; Check if there's any data; if not, don't do anything
	LDA SaveData_Index
	ASL A
	TAY
	LDA #LOW(SaveData)
	ADD Save_DataSlotOffsets,Y
	STA <Temp_Var1 
	LDA #HIGH(SaveData)
	ADC Save_DataSlotOffsets+1,Y
	STA <Temp_Var2
	
	
	; If checksum was invalid (thus slot is "empty"), it was automatically set to $0000
	LDY #(SAVE_SLOT_SIZE - 2)	; Checksum offset
	LDA [Temp_Var1],Y
	INY
	ORA [Temp_Var1],Y
	RTS

TDSM_ClearSave:
	JSR Save_TestChecksum
	BNE TDSM_ClearCont	; As long as checksum is non-zero, proceed

	; Zeroed sum; do nothing
	RTS

TDSM_ClearCont:
	; Zero out entire slot!
	LDY #(SAVE_SLOT_SIZE - 1)
	LDA #0
TDSM_ClearLoop:
	STA [Temp_Var1],Y
	DEY
	CPY #-1
	BNE TDSM_ClearLoop

	LDA #SND_PLAYERPIPE
	STA Sound_QPlayer

	; Patch in address
	LDA #$22
	STA Graphics_Buffer

	LDA SaveData_Index
	LSR A
	ROR A
	ROR A
	ROR A	; $00, $20, $40
	ORA #$10
	STA Graphics_Buffer+1

	; Copy template data into Graphics_Buffer
	LDY #(TDSM_ClearSaveTemplate_End - TDSM_ClearSaveTemplate - 1)
TISM_PrintEmpty_GBufCopyLoop:
	LDA TDSM_ClearSaveTemplate,Y
	STA Graphics_Buffer+2,Y		; +2 because we needed to patch address

	DEY
	BPL TISM_PrintEmpty_GBufCopyLoop

	LDA #$57
	STA <Graphics_Queue
	JMP GraphicsBuf_Prep_And_WaitVSyn2


Title_PrepForWorldMap:
	LDA Debug_CheatNoLoad
	BNE TPFWM_ChecksumFailed	; If starting via menu, bypass load!

	; If we have a non-zero checksum save slot, then load up the data!
	JSR Save_TestChecksum
	BEQ TPFWM_ChecksumFailed	; If empty slot, jump to TPFWM_ChecksumFailed
	
	; Copy in data...
	LDY #0
	
	; World to start
	LDA [Temp_Var1],Y
	INY
	STA World_Num
	STA Map_Previous_World
	STA Map_Previous_World+1
	
	; Skipping star coin count; the game calculates this value live
	INY
	INY
	
	; Completion data
	LDX #0
TPFWM_CopyCompData:
	LDA [Temp_Var1],Y
	INY
	STA Map_Completions,X
	INX
	CPX #(Map_ObjCompletions - Map_Completions)
	BLT TPFWM_CopyCompData

	; Map object completion data
	LDX #0
TPFWM_CopyObjCompData:
	LDA [Temp_Var1],Y
	INY
	STA Map_ObjCompletions,X
	INX
	CPX #(Map_CometMode - Map_ObjCompletions)
	BLT TPFWM_CopyObjCompData
	
	; Comet mode
	LDA [Temp_Var1],Y
	INY
	STA Map_CometMode
	
	; Inventory Items
	LDX #0
TPFWM_CopyInventoryLoop:
	LDA [Temp_Var1],Y
	INY
	STA Inventory_Items,X
	INX
	CPX #9
	BLT TPFWM_CopyInventoryLoop

	; Score 1
	LDX #0
TPFWM_CopyScore1Loop:
	LDA [Temp_Var1],Y
	INY
	STA Inventory_Score,X
	INX
	CPX #3
	BLT TPFWM_CopyScore1Loop

	; Score 2
	LDX #0
TPFWM_CopyScore2Loop:
	LDA [Temp_Var1],Y
	INY
	STA Inventory_Score2,X
	INX
	CPX #3
	BLT TPFWM_CopyScore2Loop
	
TPFWM_ChecksumFailed:
	LDA #$00
	STA World_Map_Power	 ; Mario starts as small on world map
	STA World_Map_Power+1	 ; Luigi starts as small on world map
	STA Debug_CheatNoLoad	; Clear debug flag
	INC Total_Players	 ; Total_Players should be 1/2, not 0/1
	INC <Title_State	 ; Next title state...
	
	; By default, neither world slots are ready
	LDA #$FF
	STA Map_ObjBackup_World
	STA Map_ObjBackup_World+1
	
Title_ConfigMenu_NotReady:
	RTS		 ; Return

Title_WaitForHeroes:
	JSR Title_DrawCharacterSelect
	BNE Title_ConfigMenu_NotReady	; If heroes aren't yet in position, jump to Title_ConfigMenu_NotReady

	; "PLAYER 2 / PUSH START"
	LDA #$58
	STA <Graphics_Queue

	INC <Title_State

Title_ConfigMenu:
	JSR Title_DrawCharacterSelect

	; Check if one (1P) or both (2P) Players have made their character selection
	LDX Total_Players
	LDA Title_CM_EvFlags
	AND ConfigMenu_BothSel,X
	CMP ConfigMenu_BothSel,X
	BNE PRG024_AD9C				; If Player selections are NOT done, jump to PRG024_AD9C

	LDA <Temp_Var2
	BNE PRG024_AD9C

	;LDA <Pad_Input
	;AND #PAD_START
	;BEQ PRG024_AD9C	 ; If Player is NOT pressing START, jump to PRG024_AD9C

	; RAS: Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; World_Num = 0 (World 1)
	LDA #$00
	STA World_Num
	
	
	INC <Title_State 	; Title_State = 4 (prep for world map)

	; Quick loop to set up Mario and Luigi with the lives start and world map power
	LDX Total_Players	; X = Total_Players
	LDY Player_Lives	; Y = Player_Lives
PRG024_AD69:
	TYA		 	; A = Player_Lives
	STA Player_Lives,X	; Store to this player
	LDA #$00	 
	STA World_Map_Power,X	; This player starts small on world map
	DEX		 	; X--
	BPL PRG024_AD69	 	; While X >= 0, loop...

	LDA World_Num_Debug
	STA World_Num	 	; Transfer the selected world to the game's world variable

	LDA #0
	LDX Debug_Flag
	CPX #$80
	BNE Title_ClearItems 
	
	LDA #50

Title_ClearItems:
	LDX #8
PRG024_AD7F:
	STA Inventory_Items,X	
	DEX		 ; X--
	BPL PRG024_AD7F	 ; While X >= 0, loop...


PRG024_AD9C:

	LDA <Controller2Press
	AND #PAD_START
	BEQ ConfigMenu_DrawCursors	; If Player 2 hasn't hit start, jump to ConfigMenu_DrawCursors

	LDA Total_Players
	BEQ ConfigMenu_2PJoin		; If not in 2P mode, jump to ConfigMenu_2PJoin
	
	; 2P Mode cancel...

	; "PLAYER 2 / PUSH START"
	LDA #$58
	STA <Graphics_Queue

	LDY #$88
	LDA #$F8
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y
	
	DEC Total_Players		; 1P Mode
	BEQ ConfigMenu_DrawCursors	; Jump (technically always) to ConfigMenu_DrawCursors
	
ConfigMenu_2PJoin:
	; Player 2 wants to join!
	LDA #SND_LEVELCOIN
	STA Sound_QLevel1

	; Erase "PLAYER 2 / PUSH START"
	LDA #$59
	STA <Graphics_Queue
	
	; 2P Mode
	INC Total_Players

	; Make sure 1P isn't on 2P's default...
	LDA #1
	STA Player_Character+1

	LDA Player_Character
	CMP #1
	BNE ConfigMenu_DrawCursors	; If 1P isn't on Luigi, jump to ConfigMenu_DrawCursors
	
	; Otherwise, default 2P to Mario
	DEC Player_Character+1

ConfigMenu_DrawCursors:
	; Player selection cursors
	LDA #0
	STA <Temp_Var1	; Temp_Var1 = 0 (for each Player)

	LDY #$80	; Y = $80 (Sprite_RAM offset)

ConfigMenu_DrawCursor_Loop:
	LDX <Temp_Var1		; X = current Player index

	TXA		; A = 0 or 1
	ADD #1	; A = 1 or 2
	ROR A	; Bit 0 -> C
	ROR A	; C -> Bit 7
	ROR A	; Bit 0/1 -> 6/7
	STA <Temp_Var8	; Will hold a bit to set or check if 1P/2P already made a selection

	AND <Title_CM_EvFlags
	BEQ ConfigMenu_PlayerNoSelect	; If Player hasn't made a selection yet, jump to ConfigMenu_PlayerNoSelect

	LDA #$F8
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y
	
	JMP ConfigMenu_PlayerSelected	; If Player has made a selection, jump to ConfigMenu_PlayerSelected

ConfigMenu_PlayerNoSelect:
	LDA <Controller1Press,X
	BPL Title_ConfigMenu_NotA

	; Player hit A button...
	LDA Player_Character,X
	TAX
	LDA #-$5F
	STA <Title_ObjYVel,X

	LDA #SND_PLAYERJUMP
	STA Sound_QPlayer
	
	LDA <Title_CM_EvFlags
	ORA <Temp_Var8
	STA <Title_CM_EvFlags	; Update event flags
	BNE ConfigMenu_NoSelChange	; Jump (technically always) to ConfigMenu_NoSelChange
	
Title_ConfigMenu_NotA:
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ ConfigMenu_NoSelChange

	TAX		; X = 1 if Right, 2 if Left
	
	LDA ConfigMenu_SelLR-1,X	; -1 because control is off by 1
	STA <Temp_Var3				; -> Temp_Var3
	
	; Move cursor
	LDX <Temp_Var1				; X = current Player index
	LDA Player_Character,X		; Get current Player character
	ADD <Temp_Var3				; Offset cursor
	STA <Temp_Var2				; -> Temp_Var2
	
	; Check wrap
	JSR ConfigMenu_CursorCheckWrap
	
	LDA Total_Players
	BEQ ConfigMenu_NotPOverlap	; If not in 2P mode, jump to ConfigMenu_NotPOverlap
	
	; Check if 1P/2P overlaps 2P/1P...
	
	; Invert X
	TXA
	EOR #1
	TAX
	
	; Get the other player's character
	LDA Player_Character,X
	PHA		; Save it

	; Un-Invert X
	TXA
	EOR #1
	TAX

	PLA		; Restore it
	
	CMP <Temp_Var2
	BNE ConfigMenu_NotPOverlap
	
	; Overlap!  Move one more time to dodge the other player's selection...
	ADD <Temp_Var3				; Offset cursor
	STA <Temp_Var2		; -> Temp_Var2
	
	JSR ConfigMenu_CursorCheckWrap
	
ConfigMenu_NotPOverlap:	
	
	LDA <Temp_Var2
	STA Player_Character,X		; Set current Player character
	
	LDA #SND_LEVELBLIP
	STA Sound_QLevel1
	
ConfigMenu_NoSelChange:

	LDA #$70
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y
	
	LDA <Temp_Var1		; A = current Player index
	TAX					; X = current Player index
	ASL A
	ADD #$FB	; $FB for P1, $FD for P2
	STA Sprite_RAM+$01,Y
	LDA #$FF
	STA Sprite_RAM+$05,Y
	
	LDA <Temp_Var1		; X = current Player index
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y
	
	LDX <Temp_Var1		; X = current Player index
	LDA Player_Character,X
	TAX
	LDA SelectChar_X,X
	STA Sprite_RAM+$03,Y
	ADD #8
	STA Sprite_RAM+$07,Y

ConfigMenu_PlayerSelected:
	; Next 2 sprites
	TYA
	ADD #8
	TAY
	
	INC <Temp_Var1
	LDA <Temp_Var1
	SUB #1
	CMP Total_Players
	BGS ConfigMenu_DrawCursor_Done
	JMP ConfigMenu_DrawCursor_Loop

ConfigMenu_DrawCursor_Done:
	RTS		 ; Return

ConfigMenu_CursorCheckWrap:
	LDA <Temp_Var2		; Get Player selection...
	BPL ConfigMenu_NotNeg
	
	; Went negative!  Reset to max...
	LDA #2
	BNE ConfigMenu_Set	; Jump (technically always) to ConfigMenu_Set
	
ConfigMenu_NotNeg:
	CMP #3
	BLT ConfigMenu_Set	; If < 3, jump to ConfigMenu_Set

	; Went too high!  Reset to min...
	LDA #0

ConfigMenu_Set:
	STA <Temp_Var2
	RTS

ConfigMenu_SelLR:		.byte 1, -1		; Left/Right movement
ConfigMenu_PlayerSel:	.byte $40, $80	; P1 or P2 selected character
ConfigMenu_BothSel:		.byte $40, $C0	; Bits to check that one (1P) or both (2P) Players have made their selections

T_SP_Off .func \1-Title_SpritePattern	; "Title SpritePattern Offset"

	; Index into Title_SpritePattern for all of Mario/Luigi's complex frames
Title_SpritePatternIndex:
	.byte T_SP_Off(T_SP_00), T_SP_Off(T_SP_01), T_SP_Off(T_SP_02), T_SP_Off(T_SP_03)
	.byte T_SP_Off(T_SP_04), T_SP_Off(T_SP_05), T_SP_Off(T_SP_06), T_SP_Off(T_SP_07)
	.byte T_SP_Off(T_SP_08)

	; Block of patterns, based on offsets from Title_SpritePatternIndex
	; For use with Mario/Luigi's sprites
Title_SpritePattern:
T_SP_00:	.byte $01, $03, $F1, $05, $07, $F1	; 0 Walk
T_SP_01:	.byte $0B, $0D, $F1, $0F, $29, $F1	; 1
T_SP_02:	.byte $2D, $2F, $F1, $19, $1B, $F1	; 2
T_SP_03:	.byte $0B, $0D, $F1, $0F, $29, $F1	; 3
T_SP_04:	.byte $25, $25, $F1, $27, $27, $F1	; 4 Face forward (character select)
T_SP_05:	.byte $19, $1B, $F1, $1D, $21, $F1	; 5 Jump (character select)
T_SP_06:	.byte $29, $2B, $F1, $01, $03, $3F	; 6 Fly
T_SP_07:	.byte $29, $2B, $F1, $01, $03, $05	; 7
T_SP_08:	.byte $29, $2B, $F1, $01, $03, $07	; 8


	; Specify proper VROM page for Title_ObjMLFrame sprite index
Title_SpriteVROMPage:
	.byte $00, $00, $00, $00, $00, $03, $03, $03, $03



	; Quick and dirty sprite RAM "clear" function (pushes the Y component out of visible range)
PRG024_SpriteClear:
	LDY #$1c
	LDA #$f8

PRG024_AF48:
	STA Sprite_RAM,Y
	STA Sprite_RAM+$20,Y
	STA Sprite_RAM+$40,Y
	STA Sprite_RAM+$60,Y
	STA Sprite_RAM+$80,Y
	STA Sprite_RAM+$A0,Y
	STA Sprite_RAM+$C0,Y
	STA Sprite_RAM+$E0,Y
	DEY	
	DEY	
	DEY	
	DEY	
	BPL PRG024_AF48

	RTS		 ; Return
	



; Title_AddVel_toPos
;
; This adds the X or Y velocity to an extended precision X or Y position storage
; to enable the velocity to operate as a 4.4 fixed point value, with
; a 20.4 bit X position coordinate...
Title_AddVel_toPos:
	; X is 0-7,  objects X velocity
	; X is 8-15, objects Y velocity

	; Going to perform a faux 16-bit shift 4 bits to the left on the X velocity

	LDA <Title_ObjXVel,X	; Get velocity of Mario/Luigi
	PHA		 	; Save it

	; Produce the lower half
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var12	; Temp_Var12 = velocity << 4 (multiplied by 16)

	LDY #$00	 	; Y = 0
	PLA		 	; Restore A (as velocity)

	; Produce the upper half
	LSR A
	LSR A
	LSR A
	LSR A
	CMP #$08	 	
	BLT PRG024_B088	 	; If (velocity >> 4) < 8, jump to PRG024_B088 (detects a negative source value, because there's on ASR type instruction)

	; (velocity >> 4) >= 8 ... (velocity is negative)
	DEY		 	; Y-- (Y = -1)
	ORA #$f0	 	; Simulates carrying the negative sign bit across the value, like an ASR instruction would

PRG024_B088: 
	STA <Temp_Var11		; Store resultant value into Temp_Var11

	; Register 'Y' also contains an additional level of high bits 
	; (i.e. is zero if this is positive, $FF if negative, carrying the sign across)
	STY <Temp_Var13		; Y -> Temp_Var13

	; So essentially what happened at this point is that the X velocity
	; has become a 24-bit value, shifted up 4 bits from its original
	; [Temp_Var13][Temp_Var11][Temp_Var12] = XVel << 4

	; Title_XPosFrac works as an fractional accumulator
	LDA <Title_XPosFrac,X
	ADD <Temp_Var12
	STA <Title_XPosFrac,X	; Title_XPosFrac += Temp_Var12

	; ... which, as it overflows, provides a carry into the "whole" part
	LDA <Title_ObjX,X
	ADC <Temp_Var11	
	STA <Title_ObjX,X	; Title_ObjX += Temp_Var11 + Carry

	; ... and if that overflows, the carry goes into the "high" part...
	LDA <Title_XPosHi,X	
	ADC <Temp_Var13	
	STA <Title_XPosHi,X	; Further precision of the X position stored here

	RTS		 	; Return...


; Title_MLYAccel
;
; Figures out Mario/Luigi's Y acceleration and applies it (including "gravity", and max fall rate)
Title_MLYAccel:
	LDA <Title_ObjYVel,X
	BMI Title_ApplyYVel	 	; If Y velocity is negative, jump to Title_ApplyYVel

	CMP #FALLRATE_MAX
	BLS Title_ApplyYVel		; If Y velocity is less than FALLRATE_MAX, jump to Title_ApplyYVel

	; Prevent Y velocity from being greater than FALLRATE_MAX
	; This defines the maximum fall speed!
	LDA #FALLRATE_MAX	 
	STA <Title_ObjYVel,X

Title_ApplyYVel:

	; NOTE: The "minor" objects also use code starting HERE (they have different fall/max rates)

	TXA		 ; X (object index) -> A
	PHA		 ; Save A

	; The index gets an offset added to it; this allows reuse of the velocity
	; precision adding function as X or Y velocity... relies on all pertinent values
	; to be exactly the same bytes apart...
	ADD #(Title_ObjYVel - Title_ObjXVel)
	TAX		 ; X = (object index) + 8

	JSR Title_AddVel_toPos	 ; Apply Y velocity

	PLA		 ; Restore A
	TAX		 ; Restore X back to the index value

	RTS		 ; Return

PRG024_B0B8:
	.byte $07, $06, $05, $04, $03, $02, $01, $01, $01



	; Defines offsets of 16, 8, or 0 for sprite while building
Title_SpriteOffX:
	.byte 16, 8, 0

	; Per-power level offset to the VROM page
Title_SpriteVROMPwrOff:
	.byte 151	; 0 Small
	.byte 156	; 1 Big
	.byte 161	; 2 Leaf Raccoon
	
Title_SpriteVROMCharOff:
	.byte 0		; Mario
	.byte 30	; Luigi
	.byte 60	; Toad

; Title_DrawMarioLuigi
;
; Not literally "draw", of course, but set up their hardware
; sprites in Sprite_RAM to be "drawn"...
Title_DrawMarioLuigi:
	; Input object is assumed to be 0 (Mario) or 1 (Luigi)

	LDY <Title_ObjMLFrame,X	; Get the sprite to display
	LDA Title_SpriteVROMPage,Y	; Get appropriate VROM page for this sprite index

	; VROM pages 0 - 3 are power-up based and an offset is added depending on the bro's power levels
	CMP #$04
	BGE PRG024_B21E	 		; If VROM page >= 4, jump to PRG024_B21E

	STA <Temp_Var1		 	; Store VROM Page in Temp_Var1
	
	LDY <Title_ObjMLPower,X	 	; Power level -> Y
	LDA Title_SpriteVROMPwrOff,Y	; Get VROM page offset for this power level
	ADD Title_SpriteVROMCharOff,X
	ADD <Temp_Var1		 	; Add Temp_Var1

PRG024_B21E:
	STA PatTable_BankSel+2,X 	; Set this VROM page (first quarter of sprite VROM)

	LDA #$00	 
	STA <Temp_Var12		; Clear Temp_Var12

	LDA <Title_ObjMLPower,X	 	
	BNE PRG024_B232	 		; If power level > 0 (small), jump to PRG024_B232

	LDA <Title_ObjMLDir,X	 
	AND #$10	 	
	BEQ PRG024_B232	 		; If Title_ObjMLDir does not want to set sprite priority bit, jump to PRG024_B232

	; This will set BG priority over the sprite
	ASL A		 		; AND $10 means we're $10 before, and $20 after
	STA <Temp_Var12		; Temp_Var12 = $20 (sprite priority bit)

PRG024_B232: 
	; Store Y coordinate -> <Temp_Var15
	LDA <Title_ObjY,X
	STA <Temp_Var15	

	; Store X coordinate -> <Temp_Var16
	LDA <Title_ObjX,X
	STA <Temp_Var16

	; Store flags -> Temp_Var14 
	LDA <Title_ObjMLFlags,X	 
	STA <Temp_Var14		

	; Store Title_ObjMLSprVis -> Temp_Var13
	LDA <Title_ObjMLSprVis,X
	STA <Temp_Var13		
 
	LDY <Title_ObjMLFrame,X	; Get the sprite index again
	LDA Title_SpritePatternIndex,Y	; Get the appropriate sprite tile index (CHECKME?) 
	STA <Temp_Var1		 	; Store into Temp_Var1

	LDA <Title_ObjMLSprRAMOff,X 	; Get Mario/Luigi's sprite RAM offset
	PHA		 		; Save 'A' (Title_ObjMLSprRAMOff)

	TAX		 		; X = Title_ObjMLSprRAMOff
	LDY #$02	 		; Y = 2

	; Loop begin...
PRG024_B24F:
	TYA		 		; A = 2 (loop counter, Mario/Luigi are 2-3 sprites across [top vs bottom])
	PHA		 		; Save 'A' 

	LDY <Temp_Var1		 	; Y = sprite tile index

	LDA Title_SpritePattern,Y	 	; Get tile for this sprite index
	STA Sprite_RAM+$0D,X	 	; Set pattern number of sprite

	LDA Title_SpritePattern + 3,Y	; Get next tile for this sprite index
	STA Sprite_RAM+$01,X	 	; Set pattern number of adjacent sprite

	PLA		 		; Restore 'A'
	TAY		 		; Y = A (amounts to sprite offset of 0 @ 2, 8 @ 1, 16 @ 0)

	LDA <Temp_Var14		; Get flags value
	;AND #%11000000	 		; Only caring about the horizontal / vertical flip
	ORA <Title_CurMLIndex		; Set appropriate palette by using the index value, which works out
	ORA <Temp_Var12		; 0 or $20 (choosing priority)

	; Apply same "byte 2" to both sprites
	STA Sprite_RAM+$02,X	
	STA Sprite_RAM+$0E,X	

	; Only set the Y coordinates if this part of the sprite is visible (as determined by Title_MLDetermineSpriteVis)
	; If the carry is set by the shift, we know NOT to draw this "sliver" of the sprite
	ASL <Temp_Var13		; Shift Title_ObjMLSprVis value left (updates Temp_Var13)
	BCS PRG024_B27E	 	; If bit 7 was set, jump to PRG024_B27E

	; Optionally skipped part...

	LDA <Temp_Var15		; Get Y coordinate
	STA Sprite_RAM+$0C,X	; Set Y coordinate of sprite
	ADD #16
	STA Sprite_RAM,X	; Set Y coordinate of adjacent sprite, 16 pixels beneath the one above

PRG024_B27E:

	LDA <Temp_Var16	; Get X coordinate
	ADD Title_SpriteOffX,Y	; Add offset of 16, 8, or 0 as appropriate by 'Y'
	STA Sprite_RAM+$03,X	; Store X coordinate
	STA Sprite_RAM+$0F,X	; Store X coordinate

	INX
	INX
	INX
	INX			; X += 4

	INC <Temp_Var1		; Increment the sprite tile index
	DEY		 	; Decrement Y
	BPL PRG024_B24F	 	; As long as Y >= 0, loop

	PLA		 	; Restore 'A' (Title_ObjMLSprRAMOff)
	TAX		 	; X = A

	LDA <Temp_Var14	; Get flags
	AND #%01000000	 	
	BEQ PRG024_B2C3	 	; If not horizontally flipped, jump to PRG024_B2C3

	; This mirrors the sprite layout horizontally

	; Reverse pattern index
	LDA Sprite_RAM+$01,X
	PHA		 
	LDA Sprite_RAM+$05,X
	STA Sprite_RAM+$01,X
	PLA		 
	STA Sprite_RAM+$05,X

	; Reverse X coordinates
	LDA Sprite_RAM+$0B,X
	ADD #-24
	STA Sprite_RAM+$0B,X
	STA Sprite_RAM+$17,X

	LDA Sprite_RAM+$D,X
	PHA		 
	LDA Sprite_RAM+$11,X
	STA Sprite_RAM+$D,X
	PLA		 
	STA Sprite_RAM+$11,X

PRG024_B2C3:
	LDA Sprite_RAM+$01,X
	CMP Sprite_RAM+$05,X
	BNE PRG024_B2DE	 	; If the first and second patterns are NOT the same, jump to PRG024_B2DE

	; When the first and second patterns are the same, this is assumed to be a "mirrored" sprite
	; (Think the "going down pipe" or "tail swing" face-forward frames)

	LDA Sprite_RAM+$0E,X	; Take attributes of this sprite
	AND #%10111111	 	; Keep everything EXCEPT the horizontal flip bit
	STA Sprite_RAM+$02,X	; Update both top  
	STA Sprite_RAM+$0E,X	; ... and bottom

	ORA #%01000000	 	; Set the horizontal flip
	STA Sprite_RAM+$06,X	; Update the other side
	STA Sprite_RAM+$12,X	; Ditto

PRG024_B2DE:
	LDY <Title_CurMLIndex	; Y = Mario [0] or Luigi [1]
	LDA Title_ObjMLFrame,Y	; Get their current sprite index
	CMP #$FF		; RAS: Currently not implementing "kicking out" frames, this code will probably be dead
	BNE PRG024_B307	 	; If current sprite is not $0D (kicking outward), jump to PRG024_B307

	; The kicking sprite needs one of the sprites in front for the outward foot!
	LDA Sprite_RAM,X	 
	STA Sprite_RAM+$14,X	 ; Match the Y coordinate

	; Facing left, foot is to the left
	LDA #-8			; A = -8

	; This refers to whether Mario / Luigi is horizontally flipped, but seems wrong?
	; Should only check if NOT h-flipped?

	LDY <Temp_Var14	; Y = Flags
	BEQ PRG024_B2F6		; If flags = 0 (?? this is unlikely?), jump to PRG024_B2F6

	; Facing right, foot is to the right
	LDA #16			; A = 16

PRG024_B2F6:
	ADD Sprite_RAM+$0F,X	; Apply X offset
	STA Sprite_RAM+$17,X	; Duplicate result

	LDA #$1b	 	; Foot pattern
	STA Sprite_RAM+$15,X	; Set it

	; Duplicate attribute settings
	LDA Sprite_RAM+$0E,X
	STA Sprite_RAM+$16,X

PRG024_B307:
	LDY #$05	 	; Y = 5 (loop through all five sprites for Mario/Luigi)

PRG024_B309:
	LDA Sprite_RAM+$01,X	; Get pattern
	CMP #$f1	 
	BNE PRG024_B317	 	; If pattern is not $F1, jump to PRG024_B317

	; Pattern $F1 is used as a disable:
	LDA #$f8	 	
	STA Sprite_RAM,X	; Forces this sprite's Y into oblivion, making it invisible
	BNE PRG024_B324	 	; Jump (technically always) to PRG024_B324

PRG024_B317:
	LDA <Title_CurMLIndex	
	ASL A
	ASL A
	ASL A
	ASL A
	ASL A
	ASL A

	ADD Sprite_RAM+$01,X
	STA Sprite_RAM+$01,X

PRG024_B324:
	INX
	INX
	INX
	INX		 ; X += 4 (next sprite)
	DEY		 ; Y--
	BPL PRG024_B309	 ; Loop while Y >= 0

	
	LDX <Title_CurMLIndex	; Leaving with 'X' set to what it entered with!
	RTS		 ; Return


	; XOff and XHiOff are basically 16-bit values when put together

Title_MLSpriteVis_XHiOff:
	.byte 0, 0, 0		; Not H-Flipped
	.byte 0, 0, $FF		; H-Flipped ($FF represents a full set of sign bits, for the corresponding '-8' in XOff)

Title_MLSpriteVis_XOff:
	.byte 0, 8, 16		; Not H-Flipped
	.byte 0, 8, -8		; H-Flipped

Title_MLSpriteVis_BitVal:
	; Bit vals to mark which slivers NOT to display
	.byte $80, $40, $20	; Not H-Flipped
	.byte $80, $40, $20	; H-Flipped

; Title_MLDetermineSpriteVis
;
; This function determines which "slivers" of the Player sprite are invisible, by checking if they
; cross screen boundaries (which will make them invisible), to prevent sprites "wrapping" around
; the screen, due to the limit of the 'X' part of the sprite coordinate...
Title_MLDetermineSpriteVis:
	LDA #$00	 	; A = 0
	STA <Title_ObjMLSprVis,X	; Clear Title_ObjMLSprVis

	LDY #$02	 	; Y = 2 (not H-flipped)

	LDA <Title_ObjMLFlags,X	; Get flags -> 'A'
	AND #SPR_HFLIP
	BEQ PRG024_B34E	 	; If not flipped horizontally, jump to PRG024_B34E

	LDY #$05	 	; Y = 5 (H-flipped)

	; This will loop 5, 4, 3 (H-flipped) OR 2, 1, 0 (not H-flipped)
PRG024_B34E:

	; 16-bit + 16-bit add here [Title_XPosHi][Title_ObjX] += [XHiOff][XOff]
	LDA <Title_ObjX,X		; Get object's X position
	ADD Title_MLSpriteVis_XOff,Y	; A += Title_MLSpriteVis_XOff[Y]
	LDA <Title_XPosHi,X		; Get object's "high" part of the X value
	ADC Title_MLSpriteVis_XHiOff,Y	; A += Title_MLSpriteVis_XHiOff[Y], with carry from previous op

	BEQ PRG024_B362	 		; If the X pos high value added with the Title_MLSpriteVis_XHiOff[Y] value is zero, jump to PRG024_B362

	; Otherwise, set a bit
	LDA <Title_ObjMLSprVis,X
	ORA Title_MLSpriteVis_BitVal,Y	
	STA <Title_ObjMLSprVis,X	 	; Title_ObjMLSprVis |= Title_MLSpriteVis_BitVal[Y]

PRG024_B362:
	DEY		 	; Y--
	BMI PRG024_B369	 	; If Y < 0, jump to PRG024_B369 (RTS)

	CPY #$02	
	BNE PRG024_B34E	 	; If Y <> 2, jump to PRG024_B34E

PRG024_B369:
	RTS		 ; Return


Title_ObjXVelApply: 
	INX		 
	INX		 ; X += 2 (going to use A Mario/Luigi included function, which uses a larger index span... objects start at index 2)

	JSR Title_AddVel_toPos	 ; Apply X velocity as is

	DEX		 
	DEX		 ; X -= 2 (restoring objects to their local index)
	RTS		 ; Return


Title_ApplyYVelFall:
	; X is 0-5, an index to one of the "minor" objects

	LDA <Title_ObjYVel+2,X
	BMI PRG024_B782	 	; If object's Y velocity < 0, jump to PRG024_B782

	CMP #FALLRATE_OBJECTMAX
	BLS PRG024_B782	 	; If object's Y velocity < FALLRATE_OBJECTMAX, jump to PRG024_B782

	; Prevent objects from falling faster than FALLRATE_OBJECTMAX	
	LDA #$60
	STA <Title_ObjYVel+2,X

PRG024_B782:
	INX		 
	INX		 ; X += 2 (going to use A Mario/Luigi included function, which uses a larger index span... objects start at index 2)

	JSR Title_ApplyYVel	 ; Apply Y velocity

	DEX		 
	DEX		 ; X -= 2 (restoring objects to their local index)
	RTS		 ; Return



EndLevelDef	.macro
	.word \1	; Level pointer
	.byte (\2 << 7) | \3	; YHi and tileset
	.byte (\4 << 4) | (\5)	; Start and End Scroll
	.endm

Ending_Levels:
	;			Layout			YHi	TS	XS	XE
	EndLevelDef W8BCastlCL, 	0,	15,	10,  6		; 1
	EndLevelDef W703L,			1,	14, 13,	10		; 2
	EndLevelDef W602L,			1,	 7,  4,	 0		; 3
	EndLevelDef W501L, 			1,	 9,	 8,	 4		; 4
	EndLevelDef W402L, 			1,	 1,	 8,	 4		; 5
	EndLevelDef W301L,			0,	 1,  6,	 2		; 6
	EndLevelDef W201AL,			1,	 4,  8,	 4		; 7
	EndLevelDef W101AL,			1,	 1,  4,	 0		; 8
	EndLevelDef KNG1L,			1,	 2,	 0,	 0		; 9

Ending_Text1:
	;       A    n    d         s    o         t    h    e         p    r    i    n    c    e    s    s         w    a    s         s    a    v    e    d    
	.byte $B0, $DD, $D3, $FE, $CC, $DE, $FE, $CD, $D7, $D4, $FE, $DF, $CB, $D8, $DD, $D2, $D4, $CC, $CC, $FE, $81, $D0, $CC, $FE, $CC, $D0, $CF, $D4, $D3, $00

	;       a    n    d         p    e    a    c    e         r    e    s    t    o    r    e    d         t    o         t    h    e    
	.byte $D0, $DD, $D3, $FE, $DF, $D4, $D0, $D2, $D4, $FE, $CB, $D4, $CC, $CD, $DE, $CB, $D4, $D3, $FE, $CD, $DE, $FE, $CD, $D7, $D4, $00

	;       M    u    s    h    r    o    o    m         K    i    n    g    d    o    m         a    n    d         g    a    l    a    x    y    !    
	.byte $BC, $CE, $CC, $D7, $CB, $DE, $DE, $DC, $FE, $BA, $D8, $DD, $D6, $D3, $DE, $DC, $FE, $D0, $DD, $D3, $FE, $D6, $D0, $DB, $D0, $88, $8C, $EA, $FF

Ending_Text2:
	;       S    p    e    c    i    a    l         t    h    a    n    k    s         t    o         M    F    G    G         f    o    r    
	.byte $C2, $DF, $D4, $D2, $D8, $D0, $DB, $FE, $CD, $D7, $D0, $DD, $DA, $CC, $FE, $CD, $DE, $FE, $BC, $B5, $B6, $B6, $FE, $D5, $DE, $CB, $00

	;       t    h    e         u    s    e    f    u    l         s    p    r    i    t    e         a    r    c    h    i    v    e    s    .
	.byte $CD, $D7, $D4, $FE, $CE, $CC, $D4, $D5, $CE, $DB, $FE, $CC, $DF, $CB, $D8, $CD, $D4, $FE, $D0, $CB, $D2, $D7, $D8, $CF, $D4, $CC, $E9, $00

	;       h    t    t    p    :    /    /    m    f    g    g    .    n    e    t    
	.byte $D7, $CD, $CD, $DF, $FB, $FA, $FA, $DC, $D5, $D6, $D6, $E9, $DD, $D4, $CD, $FF

Ending_Text3:
	;       S    p    e    c    i    a    l         t    h    a    n    k    s         t    o         V    G    M    u    s    i    c         f    o    r    
	.byte $C2, $DF, $D4, $D2, $D8, $D0, $DB, $FE, $CD, $D7, $D0, $DD, $DA, $CC, $FE, $CD, $DE, $FE, $C5, $B6, $BC, $CE, $CC, $D8, $D2, $FE, $D5, $DE, $CB, $00

	;       t    h    e         M    I    D    I    s         m    u    s    i    c         w    a    s         b    a    s    e    d         o    n    .    
	.byte $CD, $D7, $D4, $FE, $BC, $B8, $B3, $B8, $CC, $FE, $DC, $CE, $CC, $D8, $D2, $FE, $81, $D0, $CC, $FE, $D1, $D0, $CC, $D4, $D3, $FE, $DE, $DD, $E9, $00

	;       h    t    t    p    :    /    /    v    g    m    u    s    i    c    .    c    o    m    
	.byte $D7, $CD, $CD, $DF, $FB, $FA, $FA, $CF, $D6, $DC, $CE, $CC, $D8, $D2, $E9, $D2, $DE, $DC, $FF

Ending_Text4:
	;       T    h    a    n    k    s         t    o         m    y         b    r    o    t    h    e    r         '    Z    y    d    e    l    s    k    i    '    
	.byte $C3, $D7, $D0, $DD, $DA, $CC, $FE, $CD, $DE, $FE, $DC, $8C, $FE, $D1, $CB, $DE, $CD, $D7, $D4, $CB, $FE, $AB, $C9, $8C, $D3, $D4, $DB, $CC, $DA, $D8, $AB, $00

	;       f    o    r         t    h    e         w    o    r    k         h    e         d    i    d         o    n         n    e    w    
	.byte $D5, $DE, $CB, $FE, $CD, $D7, $D4, $FE, $81, $DE, $CB, $DA, $FE, $D7, $D4, $FE, $D3, $D8, $D3, $FE, $DE, $DD, $FE, $DD, $D4, $81, $00

	;       s    p    r    i    t    e    s    !    
	.byte $CC, $DF, $CB, $D8, $CD, $D4, $CC, $EA, $FF

Ending_Text5:
	;       T    h    a    n    k    s         t    o         m    y         s    i    s    t    e    r         '    L    a    d    y    
	.byte $C3, $D7, $D0, $DD, $DA, $CC, $FE, $CD, $DE, $FE, $DC, $8C, $FE, $CC, $D8, $CC, $CD, $D4, $CB, $FE, $AB, $BB, $D0, $D3, $8C, $00

	;       P    e    o    n    y    '         f    o    r         t    h    e         p    l    a    y    t    h    r    o    u    g    h    
	.byte $BF, $D4, $DE, $DD, $8C, $AB, $FE, $D5, $DE, $CB, $FE, $CD, $D7, $D4, $FE, $DF, $DB, $D0, $8C, $CD, $D7, $CB, $DE, $CE, $D6, $D7, $00

	;       a    n    d         b    u    g    -    f    i    n    d    i    n    g         m    i    s    s    i    o    n    !    
	.byte $D0, $DD, $D3, $FE, $D1, $CE, $D6, $FE, $D5, $D8, $DD, $D3, $D8, $DD, $D6, $FE, $DC, $D8, $CC, $CC, $D8, $DE, $DD, $EA, $FF

Ending_Text6:
	;       T    h    a    n    k    s         t    o         m    y         Y    o    u    T    u    b    e         v    i    e    w    e    r    s    
	.byte $C3, $D7, $D0, $DD, $DA, $CC, $FE, $CD, $DE, $FE, $DC, $8C, $FE, $C8, $DE, $CE, $C3, $CE, $D1, $D4, $FE, $CF, $D8, $D4, $81, $D4, $CB, $CC, $00

	;       a    n    d         s    u    b    s    c    r    i    b    e    r    s         w    h    o         h    a    v    e    
	.byte $D0, $DD, $D3, $FE, $CC, $CE, $D1, $CC, $D2, $CB, $D8, $D1, $D4, $CB, $CC, $FE, $81, $D7, $DE, $FE, $D7, $D0, $CF, $D4, $00

	;       c    h    e    e    r    e    d         m    e         o    n         a    l    l         t    h    i    s         t    i    m    e    !    
	.byte $D2, $D7, $D4, $D4, $CB, $D4, $D3, $FE, $DC, $D4, $FE, $DE, $DD, $FE, $D0, $DB, $DB, $FE, $CD, $D7, $D8, $CC, $FE, $CD, $D8, $DC, $D4, $EA, $FF

Ending_Text7:
	;       A    n    d         o    f         c    o    u    r    s    e    ,         a         v    e    r    y         s    p    e    c    i    a    l    
	.byte $B0, $DD, $D3, $FE, $DE, $D5, $FE, $D2, $DE, $CE, $CB, $CC, $D4, $9A, $FE, $D0, $FE, $CF, $D4, $CB, $8C, $FE, $CC, $DF, $D4, $D2, $D8, $D0, $DB, $00

	;       t    h    a    n    k    s         t    o         y    o    u    ,         t    h    e         p    l    a    y    e    r    !    
	.byte $CD, $D7, $D0, $DD, $DA, $CC, $FE, $CD, $DE, $FE, $8C, $DE, $CE, $9A, $FE, $CD, $D7, $D4, $FE, $DF, $DB, $D0, $8C, $D4, $CB, $EA, $FF

Ending_Text8:
	;       S    u    p    e    r         M    a    r    i    o         B    r    o    s    .         3    M    i    x    
	.byte $C2, $CE, $DF, $D4, $CB, $FE, $BC, $D0, $CB, $D8, $DE, $FE, $B1, $CB, $DE, $CC, $E9, $FE, $F3, $BC, $D8, $88, $00

	;       b    y         S    o    u    t    h    b    i    r    d         2    0    1    4    
	.byte $D1, $8C, $FE, $C2, $DE, $CE, $CD, $D7, $D1, $D8, $CB, $D3, $FE, $F2, $F0, $F1, $F4, $FF


Ending_Texts:
	.word (Ending_Text1 - Ending_Text1)
	.word (Ending_Text2 - Ending_Text1)
	.word (Ending_Text3 - Ending_Text1)
	.word (Ending_Text4 - Ending_Text1)
	.word (Ending_Text5 - Ending_Text1)
	.word (Ending_Text6 - Ending_Text1)
	.word (Ending_Text7 - Ending_Text1)
	.word (Ending_Text8 - Ending_Text1)

Ending2_Text1:	.byte $C6, $BE, $C1, $BB, $B3, $FE, $F1, $00, $BC, $CE, $CC, $D7, $CB, $DE, $DE, $DC, $FE, $BA, $D8, $DD, $D6, $D3, $DE, $DC, $FF
Ending2_Text2:	.byte $C6, $BE, $C1, $BB, $B3, $FE, $F2, $00, $FE, $FE, $FE, $FE, $FE, $C2, $CE, $D1, $D2, $DE, $DD, $FE, $FE, $FE, $FE, $FE, $FF
Ending2_Text3:	.byte $C6, $BE, $C1, $BB, $B3, $FE, $F3, $00, $FE, $FE, $B1, $DE, $DE, $AB, $CC, $FE, $C6, $DE, $DE, $D3, $CC, $FE, $FE, $FE, $FF
Ending2_Text4:	.byte $C6, $BE, $C1, $BB, $B3, $FE, $F4, $00, $FE, $B3, $D8, $DD, $DE, $CC, $D0, $CE, $CB, $FE, $BB, $D0, $DD, $D3, $FE, $FE, $FF
Ending2_Text5:	.byte $C6, $BE, $C1, $BB, $B3, $FE, $F5, $00, $B1, $D8, $CB, $D0, $D1, $CE, $CD, $DE, $FE, $BA, $D8, $DD, $D6, $D3, $DE, $DC, $FF
Ending2_Text6:	.byte $C6, $BE, $C1, $BB, $B3, $FE, $F6, $00, $FE, $FE, $B8, $CC, $DB, $D4, $FE, $B3, $D4, $DB, $D5, $D8, $DD, $DE, $FE, $FE, $FF
Ending2_Text7:	.byte $C6, $BE, $C1, $BB, $B3, $FE, $F7, $00, $FE, $B6, $CB, $D4, $D0, $CD, $D4, $CB, $FE, $B6, $D0, $DB, $D0, $88, $8C, $FE, $FF
Ending2_Text8:	.byte $C6, $BE, $C1, $BB, $B3, $FE, $F8, $00, $FE, $B1, $DE, $81, $CC, $D4, $CB, $AB, $CC, $FE, $B6, $D0, $DB, $D0, $88, $8C, $FF

Ending2_Texts:
	.byte (Ending2_Text1 - Ending2_Text1)
	.byte (Ending2_Text2 - Ending2_Text1)
	.byte (Ending2_Text3 - Ending2_Text1)
	.byte (Ending2_Text4 - Ending2_Text1)
	.byte (Ending2_Text5 - Ending2_Text1)
	.byte (Ending2_Text6 - Ending2_Text1)
	.byte (Ending2_Text7 - Ending2_Text1)
	.byte (Ending2_Text8 - Ending2_Text1)

Ending_LineStarts:
	.word $2B21, $2B41, $2B61, $2B81

Ending2_LineStarts:
	.word $2B2C, $2B48, $2B61, $2B81

Ending2_Advance:
	.word $0080	;W2
	.word $01E0	;W3
	.word $0340	;W4
	.word $0550	;W5
	.word $06E0	;W6
	.word $0870	;W7
	.word $0AF0	;W8
	.word $FFFF

EndingLevel_YStart:		.byte $00, $80
EndingLevel_YHiStart:	.byte $00, $01

Ending_CalcLevelIndex:
	LDA Player_RescuePrincess
	SUB #1		; Starts at 1, so decrement
	ASL A
	ASL A
	TAY
	
	RTS

Rescue_Princess:
	LDA Player_RescuePrincess
	BPL Ending_Normal	; If not doing the World Zero ending, jump to Ending_Normal

	JMP Ending_WorldZero

Ending_Normal:
	JSR Ending_CalcLevelIndex

	LDA Ending_Levels,Y
	STA <Level_LayPtr_AddrL
	LDA Ending_Levels+1,Y
	STA <Level_LayPtr_AddrH
	
	LDA #LOW(Empty_ObjLayout)
	STA <Level_ObjPtr_AddrL
	LDA #HIGH(Empty_ObjLayout)
	STA <Level_ObjPtr_AddrH
	
	LDA Ending_Levels+2,Y
	AND #$7F
	STA Level_Tileset
		
	; Fake a checkpoint to start scrolling at a different point
	LDX Player_Current
	LDA LevCP_ByPlayer,X
	TAX

	LDA #$80
	STA LevCP_X,X
	LDA Ending_Levels+3,Y	; High scroll is upper bits
	LSR A
	LSR A
	LSR A
	LSR A
	STA LevCP_XHi,X
		
	; Set Y pixel start for Player
	LDA Ending_Levels+2,Y
	AND #$80
	ASL A
	ROL A
	TAY
	
	LDA EndingLevel_YStart,Y
	STA LevCP_Y,X
	LDA EndingLevel_YHiStart,Y
	STA LevCP_YHi,X

	; Force the checkpoint IDs
	LDA #0
	STA LevCP_ID,X
	STA LevCP_ActiveID
	
	; Pretend we have all star coins so they don't generate
	; RAS: Bleh, none show up in the ending anyway, and this
	; introduces a bug of "free star coins!!" regardless of 
	; what you actually obtained, so NO!
	;LDA #$01
	;STA Inventory_Cards
	;STA Inventory_Cards+1
	;STA Inventory_Cards+2
	
	JMP PRG062_88AD
	
	
Ending_Loop:

	LDA #0
	STA Ending_TextPos

	LDA Ending_LineStarts
	STA Ending_VAddrL
	LDA Ending_LineStarts+1
	STA Ending_VAddrH

	LDA #0
	STA Ending_LineNum

Ending_InnerLoop:
	JSR Ending_DrawHeroFly

	LDA SndCur_Music2
	CMP #MUS2A_ENDING
	BEQ Ending_MusicSet
	
	LDA #MUS2A_ENDING
	STA Sound_QMusic2

Ending_MusicSet:
	JSR GraphicsBuf_Prep_And_WaitVSync
	JSR Level_DoAnimations
	JSR LevelScroll_Set_Ranges

	JSR Ending_UpdateText

	JSR Ending_CalcLevelIndex

	LDA <Horz_Scroll
	SUB #1
	STA <Horz_Scroll
	LDA <Horz_Scroll_Hi
	SBC #0
	STA <Horz_Scroll_Hi

	PHA		 ; Save scroll Hi
	
	LDA Ending_Levels+3,Y	; Low scroll is lower bits
	AND #$0F
	STA <Temp_Var1
	
	PLA		; Restore scroll Hi
	CMP <Temp_Var1
	BEQ Ending_NextLevel

	LDA #1
	STA <Scroll_LastDir

	JSR Scroll_Update_Ending

	JMP Ending_InnerLoop
	
Ending_NextLevel:
	INC Player_RescuePrincess

	; Switch bank A000 to page 26
	JSR_THUNKA 26, Palette_FadeOut
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Likely just using this for VSync

	LDA Player_RescuePrincess
	CMP #9
	BLT Ending_NotTheEnd

	; Final!
	INC Player_FallToKing
	
Ending_NotTheEnd:
	JMP Rescue_Princess
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Ending_UpdateText
;
; This is a sticky wicket indeed.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Ending_UpdateText:

	LDA Player_RescuePrincess
	BPL EUT_NormalEnding

	; World Zero's ending
	LDA #LOW(Ending2_Text1)
	STA <Temp_Var1
	LDA #HIGH(Ending2_Text1)
	STA <Temp_Var2
	BNE EUT_EndingCont

EUT_NormalEnding:
	LDA Player_RescuePrincess
	SUB #1
	ASL A
	TAY

	LDA #LOW(Ending_Text1)
	ADD Ending_Texts,Y
	STA <Temp_Var1
	LDA #HIGH(Ending_Text1)
	ADC Ending_Texts+1,Y
	STA <Temp_Var2
		
EUT_EndingCont:
	LDY Ending_TextPos
	LDA [Temp_Var1],Y
	BNE EUT_NotLineBreak
	
	; Line break!
	INC Ending_LineNum
	LDA Ending_LineNum
	ASL A
	
	LDX Player_RescuePrincess
	BPL EUT_NotEnding2

	ADD #(Ending2_LineStarts - Ending_LineStarts)
	
EUT_NotEnding2:
	TAX
	LDA Ending_LineStarts,X
	STA Ending_VAddrL
	INX
	LDA Ending_LineStarts,X
	STA Ending_VAddrH
	
	BNE EUT_EndLineBreak
	
EUT_NotLineBreak:
	CMP #$FF
	BEQ EUT_Done	; If at the termination character, nothing to do, jump to EUT_Done (RTS)
	
	PHA		; Save read character
	
	LDY Graphics_BufCnt 	; Current position within graphics buffer

	LDA Ending_VAddrH
	STA Graphics_Buffer,Y
	LDA Ending_VAddrL
	STA Graphics_Buffer+1,Y
	
	LDA #1
	STA Graphics_Buffer+2,Y
	
	PLA		; Restore read character
	STA Graphics_Buffer+3,Y
	
	LDA #0
	STA Graphics_Buffer+4,Y
	
	TYA
	ADD #5
	STA Graphics_BufCnt
	
	; Increment pos
	LDA Ending_VAddrL
	ADD #1
	STA Ending_VAddrL
	LDA Ending_VAddrH
	ADC #0
	STA Ending_VAddrH
	
EUT_EndLineBreak:
	INC Ending_TextPos
	
EUT_Done:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Ending_DrawHeroFly
;
; Draw the heroes proudly flying away!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HeroFly_YBase:		.byte $22, $42, $32
HeroFly_X:			.byte $40, $80, $C0

HeroFly_YVelDelta:	.byte $01, -$01
HeroFly_YVelLimit:	.byte $10, -$10

Ending_DrawHeroFly:
	LDX #0
HeroFly_Loop:
	LDA <Title_ObjMLFrame,X
	CMP #6
	BGE HeroFly_FrameInit

	LDA #6
	STA <Title_ObjMLFrame,X

	LDA HeroFly_YBase,X
	STA <Title_ObjY,X

	LDA #$01
	STA <Title_ObjMLMoveDir,X

	; Don't fly in sync, it's silly
	TXA
	ASL A
	ASL A
	STA <Title_ObjYVel,X

HeroFly_FrameInit:

	LDA IntroChar_SprOff,X
	STA <Title_ObjMLSprRAMOff,X
	
	LDA HeroFly_X,X
	STA <Title_ObjX,X

	LDY Title_ObjMLMoveDir,X
	LDA <Title_ObjYVel,X
	ADD HeroFly_YVelDelta,Y
	STA <Title_ObjYVel,X
	CMP HeroFly_YVelLimit,Y
	BNE HeroFly_NotYVelMax

	; Reverse float direction
	LDA Title_ObjMLMoveDir,X
	EOR #1
	STA Title_ObjMLMoveDir,X

HeroFly_NotYVelMax:
	JSR Title_ApplyYVel	 ; Apply Y velocity

	LDA #2
	STA Title_ObjMLPower,X	

	TXA
	STA <Title_CurMLIndex

	LDA #0
	STA <Title_ObjMLFlags,X

	TXA
	ASL A
	ADD <Counter_1
	AND #3
	BNE HeroFly_NotExpired

	LDA <Title_ObjMLFrame,X
	ADD #1
	CMP #9
	BLT HeroFly_FrameOK
	
	LDA #6

HeroFly_FrameOK:
	STA <Title_ObjMLFrame,X

HeroFly_NotExpired:
	JSR Title_DrawMarioLuigi
	
	INX
	CPX #3
	BLT HeroFly_Loop
	RTS

	
TitleMusic_Queue:
	LDA SndCur_Music2
	BNE TitleMusic_Queue_NotNeeded
	
	; RAS: Queue title song!
	LDA #MUS2B_TITLE
	STA Sound_QMusic2

TitleMusic_Queue_NotNeeded:
	RTS
	
Title_InitDebugMenu:
	; SHHH
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Disable display a second
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2
	STA <PPU_CTL2_Copy	; Show BG + sprites
	
	LDA PPU_STAT

	JSR Sprite_RAM_Clear	 ; Clear other sprites

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Raster_Effect = $80
	LDA #$80
	STA Raster_Effect

	; Clear nametable
	JSR Reset_PPU_Clear_Nametables

	LDA #%10101000
	STA PPU_CTL1	 	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA #%00011110
	STA <PPU_CTL2_Copy	; Setup for: No BG or sprite clipping, show BG and sprites

	; This will load the title graphics in reverse, $56 to $4E
	LDA #$56
	STA <Title_EventGrafX	; Title_EventGrafX = $56 (DebugMenu_Palette)

DebugMenu_LoadLoop:
	LDA <Title_EventGrafX
	ASL A		 
	TAY		 	; Y = Title_EventGrafX << 1 (2 byte index)

	; Get address, store into [Video_Upd_AddrH][Video_Upd_AddrL]
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL	
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH	

	JSR Video_Misc_Updates2	; Load those graphics!

	DEC <Title_EventGrafX	; Title_EventGrafX--

	LDA <Title_EventGrafX
	CMP #$4E
	BGE DebugMenu_LoadLoop	 	; If Title_EventGrafX >= $4E, loop!
	
	INC <Title_State
		
	RTS

Debug_CursorYPos:	.byte $10, $38, $48, $50, $78, $88, $98
Debug_CursorDelta:	.byte 1, -1

Debug_HexDigit:		.byte $1A, $1B, $1C, $1D, $1E, $1F, $20, $21, $22, $23, $00, $01, $02, $03, $04, $05

DebugMenu_LRDelta:	.byte 1, -1

Debug_SoundTest:	
	.byte MUS1_PLAYERDEATH, MUS1_GAMEOVER, MUS1_BOSSVICTORY, MUS1_WORLDVICTORY
	.byte MUS1_BOWSERFALL, MUS1_COURSECLEAR	; Not including MUS1_TIMEWARNING or MUS1_STOPMUSIC here 

Debug_SoundTest_M2Start:
	.byte MUS2A_WORLD1, MUS2A_WORLD2, MUS2A_WORLD3, MUS2A_WORLD4
	.byte MUS2A_WORLD5, MUS2A_WORLD6, MUS2A_WORLD7, MUS2A_WORLD8
	.byte MUS2A_SKY, MUS2A_INVINCIBILITY, MUS2A_BLECK, MUS2A_MUSICBOX
	.byte MUS2A_THRONEROOM, MUS2A_BONUSGAME, MUS2A_ENDING

	.byte MUS2B_OVERWORLD, MUS2B_UNDERGROUND, MUS2B_UNDERWATER, MUS2B_FORTRESS
	.byte MUS2B_BOSS, MUS2B_AIRSHIP, MUS2B_BATTLE, MUS2B_TOADHOUSE
	.byte MUS2B_ATHLETIC, MUS2B_PSWITCH, MUS2B_BOWSER, MUS2B_PURPLECOMET
	.byte MUS2B_PRINCESS, MUS2B_TITLE, MUS2B_SMB1VICTORY

	.byte MUS2C_MINIBOSS, MUS2C_GOODEGG, MUS2C_STAR, MUS2C_GHOSTHOUSE
	.byte MUS2C_GHOSTHOUSE2, MUS2C_MARIOLAND, MUS2C_SPECIAL, MUS2C_CASTLE
	.byte MUS2C_BOSSEOW, MUS2C_YOLD, MUS2C_MANSION, MUS2C_RUINS
	.byte MUS2C_ATHLETIC2, MUS2C_BOWSERCLASSIC, MUS2C_FFGALAXYF, MUS2C_REDCOMET

Debug_SoundTest_SPStart:
	; Sound_QPlayer
	.byte SND_PLAYERJUMP, SND_PLAYERBUMP, SND_PLAYERSWIM, SND_PLAYERKICK
	.byte SND_PLAYERPIPE, SND_PLAYERFIRE, SND_PLAYERPOWER, SND_PLAYERJUMPSM

Debug_SoundTest_SL1Start:
	; Sound_QLevel1
	.byte SND_LEVELCOIN, SND_LEVELRISE, SND_LEVELVINE, SND_LEVELBABOOM
	.byte SND_LEVELBLIP, SND_LEVELPOWER, SND_LEVEL1UP, SND_LEVELPOOF
	.byte SND_LEVELUNK, SND_LEVELSHOE, SND_LEVELTAILWAG
	
Debug_SoundTest_SL2Start:
	; Sound_QLevel2
	.byte SND_LEVELCRUMBLE, SND_LEVELFLAME, SND_BOOMERANG, SND_LEVELAIRSHIP
	.byte SND_LEVELMARCH, SND_LEVELSANDFILL, SND_LEVELSKID

Debug_SoundTest_SMStart:
	; Sound_QMap
	.byte SND_MAPENTERWORLD, SND_MAPPATHMOVE, SND_MAPENTERLEVEL, SND_MAPINVENTORYFLIP
	.byte SND_MAPBONUSAPPEAR, SND_MAPDENY
Debug_SoundTest_End


Title_DoDebugMenu:

	LDY <Title_DebugCursor

	LDA Debug_CursorYPos,Y
	STA Sprite_RAM+$00
	LDA #$F9
	STA Sprite_RAM+$01
	LDA #$00
	STA Sprite_RAM+$02
	LDA #$08
	STA Sprite_RAM+$03

	LDA <Pad_Input
	AND #(PAD_UP | PAD_DOWN)
	BEQ DebugMenu_NoSelChange

	; PAD_UP would equate to 8, so...
	LSR A
	LSR A
	LSR A	; Now 0 (down) or 1 (up)
	TAY

	LDA <Title_DebugCursor
	ADD Debug_CursorDelta,Y
	BPL Debug_CursorNotNeg
	
	; Went negative!
	LDA #0
	
Debug_CursorNotNeg:
	CMP #7
	BLT Debug_CurNotHigh

	; Too far!
	LDA #6
	
Debug_CurNotHigh:
	STA <Title_DebugCursor

DebugMenu_NoSelChange:

	; Music system debugging
	JSR Debug_Sound_PrintVars

	; Do whatever for the cursor position...
	LDA <Title_DebugCursor
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word DebugMenu_DoSoundTest		; 0
	.word DebugMenu_DoWorldEnd		; 1
	.word DebugMenu_DoEnding		; 2
	.word DebugMenu_DoEnding2		; 3
	.word DebugMenu_DoGetStar		; 4
	.word DebugMenu_DoCompleteWorld	; 5
	.word DebugMenu_Start			; 6


	; Temp_Var1 - vaddr high
	; Temp_Var2 - vaddr low
	; A - var to print
Debug_Print2DHex:
	PHA
	PHA

	LDY Graphics_BufCnt	 ; Y = graphics buffer counter
	
	LDA <Temp_Var1
	STA Graphics_Buffer,Y	; address high
	LDA <Temp_Var2
	STA Graphics_Buffer+1,Y	; address low
	LDA #$02
	STA Graphics_Buffer+2,Y	; run length
	
	PLA
	AND #$F0
	LSR A
	LSR A
	LSR A
	LSR A
	TAX
	LDA Debug_HexDigit,X
	STA Graphics_Buffer+3,Y	; MSD

	PLA
	AND #$0F
	TAX
	LDA Debug_HexDigit,X
	STA Graphics_Buffer+4,Y	; LSD
	
	LDA #$00
	STA Graphics_Buffer+5,Y	; terminator

	TYA
	ADD #5
	STA Graphics_BufCnt

	RTS


	; Temp_Var1 - vaddr high
	; Temp_Var2 - vaddr low
	; A (Temp_Var3) - char to print
Debug_PrintChar:
	PHA

	LDY Graphics_BufCnt	 ; Y = graphics buffer counter
	
	LDA <Temp_Var1
	STA Graphics_Buffer,Y	; address high
	LDA <Temp_Var2
	STA Graphics_Buffer+1,Y	; address low
	LDA #$01
	STA Graphics_Buffer+2,Y	; run length

	PLA
	STA Graphics_Buffer+3,Y	; LSD
	
	LDA #$00
	STA Graphics_Buffer+4,Y	; terminator

	TYA
	ADD #4
	STA Graphics_BufCnt

	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


DSPV_VAddrLow:	.byte $82, $86, $8B, $90, $94, $98, $9C, $00

Debug_Sound_PrintVars:

	; Rotating update of sound system variables
	LDA <Counter_1
	AND #$07
	TAY
	
	; Video address
	LDA #$20
	STA <Temp_Var10
	LDA DSPV_VAddrLow,Y
	STA <Temp_Var11
	
	TYA
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word DSPV_Bank
	.word DSPV_Index
	.word DSPV_Sq2
	.word DSPV_Sq1
	.word DSPV_Tri
	.word DSPV_Nse
	.word DSPV_DPCM
	.word DSPV_None

DSPV_Print:
	; DynJump corrupts Temp_Var1/2, d'oh
	LDY <Temp_Var10
	STY <Temp_Var1
	LDY <Temp_Var11
	STY <Temp_Var2

	JMP Debug_Print2DHex

DSPV_Bank:
	LDA Music_MusBank
	JMP DSPV_Print

DSPV_Index:
	LDA Music_NextIndex
	JMP DSPV_Print

DSPV_Sq2:
	LDA Music_Sq2TrkOff
	JMP DSPV_Print

DSPV_Sq1:
	LDA Music_Sq1TrkOff
	JMP DSPV_Print

DSPV_Tri:
	LDA Music_TriTrkPos
	JMP DSPV_Print

DSPV_Nse:
	LDA Music_NseTrkPos
	JMP DSPV_Print

DSPV_DPCM:
	LDA Music_PCMTrkPos
	JMP DSPV_Print

DSPV_None:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DebugMenu_DoSoundTest:
	LDA <Pad_Input
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ DMDST_NotLR

	JMP DMDST_LR

DMDST_NotLR:
	LDA <Pad_Input
	AND #PAD_A
	BEQ DMDST_NotSkip10

	JMP DMDST_Skip10

DMDST_NotSkip10:

	LDA <Pad_Input
	AND #PAD_START
	BEQ DMDST_NotPlay
	
	; If the Hurry Up song is playing, nothing we do here has effect ultimately
	LDA SndCur_Music1
	CMP #MUS1_TIMEWARNING
	BEQ DMDST_CantSlowDown
	
	; Slow down if hurry up
	LDA #0
	STA Music_RestH_Off

	LDA #$20
	STA <Temp_Var1
	LDA #$5A
	STA <Temp_Var2
	LDA #$FC	; Erase 'H'
	JSR Debug_PrintChar

DMDST_CantSlowDown:
	JMP DMDST_Play

DMDST_NotPlay:

	LDA <Pad_Input
	AND #PAD_B
	BEQ DMDST_NotHurryUp

	LDA SndCur_Music2
	CMP #MUS2A_INVINCIBILITY
	BEQ DMDST_LowOK
	CMP #MUS2A_SKY
	BEQ DMDST_LowOK
	CMP #$10
	BLT DMDST_NotHurryUp
	
DMDST_LowOK:
	LDA SndCur_Music1
	BNE DMDST_NotHurryUp

	LDA #MUS1_TIMEWARNING
	STA Sound_QMusic1

	LDA #$20
	STA <Temp_Var1
	LDA #$5A
	STA <Temp_Var2
	LDA #$07	; 'H'
	JSR Debug_PrintChar
	

DMDST_NotHurryUp:

	LDA <Pad_Input
	AND #PAD_SELECT
	BEQ DMDST_NotInvert

	LDA Music_InvertEn
	EOR #$18
	STA Music_InvertEn

	; Print/erase 'I'
	LDA #$20
	STA <Temp_Var1
	LDA #$5C
	STA <Temp_Var2
	LDA Music_InvertEn
	AND #$08
	LSR A
	LSR A
	LSR A
	TAY
	LDA DMDST_IOrBlank,Y
	JSR Debug_PrintChar

DMDST_NotInvert:
	RTS

DMDST_IOrBlank:		.byte $FC, $08

DMDST_LR:
	LSR A	; A = 0 (right) or 1 (left)
	TAY

	LDA <Title_DebugSTest
	ADD DebugMenu_LRDelta,Y
	BPL DMDST_STestNotNeg

	; Went negative!
	LDA #(Debug_SoundTest_End - Debug_SoundTest - 1)

DMDST_STestNotNeg:
	CMP #(Debug_SoundTest_End - Debug_SoundTest)
	BLT DMDST_NotHigh
	
	; Too high!
	LDA #0

DMDST_NotHigh:
	STA <Title_DebugSTest

	; Update music index
	LDY #$20
	STY <Temp_Var1
	LDY #$50
	STY <Temp_Var2
	JSR Debug_Print2DHex

	RTS
	
DMDST_Skip10:
	LDA <Title_DebugSTest
	ADD #$10
	CMP #(Debug_SoundTest_End - Debug_SoundTest)
	BLT DMDST_NotHigh
	
	AND #$0F
	JMP DMDST_NotHigh
	
DMDST_Play:
	; Get index -> 'Y'
	LDY <Title_DebugSTest
	
	; Get value
	LDA Debug_SoundTest,Y
	
	; Decide where to stuff it!
	CPY #(Debug_SoundTest_SMStart - Debug_SoundTest)
	BLT DMDSTP_NotSM

	STA Sound_QMap
	RTS

DMDSTP_NotSM:
	CPY #(Debug_SoundTest_SL2Start - Debug_SoundTest)
	BLT DMDSTP_NotSL2

	STA Sound_QLevel2
	RTS

DMDSTP_NotSL2:
	CPY #(Debug_SoundTest_SL1Start - Debug_SoundTest)
	BLT DMDSTP_NotSL1

	STA Sound_QLevel1
	RTS

DMDSTP_NotSL1:
	CPY #(Debug_SoundTest_SPStart - Debug_SoundTest)
	BLT DMDSTP_NotSP

	STA Sound_QPlayer
	RTS

DMDSTP_NotSP:
	CPY #(Debug_SoundTest_M2Start - Debug_SoundTest)
	BLT DMDSTP_NotM2

	STA Sound_QMusic2
	RTS

DMDSTP_NotM2:
	STA Sound_QMusic1
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; None, One Short, Base, Comet, All
	; None - Start with no star coins
	; One Short - Have all base (pre-comet) star coins except last one (for short letter test)
	; Base - Have all base (pre-comet) star coins (all W1 thru W8, comets excluded)
	; Comet - Have all star coins through comets, excluding World Zero
	; All - Have all star coins including World Zero
	
DMDGS_GetStarLevels:
	;      N    O    N    E
	.byte $0D, $0E, $0D, $04, $FC, $FC
		
	;      B    A    S    E
	.byte $01, $00, $12, $04, $FC, $FC
	
	;      1    S    H    O    R    T
	.byte $1B, $12, $07, $0E, $11, $13
	
	;      C    O    M    E    T
	;.byte $02, $0E, $0C, $04, $13, $FC
	
	;      A    L    L
	.byte $00, $0B, $0B, $FC, $FC, $FC

DMDGS_GetStarLevels_Offsets:
	.byte 0, 6, 12, 18, 24, 30

DebugMenu_DoGetStar:
	LDA <Pad_Input
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ DMDGS_NotLR

	LSR A	; A = 0 (right) or 1 (left)
	TAY

	LDA <Title_DebugComet
	ADD DebugMenu_LRDelta,Y
	BPL DMDGS_STestNotNeg

	; Went negative!
	LDA #3

DMDGS_STestNotNeg:
	CMP #4
	BLT DMDGS_NotHigh
	
	; Too high!
	LDA #0

DMDGS_NotHigh:
	STA <Title_DebugComet
	
	; Get to base of string -- multiply by 6 (6x = 2x + 4x)
	ASL A	; Mult 2
	PHA		; Save it
	ASL A	; Mult 4
	STA <Temp_Var1	; -> Temp_Var1
	PLA		; Mult 2
	ADD <Temp_Var1	; += Temp_Var1
	TAX		; -> 'X'

	LDY Graphics_BufCnt	 ; Y = graphics buffer counter
	
	LDA #$21
	STA Graphics_Buffer,Y	; address high
	LDA #$F0
	STA Graphics_Buffer+1,Y	; address low
	LDA #$06
	STA Graphics_Buffer+2,Y	; run length
	
	LDA DMDGS_GetStarLevels,X
	STA Graphics_Buffer+3,Y	; Character
	LDA DMDGS_GetStarLevels+1,X
	STA Graphics_Buffer+4,Y	; Character
	LDA DMDGS_GetStarLevels+2,X
	STA Graphics_Buffer+5,Y	; Character
	LDA DMDGS_GetStarLevels+3,X
	STA Graphics_Buffer+6,Y	; Character
	LDA DMDGS_GetStarLevels+4,X
	STA Graphics_Buffer+7,Y	; Character
	LDA DMDGS_GetStarLevels+5,X
	STA Graphics_Buffer+8,Y	; Character
	
	LDA #$00
	STA Graphics_Buffer+9,Y	; terminator

	TYA
	ADD #9
	STA Graphics_BufCnt
	
	
DMDGS_NotLR:
	RTS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DebugMenu_DoCompleteWorld:
	LDA <Pad_Input
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ DMDCW_NotLR

	LSR A	; A = 0 (right) or 1 (left)
	TAY

	LDA <Title_ComplWorld
	ADD DebugMenu_LRDelta,Y
	BPL DMDCW_STestNotNeg

	; Went negative!
	LDA #0

DMDCW_STestNotNeg:
	CMP #9
	BLT DMDCW_NotHigh
	
	; Too high!
	LDA #8

DMDCW_NotHigh:
	STA <Title_ComplWorld

	; NOTE: "8" actually means World Zero
	CMP #8
	BNE DMDCW_NoZeroAdj

	; For the "$1B" offset below, display "0"
	LDA #-1

DMDCW_NoZeroAdj:

	LDY #$22
	STY <Temp_Var1
	LDY #$30
	STY <Temp_Var2
	
	ADD #$1B
	JSR Debug_PrintChar

DMDCW_NotLR:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
DebugMenu_DoWorldEnd:
	LDA <Pad_Input
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ DMDWE_NotLR

	LSR A	; A = 0 (right) or 1 (left)
	TAY

	LDA <Title_WorldEnd
	ADD DebugMenu_LRDelta,Y
	BPL DMDWE_STestNotNeg

	; Went negative!
	LDA #0

DMDWE_STestNotNeg:
	CMP #9
	BLT DMDWE_NotHigh
	
	; Too high!
	LDA #8

DMDWE_NotHigh:
	STA <Title_WorldEnd

	; NOTE: "8" actually means World Zero
	CMP #8
	BNE DMDWE_NoZeroAdj

	; For the "$1B" offset below, display "0"
	LDA #-1

DMDWE_NoZeroAdj:

	LDY #$20
	STY <Temp_Var1
	LDY #$F0
	STY <Temp_Var2
	
	ADD #$1B
	JSR Debug_PrintChar

DMDWE_NotLR:
	LDA <Pad_Input
	AND #PAD_START
	BEQ DMDWE_NoStart

	LDX #0
	STX Player_Current
	
	LDA #1
	STA Player_FallToKing
	STA Total_Players

	LDA <Title_WorldEnd
	CMP #7
	BNE DMDWE_NotW8
	
	; World 8: Set princess rescue flag so "THE END" happens
	;INC Player_RescuePrincess
	
DMDWE_NotW8:
	CMP #8
	BLT DMDWE_NotWZero
	
	; Don't do one for Star Road
	ADD #1
	
DMDWE_NotWZero:
	STA Map_Previous_World,X
	STA World_Num

	JSR Debug_GetStarCoins

	JMP PRG062_88AD

DMDWE_NoStart:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
DebugMenu_DoEnding:
	LDA <Pad_Input
	AND #PAD_START
	BEQ DMDE_NoStart
	
	JSR Debug_GetStarCoins
	
	LDX #0
	STX Player_Current
	
	LDA #1
	STA Total_Players

	LDA #7
	STA Map_Previous_World,X
	
	LDA #1
	STA Player_RescuePrincess
	
	JMP PRG062_8FCA	 ; Jump to princess rescue
	
DMDE_NoStart:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
DebugMenu_DoEnding2:
	LDA <Pad_Input
	AND #PAD_START
	BEQ DMDE2_NoStart
	
	JSR Debug_GetStarCoins
	
	LDX #0
	STX Player_Current
	
	LDA #1
	STA Total_Players

	LDA #9
	STA Map_Previous_World,X
	STA World_Num
	
	LDA #$80
	STA Player_RescuePrincess
	
	JMP PRG062_8FCA	 ; Jump to princess rescue
	
DMDE2_NoStart:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DebugMenu_Start:
	LDA <Pad_Input
	AND #PAD_START
	BEQ DMS_NoStart
	
	LDA #1
	STA Debug_CheatNoLoad

	LDA <Title_ComplWorld
	CMP #8
	BLT DMS_NotWZero
	
	; Don't do one for Star Road
	ADD #1
	
DMS_NotWZero:
	STA Map_Previous_World
	STA Map_Previous_World+1
	STA World_Num

	JSR Debug_GetStarCoins
	
	LDA #6
	STA <Title_State
	
DMS_NoStart:
	RTS
	

Ending_WorldZero:

	LDA #LOW(W8AirshipL)
	STA <Level_LayPtr_AddrL
	LDA #HIGH(W8AirshipL)
	STA <Level_LayPtr_AddrH
	
	LDA #LOW(WZEnding_Objects)
	STA <Level_ObjPtr_AddrL
	LDA #HIGH(WZEnding_Objects)
	STA <Level_ObjPtr_AddrH
	
	LDA #10
	STA Level_Tileset
		
	; Fake a checkpoint to start scrolling at a different point
	LDX Player_Current
	LDA LevCP_ByPlayer,X
	TAX

	LDA #$80
	STA LevCP_X,X
	LDA #$00
	STA LevCP_XHi,X
		
	; Set Y pixel start for Player
	LDA #$80
	STA LevCP_Y,X
	LDA #$01
	STA LevCP_YHi,X

	; Force the checkpoint IDs
	LDA #0
	STA LevCP_ID,X
	STA LevCP_ActiveID
	STA Ending2_World
	STA Ending2_FadeLevel
	STA Ending2_State

	JMP PRG062_88AD

EndingWZ_PartII_jmp:
	JMP EndingWZ_PartII

Ending_LoopWZ:

	LDA #$FF
	STA <Player_X
	STA <Player_XHi
	
	LDA #$20
	STA <Player_Y
	
	LDA #4
	STA PatTable_BankSel+3

	LDA Ending2_LineStarts
	STA Ending_VAddrL
	LDA Ending2_LineStarts+1
	STA Ending_VAddrH

	LDA #0
	STA Ending_LineNum

Ending_WZInnerLoop:
	; Yes, the nonexistant Player can die
	LDA #1
	STA Player_DebugNoHitFlag

	LDA <Vert_Scroll
	STA Level_VertScroll


	LDA SndCur_Music2
	CMP #MUS2B_PURPLECOMET
	BEQ EndingWZ_MusicSet
	
	LDA #MUS2B_PURPLECOMET
	STA Sound_QMusic2

EndingWZ_MusicSet:
	JSR GraphicsBuf_Prep_And_WaitVSync
	JSR Level_DoAnimations
	JSR LevelScroll_Set_Ranges

	JSR Sprite_RAM_Clear
	JSR EndingWZ_Objects

	JSR Ending_UpdateText

	LDA <Horz_Scroll_Hi
	CMP #11
	BGE EndingWZ_PartII_jmp
	CMP #10
	BNE EndingWZ_NotLastScreen
	LDA <Horz_Scroll
	CMP #$40
	BLT EndingWZ_NotLastScreen
	BNE EndingWZ_NoSpawnBJR

	; Spawn Bowser Jr here for kicks
	JSR EWZIL_SpawnBJr

EndingWZ_NoSpawnBJR:
	;LDA Ending2_World
	;CMP #7
	;BNE EndingWZ_NotLastScreen	; If not world 8, jump to EndingWZ_NotLastScreen
	
	LDA <Counter_1
	AND #3
	BNE EndingWZ_NotLastScreen
	
	; Need to fade out
	LDA Ending2_FadeLevel
	CMP #4
	BGE EndingWZ_NotLastScreen
	
	ADD #$5A
	STA <Graphics_Queue
	JSR GraphicsBuf_Prep_And_WaitVSyn2
	
	INC Ending2_FadeLevel
	
EndingWZ_NotLastScreen:
	LDA <Counter_1
	AND #$01
	BNE EWZIL_NoScroll

	LDA <Horz_Scroll
	ADD #1
	STA <Horz_Scroll
	LDA <Horz_Scroll_Hi
	ADC #0
	STA <Horz_Scroll_Hi

	CMP #11
	BNE EndingWZ_NotHitEnd

	; Just hit end of level!
	JSR EWZIL_SpawnBowser

EndingWZ_NotHitEnd:
	; Check if we should advance to next world text
	LDA Ending2_World
	ASL A
	TAY
	LDA Ending2_Advance,Y
	CMP <Horz_Scroll
	BNE EWZIL_NoScroll
	LDA Ending2_Advance+1,Y
	CMP <Horz_Scroll_Hi
	BNE EWZIL_NoScroll
		
	; Advance!
	INC Ending2_World

	LDA Ending2_LineStarts
	STA Ending_VAddrL
	LDA Ending2_LineStarts+1
	STA Ending_VAddrH

	LDA #0
	STA Ending_LineNum	

	TYA
	LSR A
	TAY
	LDA Ending2_Texts+1,Y
	STA Ending_TextPos

EWZIL_NoScroll:
	LDA #0
	STA <Scroll_LastDir
	
	JSR Scroll_Update_Ending

	JMP Ending_WZInnerLoop


EWZIL_SpawnBJr:
	LDA #OBJ_BOSS_BOWSERJR
	JSR EWZIL_Spawn
	
	LDA <Horz_Scroll
	ADD #$FF
	STA <Objects_X,X
	LDA <Horz_Scroll_Hi
	ADC #0
	STA <Objects_XHi,X
	
	LDA #$40
	STA <Objects_Y,X
	LDA #1
	STA <Objects_YHi,X
	RTS

EWZIL_SpawnBowser:
	LDA #OBJ_BOSS_BOWSERFINAL
	JSR EWZIL_Spawn
	
	LDA <Horz_Scroll
	ADD #$70
	STA <Objects_X,X
	LDA <Horz_Scroll_Hi
	ADC #0
	STA <Objects_XHi,X
	
	LDA #$90
	STA <Objects_Y,X
	LDA #0
	STA <Objects_YHi,X

	LDA #14
	STA <Objects_Var5,X

	LDA #$5E
	STA <Graphics_Queue
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	LDA #$80
	STA Ending2_Timer

	RTS

EWZIL_Spawn:
	LDX #0
	STA Level_ObjectID,X

	JSR_THUNKC 0, Level_PrepareNewObject
	
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X
	RTS


EndingWZ_PartII:

	LDA <Objects_Var5
	CMP #15
	BNE Bowser_NotLandedYet

	LDA #$80
	STA Level_TimerEn
	
	LDA #146
	STA PatTable_BankSel+1

	LDA Ending2_Timer
	BNE EndingP2_Cont

	; Timer expired...
	LDA Controller1Press
	ORA Controller2Press
	AND #(PAD_A | PAD_START)
	BEQ Bowser_NotLandedYet
	
	LDA #1
	STA Player_FallToKing
	
	LDA #9
	STA Player_RescuePrincess
	
	JMP Rescue_Princess

EndingP2_Cont:
	DEC Ending2_Timer

	AND #$1F
	BNE Bowser_NotLandedYet

	LDA Ending2_Timer
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A

	ADD #$5F
	STA <Graphics_Queue
	STA $110
	JSR GraphicsBuf_Prep_And_WaitVSyn2
	
Bowser_NotLandedYet:
	JMP Ending_WZInnerLoop
