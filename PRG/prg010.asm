; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg010.bin, File Size: 8193, ORG: $C000
;     -> NES mode enabled
;---------------------------------------------------------------------------
Video_DoWXMario00:
	vaddr $2908
	.byte $01, $A0

	vaddr $2909
	.byte VU_REPEAT | 14, $A1

	vaddr $2917
	.byte $01, $A2

	vaddr $2928
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2929
	.byte VU_REPEAT | 14, $FE

	vaddr $2937
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2949
	.byte VU_REPEAT | 14, $FE

	vaddr $2969
	.byte VU_REPEAT | 14, $FE

	vaddr $2989
	.byte VU_REPEAT | 14, $FE

	vaddr $29A9
	.byte VU_REPEAT | 14, $FE
	
	vaddr $29C9
	.byte VU_REPEAT | 14, $FE

	vaddr $29E8, 
	.byte $01, $E3

	vaddr $29E9
	.byte VU_REPEAT | 14, $E4

	vaddr $29F7
	.byte $01, $E5

	; ----

	vaddr $294C
	.byte $05, $D8, $F0, $E9, $EC, $EE	; WORLD

	vaddr $29AA
	.byte $05, $BA, $BC, $E9, $FC, $F0	; MARIO

	vaddr $29B3
	.byte $01, $FB

	; ----

	vaddr $2BD2
	.byte VU_REPEAT | 4, $00

	vaddr $2BDA
	.byte VU_REPEAT | 4, $00
	.byte $00

Video_DoWXMario80:
	vaddr $2918
	.byte $01, $A0

	vaddr $2919
	.byte VU_REPEAT | 7, $A1

	vaddr $2900
	.byte VU_REPEAT | 7, $A1

	vaddr $2907
	.byte $01, $A2

	vaddr $2938
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2939
	.byte VU_REPEAT | 7, $FE

	vaddr $2920
	.byte VU_REPEAT | 7, $FE

	vaddr $2927
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2959
	.byte VU_REPEAT | 7, $FE

	vaddr $2940
	.byte VU_REPEAT | 7, $FE

	vaddr $2979
	.byte VU_REPEAT | 7, $FE

	vaddr $2960
	.byte VU_REPEAT | 7, $FE

	vaddr $2999
	.byte VU_REPEAT | 7, $FE

	vaddr $2980
	.byte VU_REPEAT | 7, $FE

	vaddr $29B9
	.byte VU_REPEAT | 7, $FE

	vaddr $29A0
	.byte VU_REPEAT | 7, $FE

	vaddr $29D9
	.byte VU_REPEAT | 7, $FE
	
	vaddr $29C0
	.byte VU_REPEAT | 7, $FE

	vaddr $29F8
	.byte $01, $E3

	vaddr $29F9
	.byte VU_REPEAT | 7, $E4

	vaddr $29E0
	.byte VU_REPEAT | 7, $E4

	vaddr $29E7
	.byte $01, $E5

	; ----
	
	vaddr $295C
	.byte $04, $D8, $F0, $E9, $EC	; WORL

	vaddr $2940
	.byte $01, $EE			; D

	vaddr $29BA
	.byte $05, $BA, $BC, $E9, $FC, $F0 ; MARIO

	vaddr $29A3
	.byte $01, $FB

	vaddr $2BD0
	.byte VU_REPEAT | 2, $00

	; ----
	
	vaddr $2BD6
	.byte VU_REPEAT | 4, $00

	vaddr $2BDE
	.byte VU_REPEAT | 2, $00
	.byte $00


Video_DoGameOver00:
	vaddr $2908
	.byte $01, $A0

	vaddr $2909
	.byte VU_REPEAT | 14, $A1


	vaddr $2917
	.byte $01, $A2

	vaddr $2928
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2929
	.byte VU_REPEAT | 14, $FE

	vaddr $2937
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2949
	.byte VU_REPEAT | 14, $FE

	vaddr $2969
	.byte VU_REPEAT | 14, $FE

	vaddr $2989
	.byte VU_REPEAT | 14, $FE

	vaddr $29A9
	.byte VU_REPEAT | 14, $FE
	
	vaddr $29C9
	.byte VU_REPEAT | 14, $FE

	vaddr $29E8
	.byte $01, $E3

	vaddr $29E9
	.byte VU_REPEAT | 14, $E4

	vaddr $29F7
	.byte $01, $E5

	; ----

	vaddr $296B
	.byte $0A, $EB, $BC, $BA, $E8, $FE, $F0, $6A, $E8, $E9, $6B	; GAME OVER!

	vaddr $29AF
	.byte $08, $ED, $F0, $DB, $EA, $FC, $DB, $DA, $E8	; CONTINUE

	vaddr $29CF
	.byte $03, $E8, $DB, $EE	; END

	; ----

	vaddr $2BD2
	.byte VU_REPEAT | 4, $00

	vaddr $2BDA
	.byte VU_REPEAT | 4, $00

	.byte $00


Video_DoGameOver80:
	vaddr $2918
	.byte $01, $A0

	vaddr $2919
	.byte VU_REPEAT | 7, $A1

	vaddr $2900
	.byte VU_REPEAT | 7, $A1

	vaddr $2907
	.byte $01, $A2

	vaddr $2938
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2939
	.byte VU_REPEAT | 7, $FE

	vaddr $2920
	.byte VU_REPEAT | 7, $FE

	vaddr $2927
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2959
	.byte VU_REPEAT | 7, $FE

	vaddr $2940
	.byte VU_REPEAT | 7, $FE

	vaddr $2979
	.byte VU_REPEAT | 7, $FE

	vaddr $2960
	.byte VU_REPEAT | 7, $FE

	vaddr $2999
	.byte VU_REPEAT | 7, $FE

	vaddr $2980
	.byte VU_REPEAT | 7, $FE

	vaddr $29B9
	.byte VU_REPEAT | 7, $FE

	vaddr $29A0
	.byte VU_REPEAT | 7, $FE

	vaddr $29D9
	.byte VU_REPEAT | 7, $FE
	
	vaddr $29C0
	.byte VU_REPEAT | 7, $FE

	vaddr $29F8
	.byte $01, $E3

	vaddr $29F9
	.byte VU_REPEAT | 7, $E4

	vaddr $29E0
	.byte VU_REPEAT | 7, $E4

	vaddr $29E7
	.byte $01, $E5

	; ----

	vaddr $297B
	.byte $04, $EB, $BC, $BA, $E8		; GAME

	vaddr $2960
	.byte $05, $F0, $6A, $E8, $E9, $6B	; OVER!

	vaddr $29A0
	.byte $07, $F0, $DB, $EA, $FC, $DB, $DA, $E8

	vaddr $29BF
	.byte $01, $ED

	vaddr $29C0
	.byte $02, $DB, $EE	; ND

	vaddr $29DF
	.byte $01, $E8	; E

	; ----

	vaddr $2BD0
	.byte VU_REPEAT | 2, $00 

	vaddr $2BD6
	.byte VU_REPEAT | 4, $00

	vaddr $2BDE
	.byte VU_REPEAT | 2, $00

	.byte $00

Video_DoW2WZ:	; "WELCOME TO WARP ZONE" banner
	vaddr $2884
	.byte VU_VERT | $04, $A0, $E6, $E6, $E3

	vaddr $2885
	.byte VU_REPEAT | 22, $A1

	vaddr $289B
	.byte VU_VERT | $04, $A2, $E7, $E7, $E5

	vaddr $28A5	;W    E    L    C    O    M    E         T    O         S    T    A    R         R    O    A    D
	.byte 22, $FE, $D8, $E8, $EC, $ED, $F0, $BA, $E8, $FE, $EA, $F0, $FE, $FD, $EA, $BC, $E9, $FE, $E9, $F0, $BC, $EE, $FE

	vaddr $28C5
	.byte VU_REPEAT | 22, $FE

	vaddr $28E5
	.byte VU_REPEAT | 22, $E4

	vaddr $2BC9
	.byte VU_REPEAT | 6, $00
	.byte $00

Video_DoWXLuigi00:
	vaddr $2908
	.byte $01, $A0

	vaddr $2909
	.byte VU_REPEAT | 14, $A1

	vaddr $2917
	.byte $01, $A2

	vaddr $2928
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2929

	.byte VU_REPEAT | 14, $FE

	vaddr $2937
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2949
	.byte VU_REPEAT | 14, $FE

	vaddr $2969
	.byte VU_REPEAT | 14, $FE

	vaddr $2989
	.byte VU_REPEAT | 14, $FE

	vaddr $29A9
	.byte VU_REPEAT | 14, $FE
	
	vaddr $29C9
	.byte VU_REPEAT | 14, $FE

	vaddr $29E8, 
	.byte $01, $E3

	vaddr $29E9
	.byte VU_REPEAT | 14, $E4

	vaddr $29F7
	.byte $01, $E5

	vaddr $294C
	.byte $05, $D8, $F0, $E9, $EC, $EE	; WORLD

	vaddr $29AA
	.byte $05, $EC, $DA, $FC, $EB, $FC	; LUIGI

	vaddr $29B3
	.byte $01, $FB

	vaddr $2BD2
	.byte VU_REPEAT | 4, $00

	vaddr $2BDA
	.byte VU_REPEAT | 4, $00
	.byte $00


Video_DoWXLuigi80:
	vaddr $2918
	.byte $01, $A0

	vaddr $2919
	.byte VU_REPEAT | 7, $A1

	vaddr $2900
	.byte VU_REPEAT | 7, $A1

	vaddr $2907
	.byte $01, $A2

	vaddr $2938
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2939
	.byte VU_REPEAT | 7, $FE

	vaddr $2920
	.byte VU_REPEAT | 7, $FE

	vaddr $2927
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2959
	.byte VU_REPEAT | 7, $FE

	vaddr $2940
	.byte VU_REPEAT | 7, $FE

	vaddr $2979
	.byte VU_REPEAT | 7, $FE

	vaddr $2960
	.byte VU_REPEAT | 7, $FE

	vaddr $2999
	.byte VU_REPEAT | 7, $FE

	vaddr $2980
	.byte VU_REPEAT | 7, $FE

	vaddr $29B9
	.byte VU_REPEAT | 7, $FE

	vaddr $29A0
	.byte VU_REPEAT | 7, $FE

	vaddr $29D9
	.byte VU_REPEAT | 7, $FE
	
	vaddr $29C0
	.byte VU_REPEAT | 7, $FE

	vaddr $29F8
	.byte $01, $E3

	vaddr $29F9
	.byte VU_REPEAT | 7, $E4

	vaddr $29E0
	.byte VU_REPEAT | 7, $E4

	vaddr $29E7
	.byte $01, $E5
	
	vaddr $295C
	.byte $04, $D8, $F0, $E9, $EC	; WORL

	vaddr $2940
	.byte $01, $EE			; D

	vaddr $29BA
	.byte $05, $EC, $DA, $FC, $EB, $FC	; LUIGI

	vaddr $29A3
	.byte $01, $FB

	vaddr $2BD0
	.byte VU_REPEAT | 2, $00
	
	vaddr $2BD6
	.byte VU_REPEAT | 4, $00

	vaddr $2BDE
	.byte VU_REPEAT | 2, $00
	.byte $00


Video_DoWXToad00:
	vaddr $2908
	.byte $01, $A0

	vaddr $2909
	.byte VU_REPEAT | 14, $A1

	vaddr $2917
	.byte $01, $A2

	vaddr $2928
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2929
	.byte VU_REPEAT | 14, $FE

	vaddr $2937
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2949
	.byte VU_REPEAT | 14, $FE

	vaddr $2969
	.byte VU_REPEAT | 14, $FE

	vaddr $2989
	.byte VU_REPEAT | 14, $FE

	vaddr $29A9
	.byte VU_REPEAT | 14, $FE
	
	vaddr $29C9
	.byte VU_REPEAT | 14, $FE

	vaddr $29E8, 
	.byte $01, $E3

	vaddr $29E9
	.byte VU_REPEAT | 14, $E4

	vaddr $29F7
	.byte $01, $E5

	; ----

	vaddr $294C
	.byte $05, $D8, $F0, $E9, $EC, $EE	; WORLD

	vaddr $29AA
	.byte $04, $FD, $F0, $BC, $EE		; TOAD

	vaddr $29B3
	.byte $01, $FB

	; ----

	vaddr $2BD2
	.byte VU_REPEAT | 4, $00

	vaddr $2BDA
	.byte VU_REPEAT | 4, $00
	.byte $00

Video_DoWXToad80:
	vaddr $2918
	.byte $01, $A0

	vaddr $2919
	.byte VU_REPEAT | 7, $A1

	vaddr $2900
	.byte VU_REPEAT | 7, $A1

	vaddr $2907
	.byte $01, $A2

	vaddr $2938
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2939
	.byte VU_REPEAT | 7, $FE

	vaddr $2920
	.byte VU_REPEAT | 7, $FE

	vaddr $2927
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2959
	.byte VU_REPEAT | 7, $FE

	vaddr $2940
	.byte VU_REPEAT | 7, $FE

	vaddr $2979
	.byte VU_REPEAT | 7, $FE

	vaddr $2960
	.byte VU_REPEAT | 7, $FE

	vaddr $2999
	.byte VU_REPEAT | 7, $FE

	vaddr $2980
	.byte VU_REPEAT | 7, $FE

	vaddr $29B9
	.byte VU_REPEAT | 7, $FE

	vaddr $29A0
	.byte VU_REPEAT | 7, $FE

	vaddr $29D9
	.byte VU_REPEAT | 7, $FE
	
	vaddr $29C0
	.byte VU_REPEAT | 7, $FE

	vaddr $29F8
	.byte $01, $E3

	vaddr $29F9
	.byte VU_REPEAT | 7, $E4

	vaddr $29E0
	.byte VU_REPEAT | 7, $E4

	vaddr $29E7
	.byte $01, $E5

	; ----
	
	vaddr $295C
	.byte $04, $D8, $F0, $E9, $EC	; WORL

	vaddr $2940
	.byte $01, $EE			; D

	vaddr $29BA
	.byte $04, $FD, $F0, $BC, $EE		; TOAD

	vaddr $29A3
	.byte $01, $FB

	vaddr $2BD0
	.byte VU_REPEAT | 2, $00

	; ----
	
	vaddr $2BD6
	.byte VU_REPEAT | 4, $00

	vaddr $2BDE
	.byte VU_REPEAT | 2, $00
	.byte $00


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_IntroAttrSave
;
; This subroutine saves the attribute info underneath where
; the "World X" intro box is about to sit.  This is used to
; "clean up" the changes made to the attribute table later.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_IntroAttrSave:
	LDA <Horz_Scroll
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		 ; A >> 5 (div by 32, for figuring out what set of 2x2 tiles we need to fix)
	ADD #$d2
	STA <Temp_Var1

	ADD #$08
	STA <Temp_Var2

	LDA PPU_STAT

	LDX #$00	 ; X = 0

PRG010_C2DA:
	; Set the address to $2Bxx (attribute table 2, all that the map effects)
	LDA #$2B
	STA PPU_VRAM_ADDR
	LDA <Temp_Var1	
	STA PPU_VRAM_ADDR

	LDA PPU_VRAM_DATA

	LDA PPU_VRAM_DATA
	STA <Scroll_ColorStrip,X

	LDY <Temp_Var1	 ; Y = Temp_Var1
	INY
	TYA
	AND #$07
	BNE PRG010_C2F9

	LDA <Temp_Var1
	AND #$f8
	TAY

PRG010_C2F9:
	STY <Temp_Var1
	CPX #$03
	BNE PRG010_C303
	LDA <Temp_Var2	
	STA <Temp_Var1	

PRG010_C303:
	INX	

	CPX #$08
	BNE PRG010_C2DA	 ; While X <> 8, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GameOver_PatchPlayerName
;
; This subroutine pushes the Player's name for
; the "Game Over!" box into the graphics
; buffer for further processing...
; Note that this is not a "friendly" function, in that
; it directly sets the graphics buffer, not inserts.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GameOver_MLName:
	.byte $BA, $BC, $E9, $FC, $F0, $00	; MARIO[Terminator]
	.byte $EC, $DA, $FC, $EB, $FC, $00	; LUIGI[Terminator]
GameOver_MLName_Len = 6

GameOver_PatchPlayerName:
	LDY Player_Current	; Y = Player_Current
	LDX #$00	 ; X = 0

	CPY #$00
	BEQ PRG010_C320	 ; If Player_Current = 0 (Player is Mario), jump to PRG010_C320

	LDX #GameOver_MLName_Len	; X = GameOver_MLName_Len

PRG010_C320:
	LDY #$00	 ; Y = 0
PRG010_C322:
	LDA GameOver_MLName,X	 ; Get patterns for MARIO/LUIGI
	STA Graphics_Buffer+3,Y	 ; -> graphics buffer

	INX		 ; X++ (next name character pattern)
	INY		 ; Y++ (next graphics buffer byte)

	CPY #GameOver_MLName_Len
	BNE PRG010_C322	; While Y < GameOver_MLName_Len, loop!

	; Store VRAM high address
	LDA #$29
	STA Graphics_Buffer

	; Store run length
	LDA #(GameOver_MLName_Len-1)
	STA Graphics_Buffer+2

	; Store VRAM low address
	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	ADD #$2a
	STA Graphics_Buffer+1

	; Graphics_BufCnt += (GameOver_MLName_Len + 2)
	LDA Graphics_BufCnt
	ADD #(GameOver_MLName_Len + 2)
	STA Graphics_BufCnt

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_ConfigWorldIntro
;
; This subroutine pushes the world number and the
; player's lives counter into the intro box into
; the graphics buffer for further processing...
; Note that this is not a "friendly" function, in that
; it directly sets the graphics buffer, not inserts.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_ConfigWorldIntro:

	; High byte
	LDA #$29	 	
	STA Graphics_Buffer

	; Low byte: Calculate the proper offset address based on the horizontal scroll
	LDA <Horz_Scroll
	LSR A		 
	LSR A		 
	LSR A		 ; A = Horz_Scroll >> 3
	CLC		 
	EOR #$52
	STA Graphics_Buffer+1

	; Run length of 1
	LDA #$01
	STA Graphics_Buffer+2


	LDY World_Num	 	; Y = World_Num
	CPY #9
	BNE WorldIntro_NotZero	; If World_Num <> 9 (World 10 AKA World 0), jump to WorldFill_NotZero

	; World 0 only...
	LDA #$F0
	BNE WorldIntro_Zero	; Jump (technically always) to WorldIntro_Zero

WorldIntro_NotZero: 
	INY		 	; Worlds start at 0, so Y++
	TYA		 	; A = World_Num + 1
	ORA #$f0	 	; Offset to correct tile

WorldIntro_Zero:
	STA Graphics_Buffer+3	; Store the tile into the buffer

	; High byte
	LDA #$29	 	
	STA Graphics_Buffer+4	

	; Low byte: Calculate the proper offset address based on the horizontal scroll
	LDA <Horz_Scroll	
	LSR A		
	LSR A		
	LSR A		 ; A = Horz_Scroll >> 3
	EOR #$b4
	STA Graphics_Buffer+5

	; Run length of 2
	LDA #$02
	STA Graphics_Buffer+6

	; Takes the lives from the status bar!
	LDA StatusBar_LivesH
	STA Graphics_Buffer+7
	LDA StatusBar_LivesL
	STA Graphics_Buffer+8

	LDA #$00	
	STA Graphics_Buffer+9	 ; Terminator

	RTS		 ; Return

	; Cover map screen with black
Map_W8DarknessFill:
	LDA PPU_STAT

	; Use horizontal updates
	LDA <PPU_CTL1_Copy
	AND #~$04
	STA PPU_CTL1

	LDY #$02	 ; Y = $02

	LDX #$60	 ; X = $60 (low VRAM address)
	LDA #$28	 ; A = $28 (high VRAM address)
	STA PPU_VRAM_ADDR	; Set VRAM high address

	LDA #$80	 ; A = $80
	STA PPU_VRAM_ADDR	 ; Set VRAM low address

	LDA #$ff	 ; A = $FF (the black tile)
PRG010_C3AC:
	STA PPU_VRAM_DATA	 ; Store black pattern tile

	DEX		 ; X--
	BNE PRG010_C3AC	 ; While X <> 0, loop
 
	DEY		 ; Y--
	BPL PRG010_C3AC	 ; While Y > 0, loop

	RTS		 ; Return

Map_ScrollDeltaX:	.byte 2, -2	; Based on scroll direction, moves Horz_Scroll by this amount
Map_ScrollDeltaXHi:	.byte 0, $FF	; sign extension to above


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DoMap
;
; A very large, encompassing function which
; runs most Map_Operations and performs 
; other required tasks that keep the world
; lively and interesting...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_DoMap:
	;JSR World5_Sky_AddCloudDeco	; Add world 5's cloud decoration

	LDA Map_Operation
	CMP #$0d	 
	BNE PRG010_C413	 	; If Map_Operation <> $0D (normal), jump to PRG010_C413

	; Map is operating normally
	LDX World_Num	 	; X = World_Num
	LDY World_BGM,X		; Y = World_BGM_Arrival[X]

	LDA #0

	CPX #$09
	BNE PRG010_C3E3	 	; If X <> 9 (not on World Zero), jump to PRG010_C3E3

	; Enable inverted music on World Zero
	LDA #$18

PRG010_C3E3:
	STA Music_InvertEn

	LDA Map_MusicBox_Cnt	
	BEQ PRG010_C3EA	 	; If Map_MusicBox_Cnt = 0 (music box not active), jump to PRG010_C3EA

	LDY #MUS2A_MUSICBOX	 ; Otherwise, Y = $C (music box song)

PRG010_C3EA:
	LDA SndCur_Music2
	BNE PRG010_C3F2	 	; If SndCur_Music2 <> 0 (a song from set 2 is playing), jump to PRG010_C3F2

	; Otherwise, queue the requested song!
	STY Sound_QMusic2	

PRG010_C3F2:
	LDX Player_Current	; X = Player_Current

	LDA <World_Map_Move,X
	BNE PRG010_C40C	 	; If Player is moving on the map, jump to PRG010_C40C

	LDA Map_MoveRepeat,X
	CMP #$18	 
	BEQ PRG010_C403	 	; If at the movement repeat limit, jump to PRG010_C403

	; Otherwise...
	INC Map_MoveRepeat,X	; Map_MoveRepeat++

PRG010_C403:
	LDA <Pad_Holding
	BNE PRG010_C40C	 	; If Pad_Holding <> 0, jump to PRG010_C40C

	; Player has stopped holding a direction; stop the repeat
	LDA #$ff	 
	STA Map_MoveRepeat,X	; Otherwise, Map_MoveRepeat = $FF

PRG010_C40C:
	LDA <Map_WarpWind_FX
	BEQ PRG010_C413	 		; If Map_WarpWind_FX = 0 (no warp wind happening), jump to PRG010_C413
	JMP Map_DoMap_WarpWind_FX	; Do the warp wind effect!

PRG010_C413:
	LDA Map_Pan_Count
	BNE PRG010_C43C	 	; If map is panning, jump to PRG010_C43C

	LDX Player_Current	; X = Player_Current
	LDA <World_Map_Move,X
	BNE PRG010_C46B	 	; If Player is moving on map, jump to PRG010_C46B

	LDA Map_Operation
	CMP #$0d	 
	BNE PRG010_C46B	 	; If Map_Operation <> $D (Normal), jump to PRG010_C46B

	LDA <Pad_Input
	AND #PAD_B	
	BEQ PRG010_C46B		; If Player is NOT pressing B, jump to PRG010_C46B

	; Player is pressing B button...
	LDA #SND_MAPINVENTORYFLIP	 
	STA Sound_QMap	 	; Play inventory opening sound

	LDA Inventory_Open
	EOR #$01	 	
	STA Inventory_Open	; Toggle the Inventory_Open flag

	JMP WorldMap_UpdateAndDraw	; Jump into WorldMap_UpdateAndDraw...

PRG010_C43C:
	LDA Map_DrawPanState
	BEQ PRG010_C447	 	; If Map_DrawPanState = 0, jump to PRG010_C447

	JSR Map_DrawAndPan	 	; Otherwise, call the dynamic jump routine required!
	JMP WorldMap_UpdateAndDraw	; Jump into WorldMap_UpdateAndDraw...

PRG010_C447:
	LDY <Scroll_LastDir
	LDA <Horz_Scroll
	ADD Map_ScrollDeltaX,Y
	STA <Horz_Scroll	 ; Horz_Scroll += Map_ScrollDeltaX[Y] (scroll in proper direction by delta amount)
	STA <Scroll_Temp	 ; Scroll_Temp = Horz_Scroll

	LDA <Horz_Scroll_Hi
	ADC Map_ScrollDeltaXHi,Y	
	STA <Horz_Scroll_Hi	; Add carry if needed!

	JSR Scroll_Update_Ranges	; Update Scroll column values
	JSR Scroll_Update	 	; Render new column of tiles if needed
	JSR Scroll_Map_SpriteBorder	; Keep up the map's sprite border

	DEC Map_Pan_Count
	DEC Map_Pan_Count 	; Map_Pan_Count -= 2
	BNE PRG010_C46B
	
	; Map_Pan_Count = 0...
	
	; Hack fix: If you press 'A' quickly enough right when pan stops,
	; you can enter the level behind a comet or whatever else is there.
	; Just hang back a couple ticks to let the map objects sync.
	LDA #10
	STA Map_Intro_Tick
	
	BNE PRG010_C470	 	; Jump (technically always) to PRG010_C470

PRG010_C46B:
	LDA Map_DrawPanState	
	BEQ PRG010_C481	 	; If Map_DrawPanState = 0, jump to PRG010_C481

PRG010_C470:
	JSR Map_DrawAndPan	 	; Otherwise, call the dynamic jump routine required!
	JSR WorldMap_UpdateAndDraw	; Update and draw the world map

	LDA Map_DrawPanState
	BNE PRG010_C481	 		; If Map_DrawPanState <> 0, jump to PRG010_C481

	LDA #$01
	STA World_EnterState	 ; World_EnterState = 1

	RTS		 ; Return

PRG010_C481:

	; If the first map object's actual Y is not zero, jump to Map_DoOperation (??  Why??)
	LDA Map_Object_ActY
	BNE Map_DoOperation	 	; If Map_Object_ActY <> 0, jump to Map_DoOperation

	; For all objects $D - $0...
	LDY #(MAPOBJ_TOTAL-1)
PRG010_C488:
	; Copy object's Y and XHi/Los into their display variables
	LDA Map_Objects_Y,Y
	STA Map_Object_ActY,Y
	LDA Map_Objects_XHi,Y
	STA Map_Object_ActXH,Y
	LDA Map_Objects_XLo,Y
	STA Map_Object_ActX,Y

	;LDA Map_Objects_IDs,Y
	;CMP #MAPOBJ_CANOE
	;BGE PRG010_C4A9		; If object ID >= MAPOBJ_CANOE, jump to PRG010_C4A9

	; All other objects get a random number of 0-3 assigned to their "data" field
	;LDA RandomN,Y
	;AND #$03	
	;STA Map_Object_Data,Y

;PRG010_C4A9:
	DEY		 ; Y--
	BPL PRG010_C488	 ; If Y >= 0, loop!

Map_DoOperation:
	LDA Map_Operation
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word MO_WorldXIntro	; 0 - "World X" Intro (the box, erasing it, and the stars)
	.word MO_SwitchToMO_D	; 1 - Just switches to Map_Operation = $D
	.word MO_SkidToPrev	; 2 - "Skid" backwards from death (short distance, same map screen)
	.word MO_SkidToPrevAfar	; 3 - "Skid" backwards from death, from far away (different map screen); this skids from the far end...
	.word MO_SkidAfarPrep	; 4 - Prepare to finish skid from afar
	.word MO_SkidAfarFinish	; 5 - Finish the far away skidding
	.word MO_Wait14Ticks	; 6 - Loads 14 ticks and wait for it
	.word MO_DoLevelClear	; 7 - Do level completion effect
	.word MO_DoFortressFX	; 8 - If any Poof-then-Fortress effect (e.g. busting a lock) to do, do it!
	.word MO_CheckWZUnlock	; 9 - Check if World Zero unlock sequence should run
	.word MO_Wait14Ticks	; A - Loads 14 ticks and wait for it
	.word MO_HammerBroMarch	; B - Map Hammer brother march around (mostly handled elsewhere instead of this state routine)
	.word MO_Wait8Proceed	; C - After 8 ticks, resume normal operations (if 1P game or didn't end turn), or else go to state $0F
	.word MO_NormalMoveEnter; D - "Normal" map operations; move on map (paths, canoe, bridges etc.), enter levels (including 2P vs and hand trap random)
	.word MO_HandTrap	; E - Hand trap gotcha!

	; NOTE: There is a Map_Operation $F (edge scroll) and Map_Operation $10 (enter level)
	; that are not in this jump table, but handled explicitly...

;World5_Sky_CloudDeco:
	; Sprite data of a single cloud over the lower world
	;.byte $30, $7D, $03, $48, $30, $7F, $03, $50, $30, $A3, $03, $58, $30, $A5, $03, $60
;World5_Sky_CloudDeco_End

;World5_Sky_AddCloudDeco:
	; All this does is on World 5, Sky part ONLY, add a cloud
	; Maybe there was to be intention of other map graphic decorations?

;	LDA World_Num	 ; A = World_Num
;	CMP #4
;	BNE PRG010_C4F9	 ; If World_Num <> 4 (World 5), jump to PRG010_C4F9 (RTS)

	; World 5 only!
;	LDX Player_Current	; X = Player_Current
;	LDA <World_Map_XHi,X	; A = Player's X Hi byte (to determine if we're on the Sky part of W5)
;	BEQ PRG010_C4F9	 	; If not on World 5 sky screen, jump to PRG010_C4F9 (RTS)

	; World 5 Sky only!

	; Copy in the cloud sprite data
;	LDY #(World5_Sky_CloudDeco_End - World5_Sky_CloudDeco - 1)
;PRG010_C4F0:
;	LDA World5_Sky_CloudDeco,Y
;	STA Sprite_RAM+$50,Y
;	DEY		 	; Y--
;	BPL PRG010_C4F0	 	; While Y >= 0, loop!

;PRG010_C4F9:
;	RTS		 ; Return


MO_WorldXIntro:

	; Process by current World_EnterState value...
	LDA World_EnterState
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word WorldIntro_BoxTimer	; 0 - Draws Player sprite in "World X" box, and delays until Map_Intro_Tick = 0
	.word WorldIntro_EraseAndStars	; 1 - Erases the "World X" intro box and does the starry intro
	.word WorldIntro_CompleteStars	; 2 - Complete the starry intro

WorldIntro_BoxTimer:
	JSR Map_WorldIntro_DrawPlayer	 ; Put in the tiny player symbol

WorldIntro_BoxTimer_NoSym:
	LDA Map_Intro_Tick
	BNE PRG010_C513	 	; If Map_Intro_Tick <> 0, jump to PRG010_C513

	; This initializes it, since if the world intro box is new, this is zero
	LDA #$80
	STA Map_Intro_Tick	; Map_Intro_Tick = $80

PRG010_C513:
	DEC Map_Intro_Tick	; Map_Intro_Tick--
	BNE PRG010_C51B	 	; If Map_Intro_Tick <> 0, jump to PRG010_C51B

	; Map_Intro_Tick expired
	INC World_EnterState	; Go to next state!

PRG010_C51B:
	RTS		 ; Return


	; This defines two sprites to make up the Player's current powerup
Map_WorldIntro_PSpr:
	.byte $60, $2D, $00, $84	; Left half of Player sprite
	.byte $60, $2F, $00, $8C	; Right half of Player sprite

	; This defines the first pattern to use for the Player sprite based on powerup
	; The second pattern is implicitly +2 to this value
Map_WorldIntro_PSPat:
	.byte $41	; 0 - Small
	.byte $41	; 1 - Big
	.byte $41	; 2 - Fire
	.byte $45	; 3 - Leaf
	.byte $49	; 4 - Penguin
	.byte $4D	; 5 - Rabbit
	.byte $51	; 6 - Hammer


	; Draws the tiny Player icon in the world intro box
Map_WorldIntro_DrawPlayer:

	; Copies in the 2 sprites from Map_WorldIntro_PSpr
	LDY #$07	 ; Y = 7
PRG010_C52D:
	LDA Map_WorldIntro_PSpr,Y
	STA Sprite_RAM+$84,Y	
	DEY		 	; Y--
	BPL PRG010_C52D	 	; While Y >= 0, loop!

	LDX Player_Current	 
	LDY World_Map_Power,X	 
	LDA Map_WorldIntro_PSPat,Y	; Get pattern to use based on Player's current powerup
	STA Sprite_RAM+$85	 	; Store as pattern

	ADD #$02	 
	STA Sprite_RAM+$89	 	; Opposite side is prior value + 2

	RTS		 	; Return...

	RTS		 ; Return

WorldIntro_EraseAndStars:
	JSR Map_Intro_Erase1Strip	; Erase one strip of the "World X" Intro box
	JMP MapStarsIntro_DoStarFX	 		; Jump to PRG010_B76C

	; Provides "Video_Upd_Table" format Graphics_Buffer data specifically
	; for eradicating the "World X" intro from a dark World 8 map
	; The low bytes of the video address are replaced with the appropriate offset
Map_W8Dark_IntroCover:
	vaddr $2900
	.byte VU_VERT | 8
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF 

	vaddr $2900
	.byte VU_VERT | 8
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF


; Map_Intro_Erase1Strip
;
; Erases one "strip" of 16x16 tiles to clear the "World X" intro box (or Gameover!) box
; It's important to note that it's done one strip at a time, not at once!
Map_Intro_Erase1Strip:

	; Set page @ A000 to 12
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA <Map_IntBoxErase
	BNE PRG010_C5A9	 	; If Map_IntBoxErase <> 0, jump to PRG010_C5A9

	; Map_IntBoxErase is set to offset of upper-left corner of "World X" 
	; intro box to tell where to start copying the map tiles from!
	LDA <Scroll_ColumnR
	AND #$08	 
	ADD #$34
	STA <Map_IntBoxErase	; Map_IntBoxErase = (Scroll_ColumnR & 8) + $34

	LDA <Scroll_ColumnL
	AND #$f0	
	LSR A		
	LSR A		
	LSR A		
	TAY		 	; Y = (Scroll_ColumnL & $F0) >> 3 (basically current "screen" of map * 2, for indexing Tile_Mem_Addr)

	; Store starting offset for this map screen into Map_Tile_AddrL/H
	LDA Tile_Mem_Addr,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,Y
	STA <Map_Tile_AddrH

	INC <Map_Tile_AddrH	; Effectively adds $100 to the address (maps get loaded at screen base + $110)


	; Calculates the base offset into the nametable for erasing the "World X" intro box
	LDA <Scroll_ColumnR
	AND #$08	 	; 0 or 8, depending if we're scrolled "halfway" across two screens
	ASL A		 	; Now 0 or 16
	ADD #$08	 	; Now 8 or 24
	STA <Map_Intro_NTOff	; Map_Intro_NTOff = 8 or 24

	; Calculates the corresponding offset to the attribute table
	LDA <Horz_Scroll
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A			; Divide by 32 because EACH attribute BYTE defines FOUR 8x8 tiles (4 * 8 = 32)
	ADD #$d2	
	STA <Map_Intro_ATOff		; Map_Intro_ATOff = (Horz_Scroll / 32) + $D2

	LDA #$02	
	STA <Map_StarsState		; Map_StarsState = 2

PRG010_C5A9:
	LDA World_8_Dark
	BEQ PRG010_C5C5		; If World_8_Dark = 0 (no darkness effect), jump to PRG010_C5C5

	; The World 8 Darkness effect version of clearing the World X intro box...

	; Copy Map_W8Dark_IntroCover into the Graphics_Buffer
	LDY #$15	 	
PRG010_C5B0:
	LDA Map_W8Dark_IntroCover,Y	
	STA Graphics_Buffer,Y	 	
	DEY		 		; Y--
	BPL PRG010_C5B0	 		; While Y >= 0, loop!

	; Patch in the correct low byte for the video address
	LDX <Map_Intro_NTOff		
	STX Graphics_Buffer+1	
	INX		 
	STX Graphics_Buffer+$C
	JMP PRG010_C622	 		; Jump to PRG010_C622

PRG010_C5C5:
	LDA Map_IntBoxErase	 
	STA <Temp_Var1		 	; Temp_Var1 = Map_IntBoxErase

	LDX #$00	 		; X = 0

PRG010_C5CC:	
	; CHECKME: Isn't Level_Tileset always equal to zero on world maps??
	; Probably wouldn't matter since PAGE_A000 is hard-coded to 12,
	; instead of using Page_Per_Tileset like it ought to :)
	LDA Level_Tileset
	ASL A		 
	TAY		 		; Y = Level_Tileset << 1 (for indexing TileLayout_ByTileset)

	; Set Temp_Var15 to point to the 16x16 tile 8x8 layout data
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var15		 
	LDA TileLayout_ByTileset+1,Y
	STA <Temp_Var16	

	LDY <Temp_Var1		 	; Get offset to current 16x16 tile we want to grab
	LDA [Map_Tile_AddrL],Y	 	; Grab it!
	TAY		 		; Y = tile

	; The 16x16 tile is laid out in four 256 byte sized "chunks" which define each 8x8
	; in the order of upper-left, lower-left, upper-right, lower-right

	; Upper-left
	LDA [Temp_Var15],Y	 	; Get first 8x8
	STA Scroll_PatStrip,X	 	; Store this 8x8 into the vertical strip

	; Lower-left
	INC <Temp_Var16		; Jump to next layout chunk
	LDA [Temp_Var15],Y	 	; Get next 8x8
	STA Scroll_PatStrip+1,X	; Store this 8x8 into vertical strip, next slot to the right

	; Upper-right
	INC <Temp_Var16		; Jump to next layout chunk
	LDA [Temp_Var15],Y	 	; Get next 8x8
	STA Scroll_PatStrip+$B,X	; Store into vertical strip

	; Lower-right
	INC <Temp_Var16		; Jump to next layout chunk
	LDA [Temp_Var15],Y	 	; Get next 8x8
	STA Scroll_PatStrip+$C,X	; Store into vertical strip

	LDA <Temp_Var1	
	ADD #16	
	STA <Temp_Var1		 	; Temp_Var1 += 16 (get next tile one row down)

	INX
	INX		; X += 2 (next block down in Scroll_PatStrip)

	CPX #$08	
	BNE PRG010_C5CC	; If X <> 8 (4 tiles downward in Scroll_PatStrip), loop!

	; Pushes the Scroll_PatStrip memory into the Graphics_Buffer
	LDX #$12	 		; X = $12
PRG010_C609:
	LDA Scroll_PatStrip,X
	STA Graphics_Buffer+3,X
	DEX		 		; X--
	BPL PRG010_C609	 		; If X >= 0, loop!

	; Used VRAM addr $29xx for both strips
	LDA #$29	 
	STA Graphics_Buffer	
	STA Graphics_Buffer+$B
	
	LDA #(VU_VERT | 8)		; 8 8x8s vertically applied
	STA Graphics_Buffer+2
	STA Graphics_Buffer+$D

PRG010_C622:
	LDX <Map_Intro_NTOff		
	STX Graphics_Buffer+1	 	; Store lower part of VRAM address
	INX		 
	STX Graphics_Buffer+$C	 	; Store lower part of VRAM address


	; Now it's the attribute table's turn...

	; Store VRAM addr $2Bxx
	LDA #$2b
	STA Graphics_Buffer+$16
	STA Graphics_Buffer+$1A

	; Store lower part of VRAM address
	LDA <Map_Intro_ATOff	
	STA Graphics_Buffer+$17
	ADD #$08	 
	STA Graphics_Buffer+$1B

	; Just one byte to copy
	LDA #$01
	STA Graphics_Buffer+$18
	STA Graphics_Buffer+$1C

	LDA <Map_Intro_CurStripe
	AND #$06	
	LSR A		
	TAX		 ; X = (Map_Intro_CurStripe & 6) >> 1

	LDA <Scroll_ColorStrip,X
	STA Graphics_Buffer+$19	

	LDA <Scroll_ColorStrip+4,X	
	STA Graphics_Buffer+$1D	

	LDA <Map_Intro_CurStripe		
	AND #$01	 
	BNE PRG010_C66A	 	; If Map_Intro_CurStripe bit 0 set, jump to PRG010_C66A

	; Otherwise...
	LDA <Scroll_ColorStrip,X
	AND #$33	 
	STA Graphics_Buffer+$19

	LDA <Scroll_ColorStrip+4,X	
	AND #$33	 	
	STA Graphics_Buffer+$1D	

PRG010_C66A:
	LDA #$00	 
	STA Graphics_Buffer+$1E

	; If, on the next increment to Map_IntBoxErase, the lower 4 bits are "zero",
	; it has wrapped to a new row.  This should only happen when the "World X"
	; intro is being performed in "halfway off-centered" mode...
	LDX <Map_IntBoxErase
	INX		
	TXA		
	AND #$0f	 	
	BNE PRG010_C689	 	; If (Map_IntBoxErase + 1) & $0F is non-zero, jump to PRG010_C689

	; Otherwise, we need to update the address
	JSR Map_NextScreen

	LDA <Map_IntBoxErase
	AND #$f0	 	
	TAX		 	; X = (Map_IntBoxErase & $F0); current row within map "screen" of tiles

PRG010_C689:
	STX <Map_IntBoxErase	; Update Map_IntBoxErase

	TXA		
	AND #$01	
	BNE PRG010_C69F	 	; If (Map_IntBoxErase & 1) <> 0 (if we're on an "odd" tile), jump to PRG010_C69F

	; Otherwise need to update the attribute stuff!

	; If, on the next increment to Map_Intro_ATOff, the lower 3 bits are "zero",
	; it has wrapped to a new row.  This should only happen when the "World X"
	; intro is being performed in "halfway off-centered" mode...
	LDX <Map_Intro_ATOff
	INX
	TXA
	AND #$07
	BNE PRG010_C69D	 	; If (Map_Intro_ATOff + 1) & 7 <> 0, jump to PRG010_C69D

	LDA <Map_Intro_ATOff
	AND #$f0	 
	TAX		 	; X contains just the upper 4 bits of Map_Intro_ATOff

PRG010_C69D:
	STX <Map_Intro_ATOff	; Update Map_Intro_ATOff


PRG010_C69F

	; If, on the next +2 to Map_Intro_NTOff, the lower 5 bits are "zero",
	; it has wrapped to a new row.  This should only happen when the "World X"
	; intro is being performed in "halfway off-centered" mode...
	LDX <Map_Intro_NTOff
	INX
	INX
	TXA
	AND #$1f
	BNE PRG010_C6AA		; If (Map_Intro_NTOff + 1) & $1f <> 0, jump to PRG010_C6AA

	LDX #$00	 	; X = 0

PRG010_C6AA:
	STX <Map_Intro_NTOff	; Update Map_Intro_NTOff

	INC <Map_Intro_CurStripe ; Map_Intro_CurStripe++

	LDA <Map_Intro_CurStripe
	CMP #$08	 
	BNE PRG010_C6BB	 	; If Map_Intro_CurStripe <> 8, jump to PRG010_C6BB

	; Otherwise, we're done!  The stupid box is erased!
	LDA #$00
	STA <Map_IntBoxErase	; Map_IntBoxErase = 0
	INC World_EnterState	; Next state!  (NOTE: Gameover uses this too, so GameOver_State, which is the same memory)

PRG010_C6BB:
	; In any case, put page 11 back in at A000
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	RTS		 ; Return

WorldIntro_CompleteStars:
	JSR MapStarsIntro_DoStarFX	; Continue updating starry intro until complete
	LDA Map_StarFX_State	 
	BNE PRG010_C6D7		; If Map_StarFX_State <> 0, jump to PRG010_C6D7 (RTS)

	; Star intro is over!

	INC Map_Operation	; Next Map_Operation...

	LDA #$00
	STA World_EnterState	; World_EnterState = 0

	JMP Map_DrawPlayer	; Jump to Map_DrawPlayer

PRG010_C6D7:
	RTS		 ; Return

GameOver_Complete:
	LDA Map_Intro_Tick
	BNE PRG010_C6E2	 ; If Map_Intro_Tick <> 0, jump to PRG010_C6E2

	; Map_Intro_Tick = $10
	LDA #$10
	STA Map_Intro_Tick

PRG010_C6E2:
	JSR PRG010_C513

	LDA Map_Intro_Tick
	BNE PRG010_C6EF	 ; If Map_Intro_Tick <> 0, jump to PRG010_C6EF

	LDA #$00
	STA Map_Object_ActY

PRG010_C6EF:
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

GameOver_Loop:
	LDA GameOver_State
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word GameOver_WaitOnBGM	; 0: Wait for "Game Over" music to finish
	.word GameOver_DoMenu		; 1: Player selects action

	; Player selected CONTINUE...
	.word Map_Intro_Erase1Strip	; 2: Erase the Gameover box
	.word GameOver_Timeout		; 3: Short timeout before we decide what to do next
	.word GameOver_TwirlToStart	; 4: Player twirls back to map start (jumps to State 8 after this)
	.word GameOver_TwirlFromAfar	; 5: Player twirling in from far away; pretty much straight left
	.word GameOver_AlignToStartY	; 6: Player aligns to starting map Y
	.word GameOver_ReturnToStartX	; 7: Player slides back to starting X
	.word GameOver_Complete		; 8: Complete the sequence

	; NOTE: GameOver_State = 9 is handled specially outside of this routine

GameOver_WaitOnBGM:
	LDA SndCur_Music1	 
	BNE PRG010_C712	 ; If Game Over music is still playing, jump to PRG010_C712

	INC GameOver_State	 ; GameOver_State++

PRG010_C712:
	JMP PRG010_C772	 ; Jump to PRG010_C772

GameOver_DoMenu:
	LDA <Pad_Input
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG010_C72B	 ; If Player is pressing neither UP nor DOWN, jump to PRG010_C72B

	; Play the bleep noise
	LDA #SND_MAPPATHMOVE
	STA Sound_QMap

	; Switch between $60/$68 (cursor up and down)
	LDA Map_GameOver_CursorY
	EOR #$08
	STA Map_GameOver_CursorY

	JMP PRG010_C748	 ; Jump to PRG010_C748

PRG010_C72B:

	; Player not pressing UP or DOWN...

	LDA <Pad_Input
	AND #PAD_START
	BEQ PRG010_C748	 ; If Player is NOT pressing START, jump to PRG010_C748

	; Play the starry entrance sound (this is never heard!)
	LDA #SND_MAPENTERWORLD
	STA Sound_QLevel1

	LDX #$09	 ; X = 9 (Player selects END)
	LDA Map_GameOver_CursorY

	AND #$08
	BNE PRG010_C741	 ; If Player selected "END", jump to PRG010_C741

	LDX #$02	 ; X = 2 (Player selects CONTINUE)

PRG010_C741:
	STX GameOver_State	 ; Set GameOver_State appropriately

	; Map_UnusedGOFlag = $F8 
	LDA #$f8
	STA <Map_UnusedGOFlag

PRG010_C748:
	; Clear all the map object Y to $F8 (off-screen)!
	LDY #$0d	 ; Y = $D
	LDA #$f8	 ; A = $F8
PRG010_C74C:
	STA Map_Object_ActY,Y	 ; -> map object's Y
	DEY		 ; Y--
	BPL PRG010_C74C	 ; While Y >= 0, loop!

	JMP PRG010_C75D	 ; Jump to PRG010_C75D

GameOver_DeadPlayerSprite:
	.byte $64, $61, $00, $50	; Left half
	.byte $64, $61, $40, $58	; Right half
	
PRG010_C75D:

	; Set game over action cursor Y
	LDA Map_GameOver_CursorY
	STA Sprite_RAM+$94

	; Set game over action cursor pattern
	LDA #$6f
	STA Sprite_RAM+$95

	; Set game over action cursor attributes
	LDA #SPR_PAL0
	STA Sprite_RAM+$96

	; Set game over action cursor X
	LDA #$68
	STA Sprite_RAM+$97

	; Generate the little "dead Player" sprite in the Game Over box
PRG010_C772:
	LDY #$07	 ; Y = 7
PRG010_C774:
	LDA GameOver_DeadPlayerSprite,Y	 ; Get dead player sprite byte
	STA Sprite_RAM+$84,Y	 ; Store into Sprite_RAM

	DEY		 ; Y--
	BPL PRG010_C774	 ; While Y >= 0, loop!

	RTS		 ; Return

GameOver_Timeout:
	LDA Map_Intro_Tick
	BNE PRG010_C788	 ; If Map_Intro_Tick <> 0, jump to PRG010_C788

	; Map_Intro_Tick = $10 -- short version
	LDA #$10
	STA Map_Intro_Tick

PRG010_C788:
	JSR WorldIntro_BoxTimer_NoSym	 ; Just delay until Map_Intro_Tick = 0

	LDA GameOver_State
	CMP #$04
	BNE PRG010_C79D	 ; If GameOver_State <> 4 (4 means timer expired, went to next state), jump to PRG010_C79D (WorldMap_UpdateAndDraw)

	; We're in state 4 now... (this will be for one cycle only, we're on our way out)

	LDA <Horz_Scroll_Hi
	BNE PRG010_C79A	 ; If not back on the first map screen yet, jump to PRG010_C79A

	LDA <Horz_Scroll
	BEQ PRG010_C79D	 ; If on the first map screen hard left, jump to PRG010_C79D (WorldMap_UpdateAndDraw)

PRG010_C79A:

	; In some way we're not all the way to the left on the map at this time...

	INC GameOver_State	 ; GameOver_State++

PRG010_C79D:
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

MO_SwitchToMO_D:
	; Kind of a silly and pointless Map_Operation; maybe they intended for more here?
	LDA #$0d
	STA Map_Operation	; Map_Operation = $D
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

MO_Wait14Ticks:
	LDA Map_Intro_Tick
	BNE PRG010_C7B2	 ; If Map_Intro_Tick <> 0, jump to PRG010_C7B2

	; Map_Intro_Tick = 14
	LDA #14
	STA Map_Intro_Tick

PRG010_C7B2:
	DEC Map_Intro_Tick	; Map_Intro_Tick--
	BNE PRG010_C7BA	 	; If Map_Intro_Tick <> 0, jump to PRG010_C7BA

	INC Map_Operation	; Map_Operation++

PRG010_C7BA:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw map and don't come back


MO_DoFortressFX:
	LDA <Map_ClearLevelFXCnt
	BEQ PRG010_C8B0	 ; If not already doing a "poof" effect, jump to PRG010_C8B0
	JMP PRG010_C9A4	 ; Otherwise, jump to PRG010_C9A4

PRG010_C8B0:
	LDA Map_DoFortressFX
	BNE PRG010_C8B8	 ; If we've got some post-Mini-Fortress effect to do, jump to PRG010_C8B8
	JMP PRG010_C9D0	 ; Otherwise, jump to PRG010_C9D0

PRG010_C8B8:

	; Got a post-Mini-Fortress effect to do

	LDA Map_Intro_Tick
	BNE PRG010_C8C2	 ; If tick counter <> 0, jump to PRG010_C8C2

	; Otherwise, Map_Intro_Tick = $20
	LDA #$20
	STA Map_Intro_Tick

PRG010_C8C2:
	JSR FX_MonoFlash_By_MapTick	; Do "flash" effect while busting lock / creating bridge / etc.

	LDA Map_Intro_Tick
	BEQ PRG010_C8CD	 ; If Map_Intro_Tick = 0, jump to PRG010_C8CD

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

FortressFX_VAddrH:	.byte $29, $28, $29, $2A
FortressFX_VAddrL:	.byte $8A, $D0, $96, $50

FortressFX_Patterns:
	.byte $FE, $FE, $E1, $E1	; 0
	.byte $FE, $C0, $FE, $C0	; 1
	.byte $FE, $FE, $E1, $E1	; 2
	.byte $FE, $C0, $FE, $C0	; 3

	; The related "row" for the FortressFX_MapLocation
FortressFX_MapLocationRow:
	.byte $60, $30, $60, $90

	; Lower 4 bits are the "screen", upper 4 bits are the column
FortressFX_MapLocation:
	.byte $50, $80, $B0, $80

FortressFX_MapTileReplace:
	.byte TILE_HORZPATH, TILE_VERTPATH, TILE_HORZPATH, TILE_VERTPATH

PRG010_C8CD:
	DEC Map_DoFortressFX	 ; Map_DoFortressFX-- (normalize the index, since Boom Boom should set this at 1+)

	; Play Magic sound
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

	; Set poof counter
	LDA #$01
	STA <Map_ClearLevelFXCnt

	LDY Graphics_BufCnt	 ; Y = current graphics buffer count
	LDX Map_DoFortressFX	 ; X = Mini Fortress effect slot index

	; Get appropriate high byte of VRAM address -> Temp_Var11
	LDA FortressFX_VAddrH,X
	STA <Temp_Var11	
	STA Graphics_Buffer,Y	; ... and into Graphics Buffer

	INY		 ; Y++ (next byte in graphics buffer)

	; Get appropriate low byte of VRAM address -> Temp_Var12
	LDA FortressFX_VAddrL,X
	STA <Temp_Var12	
	STA Graphics_Buffer,Y	; ... and into Graphics Buffer

	INY		 ; Y++ (next byte in graphics buffer)

	; Mark a 2 byte run
	LDA #$02
	STA Graphics_Buffer,Y
	INY		 ; Y++ (next byte in graphics buffer)

	LDA Map_DoFortressFX
	ASL A
	ASL A
	TAX		 ; X = Map_DoFortressFX * 4 (four 8x8 tiles per Map_DoFortressFX index)

	LDA FortressFX_Patterns,X	; Get pattern
	STA Graphics_Buffer,Y	 	; Store into graphics buffer
	INX		 ; X++ (next pattern)
	INY		 ; Y++ (next byte in graphics buffer)

	LDA FortressFX_Patterns,X	; Get pattern
	STA Graphics_Buffer,Y	 	; Store into graphics buffer
	INX		 ; X++ (next pattern)
	INY		 ; Y++ (next byte in graphics buffer)

	; 32 bytes to get to the next row (bottom half of map tile getting changed)
	LDA <Temp_Var12
	ADD #32
	STA <Temp_Var12
	LDA <Temp_Var11
	ADC #$00
	STA <Temp_Var11

	STA Graphics_Buffer,Y	 ; Store new high byte

	INY		 ; Y++ (next byte in graphics buffer)

	LDA <Temp_Var12
	STA Graphics_Buffer,Y	 ; Store new low byte

	INY		 ; Y++ (next byte in graphics buffer)

	; Mark a 2 byte run
	LDA #$02
	STA Graphics_Buffer,Y
	INY		 ; Y++ (next byte in graphics buffer)

	LDA FortressFX_Patterns,X	; Get pattern
	STA Graphics_Buffer,Y	 	; Store into graphics buffer
	INY		 ; Y++ (next byte in graphics buffer)
	INX		 ; X++ (next pattern)

	LDA FortressFX_Patterns,X	; Get pattern
	STA Graphics_Buffer,Y	 	; Store into graphics buffer
	INY		 ; Y++ (next byte in graphics buffer)

	; Terminator!
	LDA #$00
	STA Graphics_Buffer,Y

	STY Graphics_BufCnt	 ; Update graphics buffer count
	
	LDX Map_DoFortressFX
	LDA FortressFX_MapLocation,X
	AND #$0f	 ; Extract the "screen" of the map
	ASL A		 ; Convert to 2-byte index
	TAY		 ; -> 'Y'

	LDA Tile_Mem_Addr,Y	; Get low byte of address to tile memory for the specified screen
	ADD #$f0		; Offset to map level
	STA <Temp_Var15		; -> Temp_Var15

	LDA Tile_Mem_Addr+1,Y	; Get high byte of address to tile memory for the specified screen
	ADC #$00		; Apply carry
	STA <Temp_Var16		; -> Temp_Var16

	LDA FortressFX_MapLocation,X	; Get the column value
	LSR A
	LSR A
	LSR A
	LSR A				; Shift into position
	ORA FortressFX_MapLocationRow,X	 ; OR on the Row
	TAY		 ; -> 'Y'

	; Replace the tile in-memory
	LDA FortressFX_MapTileReplace,X
	STA [Temp_Var15],Y
	

PRG010_C9A4:
	LDA <Counter_1
	AND #$03
	BNE PRG010_C9B2	 ; Only proceed 1:4 ticks, otherwise jump to PRG010_C9B2

	INC <Map_ClearLevelFXCnt
	LDA <Map_ClearLevelFXCnt
	CMP #$07
	BEQ PRG010_C9C9	 ; Basically event ends in 7*4 = 28 ticks, then jump to PRG010_C9C9

PRG010_C9B2:
	LDY Map_DoFortressFX	 ; Y = Map_DoFortressFX

	; Store the map location pixel Y -> Temp_Var1
	LDA FortressFX_MapLocationRow,Y
	STA <Temp_Var1

	; Store the map location pixel X -> Temp_Var2
	LDA FortressFX_MapLocation,Y
	AND #$f0
	STA <Temp_Var2

	LDY <Map_ClearLevelFXCnt		 ; Y = Map_ClearLevelFXCnt
	JSR Map_DrawClearLevelPoof	 ; Draw the "poof"
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG010_C9C9:
	; Clear variables
	LDA #$00
	STA Map_DoFortressFX
	STA <Map_ClearLevelFXCnt

PRG010_C9D0:
	INC Map_Operation	 	; Map_Operation++
	JMP WorldMap_UpdateAndDraw	; Jump to WorldMap_UpdateAndDraw

FX_MonoFlash_By_MapTick:
	; Every 4 ticks, this alternates between color and mono on the PPU
	; to produce a quick and dirty "bright flash" effect
	LDA Map_Intro_Tick
	AND #$04	 	; A = Map_Intro_Tick & 4
	LSR A		 
	LSR A		 	; Shift down twice (so 0/1 toggle only, every 4 map ticks)
	ORA #$18	 	; Normal BG/sprite bits
	STA <PPU_CTL2_Copy	; Update PPU_CTL2
	DEC Map_Intro_Tick	; Map_Intro_Tick--
	RTS		 	; Return


MO_HammerBroMarch:
	LDA Map_NoLoseTurn
	BEQ PRG010_C9F2	 ; If Player's turn will end, jump to PRG010_C9F2

	; Otherwise, Map_Operation = $0C (the "Wait 8 ticks and proceed" state...)
	LDA #$0c
	STA Map_Operation

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG010_C9F2:
	JSR WorldMap_UpdateAndDraw	; Update and draw map

	LDY #(MAPOBJ_TOTAL-1)	; Y = (MAPOBJ_TOTAL-1) (For all map objects)
PRG010_C9F7:
	LDA Map_March_Count,Y
	BNE PRG010_CA2A	 	; If march counter <> 0, jump to PRG010_CA2A (RTS)

	DEY		 	; Y--
	BPL PRG010_C9F7		; While Y >= 0, loop

	; ALL March counters are zero...

	; First Map_March_Count = 8
	LDA #$08
	STA Map_March_Count

	INC Map_Operation	 ; Map_Operation++ (the "Wait 8 ticks and proceed" state...)

	LDY #(MAPOBJ_TOTAL-1)	; Y = (MAPOBJ_TOTAL-1) (For all map objects)
PRG010_CA09:
	LDA Map_Object_ActY,Y
	ADD #$08	; +8
	AND #$f0	; Align to grid
	STA Map_Objects_Y,Y	 ; -> Map object Y

	LDA Map_Object_ActX,Y
	ADD #$08	; +8
	AND #$f0	; Align to grid
	STA Map_Objects_XLo,Y	 ; -> Map object X

	LDA Map_Object_ActXH,Y
	ADC #$00	 ; Apply carry
	STA Map_Objects_XHi,Y	 ; -> Map object X Hi

	DEY		 	; Y--
	BPL PRG010_CA09		; While Y >= 0, loop

PRG010_CA2A:
	RTS		 ; Return


MO_Wait8Proceed:
	; SB: I made this happen later than it used to around PRG062_910C
	LDA #$00
	STA Map_ReturnStatus

	; Since Daredevil Comet takes away your power-up,
	; we back it up into Level_TreasureItem and restore
	; it once you return to the map. This is signified by
	; bit 7 being set on it!
	LDA Level_TreasureItem
	BPL MOW8P_NoPowerRestore

	LDX Player_Current	 ; X = Player_Current 
	AND #$7F
	STA World_Map_Power,X
	STA Map_Power_Disp

	; If Fire flower or greater, restore palette
	CMP #2
	BLT MOW8P_NoPowerRestore

	ASL A
	ASL A
	TAY
	JSR_THUNKA 26, Inv_PUp_SetPalette

MOW8P_NoPowerRestore:
	LDA Map_Intro_Tick
	BNE PRG010_CA35	 ; If Map_Intro_Tick <> 0, jump to PRG010_CA35

	JSR Map_BackupObjects

	; Map_Intro_Tick = 8
	LDA #$08
	STA Map_Intro_Tick

	; Update Star Coins in case of death
	JSR Map_UpdateStarCoins_AtPlayer

PRG010_CA35:
	DEC Map_Intro_Tick	 ; Map_Intro_Tick--
	BNE PRG010_CA7F	 	; If Map_Intro_Tick <> 0, jump to PRG010_CA7F

	; Map_Intro_Tick just expired...

	LDX Player_Current	 ; X = Player_Current 

	; Clear all controller input data
	LDA #$00	 
	STA <Controller1	
	STA <Controller1Press	
	STA <Controller2	
	STA <Controller2Press	

	; Stop any movement repeating
	LDA #$ff	 ; A = $FF
	STA Map_MoveRepeat,X

	LDA Map_NoLoseTurn
	BNE PRG010_CA77	 ; If Player's turn does not end (e.g. used a pipeway, Toad House, etc.), jump to PRG010_CA77

	LDA World_Num
	CMP #$02
	BNE PRG010_CA60	 ; If World_Num <> 2 (World 3), jump to PRG010_CA60

	; On World 3, toggle the bridge state
	LDA World3_Bridge
	EOR #$01
	STA World3_Bridge

PRG010_CA60:
	LDA Total_Players
	CMP #$01
	BEQ PRG010_CA77	 ; If only a 1P game, jump to PRG010_CA77

	LDX Player_Current	 ; X = Player_Current

	LDA #$01
	STA Map_Player_SkidBack,X

	; Map_Operation = $0F
	LDA #$0f
	STA Map_Operation

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG010_CA77:
	INC Map_Operation	 ; Map_Operation++ (Map_Operation = $0D, resume normal operations)

	; World_EnterState = 0
	LDA #$00
	STA World_EnterState

PRG010_CA7F:
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw


	; FIXME: Anybody wants to claim this??
; $CA82
	LDA World_EnterState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Map_StateNothing
	.word MO_NormalMoveEnter

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DrawAndPan
;
; Draw and perform panning on World Map
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_DrawAndPan:
	LDA Map_DrawPanState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Map_Do_Borders	; 0 - NOT USED (Map_DrawAndPan is not called if Map_DrawPanState == 0)
	.word Map_Do_Borders	; 1 - Draw left/right borders
	.word Map_DoVBorders	; 2 - Vertical border 
	.word Map_DoVBorders	; 3 - Vertical border 
	.word Map_PanInit	; 4 - Initialize map panning
	.word Map_PanRight	; 5 - Pan map to the right
	.word Map_PanLeft	; 6 - Pan map to the left
	
PRG010_CAA0:
	.byte $00, $0E

Map_Do_Borders:
	LDX <Map_ScrollOddEven	; X = Map_ScrollOddEven
	LDA <Scroll_ColumnL	; A = Scroll_ColumnL
	ADD PRG010_CAA0,X	; Add a value based on the value of Map_ScrollOddEven (0 for not entering, 1 for entering; 2 was used in Japanese version only showing the level)
	PHA			; Save A
	AND #$f0	 	; Screen only
	LSR A		 
	LSR A		 
	LSR A		 	; A >> 2 screen index
	TAY		 	; Y = A
	LDA Tile_Mem_Addr,Y	; Beginning of tiles we're going to modify
	ADD #$f0	 	; Add $f0 to it??

	; Store address into [<Map_Tile_AddrH][Map_Tile_AddrL]
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,Y
	ADC #$00	 	; if any overflow from the addition
	STA <Map_Tile_AddrH	

	PLA		 	; Restore A (Screen_ColumnL + value)
	AND #$0f	 	; Screen-relative column index 
	STA <Temp_Var5	 	; Store that to Temp_Var5
	LDX #$00	 	; X = 0
	LDA <Map_ScrollOddEven	; A = Map_ScrollOddEven
	AND #$01	 	; Check if entering
	BEQ PRG010_CACF	 	; If NOT entering, jump to PRG010_CACF
	LDX #$06	 	; Otherwise, X = 6
PRG010_CACF:
	LDY <Temp_Var5		; Y = Temp_Var5 (screen-relative column index)
	LDA [Map_Tile_AddrL],Y	; Get tile
	AND #$c0	 	; Only keep its upper 2 bits ($00, $40, $80, $C0)
	STA <Temp_Var1		; Store this into Temp_Var1
	INY		 	; Y++
	LDA [Map_Tile_AddrL],Y	; Get the next tile
	AND #$c0	 	; Only keep its upper 2 bits ($00, $40, $80, $C0)
	STA <Temp_Var2		; Store this into Temp_Var2

	TYA		 	
	ADD #15
	TAY		 	; Y += 15 (next row)

	LDA [Map_Tile_AddrL],Y	; Get this tile
	AND #$c0	 	; Only keep its upper 2 bits ($00, $40, $80, $C0)
	STA <Temp_Var3		; Store this into Temp_Var3
	INY		 	; Y++
	LDA [Map_Tile_AddrL],Y	; Get this tile
	AND #$c0	 	; Only keep its upper 2 bits ($00, $40, $80, $C0)
	STA <Temp_Var4		; Store this into Temp_Var4

	; Take the four tiles and form an attribute byte
	LDA <Temp_Var1
	LSR A		
	LSR A		
	ORA <Temp_Var2	
	LSR A		
	LSR A		
	ORA <Temp_Var3	
	LSR A		
	LSR A		
	ORA <Temp_Var4	

	STA Map_BorderAttrFromTiles,X
	INX		 ; X++

	LDA <Temp_Var5
	ADD #32
	STA <Temp_Var5	 ; Temp_Var5 += 32

	AND #$f0	 ; Only keep upper four bits of Temp_Var5
	CMP #$c0	 
	BNE PRG010_CACF	 ; If not equal to $C0, loop!

	INC Map_DrawPanState	 ; Map_DrawPanState++
	INC <Map_ScrollOddEven	 ; Map_ScrollOddEven++

	LDA <Map_ScrollOddEven
	AND #$01
	BNE PRG010_CB1E

	; Map_ScrollOddEven = 0
	LDA #$00
	STA <Map_ScrollOddEven

PRG010_CB1E:
	JMP Scroll_Map_SpriteBorder	 ; Draw the sprite version of the border

Border_VAttrMask:	.byte $CC, $CC, $CC, $CC, $CC, $CC
			.byte $33, $33, $33, $33, $33, $33
Border_VAttrs:		.byte $11, $11, $11, $11, $11, $11	; Attributes along left vertical border
			.byte $44, $44, $44, $44, $44, $44	; Attributes along right vertical border

PRG010_CB39:
	vaddr $2BC0
	.byte $01, $00

	vaddr $2BC8
	.byte $01, $00

	vaddr $2BD0
	.byte $01, $00

	vaddr $2BD8
	.byte $01, $00

	vaddr $2BE0
	.byte $01, $00

	vaddr $2BE8
	.byte $01, $00

	.byte $00	; Terminator
PRG010_CB39_End

; FIXME: Anybody want to claim this??
; $CB52
        vaddr $2BC7
	.byte $01, $00

	vaddr $2BCF
	.byte $01, $00

	vaddr $2BD7
	.byte $01, $00

	vaddr $2BDF
	.byte $01, $00

	vaddr $2BE7
	.byte $01, $00

	vaddr $2BEF
	.byte $01, $00

	; Terminator
	.byte $00

PRG010_CB6B:
	vaddr $2860
	.byte $01, $00

	vaddr $2880
	.byte VU_VERT | VU_REPEAT | $13, $00

	vaddr $2AE0
	.byte $01, $00

	.byte $00	; Terminator
PRG010_CB6B_End

Border_TopCorners:	.byte $80, $81, $FF	; Upper left corner, upper right corner, and a black one more to the right
Border_VertEdges:	.byte $CC, $CC, $FF	; Border left, border right, and a black one more to the right
Border_BottomCorners:	.byte $82, $83, $FF	; Lower left corner, lower right corner, and a black one more to the right

VBorder_Offset:
	.byte $01, $1E, $1F


Map_DoVBorders:
	LDA Map_DrawPanState
	CMP #$02
	BNE PRG010_CBE0	 ; If Map_DrawPanState <> 2, jump to PRG010_CBE0

	LDY #(PRG010_CB6B_End - PRG010_CB6B - 1)
PRG010_CB8D:
	LDA PRG010_CB6B,Y	 ; Get graphics buffer command byte
	STA Graphics_Buffer,Y	 ; Store into graphics buffer

	DEY		 ; Y--
	BPL PRG010_CB8D	; While Y >= 0, loop

	LDX <Map_ScrollOddEven		 ; X = Map_ScrollOddEven

	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	EOR VBorder_Offset,X
	STA <Temp_Var1

	LDY #$02	 ; Y = 2
	LDX #$00	 ; X = 0
PRG010_CBA6:
	LDA Graphics_Buffer+1,X
	EOR <Temp_Var1
	STA Graphics_Buffer+1,X

	INX
	INX
	INX
	INX	; X += 4

	DEY		 ; Y--
	BPL PRG010_CBA6	; While Y >= 0, loop

	LDY <Map_ScrollOddEven	 ; Y = Map_ScrollOddEven

	LDA Border_TopCorners,Y
	STA Graphics_Buffer+3

	LDA Border_VertEdges,Y
	STA Graphics_Buffer+7

	LDA Border_BottomCorners,Y
	STA Graphics_Buffer+$B

	; Graphics_BufCnt = 12
	LDA #12
	STA Graphics_BufCnt

	INC <Map_ScrollOddEven	 ; Map_ScrollOddEven++

	LDA <Map_ScrollOddEven
	CMP #$03
	BNE PRG010_CBDD	 ; If Map_ScrollOddEven <> 3, jump to PRG010_CBDD

	; Map_ScrollOddEven = 0
	LDA #$00
	STA <Map_ScrollOddEven

	INC Map_DrawPanState	 ; Map_DrawPanState++

PRG010_CBDD:
	JMP Scroll_Map_SpriteBorder	 ; Draw sprite border and don't come back!

PRG010_CBE0:
	LDY #(PRG010_CB39_End - PRG010_CB39 - 1)
	LDX #(PRG010_CB39_End - PRG010_CB39 - 1)

	LDA <Map_ScrollOddEven
	BEQ PRG010_CBEA	 ; If Map_ScrollOddEven = 0, jump to PRG010_CBEA

	LDX #$31	 ; X = $31

PRG010_CBEA:
	LDA PRG010_CB39,X	 ; Get graphics buffer command byte
	STA Graphics_Buffer,Y	 ; Store into graphics buffer

	DEX		 ; X--
	DEY		 ; Y--
	BPL PRG010_CBEA	 ; While Y >= 0, loop

	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var1

	LDY #$00	 ; Y = 0
	LDX #$00	 ; X = 0

	; Temp_Var2 = 5
	LDA #$05
	STA <Temp_Var2

	LDA <Map_ScrollOddEven
	BEQ PRG010_CC0B	 ; If Map_ScrollOddEven = 0, jump to PRG010_CC0B

	LDY #$06	 ; Y = 6

PRG010_CC0B: 

	; Set VRAM low address in graphics buffer
	LDA Graphics_Buffer+1,X
	EOR <Temp_Var1
	STA Graphics_Buffer+1,X

	LDA Map_BorderAttrFromTiles,Y
	AND Border_VAttrMask,Y
	ORA Border_VAttrs,Y
	STA Graphics_Buffer+3,X

	INX
	INX
	INX
	INX		 ; X += 4

	INY		 ; Y++

	DEC <Temp_Var2	 ; Temp_Var2--
	BPL PRG010_CC0B	 ; While Temp_Var2 >= 0, loop

	; Graphics_BufCnt = $18
	LDA #$18
	STA Graphics_BufCnt

	INC <Map_ScrollOddEven	 ; Map_ScrollOddEven++

	LDA <Map_ScrollOddEven
	AND #$01
	BNE PRG030_CC3C

	; Map_DrawPanState = 0
	LDA #$00
	STA Map_DrawPanState
	STA <Map_ScrollOddEven

PRG030_CC3C:
	JMP Scroll_Map_SpriteBorder	 ; Draw sprite border and don't come back

Map_PanInit:

	; Map_ScrollOddEven = 0
	LDA #$00
	STA <Map_ScrollOddEven

	INC Map_DrawPanState	 ; Map_DrawPanState++

	JMP Map_PanRight	 ; Jump to Map_PanRight

Scroll_ColumnLOff:	.byte $00, $0F, $00

Map_PanRight:
	; Switch to page 12 @ A000 (for map tile 8x8 layout data)
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #12
	STA MMC3_PAGE

	LDY <Map_ScrollOddEven		 ; Y = Map_ScrollOddEven

	LDA <Scroll_ColumnL
	ADD Scroll_ColumnLOff,Y
	STA <Scroll_ColumnL

	AND #$f0
	LSR A
	LSR A
	LSR A
	TAY		 ; -> 'Y'

	; Set Map_Tile_AddrL/H 
	LDA Tile_Mem_Addr,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,Y
	STA <Map_Tile_AddrH

	INC <Map_Tile_AddrH	; Map is always on the "lower" tile memory

	LDA <Scroll_ColumnL
	AND #$0f
	STA <Temp_Var1

	LDX #$00	 ; X = 0

PRG010_CC7A:
	LDA Level_Tileset
	ASL A 
	TAY		 ; Y = Level_Tileset * 2

	; Get pointer to tile layout -> Temp_Var15/16
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var15
	LDA TileLayout_ByTileset+1,Y
	STA <Temp_Var16

	LDY <Temp_Var1		 ; Y = Temp_Var1

	LDA [Map_Tile_AddrL],Y	; Get tile
	TAY		 	; -> 'Y'

	LDA <Map_ScrollOddEven
	AND #$01
	BNE PRG010_CC98

	; Temp_Var16 += 2 (two 8x8 patterns over)
	INC <Temp_Var16
	INC <Temp_Var16

PRG010_CC98:
	LDA [Temp_Var15],Y		; Get this pattern
	STA Scroll_PatStrip+$20,X	; Store into Scroll_PatStrip

	INC <Temp_Var16			; Temp_Var16++

	LDA [Temp_Var15],Y		; Get this pattern
	STA Scroll_PatStrip+$21,X	; Store into Scroll_PatStrip

	; X += 2
	INX
	INX

	; Temp_Var1 += 16
	LDA <Temp_Var1
	ADD #$10
	STA <Temp_Var1

	AND #$f0
	CMP #$b0
	BNE PRG010_CC7A

	LDA <Scroll_ColumnL
	AND #$0f
	ASL A
	TAY		 ; -> 'Y'

	LDA <Map_ScrollOddEven
	AND #$01
	BNE PRG010_CCC0

	INY		 ; Y++

PRG010_CCC0:
	LDA #$20
	STA Scroll_ToVRAMHi	 ; Scroll_ToVRAMHi = $20

	STY Scroll_LastCol8

	INC <Map_ScrollOddEven	 ; Map_ScrollOddEven++

	LDA <Map_ScrollOddEven
	CMP #$03
	BNE PRG010_CCD7	 ; If Map_ScrollOddEven <> 3, jump to PRG010_CCD7

	; Map_ScrollOddEven = 0
	LDA #$00
	STA <Map_ScrollOddEven

	INC Map_DrawPanState	 ; Map_DrawPanState++

PRG010_CCD7:
	; Switch to page 11 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #11
	STA MMC3_PAGE

	JMP Scroll_Map_SpriteBorder	 ; Draw map sprite border and don't come back

Map_PanLeft:
	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var1

	LDY #(PRG010_CB39_End - PRG010_CB39 - 1)
	LDX #(PRG010_CB39_End - PRG010_CB39 - 1)

	LDA <Map_ScrollOddEven
	BEQ PRG010_CCF7	 ; If Map_ScrollOddEven = 0, jump to PRG010_CCF7

	LDX #$31	 ; X = $31
PRG010_CCF7:
	LDA PRG010_CB39,X	 ; Get graphics buffer command byte
	STA Graphics_Buffer,Y	 ; Store into graphics buffer

	DEX		 ; X--
	DEY		 ; Y--
	BPL PRG010_CCF7	 ; While Y >= 0, loop

	LDY #$00	 ; Y = 0
	LDX #$00	 ; X = 0

	LDA <Map_ScrollOddEven
	BEQ PRG010_CD0B	 ; If Map_ScrollOddEven = 0, jump to PRG010_CD0B

	LDY #$06	 ; Y = 6

PRG010_CD0B:
	; Set VRAM low address in graphics buffer
	LDA Graphics_Buffer+1,X
	EOR <Temp_Var1
	STA Graphics_Buffer+1,X

	LDA Map_BorderAttrFromTiles,Y
	STA Graphics_Buffer+3,X

	INX
	INX
	INX
	INX	; X += 4

	INY	; Y++

	CPY #$0c
	BNE PRG010_CD0B	 ; If Y <> 12, loop

	; Graphics_BufCnt = $18
	LDA #$18
	STA Graphics_BufCnt


	INC <Map_ScrollOddEven	 ; Map_ScrollOddEven++

	LDA <Map_ScrollOddEven
	AND #$01
	BNE PRG030_CD36

	LDA #$00
	STA Map_DrawPanState	 ; Map_DrawPanState = 0
	STA <Map_ScrollOddEven	 ; Map_ScrollOddEven = 0

PRG030_CD36:
	JMP Scroll_Map_SpriteBorder	 ; Draw map sprite border and don't come back

Map_StateNothing:
	INC World_EnterState		; World_EnterState++
	JMP WorldMap_UpdateAndDraw	; Jump to WorldMap_UpdateAndDraw

	; FIXME: Anyone want to claim this?  Related to $CA82??
; $CD3F
	LDX Player_Current	 ; X = Player_Current

	LDA #$00
	STA Player_FallToKing
	STA Bonus_UnusedFlag	; ?

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw


	; FIXME: Anyone want to claim this?  Related to $CA82??
; $CD53

	; Map_ReturnStatus = 3 (??)
	LDA #$03	 
	STA Map_ReturnStatus

	; Map_Intro_Tick = $80
	LDA #$80
	STA Map_Intro_Tick

	LDX Player_Current	; X = Player_Current

	LDA #$00
	STA Player_FallToKing

	INC World_EnterState	 ; World_EnterState++

PRG010_CD6E:
	JMP WorldMap_UpdateAndDraw	; Jump to WorldMap_UpdateAndDraw

	; Amount to move on map when standard or in canoe ('C')
MapMove_DeltaY:		.byte   0,   0,   0,   0,   2,   0,   0,   0,  -2
MapMove_DeltaX:		.byte   0,   2,  -2,   0,   0,   0,   0,   0,   0
MapMove_DeltaXHi:	.byte   0,   0, $FF,   0,   0,   0,   0,   0,   0	; sign extension $FF

MapMove_DeltaYC:	.byte   0,   0,   0,   0,   1,   0,   0,   0,  -1
MapMove_DeltaXC:	.byte   0,   1,  -1,   0,   0,   0,   0,   0,   0
MapMove_DeltaXHiC:	.byte   0,   0, $FF,   0,   0,   0,   0,   0,   0	; sign extension $FF

MapMove_DeltaDiff = MapMove_DeltaYC - MapMove_DeltaY	; For clarity

PRG010_CDA7:
	.byte $06, $05, $0A, $09, $09, $0A, $05, $06

	; Enterable special tiles (Note the couple of oddities here...)
	; NOTE: Fixed Nintendo's over-indexing bug
Map_EnterSpecialTiles:
	.byte TILE_TOADHOUSE, TILE_PIPE, TILE_ALTTOADHOUSE
	.byte TILE_CASTLEBOTTOM, TILE_QBLOCK, TILE_ALTSPIRAL, TILE_PATHANDNUB
	.byte TILE_DANCINGFLOWER, TILE_HANDTRAP
Map_EnterSpecialTiles_End

	; SB: Defines tiles you can step over (even if enterable!)
	; $1x tiles are hardcoded in MapTile_CheckBypassable
Map_BypassTiles:
	.byte TILE_WORLD5STAR, TILE_QBLOCK, TILE_FORTRUBBLE, TILE_ALTRUBBLE
Map_BypassTiles_End

	; Color table for setting the 2nd entry power up color on the map used for clearing Judgem's cloud!
	; NOTE: This is a patch table, you'll want it to agree with PRG027's "InitPals_Per_MapPUp"
Map_PostJC_PUpPP1:	.byte $16, $16, $27, $16, $2A, $17, $30

	; In conjunction with the table above; patches Luigi/Toad for $16 as needed
Map_PostJC_PUpPML:	.byte $16, $1A, $00, $00, $00, $00

	; Color table for setting the 4th entry power up color on the map used for clearing Judgem's cloud!
	; NOTE: This is a patch table, you'll want it to agree with PRG027's "InitPals_Per_MapPUp"
Map_PostJC_PUpPP2:	.byte $0F, $0F, $16, $0F, $0F, $0F, $0F

MO_NormalMoveEnter:
	LDA #$00
	STA Map_NoLoseTurn	 ; Map_NoLoseTurn = 0
	STA Map_WasInPipeway	 ; Map_WasInPipeway = 0

	LDX Player_Current
	LDA <World_Map_Move,X
	BEQ PRG010_CDDC	 	; If Player is not moving on map, jump to PRG010_CDDC

	JMP PRG010_CEE4	 	; Otherwise, jump to PRG010_CEE4...

PRG010_CDDC:
	LDA Map_Pan_Count	
	BNE PRG010_CD6E	 	; If map is panning, jump to PRG010_CD6E (indirect to WorldMap_UpdateAndDraw)

	LDA Map_Intro_Tick
	BEQ MNME_Cont

	; Map_Intro_Tick > 0 (being used as dampener after scrolling ends to avoid a bug)
	DEC Map_Intro_Tick
	JMP WorldMap_UpdateAndDraw

MNME_Cont:
	LDA <Pad_Input	
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)	 
	BEQ PRG010_CDEC	 	; If Player is not pushing up/down/left/right, jump to PRG010_CDEC

	LDA #SND_PLAYERBUMP	 
	STA Sound_QPlayer	; "Bump" noise

PRG010_CDEC:
	JSR Map_GetTile	 	; Get current tile Player is standing on

	AND #$c0	 	; Only keeping the upper 2 bits of it
	CLC		 
	ROL A		 
	ROL A		 
	ROL A		 
	TAY		 	; Y = upper 2 bits of map tile shifted down; the "tile quadrant"


	; SB: Removed old blocker code because we're doing faded paths now


	JSR Map_CheckDoMove	; Attempt move

	LDA Sound_QMap
	BEQ PRG010_CE71	 	; If no sound played, Player didn't move (Dirty check!); jump to PRG010_CE71

	LDA #$00	 
	STA Sound_QPlayer	; Otherwise, stop any Player sound (perhaps "bump")

PRG010_CE71: 
	LDX Player_Current	
	LDA <World_Map_Move,X
	BEQ PRG010_CE78
	JMP PRG010_CEE4	 	; If the Player's map movement is non-zero, jump to PRG010_CEE4

PRG010_CE78:
	; Player is not moving on map...

	; SB: If Player presses START, open menu
	LDX Player_Current
	LDA <Controller1Press,X
	AND #PAD_START
	BEQ Map_NoPressStart

	; Initiate warp whistle mode
	INC Map_WarpWind_FX
	;INC World_Map_Twirl

	LDA #0
	STA Level_PauseSelect

	LDA #PAUSE_STOPMUSIC
	STA Sound_QPause

Map_NoPressStart:
	; SB: Disabling old 2P Vs
	LDA <Pad_Input
	AND #PAD_A
	BEQ PRG010_CEE1
	BNE PRG010_CEBF

	;LDA <Controller1Press
	;ORA <Controller2Press
	;AND #$80	 
	;BEQ PRG010_CEE1		; If neither of the two players are pressing the 'A' button jump to PRG010_CEE1

	;LDX Player_Current	; X = Player_Current
	;TXA		 
	;EOR #$01	 	
	;TAY		 	; Y = Player_Current ^ 1 (i.e. the OTHER Player)

	;LDA Player_Lives,Y
	;CMP #$ff	 
	;BEQ PRG010_CEBF	 	; If the other Player is dead, jump to PRG010_CEBF

	; Basically if Player 1 and 2 are not standing on top of eachother when one of them pushed A, jump to PRG010_CEBF
	;LDA <World_Map_XHi,X
	;CMP World_Map_XHi,Y
	;BNE PRG010_CEBF	
	;LDA <World_Map_Y,X
	;CMP World_Map_Y,Y
	;BNE PRG010_CEBF	
	;LDA <World_Map_X,X
	;CMP World_Map_X,Y
	;BNE PRG010_CEBF	

	;LDA #$12
	;STA <Map_Enter2PFlag	; Map_Enter2PFlag = $12 (enterint 2P Vs)

PRG010_CEA7:
	LDA #$10
	STA Map_Operation	; Map_Operation = $10 (begin "enter level" effect)

PRG010_CEAC:
	LDX Player_Current	; X = Player_Current

	LDA #$00	 
	STA Map_Player_SkidBack,X	; Clear Map_Player_SkidBack

	LDA #$00	 
	STA World_EnterState	; World_EnterState = 0
	STA Map_NoLoseTurn	 ; Clear Map_NoLoseTurn

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG010_CEBF:
	; A Player pressed 'A' but they were not on top of each other, so no 2P vs...

	LDA <Pad_Input
	AND #PAD_A	
	BEQ PRG010_CEE1	 	; If Player is not pressing 'A', jump to PRG010_CEE1

	LDA <World_Map_Tile
	LDY #(Map_EnterSpecialTiles_End - Map_EnterSpecialTiles - 1)	; SB: Corrected bug
PRG010_CEC9:
	CMP Map_EnterSpecialTiles,Y
	BEQ PRG010_CEA7	 	; If this is one of the special enterable tiles, jump to PRG010_CEA7 (enter level!)
	DEY		 	; Y--
	BPL PRG010_CEC9	 	; If Y >= 0, jump to PRG010_CEC9

	; Not a special tile...
	LDA <World_Map_Tile
	AND #$c0	 	; Only keeping the upper 2 bits of it
	CLC		 
	ROL A		 
	ROL A		 
	ROL A		 
	TAY		 	; Y = map tile >> 6 (basically)

	; What makes other tiles (e.g. standard panels) work...
	LDA <World_Map_Tile
	CMP Tile_AttrTable+4,Y
	BGE PRG010_CEA7	 	; If the tile the Player is standing on >= Tile_AttrTable+4[Y], jump to PRG010_CEA7 (enter level!)

PRG010_CEE1:		
	JMP WorldMap_UpdateAndDraw	; Jump to WorldMap_UpdateAndDraw


Map_UpdateStarCoins:

	; Find the Map_Completion -- will not return here if there's no map link!
	JSR Map_FindCompForPlayerPos

	; If you get here, found a map link; update the star coins
	LDA Map_Completions,Y
	STA <Temp_Var1	; -> Temp_Var1

	; If one of the completion bits is set, put that in Level_IsComplete
	STA Level_IsComplete

	LDX #2	; X = 2 (3 star coins)
Map_UpdCoin_Loop:

	LDA <Temp_Var1
	AND #$01
	STA Inventory_Cards,X

	LSR <Temp_Var1

	DEX	; X--
	BPL Map_UpdCoin_Loop	; While X >= 0, loop
	

	RTS

PRG010_CEE4:
	; Player is moving on map...

	DEC <World_Map_Move,X
	DEC <World_Map_Move,X	 	; World_Map_Move -= 2

	LDA <World_Map_Dir,X	 
	LDY Map_InCanoe_Flag	 
	BEQ PRG010_CEF4	 		; If not in canoe, jump to PRG010_CEF4

	; Otherwise, in canoe...
	ADD #MapMove_DeltaDiff 		; Add MapMove_DeltaDiff to World_Map_Dir (use canoe values)
	INC <World_Map_Move,X	 	; Soften the map move reduction by adding on back

PRG010_CEF4:
	TAY		 		; Y = 'A'

	; Move Player as according to specified delta
	LDA <World_Map_Y,X	 
	ADD MapMove_DeltaY,Y
	STA <World_Map_Y,X
	LDA <World_Map_X,X
	ADD MapMove_DeltaX,Y
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	ADC MapMove_DeltaXHi,Y	
	STA <World_Map_XHi,X

	LDA <World_Map_Move,X
	AND #31				; Check if any move is left (relies on starting value of 32!)
	BNE WorldMap_UpdateAndDraw	; If so, jump to WorldMap_UpdateAndDraw...

	JSR Map_UpdateStarCoins_AtPlayer

	; The move has completed...
	JSR Map_GetTile	 
	CMP #TILE_HANDTRAP
	BNE WorldMap_UpdateAndDraw	; If the Player has not landed on a hand trap, jump to WorldMap_UpdateAndDraw

	; Player's on a hand trap...
	LDX Player_Current
	LDA RandomN,X	 
	AND #$01			; 50/50 chance
	BNE WorldMap_UpdateAndDraw	; Player has 50/50 chance we just jump to WorldMap_UpdateAndDraw

	INC Map_Operation	 	; Otherwise, Map_Operation++ (now $E)
	JMP PRG010_CEAC	 		; Jump to PRG010_CEAC

WorldMap_UpdateAndDraw:
	; SB: Update star coins, if any
	LDA Map_UpdStarCoinsCnt
	BEQ MONorm_NoStarCoins

	SUB #1
	STA Map_UpdStarCoinsCnt

	TAY

	; Updates one at a time over three frames to prevent full screen flicker
	JSR StatusBar_DrawCardPiece

MONorm_NoStarCoins:


	LDY Player_Current 	; Y = Player_Current

	; SB: Old, unknown code; AFAIK this is unused, but I'll be safe with 0
	;LDA Map_Previous_World,Y	; A = Map_Previous_World
	LDA #0
	STA <Temp_Var3		; Stored into Temp_Var3
	JMP Map_DrawPlayer	; Draw Player sprite on map

Map_UpdateStarCoins_AtPlayer:
	; Backup 'X'
	TXA
	PHA

	; Update the star coins based on this location (if anything applies)
	JSR Map_UpdateStarCoins

	; If the search for a map link aborted (not found), 'Y' is negative
	TYA
	BPL Map_StarCoinUpdOK	; If map link found ('Y' is positive), jump to Map_StarCoinUpdOK

	; No map link found; clear star coin memory (so they show up blank)
	LDA #0
	STA Inventory_Cards
	STA Inventory_Cards+1
	STA Inventory_Cards+2
	STA Level_IsComplete	; Not a level, so it can't be complete, either

Map_StarCoinUpdOK:
	; Update all 3 star coins
	LDA #3
	STA Map_UpdStarCoinsCnt

	; Restore 'X'
	PLA
	TAX
	RTS

World_Map_Max_PanR:
	; Per-world defintion of the maximum scroll column allowed on the map
	; $10 defines one screen.  Worlds which have multiple screens but do
	; not pan between them (World 5 & 8) have $00, but this not what actually
	; restricts movement (though in a cleaner implementation probably should
	; have been.)  Instead, you'll find specific lock-out code a bit after
	; the Map_Check_PanR label... also of note, there's no entry for World 9
	; (Warp Zone) which will incorrectly pan if the Player ever could scoot
	; that far over (not that there's anything to scroll TO of course)
	.byte $20, $20, $30, $30, $20, $30, $30, $00

	; NOTE: Should be safe to expand these to include new map powers,
	; BUT make sure to add elements to all of Map_Power_TilesF1/2 and
	; Map_Power_AttribF1/2 together or else funny visuals will occur...

Map_Power_Pats_F1:
	; This table defines patterns to be used per power-up
	; to the sprites making up the Player.
	; Byte order is upper left, upper right, lower left, lower right
	; Note that Small Mario / Judgems do not have a visible "upper"
	;
	; NOTE: $27 is actually a magic value hard-wired to remove the
	; upper sprites!  (The tiles appear as a black box otherwise)
	; See code following label PRG010_D045 for this hardcode...
	.byte $27, $27, $41, $43	; Small
	.byte $55, $55, $57, $59	; Super Mushroom
	.byte $55, $55, $57, $59	; Fire Flower
	.byte $5B, $5B, $5F, $5F	; Leaf
	.byte $63, $65, $67, $69	; Penguin Suit
	.byte $6B, $6B, $57, $59	; Rabbit
	.byte $6D, $6D, $6F, $71	; Hammer Suit

Map_Power_Pats_F2:
	.byte $27, $27, $43, $41	; Small
	.byte $55, $55, $59, $57	; Super Mushroom
	.byte $55, $55, $59, $57	; Fire Flower
	.byte $5D, $5D, $61, $61	; Leaf
	.byte $65, $63, $69, $67	; Penguin Suit
	.byte $6B, $6B, $59, $57	; Rabbit
	.byte $6D, $6D, $71, $6F	; Hammer Suit

Map_Power_Attrib_F1:
	; This table defines attributes to be applied per power-up
	; to the sprites making up the Player; only actually used
	; to apply horizontal flips here and there...
	; Byte order is upper left, upper right, lower left, lower right
	; Note that Small Mario / Judgems do not have a visible "upper"
	.byte $00, $40, $00, $00	; Small
	.byte $00, $40, $00, $00	; Super Mushroom
	.byte $00, $40, $00, $00	; Fire Flower
	.byte $00, $40, $00, $40	; Leaf
	.byte $00, $00, $00, $00	; Penguin Suit
	.byte $00, $40, $00, $00	; Rabbit
	.byte $00, $40, $00, $00	; Hammer Suit

Map_Power_Attrib_F2:
	; Frame 2; see Map_Power_Attrib_F1
	.byte $00, $40, $40, $40	; Small
	.byte $00, $40, $40, $40	; Super Mushroom
	.byte $00, $40, $40, $40	; Fire Flower
	.byte $00, $40, $00, $40	; Leaf
	.byte $40, $40, $40, $40	; Penguin Suit
	.byte $00, $40, $40, $40	; Rabbit
	.byte $00, $40, $40, $40	; Hammer Suit

Map_Marker_MorL:
	.byte $0D, $0F		; The (M), (L) small markers

PRG010_CFCE:
	.byte $00, $04, $05, $06


; These two LUTs define four frames (two bytes each) of "twirling" frames
Player_Twirl_Tiles:	.byte $0F, $0D, $2D, $2F, $0D, $0F, $3D, $3F
Player_Twirl_Attribs:	.byte $40, $40, $00, $00, $00, $00, $00, $00

Map_BorderSprites:
	.byte $10, $03, $01, $08
	.byte $10, $05, $01, $F0
	.byte $10, $0B, $01, $F8
	.byte $B0, $09, $01, $08
	.byte $B0, $07, $01, $F0
	.byte $B0, $0B, $01, $F8
Map_BorderSprites_End

Map_DrawPlayer:
	LDX Player_Current	; X = Player_Current
	LDA <World_Map_Y,X	; A = Player's Y position
	CMP #$f8
	BEQ PRG010_D012	 	; If Player's Y = $f8, jump to PRG010_D012

	; Update Player's sprite Y position!
	STA Sprite_RAM+$8C
	STA Sprite_RAM+$90
	SUB #16			 ; Subtract 16 for upper half
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88

PRG010_D012:
	LDA <World_Map_X,X	 ; A = Player's X position
	SUB <Horz_Scroll	 ; Made relative to the horizontal scroll

	; Update Player's sprite X position!
	STA Sprite_RAM+$87
	STA Sprite_RAM+$8F
	ADD #8		 	 ; Add 8 for right half 
	STA Sprite_RAM+$8B
	STA Sprite_RAM+$93

	LDA Map_Power_Disp
	ASL A		 
	ASL A		 
	TAX		 ; X = Map_Power_Disp << 2 (4 bytes index per power-up)

	LDA <Counter_1
	AND #$08	; On 8 ticks, off 8 ticks
	BEQ PRG010_D037	; 
	TXA		
	ADD #(Map_Power_Pats_F2-Map_Power_Pats_F1)	
	TAX		; X Offset to second frame

PRG010_D037:
	LDY #$00	 ; Y = 0
	LDA Map_Starman	
	BEQ PRG010_D045	 ; If not using a starman, jump to PRG010_D045

	LDA <Counter_1
	AND #%00001100
	LSR A
	LSR A
	TAY		 ; Y = 0 to 3 (color cycle Star Man)

PRG010_D045:

	; This builds the 4 hardware sprites for the Player sprite
	TYA		 
	ORA Map_Power_Attrib_F1,X	 
	STA Sprite_RAM+$86	 
	LDA Map_Power_Pats_F1,X	 
	STA Sprite_RAM+$85	 
	TYA		 
	ORA Map_Power_Attrib_F1+1,X	 
	STA Sprite_RAM+$8A	 
	LDA Map_Power_Pats_F1+1,X	 
	STA Sprite_RAM+$89	 
	TYA		 
	ORA Map_Power_Attrib_F1+2,X	 
	STA Sprite_RAM+$8E	 
	LDA Map_Power_Pats_F1+2,X	 
	STA Sprite_RAM+$8D	 
	TYA		 
	ORA Map_Power_Attrib_F1+3,X	 
	STA Sprite_RAM+$92	 
	LDA Map_Power_Pats_F1+3,X	 
	STA Sprite_RAM+$91	 

	; Hardcode: Tile $27 removes the upper sprites
	LDA Sprite_RAM+$85	 
	CMP #$27	 
	BNE PRG010_D088	 	; If not using tile $27, jump to PRG010_D088	

	; Set the unused upper sprites to Y coord = $f8 (off-screen, invisible)
	LDA #$f8	 
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88

PRG010_D088:
	LDX Player_Current	; X = Player_Current
	LDA World_Map_Twirl,X
	BNE Map_DoPlayer_As_Twirl	 	; If this player is "twirling", jump to Map_DoPlayer_As_Twirl

	; Player isn't twirling ...

	LDA Map_Operation
	CMP #6
	BLT Map_DoPlayer_Edge_Scroll	 ; If Map_Operation < $06, jump to Map_DoPlayer_Edge_Scroll

	CMP #$0d
	BLT Map_DoPlayer_As_Marker	 ; If Map_Operation < $0d, jump to Map_DoPlayer_As_Marker

	CMP #$0f
	BNE Map_DoPlayer_Edge_Scroll	 ; If Map_Operation <> $0f, jump to Map_DoPlayer_Edge_Scroll

Map_DoPlayer_As_Marker:
	; If you get here: $06 >= Map_Operation >= $0C, or $0F

	LDX Player_Current	; X = Player_Current

	; Player is displayed as (M) or (L) marker as appropriate
	LDA Map_Marker_MorL,X	
	STA Sprite_RAM+$91	
	LDA #$03	 	
	STA Sprite_RAM+$92	

	; Other sprites are disabled
	LDA #$f8	 	
	STA Sprite_RAM+$84	
	STA Sprite_RAM+$88	
	STA Sprite_RAM+$8C	

	JMP Map_DoPlayer_Edge_Scroll	 	; Jump to Map_DoPlayer_Edge_Scroll...

Map_DoPlayer_As_Twirl:
	; Player is "twirling"!
	DEC <Map_Skid_Count	; Map_Skid_Count-- (wraps around forever)
	LDA <Map_Skid_Count	 
	AND #$06	 	; Take Map_Skid_Count as a 2 byte offset, 1:4
	TAY

	; Setup appropriate "twirl" frame!		 
	LDA Player_Twirl_Tiles,Y	 
	STA Sprite_RAM+$8D	 
	LDA Player_Twirl_Tiles+1,Y	 
	STA Sprite_RAM+$91	 
	LDA Player_Twirl_Attribs,Y	 
	STA Sprite_RAM+$8E	 
	LDA Player_Twirl_Attribs+1,Y	 
	STA Sprite_RAM+$92	 

Map_DoPlayer_Edge_Scroll:
	LDA Map_Operation
	CMP #$02
	BEQ Map_Check_PanR	 	; If Map_Operation = $02 (Skidding backward), jump to Map_Check_PanR

	LDX Player_Current	; X = Player_Current

	LDA Map_Player_SkidBack,X 
	BNE Map_No_Pan	 	; If Player did not skid back, jump to Map_No_Pan

	LDA <Map_WarpWind_FX
	BNE Map_No_Pan	 	; If any world map FX are occurring, jump to Map_No_Pan

Map_Check_PanR:
	LDA Map_Pan_Count
	BNE Map_No_Pan	 	; If map is panning, jump to Map_No_Pan

	; NOTE: This block disables panning on World 5 and 8.  Change this
	; to make them pan like normal maps!! *****
	LDA World_Num
	CMP #7			
	BEQ Map_No_Pan	 	; If World_Num = 7 (World 8), jump to Map_No_Pan

	LDA Sprite_RAM+$87
	CMP #208
	BLT Map_Check_PanL 	; If Player's sprite's X coord is less than 208, jump to Map_Check_PanL

	LDY World_Num	 	; Y = World_Num
	LDA <Scroll_ColumnR	; A = Current right-hand column
	CMP World_Map_Max_PanR,Y
	BEQ Map_No_Pan	 	; If map scrolling has already reached the right-side limit, jump to Map_No_Pan

	LDX #$00	 	; X = 0
	JMP Map_Set_Pan	 	; Jump to Map_Set_Pan ...

Map_Check_PanL:
	LDA <Scroll_ColumnL	; A = Current left-hand column 
	BEQ Map_No_Pan	 	; If map scrolling has already reached the left-side limit, jump to Map_No_Pan

	LDA Sprite_RAM+$87
	CMP #33

	BGE Map_No_Pan	 	; If Player's sprite's X coord is >= 33, jump to Map_No_Pan
	LDX #$01	 	; X = 1

Map_Set_Pan:
	; We need to pan the map!
	STX <Scroll_LastDir	; Set proper pan direction
	LDA #$80	 
	STA Map_Pan_Count	; Map_Pan_Count = $80 (moves half a screen's worth)
	LDA #$04	 
	STA Map_DrawPanState	; Map_DrawPanState = 4 (Do panning)

Map_No_Pan:
	LDA Total_Players
	CMP #$01
	BEQ PRG010_D16F	 	; If Total_Players = 1 (1P mode), jump to PRG010_D16F

	LDA World_Num
	CMP #$08
	BEQ PRG010_D16F	 	; If World_Num = 8 (World 9, Warp Zone), jump to PRG010_D16F

	LDA Player_Current
	EOR #$01	 	; Switch to the opposite Player
	TAX		 	; X = Player_Current ^ 1
	LDA Player_Lives,X	; The "other" Player's lives
	BMI PRG010_D16F	 	; If they're deceased, jump to PRG010_D16F

	LDA <World_Map_X,X	; A = Other player's X coord
	SUB <Horz_Scroll	; Made relative to the screen
	BEQ PRG010_D16F	 	; If relatively 0, jump to PRG010_D16F

	LDA <World_Map_XHi,X	; A = Other player's X Hi byte 
	SBC #$00	 	
	CMP <Horz_Scroll_Hi	
	BNE PRG010_D16F	 	; If other Player's marker is not visible, jump to PRG010_D16F

	; SB: Also need to make sure Players are on the same world!!
	LDA Map_Previous_World,X
	CMP World_Num
	BNE PRG010_D16F	 	; If other Player's on a different world, jump to PRG010_D16F

	; Other Player sprite marker
	LDA <World_Map_Y,X	 
	STA Sprite_RAM+$94	 
	LDA Map_Marker_MorL,X	 
	STA Sprite_RAM+$95	 
	LDA #$03	 
	STA Sprite_RAM+$96	 
	LDA <World_Map_X,X	 
	SUB <Horz_Scroll		 
	ADD #$04	 
	STA Sprite_RAM+$97	 

PRG010_D16F:
	LDA Map_Operation
	CMP #$01	
	BLT PRG010_D179	 ; If Map_Operation < 1, jump to PRG010_D179

	JSR MapObjects_UpdateDrawEnter	; Update all objects, draw them, enter them

PRG010_D179:
	LDA World_Num
	CMP #$08	
	BNE PRG010_D183	 ; If World_Num <> 8 (World 9, Warp Zone), jump to PRG010_D183 (RTS)
	JSR Map_WarpZone_DrawNumbers	 ; Draw the numbers of the warp zone

PRG010_D183:
	RTS		 ; Return

Map_WarpZone_Numbers:
	; Sprites of the world numbers used in the warp zone
	.byte $5C, $83, $01, $54	; 1
	.byte $48, $85, $01, $64	; 2
	.byte $28, $87, $01, $84	; 3
	.byte $48, $89, $01, $A4	; 4
	.byte $5C, $8B, $01, $B4	; 5
	.byte $6F, $8D, $01, $A4	; 6
	.byte $8F, $8F, $01, $84	; 7
	.byte $6F, $91, $01, $64	; 8
Map_WarpZone_Numbers_End

Map_WarpZone_DrawNumbers:

	LDA Map_WarpWind_FX
	BNE MWZDN_NotStopped

	LDY #(Map_WarpZone_Numbers_End - Map_WarpZone_Numbers - 1)
PRG010_D1A2:
	LDA Map_WarpZone_Numbers,Y
	STA Sprite_RAM+$98,Y
	DEY		 
	BPL PRG010_D1A2	 ; While Y >= 0, loop!
	
MWZDN_NotStopped:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Map_SpriteBorder
;
; When the world map scrolls, there's no way
; to maintain the border graphic using the
; BG layer, so it emulates it with sprites
; until the scrolling ceases!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Map_SpriteBorder:

	LDA #$20	 
	STA <Temp_Var1	 ; Temp_Var1 = $20
	LDY #$60	 ; Y = $60

PRG010_D1B2:

	; Set first three hardware sprites to Y = Temp_Var1
	LDA <Temp_Var1
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y
	STA Sprite_RAM+8,Y

	; Set first and second pattern to 1 (border tile)
	LDA #$01	 
	STA Sprite_RAM+1,Y
	STA Sprite_RAM+5,Y

	; And third to $B
	LDA #$0b	 	
	STA Sprite_RAM+9,Y	

	; Set all of their attributes to 1 (palette)
	LDA #$01	 
	STA Sprite_RAM+2,Y
	STA Sprite_RAM+6,Y
	STA Sprite_RAM+10,Y

	; First X = 8
	LDA #$08	
	STA Sprite_RAM+3,Y
 
	; Second X = 240
	LDA #240
	STA Sprite_RAM+7,Y

	; Third X = 248
	LDA #248
	STA Sprite_RAM+11,Y

	LDA <Temp_Var1	
	ADD #16
	STA <Temp_Var1	 ; Temp_Var1 += 16

	TYA		
	SUB #12	
	TAY		 ; Y -= 12 (3 sprites backward)
	BPL PRG010_D1B2	 ; While Y >= 0, loop!

	LDY #(Map_BorderSprites_End - Map_BorderSprites - 1)
PRG010_D1F4:
	LDA Map_BorderSprites,Y
	STA Sprite_RAM+$6C,Y

	DEY		 	; Y--
	BPL PRG010_D1F4	 	; While Y >= 0, loop!

	RTS		 ; Return

Map_GetTile:
	LDX Player_Current
	LDA <World_Map_XHi,X
	ASL A		 
	TAY		 

	; Store starting offset for this map screen into Map_Tile_AddrL/H
	LDA Tile_Mem_Addr,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,Y
	STA <Map_Tile_AddrH

	INC <Map_Tile_AddrH	; Effectively adds $100 to the address (maps get loaded at screen base + $110)

	LDA <World_Map_X,X
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA <Temp_Var1		; Temp_Var1 = World_Map_X / 16 (the current column of the current screen)

	LDA <World_Map_Y,X
	SUB #16
	AND #$f0
	ORA <Temp_Var1		; Temp_Var1 now holds the X column in the lower 4-bits and the Y row in the upper 4-bits

	TAY		 	; Store this offset value into 'Y'

	LDA [Map_Tile_AddrL],Y
	STA <World_Map_Tile	
	RTS		 ; Return


	; FIXME: Anyone want to claim this?  (Exact same routine appears in PRG011 @ $B6F6)
; $D228 
	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_Dir,X	; Get Player's map direction
	EOR #$03
	CMP #$03
	BNE PRG010_D235	 	; If Player did not travel left or right, jump to PRG010_D235

	EOR #$0f	 ; Otherwise invert all direction bits??

PRG010_D235:
	STA <World_Map_Dir,X	 ; -> World_Map_Dir

	RTS		 ; Return

	; For Player holding Right 01 Left 02 Down 04 Up 08 check
Map_HoldPadDir:	.byte $01, $02, $04, $08	; R01 L02 D04 U08

	; Lookup indexed same as above to see if Player reversed direction from their last move
Map_RevDir:	.byte $02, $01, $08, $04	; R01 L02 D04 U08

	; LUT based on map object's travel direction to get a list of
	; valid tiles to travel over in that direction...
	;
	; Travel directions:
	; 0 = Right, 1 = Left, 2 = Down, 3 = Up
	;
	; Seems Nintendo was possibly leaving "one way" tiles open
	; as an idea or something, since left/right and up/down
	; are duplicated, identical data (when the pointers could've
	; been made the same, y'know?)
Map_Object_Valid_Tiles:	.word Map_Object_Valid_Left, Map_Object_Valid_Right, Map_Object_Valid_Down, Map_Object_Valid_Up

	; Safe to expand this, but make sure you update all four!!
Map_Object_Valid_Left:	
	.byte TILE_HORZPATH,    TILE_DRAWBRIDGEH, TILE_BRIDGE,      TILE_HORZPATHW, TILE_HORZPATHWLL
	.byte TILE_HORZPATHWLR, TILE_HORZPATHSKY, TILE_HORZPATHWLB, TILE_HANDTRAP,  TILE_HORZPATH0
Map_Valid_TileLimit
	.byte TILE_HORZPATH_INCOMP, TILE_HORZPATH_INCOMPA, TILE_ROCKBREAKH
Map_Object_Valid_Right:
	.byte TILE_HORZPATH,    TILE_DRAWBRIDGEH, TILE_BRIDGE,      TILE_HORZPATHW, TILE_HORZPATHWLL
	.byte TILE_HORZPATHWLR, TILE_HORZPATHSKY, TILE_HORZPATHWLB, TILE_HANDTRAP,  TILE_HORZPATH0
	.byte TILE_HORZPATH_INCOMP, TILE_HORZPATH_INCOMPA, TILE_ROCKBREAKH
Map_Object_Valid_Down:	
	.byte TILE_VERTPATH,    TILE_VERTPATH,    TILE_VERTPATH,    TILE_DRAWBRIDGEV, TILE_VERTPATHWLU
	.byte TILE_VERTPATHWLL, TILE_VERTPATHW,   TILE_VERTPATHSKY, TILE_VERTPATHWLB, TILE_VERTPATH0
	.byte TILE_VERTPATH_INCOMP, TILE_VERTPATH_INCOMPA, TILE_ROCKBREAKV
Map_Object_Valid_Up:
	.byte TILE_VERTPATH,    TILE_VERTPATH,    TILE_VERTPATH,    TILE_DRAWBRIDGEV, TILE_VERTPATHWLU
	.byte TILE_VERTPATHWLL, TILE_VERTPATHW,   TILE_VERTPATHSKY, TILE_VERTPATHWLB, TILE_VERTPATH0
	.byte TILE_VERTPATH_INCOMP, TILE_VERTPATH_INCOMPA, TILE_ROCKBREAKV

	; This makes it safe to expand the above
Map_Object_Valid_Tiles2Check = (Map_Object_Valid_Right - Map_Object_Valid_Left)
Player_Valid_Tiles2Check = (Map_Valid_TileLimit - Map_Object_Valid_Left)

	; Appropriate crossable draw bridge tile based on direction 0-3
	; 0-3 (right, left, down, up respectively)
Map_DrawBridgeCheck:	.byte TILE_DRAWBRIDGEH, TILE_DRAWBRIDGEH, TILE_DRAWBRIDGEV, TILE_DRAWBRIDGEV

	; Matching elements for Map_DrawBridgeCheck, looks to see if World3_Bridge value is
	; an appropriate number to allow crossing of the bridge
Map_DrawBridgeCheckV:	.byte $00, $00, $01, $01

	; Appropriate Y, X, and XHi offsets to check for a canoe based on direction 0-3
	; 0-3 (right, left, down, up respectively)
Map_CanoeCheckYOff:	.byte  0,   0, 16, -16
Map_CanoeCheckXOff:	.byte 16, -16,  0,   0
Map_CanoeCheckXHiOff:	.byte  0,  $FF, 0,   0	; Remember, this is used more as a 16-bit sign extension, hence $FF in position of X's -16


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_CheckDoMove
;
; Checks if able to move and performs moves based on Player's pad input
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_CheckDoMove:
	LDA <Pad_Holding
	STA <Temp_Var4		; Temp_Var4 = Pad_Holding

	LDA Debug_Flag
	CMP #$80
	BNE MCDM_NotHoldingSelectDebug
	
	LDX Player_Current
	LDA <Controller1,X
	AND #PAD_SELECT
	BEQ MCDM_NotHoldingSelectDebug
	LDA <Temp_Var4
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	BEQ MCDM_NotHoldingSelectDebug
	JMP PRG010_D336

MCDM_NotHoldingSelectDebug:
	LDA Map_InCanoe_Flag
	BNE PRG010_D296	 	; If Player is in canoe, jump to PRG010_D296

	LDX Player_Current
	LDA Map_MoveRepeat,X
	BEQ PRG010_D296		; If Player's "move repeat" value is at zero, jump to PRG010_D296

	CMP #$18
	BEQ PRG010_D296	 	; If the "move repeat" value is at $18 (the max), jump to PRG010_D296

	RTS		 	; Return...

PRG010_D296:

	LDY #$03	 	; Y = 3
	LDA <Temp_Var4		; A = Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)	 	; Just up/down/left/right

PRG010_D29C:
	CMP Map_HoldPadDir,Y
	BEQ PRG010_D2A5	 	; If this is the direction the Player was going, jump to PRG010_D2A5
	DEY		 	; Y--
	BPL PRG010_D29C	 	; While Y >= 0, loop!

	RTS		 	; Return...

PRG010_D2A5:

	; 'A' is the Pad_Holding value...

	; This loop converts R01 L02 D04 U08 to 0, 1, 2, 3
	LDY #$00	 	; Y = 0
PRG010_D2A7
	LSR A		 	; A >>= 1
	BCS PRG010_D2AD	 	; If the LSb of 'A' was set, jump to PRG010_D2AD
	INY		 	; Y++
	BNE PRG010_D2A7	 	; Loop (shouldn't be more than 3 times)

PRG010_D2AD:
	TYA		 	; A = 0-3
	STA <Temp_Var3		; Temp_Var3 = 0-3 (right, left, down, up respectively)
	ASL A		 	

	TAX		 	; X = A << 1 (indexing Map_Object_Valid_Tiles)

	; [Temp_Var2][Temp_Var1] become an address into Map_Object_Valid_Tiles
	LDA Map_Object_Valid_Tiles,X
	STA <Temp_Var1		 
	LDA Map_Object_Valid_Tiles+1,X
	STA <Temp_Var2		 

	JSR MapTile_Get_By_Offset	; Get tile Player is going to move over (adjacent tile in travel direction)

	; Search to see if this is a valid to move over given the Player's direction et al.
	LDY #(Player_Valid_Tiles2Check-1)
PRG010_D2C1:
	CMP [Temp_Var1],Y	
	BEQ PRG010_D336	 	; If Player is going to travel over this particular valid tile, jump to PRG010_D336
	DEY		 	; Y--
	BPL PRG010_D2C1	 	; While Y >= 0, loop!

	; Player is not on any of the valid tiles...

	LDY Map_InCanoe_Flag
	BEQ PRG010_D2E1	 	; If Player is NOT in a canoe, jump to PRG010_D2E1

	CMP #TILE_DOCK	 
	BNE PRG010_D2D8	 	; If Player is not docking, jump to PRG010_D2D8

	LDA #$00
	STA Map_InCanoe_Flag	; Map_InCanoe_Flag = 0
	BEQ PRG010_D332	 	; Jump (technically always) to PRG010_D332

PRG010_D2D8:
	; Canoe range checks!

	CMP #TILE_WATER_INVT
	BLT PRG010_D310	 	; If tile is less than the inverted-T water tile, jump to PRG010_D310

	CMP #TILE_VERTPATHWLU
	BLT PRG010_D332		; If tile is less than the overwater path tile, jump to PRG010_D332

	; Tile index larger than TILE_VERTPATHWLU / $AA can never be moved over in the canoe

	RTS		 ; Return

PRG010_D2E1:
	; On a dock, not in a canoe!  But let's see if there's one to hop into...

	LDY World_Map_Tile
	CPY #TILE_DOCK	
	BNE PRG010_D310	 	; If Player is not standing on a dock tile, jump to PRG010_D310

	LDY <Temp_Var3		; Y = Temp_Var3; 0-3 (right, left, down, up respectively)

	LDX Player_Current
	LDA <World_Map_Y,X
	ADD Map_CanoeCheckYOff,Y
	STA <Temp_Var1		; Temp_Var1 = Player's Y on map plus an appropriate offset to search for canoe

	LDA <World_Map_X,X
	ADD Map_CanoeCheckXOff,Y
	STA <Temp_Var2		; Temp_Var2 is like Temp_Var1, for X

	LDA <World_Map_XHi,X	
	ADC Map_CanoeCheckXHiOff,Y
	STA <Temp_Var3		; Temp_Var3 is like Temp_Var2, for X Hi

	;LDX #(MAPOBJ_TOTAL-1) 	; X = (MAPOBJ_TOTAL-1) (search all map objects)
;PRG010_D306:
	;LDY Map_Objects_IDs,X	
	;CPY #MAPOBJ_CANOE
	;BEQ PRG010_D31D	 	; If this is a canoe, jump to PRG010_D31D
	;DEX		 	; X--
	;BNE PRG010_D306	 	; If X > 0, loop! (NOTE: Does not check map object index 0 as a canoe

PRG010_D310:
	LDA Pad_Input
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	BEQ PRG010_D31C	 	; If Player is not pressing left/right/down/up, jump to PRG010_D31C (RTS)

	LDA #SND_PLAYERBUMP	 
	STA Sound_QPlayer	; Play "bump" sound (there's no canoe here or tile can't possibly be moved over [< TILE_WATER_INVT/$82])

PRG010_D31C:
	RTS		 	; Return!

PRG010_D31D:
	; There's a canoe here...!

	; Temp_Var1-3 configure a detection position precisely one tile away
	; from the Player in whatever direction is appropriate; the canoe
	; must match this coordinate precisely.

	; NOTE: Currently the detection loop, as it stands, works for ONE CANOE 
	; PER MAP ONLY!!  (Because as soon as it finds one, it jumps down here,
	; and there's no mechanism to return to the loop!)

	; If the canoe isn't positioned right for any of the calculated coordinates,
	; we fail this test (and make the "bump" sound if needed)

	LDY Map_Object_ActY,X
	CPY <Temp_Var1	
	BNE PRG010_D310	

	LDY Map_Object_ActX,X	
	CPY <Temp_Var2	
	BNE PRG010_D310	 

	LDY Map_Object_ActXH,X
	CPY <Temp_Var3	
	BNE PRG010_D310	 

PRG010_D332:
	LDA #16		 ; A = 16 (canoe movement amount)
	BNE PRG010_D349	 ; Jump (technically always) to PRG010_D349

PRG010_D336:
	; Player has a tile he can travel over ... (non-canoe)

	LDX #SND_MAPPATHMOVE		; X = SND_MAPPATHMOVE

	; Drawbridge check!
	;LDY <Temp_Var3			; Y = Temp_Var3; 0-3 (right, left, down, up respectively)
	;CMP Map_DrawBridgeCheck,Y	
	;BNE PRG010_D347	 		; If Player is not crossing a draw bridge tile, jump to PRG010_D347

	;LDA World3_Bridge
	;CMP Map_DrawBridgeCheckV,Y
	;BNE PRG010_D359	 		; If the bridge is up, jump to PRG010_D359

;PRG010_D347:

	; Valid tile move!
	; Note: 32 is used here, it's also relied on in the logic further down (see a bit below PRG010_CEF4)
	LDA #32		 		; A = 32 (value to be stored into World_Map_Move, i.e. units to move, two tiles [16 * 2])

PRG010_D349:
	LDX Player_Current
	STA <World_Map_Move,X	 	; Tell Player to move 'A' units

	LDA <Temp_Var4			; A = Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)	; Just the left/right/down/up bits
	STA <World_Map_Dir,X	 	; Store as movement direction!
	STA Map_PrevMoveDir	 	; Store as previous move!

	LDX #SND_MAPPATHMOVE 		; Play the "path move" sound!

PRG010_D359:

	; The only possible value that ever gets here in 'X' is SND_MAPPATHMOVE; 
	; they may have intended other possible sounds to play e.g. in the canoe.
	; Of note, the check used after Map_CheckDoMove is called is to see if
	; Sound_QMap = 0, which would indicate failure to traverse a path.
	STX Sound_QMap

	RTS		 		; Return...!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get_Tile_By_Offset
;
; Returns the tile that the Player is standing on or near, selected
; by input 'Y' register.  Tile returned in 'A'.  'X' is two times
; the screen/Player X Hi byte when this function exits...
; Y is a value from 0-3 specifying a "search direction"
; 0 = To the right
; 1 = To the left
; 2 = Below
; 3 = Above
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Search_YOff:	.byte -16, -16, 0, -32
Search_XHiOff:	.byte   0,  -1, 0,   0
Search_XOff:	.byte  16, -16, 0,   0

MapTile_Get_By_Offset:	; $D369
	; Y is a value from 0-3 specifying a "search direction"
	LDX Player_Current	; X = Player_Current

	LDA <World_Map_Y,X	; A = player's current Y position on-map
	ADD Search_YOff,Y	; Offset Player's Y based on current search direction
	STA <Temp_Var15		; Store into Temp_Var15

	LDA <World_Map_X,X	; A = player's current X position on-map
	ADD Search_XOff,Y	; Offset Player's X based on current search direction
	STA <Temp_Var16	; Store into Temp_Var16

	LDA <World_Map_XHi,X	; A = player's current X Hi position on-map
	ADC Search_XHiOff,Y	; Offset Player's X Hi based on current search direction
	ASL A		 	; Take result, left shift 1 (two byte offset into Tile_Mem_Addr)
	TAX		 	; X = A (selects starting offset for this screen)

	; Store starting offset for this map screen into Map_Tile_AddrL/H
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	INC <Map_Tile_AddrH	; Effectively adds $100 to the address (maps get loaded at screen base + $110)

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var16	; Temp_Var16 = Temp_Var16 >> 4

	LDA <Temp_Var15
	AND #$f0		; Aligns Player's Y to a tile
	ORA <Temp_Var16
	TAY		 	; Y = (Temp_Var15 & 0xF0) | Temp_Var15 (offset to specific tile Player is at)
	LDA [Map_Tile_AddrL],Y	; Get this tile
	RTS		 	; Return!
 
	; Offsets around Player for darkness effect
Map_W8D_XOffTable:	.byte -16, 32, 32, -16
Map_W8D_YOffTable:	.byte -16, 32, 32, -16

	; Update darkness around Player
Map_W8DarknessUpdate:
	; Map_W8D_Idx starts at 0
	; A = Player's X coordinate + some offset
	; Y = Player's Y coordinate
	; X = 1

	; Set variables by input parameters
	STA Map_W8D_XOff
	STY Map_W8D_YOff
	STX Map_W8D_Dir	

	LDY #$00	 ; Y = 0
	LDX #$00	 ; X = 0

	LDA Map_W8D_Dir	 ; A = Map_W8D_Dir
	AND #$03	 
	BEQ PRG010_D3E3	 ; If (Map_W8D_Dir & 3) = 0 (every 4 counts), jump to PRG010_D3E3

	LDY #$86	 ; Y = $86
	STY <Temp_Var3	 ; Temp_Var3 = $86

	AND #$02
	BNE PRG010_D3C6
	INX		 ; If (Map_W8D_Dir & 2) = 0 (every 2 counts), X++
PRG010_D3C6:
	LDA Map_W8D_Idx	 ; A = Map_W8D_Idx
	BEQ PRG010_D3CD	 ; If Map_W8D_Idx = 0, jump to PRG010_D3CD
	INX
	INX		 ; Otherwise, X += 2
PRG010_D3CD:
	LDA Map_W8D_XOff 	; A = Map_W8D_XOff
	ADD Map_W8D_XOffTable,X	; Add appropriate offset for here
	STA Map_W8D_X	 	; Store result into Map_W8D_X

	LDA Map_W8D_YOff
	SUB #16		
	STA Map_W8D_Y		; Map_W8D_Y = Map_W8D_YOff - 16
	JMP PRG010_D40B	 	; Jump to PRG010_D40B

PRG010_D3E3:
	LDY #$06	 	; Y = 6
	STY <Temp_Var3		; Temp_Var3 = 6
	LDX #$00	 	; X = 0
	LDA Map_W8D_Dir	; A = Map_W8D_Dir
	AND #$08	 	
	BNE PRG010_D3F1
	INX		 	; If (Map_W8D_Dir & 8) = 0 (every 8 counts), X++
PRG010_D3F1:
	LDA Map_W8D_Idx	 	; A = Map_W8D_Idx
	BEQ PRG010_D3F8	 	; If Map_W8D_Idx = 0, jump to PRG010_D3F8
	INX
	INX		 	; Otherwise, X += 2
PRG010_D3F8:
	LDA Map_W8D_YOff
	ADD Map_W8D_YOffTable,X	
	STA Map_W8D_Y		; Map_W8D_Y = Map_W8D_Y + Y offset

	LDA Map_W8D_XOff
	SUB #16
	STA Map_W8D_X	 	; Map_W8D_X = Map_W8D_XOff - 16

PRG010_D40B:
	LDA Map_W8D_Y	 	; A = Map_W8D_Y
	LDX Map_W8D_X	 	; X = Map_W8D_X
	JSR W8D_Calc_VRAM_Addr	; Returns Temp_Var15 as the video address we need to modify

	; Store Temp_Var15 -> Map_W8D_VAddrH/L
	LDA <Temp_Var15
	STA Map_W8D_VAddrH
	LDA <Temp_Var16
	STA Map_W8D_VAddrL

	JSR W8D_Calc_RC	; Calculate the Map_W8D_RC value (row in upper bits, column in lower bits)

	; Copy Map_W8D_VAddrH/L -> Map_W8D_VAddrH2/L2
	LDA Map_W8D_VAddrH
	STA Map_W8D_VAddrH2
	LDA Map_W8D_VAddrL
	STA Map_W8D_VAddrL2

	JSR W8D_FillGraphicsBuffer	 ; Fill graphics buffer with commands required

	; Set the terminator
	LDA #$00
	STA Graphics_Buffer,Y

	; Update Graphics_BufCnt
	STY Graphics_BufCnt
	RTS		 ; Return

W8D_FillGraphicsBuffer:
	LDA Map_W8D_Dir
	AND #$03
	BNE PRG010_D445	 	; If traveling left or right, jump to PRG010_D445

	; Traveling up or down 

	LDA #$01		; A = 1 (1 byte, i.e. horizontal offset between 8x8 patterns)
	TAX		 	; X = 1 (1 byte, i.e. horizontal offset between map tiles)
	BNE PRG010_D449	 	; (technically always) jump to PRG010_D449

PRG010_D445:
	LDA #32	 ; A = 32 (32 bytes, i.e. vertical offset between 8x8 patterns)
	LDX #16	 ; X = 16 (16 bytes, i.e. vertical offset between map tiles)
PRG010_D449:
	STA <Temp_Var6
	STX <Temp_Var7

	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	LDX #$05	 	; X = 5

	LDA Map_W8D_VAddrH2
	STA Graphics_Buffer,Y

	INY

	LDA Map_W8D_VAddrL2
	STA Graphics_Buffer,Y

	INY

	LDA <Temp_Var3	
	STA Graphics_Buffer,Y

	INY

PRG010_D466:
	LDA Map_W8D_Idx
	BEQ PRG010_D46F	 ; If Map_W8D_Idx = 0, jump to PRG010_D46F

	LDA #$ff	 ; A = $FF
	BNE PRG010_D472	 ; Jump (technically always) to PRG010_D472

PRG010_D46F:
	JSR W8D_GetNext8x8	 ; Get next 8x8 tile to display

PRG010_D472:
	STA Graphics_Buffer,Y	 ; Store into graphics buffer
	INY		 ; Y++ Next buffer byte

	; Address offset to next 8x8 pattern
	LDA Map_W8D_VAddrL2
	ADD <Temp_Var6
	STA Map_W8D_VAddrL2
	LDA Map_W8D_VAddrH2
	ADC #$00
	STA Map_W8D_VAddrH2

	TXA
	AND #$01
	BNE PRG010_D495	; If we're offseting horizontally instead of vertically, jump to PRG010_D495

	; Offsetting vertically...

	; Offset to next row
	LDA Map_W8D_RC
	ADD <Temp_Var7
	STA Map_W8D_RC

PRG010_D495:
	DEX			; X--
	BPL PRG010_D466		; While X >= 0, loop

	RTS		 ; Return

W8D_Calc_RC:
	LDA Map_W8D_Y
	AND #$f0	 ; Grid align 
	STA Map_W8D_RC ; -> Map_W8D_RC

	LDA Map_W8D_X
	LSR A		
	LSR A		
	LSR A		
	LSR A		 ; Shift right 4 bits (column)
	ORA Map_W8D_RC
	STA Map_W8D_RC ; Form row/column offset -> Map_W8D_RC

	RTS		 ; Return


W8D_GetNext8x8:
	; Backup X and Y into Temp_Var2 and Temp_Var5
	STY <Temp_Var2		 
	STX <Temp_Var5

	JSR W8D_Calc_TileOff	 ; Calculate offset within tile

	LDY Map_W8D_RC	 ; Y = row/column offset

	; Uses a fixed offset of Tile_Mem + $450
	LDA Tile_Mem + $450,Y	 ; Get tile here
	STA <Temp_Var11		 ; -> Temp_Var11

	; Switch to page 12 @ A000 (for map tile 8x8 layout data)
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #12
	STA MMC3_PAGE

	JSR TileLayout_GetBaseAddr	 ; Set Temp_Var13/14 to layout pointer, and reload Y = Temp_Var11 (the tile)

	LDA Map_W8D_TileOff	; In-tile offset
	ADD <Temp_Var14
	STA <Temp_Var14		; Temp_Var14 += Map_W8D_TileOff

	LDA [Temp_Var13],Y	; Load this 8x8 pattern of tile
	PHA		 ; Save it

	; Restore previous page @ A000
	JSR PRGROM_Change_A000

	PLA		 ; Restore 8x8 pattern

	; Restore X and Y
	LDY <Temp_Var2
	LDX <Temp_Var5

	RTS		 ; Return

W8D_Calc_VRAM_Addr:
	; A = Map_W8D_Y
	; X = Map_W8D_X

	; This will shift 'A' to the left twice, but with each shift immediately put the
	; shifted out carry right back into the bit 0 position...
	ASL A
	ADC #$00
	ASL A	
	ADC #$00
	STA <Temp_Var13	 ; Result -> <Temp_Var13

	TXA		 ; A = X (Map_W8D_X)
	LSR A
	LSR A
	LSR A
	STA <Temp_Var14 ; <Temp_Var14 = Map_W8D_X >> 3

	; Forming a video address into Temp_Var15
	LDA <Temp_Var13	 ; 
	AND #$03	 ; Cap within Name table 2
	ORA #$28	 ; Name Table 2 hi addr
	STA <Temp_Var15  ; Video address -> Temp_Var15

	LDA <Temp_Var13	  
	AND #$e0	  
	ORA <Temp_Var14  
	STA <Temp_Var16
	RTS		 ; Return


W8D_Calc_TileOff:
	LDA Map_W8D_VAddrL2
	AND #$01
	STA Map_W8D_TileOff

	LDA Map_W8D_VAddrL2
	AND #$20
	BNE PRG010_D513

	ASL Map_W8D_TileOff
	JMP PRG010_D517	 ; Jump to PRG010_D517

PRG010_D513:
	SEC
	ROL Map_W8D_TileOff

PRG010_D517:
	RTS		 ; Return


	; FIXME: Anybody want to claim this? (PRG010_D535)
PRG010_D518:
	.byte $16, $36, $0F, $2A, $36, $0F, $2A, $26, $0F, $17, $36, $0F, $30, $36, $0F, $27
	.byte $36, $16, $02, $05, $08, $0B, $0E, $11, $BC, $2A, $D5, $A2, $02

PRG010_D535:
	LDA PRG010_D518,Y	 	; Get palette value
	STA Palette_Buffer+$11,X	; Store into palette buffer

	DEY		 ; Y--
	DEX		 ; X--
	BPL PRG010_D535	 ; While X >= 0, loop

	; Command palette update
	LDA #$06
	STA <Graphics_Queue

	RTS		 ; Return


; SB: This lookup table supports the new system of map completions by map link instead of by column/row
; This RELIES on the ordering of "ByScrCol" following "ByRowType" to get a proper count of links in the world!
; Will work up to 256 total links on all maps
MapCompletions_Starts:
	.byte 0		; W1
	.byte (W1_ByScrCol - W1_ByRowType)	; W2 (needs the count of W1's for proper offset)
	.byte (W2_ByScrCol - W2_ByRowType) + (W1_ByScrCol - W1_ByRowType)	; W3 (needs the count of W1's and W2's for proper offset, etc.)
	.byte (W3_ByScrCol - W3_ByRowType) + (W2_ByScrCol - W2_ByRowType) + (W1_ByScrCol - W1_ByRowType)	; W4
	.byte (W4_ByScrCol - W4_ByRowType) + (W3_ByScrCol - W3_ByRowType) + (W2_ByScrCol - W2_ByRowType) + (W1_ByScrCol - W1_ByRowType)	; W5
	.byte (W5_ByScrCol - W5_ByRowType) + (W4_ByScrCol - W4_ByRowType) + (W3_ByScrCol - W3_ByRowType) + (W2_ByScrCol - W2_ByRowType) + (W1_ByScrCol - W1_ByRowType)	; W6
	.byte (W6_ByScrCol - W6_ByRowType) + (W5_ByScrCol - W5_ByRowType) + (W4_ByScrCol - W4_ByRowType) + (W3_ByScrCol - W3_ByRowType) + (W2_ByScrCol - W2_ByRowType) + (W1_ByScrCol - W1_ByRowType)	; W7
	.byte (W7_ByScrCol - W7_ByRowType) + (W6_ByScrCol - W6_ByRowType) + (W5_ByScrCol - W5_ByRowType) + (W4_ByScrCol - W4_ByRowType) + (W3_ByScrCol - W3_ByRowType) + (W2_ByScrCol - W2_ByRowType) + (W1_ByScrCol - W1_ByRowType)	; W8
	.byte (W8_ByScrCol - W8_ByRowType) + (W7_ByScrCol - W7_ByRowType) + (W6_ByScrCol - W6_ByRowType) + (W5_ByScrCol - W5_ByRowType) + (W4_ByScrCol - W4_ByRowType) + (W3_ByScrCol - W3_ByRowType) + (W2_ByScrCol - W2_ByRowType) + (W1_ByScrCol - W1_ByRowType)	; W9
	.byte (W9_ByScrCol - W9_ByRowType) + (W8_ByScrCol - W8_ByRowType) + (W7_ByScrCol - W7_ByRowType) + (W6_ByScrCol - W6_ByRowType) + (W5_ByScrCol - W5_ByRowType) + (W4_ByScrCol - W4_ByRowType) + (W3_ByScrCol - W3_ByRowType) + (W2_ByScrCol - W2_ByRowType) + (W1_ByScrCol - W1_ByRowType)	; W0
	.byte (W10_ByScrCol - W10_ByRowType) + (W9_ByScrCol - W9_ByRowType) + (W8_ByScrCol - W8_ByRowType) + (W7_ByScrCol - W7_ByRowType) + (W6_ByScrCol - W6_ByRowType) + (W5_ByScrCol - W5_ByRowType) + (W4_ByScrCol - W4_ByRowType) + (W3_ByScrCol - W3_ByRowType) + (W2_ByScrCol - W2_ByRowType) + (W1_ByScrCol - W1_ByRowType)	; Terminator

Map_CompleteWorld:

	; Set page 12 temporarily (for access to map layout info)
	LDA #MMC3_8K_TO_PRG_A000	; Changing PRG ROM at A000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA #12	 			; Page 12
	STA MMC3_PAGE	 		; Set MMC3 page
	
	LDX #8		; World 9 (Star Road)

	; Y = index into Map_Completions
	LDA MapCompletions_Starts+1,X	; Following world's start map completion index
	SUB #1							; Make end index for warp zone
	TAY								; Set at end of links (last index of world 9)

	; X = loop counter, local world index
	SUB MapCompletions_Starts,X	; Subtract this world's start map completion index (make relative for map links)
	TAX	; -> 'X'

	; Going to look for the ByRowType specifying the current world...
Map_CW_Loop:	
	LDA W9_ByRowType,X
	AND #$0F
	CMP World_Num
	BEQ Map_CW_FoundWorld

	DEY					; Y-- (previous completion)
	DEX					; X-- (previous index)
	BNE Map_CW_Loop		; While X > 0, loop!

Map_CW_FoundWorld:
	LDA	Map_Completions,Y	; Get current completion data
	ORA #MCOMP_COMPLETE		; Mark "complete" (access to next world)
	STA	Map_Completions,Y	; Update current completion data

	; Restore page
	JMP PRGROM_Change_A000

	; Locate the Map_Completion index for the given Player position -> 'Y'
Map_FindCompForPlayerPos:
	; Set page @ A000 to 12
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; Load 'Y' with the final map link index
	LDX World_Num
	LDA MapCompletions_Starts+1,X	; Following world's start map completion index
	SUB MapCompletions_Starts,X	; Subtract this world's start map completion index (make relative for map links)
	SUB #1				; Make end index for THIS world
	TAY	; -> 'Y'

	; 2-byte wide index
	TXA
	ASL A
	TAX

	; Temp_Var3/4 form an address to Map_ByRowType
	LDA Map_ByRowType,X
	STA <Temp_Var3
	LDA Map_ByRowType+1,X
	STA <Temp_Var4

	; Temp_Var5/6 form an address to Map_ByScrCol
	LDA Map_ByScrCol,X 
	STA <Temp_Var5
	LDA Map_ByScrCol+1,X
	STA <Temp_Var6

	; X = Player_Current
	LDX Player_Current

	; Form a column location out of Map X/Hi position -> Temp_Var1
	LDA <World_Map_XHi,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var1		; Map screen * 16
	LDA <World_Map_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var1		; Specific column on map screen (0-15)
	STA <Temp_Var1		; -> Temp_Var1

	; Form a row location out of Map Y position -> Temp_Var2
	LDA <World_Map_Y,X
	AND #$F0		; Row only, no tileset
	STA <Temp_Var2		; -> Temp_Var2

	; Need to iterate all map links of this world looking for this column
MarkComp_Loop:
	LDA [Temp_Var5],Y	; Get column/hi value
	CMP <Temp_Var1		; Compare to Player's column/hi
	BNE MarkComp_DoNext	; If this is not the correct horizontal location, jump to MarkComp_DoNext

	LDA [Temp_Var3],Y	; Get row/tileset value
	AND #$F0		; Keep row only
	CMP <Temp_Var2		; Compare to Player's row
	BNE MarkComp_DoNext	; If this is not the correct vertical location, jump to MarkComp_DoNext

	; We've found the appropriate map link!
	LDX World_Num
	LDA MapCompletions_Starts,X	; This world's start map completion index
	STA <Temp_Var1			; -> Temp_Var1

	TYA		; Map link index
	ADD <Temp_Var1	; Add map completion index offset
	TAY		; -> 'Y'

MarkComp_Exit:
	; Set page @ A000 to 11
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	RTS


MarkComp_DoNext:
	DEY			; Y--
	BPL MarkComp_Loop	; If more map links remain, loop!

	; If you get here, no map link was found; abort!
	PLA
	PLA

	JMP MarkComp_Exit

	; SB: Instead of hardcoding pattern tables, let's just fetch the damn things!
MapTile_GetPats:

	; World_Map_Tile -> 'Y'
	LDY World_Map_Tile
		
	; Set page @ A000 to 12
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; Four pattern pieces to Temp_Var1 thru 4
	LDA Tile_Layout_TS0,Y
	STA <Temp_Var1
	LDA Tile_Layout_TS0+$100,Y
	STA <Temp_Var2
	LDA Tile_Layout_TS0+$200,Y
	STA <Temp_Var3
	LDA Tile_Layout_TS0+$300,Y
	STA <Temp_Var4


	; Set page @ A000 to 11
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	RTS


	; SB: Function to determine tiles you can step over (even if enterable!)
MapTile_CheckBypassable:
	LDX #(Map_BypassTiles_End - Map_BypassTiles - 1)

MT_CheckBypass_Loop:
	CMP Map_BypassTiles,X
	BEQ MT_CheckBypass_Exit

	DEX	; X--
	BPL MT_CheckBypass_Loop	; While X >= 0, loop!

	; Was not in the list of bypassable tiles...
	AND #$F0	; Mask for checking if $1x tile
	CMP #$10	; Will set condition for BEQ if bypassable, BNE if not!

MT_CheckBypass_Exit:
	RTS


	; Offsets to Player's Map X and Y based on which stage of MapCompletion_FixAdjPaths we're
	; on... used for when we're updating tiles "live" immediately after level completion.
MCFAPs_PMXOff:	.byte   0,  0, -16, 16	; Up, Down, Left, Right
MCFAPs_PMYOff:	.byte -16, 16,   0,  0	; Up, Down, Left, Right

	; If a tile is complete, check for adjacent paths that should be opened
	; Uses Temp_VarNP0:
	; Bit 0/1: Index of which adjacent tie we're on
	; Bit 4: MCOMP_COMPLETE (if set)
	; Bit 5: MCOMP_SECRET (if set)
	; Bit 7: If set, we're NOT doing video updates (i.e. immediate commit tile changes to the nametable)
MapCompletion_FixAdjPaths:

	; NOTE: Due to the world map design, we can always safely check above or below
	; Too far above will be border tiles, obviously not path completable
	; Too far below will be default filler tiles, also not path completable

	; Check tile above
	TYA
	SUB #16	; -16 (up one row)
	TAY
	JSR MapCompletion_FixAdjPath

	; Check tile below
	TYA
	ADD #32	; +32 (2 rows down) Since we subtracted 16 before
	TAY
	JSR MapCompletion_FixAdjPath

	; Left/right checks aren't quite as clean...
	; Back up Map_Tile_AddrL/H and 'Y' in case we modify them
	LDA <Map_Tile_AddrL
	PHA
	LDA <Map_Tile_AddrH
	PHA
	TYA
	SUB #16	; -16 (1 row up, back to where we started)
	PHA

	TAY

	; We'll do left first...
	AND #$0F
	BNE MComp_LeftNoFix	; If we're not at the leftmost column of this screen (lower 4 bits zero) jump to MComp_LeftNoFix

	; We're at the leftmost position of the screen!  
	; Need to move to the last column and go to previous screen...
	LDA <Temp_Var1
	BEQ MComp_NoLeftAtAll	; ... unless we're on the first screen, in which case there's no left at all; jump to MComp_NoLeftAtAll

	; Move one screen to the left
	LDA <Map_Tile_AddrL
	SUB #$b0	
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	SBC #$01
	STA <Map_Tile_AddrH

	; Fix 'Y' to be end of the row of the previous screen
	TYA
	ORA #$0F
	TAY
	BNE MComp_LeftFixed	; Jump (technically always) to MComp_LeftFixed

MComp_LeftNoFix:
	; Just subtract 1 from 'Y' in this case :)
	DEY	

MComp_LeftFixed:
	; Whew, all that work... fix the left tile!
	JSR MapCompletion_FixAdjPath

MComp_NoLeftAtAll:
	; Restore 'Y' and Map_Tile_AddrH/L in case they were modified
	PLA
	TAY
	PLA
	STA <Map_Tile_AddrH
	PLA
	STA <Map_Tile_AddrL


	; Now for the right hand side...
	TYA
	AND #$0F
	CMP #$0F
	BNE MComp_RightNoFix	; If we're not on the absolute right column of this screen, jump to MComp_RightNoFix

	; Move one screen to the right
	JSR Map_NextScreen

	; Fix 'Y' to be beginning of the row of the next screen
	TYA
	AND #$F0
	TAY
	BNE MComp_RightFixed	; Jump (technically always) to MComp_RightFixed

MComp_RightNoFix:
	; Just add 1 from 'Y' in this case :)
	INY

MComp_RightFixed:
	; Whew, all that work... fix the right tile!
	JSR MapCompletion_FixAdjPath

	RTS

AdjPath_Check:
	.byte TILE_HORZPATH_INCOMP, TILE_VERTPATH_INCOMP, TILE_HORZPATH_INCOMP0, TILE_VERTPATH_INCOMP0, TILE_HORZPATH_INCOMP3, TILE_VERTPATH_INCOMP3
AdjPath_CheckAlt:
	.byte TILE_HORZPATH_INCOMPA, TILE_VERTPATH_INCOMPA
AdjPath_Change:	
	.byte TILE_HORZPATH, TILE_VERTPATH, TILE_HORZPATH0, TILE_VERTPATH0, TILE_HORZPATHSKY, TILE_VERTPATHSKY
	.byte TILE_HORZPATH, TILE_VERTPATH

AdjPath_LoopStarts:	.byte (AdjPath_CheckAlt - AdjPath_Check - 1), (AdjPath_Change - AdjPath_Check - 1)

	; Change tile detected here to proper completed path tile
MapCompletion_FixAdjPath:

	LDA Temp_VarNP0
	AND #MCOMP_SECRET	; This is bit 5, so to make 0/1, we must roll it around...
	ASL A	; bit 6
	ASL A	; bit 7
	ASL A	; bit carry
	ROL A	; ... back to bit 0
	AND #1
	TAX	; X = 0 or 1
	
	; Choose appropriate loop start, i.e. if we need to process secret/alternate exits, start at a higher value
	LDA AdjPath_LoopStarts,X
	TAX

	LDA [Map_Tile_AddrL],Y
	STA <World_Map_Tile	; ... as well as the tile detected

	; For all known completable path tiles...
MComp_AdjPath_Loop:
	LDA <World_Map_Tile
	CMP AdjPath_Check,X		; Check tile against this known tile...
	BNE MComp_AdjPath_NoMatch	; If not matching this known tile, loop

	; We matched a tile!
	LDA AdjPath_Change,X	; Get tile to change it to
	STA [Map_Tile_AddrL],Y	; Change it!
	STA <World_Map_Tile	; ... as well as the tile detected

	; If Temp_VarNP0 has bit 7 set, we will not do video updates for this tile
	; change, jump to MComp_AdjPath_Done
	LDA Temp_VarNP0
	BMI MComp_AdjPath_Done

	; Backup 'X' and 'Y'
	TXA
	PHA
	TYA
	PHA

	LDA Temp_VarNP0		; Get Temp_VarNP0 (input var)
	AND #%00000011		; Mask out the index value
	TAX			; X = current tile offset

	LDY Player_Current	; Y = Player_Current

	LDA World_Map_Y,Y	; Player Map Y
	ADD MCFAPs_PMYOff,X	; Offset Y to this tile
	PHA			; Save offseted Y for a moment

	LDA World_Map_X,Y	; Player Map X
	ADD MCFAPs_PMXOff,X	; Offset X to this tile
	TAX			; -> 'X' (X parameter to Map_DrawTileChange)

	PLA			; Offset Y -> 'A' (Y parameter to Map_DrawTileChange)

	; Commit tile change
	JSR Map_DrawTileChange


	; Restore 'Y' and 'X'
	PLA
	TAY
	PLA
	TAX


	; Done!
	JMP MComp_AdjPath_Done	; Jump to MComp_AdjPath_Done

MComp_AdjPath_NoMatch:
	DEX			; X--

	; If the MCOMP_COMPLETE bit is set on Temp_VarNP0, we MUST include ALL tiles, so don't range check!
	LDA Temp_VarNP0
	AND #MCOMP_COMPLETE
	BNE MComp_AdjPath_IncComplete

	CPX #(AdjPath_CheckAlt - AdjPath_Check - 1)	; If we're checking alt tiles, check if we hit the bottom of that set
	BEQ MComp_AdjPath_Done

MComp_AdjPath_IncComplete:

	; NOTE: This check is safe to run even if we're only processing the alternate/secret
	; exits because the above compare will trap it first ...

	CPX #(AdjPath_Check - AdjPath_Check - 1)	; If we're checking regular tiles, check if we hit the bottom of that set
	BNE MComp_AdjPath_Loop

	; Didn't match anything...

MComp_AdjPath_Done:
	INC Temp_VarNP0		; Temp_VarNP0++ (next tile offset)
	RTS

	; Might as well make this a subroutine...
Map_NextScreen:
	LDA <Map_Tile_AddrL
	ADD #$b0	
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	ADC #$01
	STA <Map_Tile_AddrH
	RTS


	; TO BE REMOVED: Debug auto complete all worlds for full star road access!!
;MapDEBUG_CompleteW9:
;	LDA World_Num
;	PHA
	
;	LDA #0
;	STA World_Num
;MapDEBUG_CompleteW9_Loop:
;	JSR Map_CompleteWorld

;	LDA	Map_Completions,Y	; Get current completion data
;	ORA #MCOMP_SECRET		; Mark "secret" (access to World Zero)
;	STA	Map_Completions,Y	; Update current completion data

;	LDA World_Num
;	ADD #1
;	STA World_Num

;	CMP #8
;	BLT MapDEBUG_CompleteW9_Loop
	
;	PLA
;	STA World_Num
	
;	RTS

Map_CountStarCoins:
	LDX World_Num
	
	LDA #0
	STA Debug_ForceStarCoins

Map_CountAllEntry:
	LDA #0
	STA Map_StarCoin_Got
	STA Map_StarCoin_Total

	; Initialize Temp_Var3-8 (addresses of bank 12 context)
	JSR Map_GetTile_ByWorld_Init

	; Get start of index into Map_Completions -> 'Y'
	LDA MapCompletions_Starts+1,X
	SUB MapCompletions_Starts,X
	STA <Temp_Var9
	
	LDY #0
Map_CSC_Loop:

	; Get tile associated with this map link to check if it's
	; a normal level tile (thus chipping in 3 star coins
	; towards the total)
	JSR Map_GetTile_ByWorld
	
	TYA
	PHA
	PHA
	
	LDA <Temp_Var10
	CMP #16					; Lazy check for numbered panel
	BLT Map_CSC_CountTile	; If numbered panel, jump to Map_CSC_CountTile
	
	; Check the other tile list
	LDY #(Map_CSC_CountTiles_End - Map_CSC_CountTiles)
Map_CSC_CountTile_Loop:

	LDA Map_CSC_CountTiles,Y
	CMP <Temp_Var10
	BEQ Map_CSC_CountTile	; If this is one of the listed tiles, jump to Map_CSC_CountTile

	DEY
	BPL Map_CSC_CountTile_Loop
	JMP Map_CSC_DontCount
	
Map_CSC_CountTile:
	LDA Map_StarCoin_Total
	ADD #3
	STA Map_StarCoin_Total

	; Super completer hacker coder
	LDA Debug_ForceStarCoins
	BEQ Map_CSC_DontCount
	
	PLA
	PHA
	ADD MapCompletions_Starts,X		; Offset to proper start position
	TAY
	LDA Map_Completions,Y
	ORA #(MCOMP_SCOIN1 | MCOMP_SCOIN2 | MCOMP_SCOIN3 | MCOMP_COMPLETE)
	STA Map_Completions,Y

Map_CSC_DontCount:

	PLA		; 'A' has our relative loop index

	; Now count any star coins recorded in the completion bits
	; Need to change relative index to exact to get to proper
	; location in Map_Completions...
	ADD MapCompletions_Starts,X		; Offset to proper start position
	TAY		; -> 'Y'
	
	LDA Map_Completions,Y
	AND #(MCOMP_SCOIN1 | MCOMP_SCOIN2 | MCOMP_SCOIN3)
	
	; Now we use the Map_CSC_SCoinBitToVal table to get a
	; quick count based on what bits are set...
	TAY
	LDA Map_StarCoin_Got
	ADD Map_CSC_SCoinBitToVal,Y
	STA Map_StarCoin_Got	
	
	; Restore relative loop index
	PLA
	TAY

	INY		; Y++
	CPY <Temp_Var9
	BLT Map_CSC_Loop	; While there's more start indicies, loop


	; In Comet mode, also need to count up comets in the world
	; versus comets that have been completed for additional coinage
	LDA Map_CometMode
	BEQ Map_CSC_NotCometMode

	; Objects are in 11...
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_CountComets_ByWorld

	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_A000

Map_CSC_NotCometMode:
	RTS

	; List of tiles to count 3 more towards star coin total,
	; besides the basic number panels...
Map_CSC_CountTiles:
	.byte TILE_FORT
	.byte TILE_ALTFORT
	.byte TILE_LARGEFORT
	.byte TILE_GHOSTHOUSE
	.byte TILE_AIRSHIP
	.byte TILE_PYRAMID
	.byte TILE_BOWSERCASTLELR
	.byte TILE_HANDTRAP
Map_CSC_CountTiles_End

	; Given that the star coins are stored in Map_Completions
	; as individual bits, but we just need a total, this is
	; a quick cheater table that helps us get there...
	;MCOMP_SCOIN3	= %00000001	; Bit 0 - Star Coin 3 collected
	;MCOMP_SCOIN2	= %00000010	; Bit 1 - Star Coin 2 collected
	;MCOMP_SCOIN1	= %00000100	; Bit 2 - Star Coin 1 collected
Map_CSC_SCoinBitToVal:
	.byte 0		; %000
	.byte 1		; %001
	.byte 1		; %010
	.byte 2		; %011
	.byte 1		; %100
	.byte 2		; %101
	.byte 2		; %110
	.byte 3		; %111

Map_CountAllStarCoinsToW8:
	LDA #8
	BNE Map_CountAllStarCoinsAlt
	
Map_CountAllStarCoins:
	LDA #10

Map_CountAllStarCoinsAlt:
	STA <Temp_Var16

	LDX #0
	STX Map_StarCoin_Got
	STX Map_StarCoin_Total
	STX Temp_VarNP0
	STX Debug_ForceStarCoins
Map_CSC_AllLoop:

	; Since Map_StarCoin_Got / Map_StarCoin_Total are reset on
	; every call to the counter routine, we need to keep them
	; backed up...
	LDA Map_StarCoin_Got
	PHA
	LDA Map_StarCoin_Total
	PHA

	JSR Map_CountAllEntry

	; Accumulate totals
	PLA
	ADD Map_StarCoin_Total
	STA Map_StarCoin_Total
	PLA
	ADD Map_StarCoin_Got
	STA Map_StarCoin_Got

	; Now, there's 264 star coins, which means we can't
	; fit the total into an 8-bit value. However, I'm
	; going to be lazy, and instead of seeking to store
	; a 16-bit value, I'll just increment Temp_VarNP0 if
	; we get a carry flag. We KNOW that "Total" will
	; carry, so we're only interested in "Got" carrying.
	BCC Map_CSC_AllNoCarry
	
	INC Temp_VarNP0

Map_CSC_AllNoCarry:
	INX
	CPX <Temp_Var16
	BLT Map_CSC_AllLoop	; While X < 10, loop!

	RTS


	; Used by debug menu. Relies on position set by Title_DebugComet
Map_DebugGetStarCoins:

	; Clear completion data (danger!!)
	LDX #(Map_ObjCompletions - Map_Completions - 1)
	LDA #0
MDGSC_ClearCompDataLoop:
	STA Map_Completions,X
	DEX
	BPL MDGSC_ClearCompDataLoop
	
	; Clear object completion data (danger!!)
	LDX #(Map_CometMode - Map_ObjCompletions - 1)
MDGSC_ClearObjCompDataLoop:
	STA Map_ObjCompletions,X
	DEX
	BPL MDGSC_ClearObjCompDataLoop

	; Title_DebugComet values:
	;	0 - None
	;	1 - Base (all pre-comet)	[Test comet mode activation after ending]
	;	2 - All comet, missing 1	[Test World Zero unlock sequence]
	;	3 - All through World Zero (everything!)

	LDA <Title_DebugComet
	BEQ MDGSC_NoCoins

	LDX #7	; Worlds 1 thru 8

	CMP #2
	BLT MDGSC_AllLoop	; If Title_DebugComet < 2, jump to MDGSC_AllLoop

	; At Title_DebugComet >= 1, activate comet mode
	LDY #1
	STY Map_CometMode

	CMP #3
	BLT MDGSC_AllLoop	; If Title_DebugComet < 3 (One Short / Base), jump to MDGSC_AllLoop
	
	; At 3 (All), we need all worlds... also, markup star road secrets 
	; as open since we would be with that star coin level
	LDX MapCompletions_Starts+8
MDGSC_UnlockWZLoop:
	LDA Map_Completions,X
	ORA #MCOMP_SECRET
	STA Map_Completions,X

	INX
	CPX MapCompletions_Starts+9
	BNE MDGSC_UnlockWZLoop
	
	LDX #9
	STX Debug_ForceStarCoins	; Complete the levels with star coins obtained!

MDGSC_AllLoop:
	LDA #1
	STA Debug_ForceStarCoins

	JSR Map_CountAllEntry

	DEX
	BPL MDGSC_AllLoop	; While X >= 0, loop!

	LDA <Title_DebugComet
	CMP #2
	BLT MDGSC_NoCoins	; If not on one of the comet completions, jump to MDGSC_NoCoins
	
	PHA

	; Force all objects completed (technically more than just comets, but close enough)
	LDX #(Map_CometMode - Map_ObjCompletions - 1)
	LDA #$FF
MDGSC_SetObjCompDataLoop:
	STA Map_ObjCompletions,X
	DEX
	BPL MDGSC_SetObjCompDataLoop
	
	PLA
	CMP #2
	BNE MDGSC_NoCoins	; If not doing "One Short", jump to MDGSC_NoCoins
	
	; "One short"... just clear first comet completion
	; This is making an assumption the first object
	; is in fact a comet.
	; If you don't fuck with things, this is true.
	LDA Map_ObjCompletions
	AND #%11111110
	STA Map_ObjCompletions
	
MDGSC_NoCoins:
	RTS


	; Checks W9's "completions" for the highest opened world -> Temp_Var10
Save_GetHighestWorld:
	TXA
	PHA

	LDX #0
	STX <Temp_Var10
	LDY MapCompletions_Starts+8
SGHW_Loop:
	LDA Map_Completions,Y
	AND #MCOMP_SECRET
	BEQ SGHW_NotWZero
	
	; If a "secret" is complete in W9, then World Zero is open!
	LDA #9
	BNE SGHW_SetWZero
	
SGHW_NotWZero:
	LDA Map_Completions,Y
	AND #MCOMP_COMPLETE
	BEQ SGHW_WGreater

	LDA W9_ByRowType,X
	AND #$0F	; Get the world this points to
	CMP <Temp_Var10
	BLT SGHW_WGreater	; If fetched world < Temp_Var10, we still have largest value, jump to SGHW_WGreater

	ADD #1	; Because what's unlocked is the brain you completed

SGHW_SetWZero:
	; New highest value
	STA <Temp_Var10

SGHW_WGreater:
	INX
	INY
	CPY MapCompletions_Starts+9
	BLT SGHW_Loop

	PLA
	TAX

	LDA <Temp_Var10
	CMP #8
	BNE SGHW_NotW9

	; If you've completed W8, you may get "World 9" as the "next world"
	; Obviously that's wrong...
	LDA #7
	DEC <Temp_Var10

SGHW_NotW9:
	CMP #10
	BLT SGHW_NotInvalid
	
	; I've occasionally seen a bug that makes an invalid world number.
	; Not sure why this happens, but let's just make sure it never does.
	LDA #9
	STA <Temp_Var10
	
SGHW_NotInvalid:
	RTS

	; Sets W9's "completions" up to the specified world
Debug_SetCompletedToWorld
	; Normally just setting regular completion, but set World Zero
	; secret too if needed...
	
	LDA #MCOMP_COMPLETE
	
	LDX <Title_ComplWorld
	CPX #8
	BNE DSCTW_NotWZero

	LDA #(MCOMP_COMPLETE | MCOMP_SECRET)

DSCTW_NotWZero:
	STA <Temp_Var1

	LDX #0
	LDY MapCompletions_Starts+8
DSCTW_Loop:
	LDA W9_ByRowType,X
	AND #$0F		; Get the world this points to
	CMP <Title_ComplWorld
	BEQ DSCTW_Equal		; Complete equal world
	BGE DSCTW_Greater	; If world is greater than our completion point, jump to DSCTW_Greater

DSCTW_Equal:
	
	; Complete this world appropriately!
	LDA Map_Completions,Y
	ORA <Temp_Var1
	STA Map_Completions,Y

DSCTW_Greater:
	INX
	INY
	CPY MapCompletions_Starts+9
	BLT DSCTW_Loop

	RTS


Map_ResetToadHouses:
	LDX #6
Map_RTH_WorldLoop:
	JSR Map_ResetToadHouse
	
	DEX
	BPL Map_RTH_WorldLoop
	
	RTS

Map_ResetToadHouse:
	; Initialize Temp_Var3-8 (addresses of bank 12 context)
	JSR Map_GetTile_ByWorld_Init

	; Get start of index into Map_Completions -> 'Y'
	LDA MapCompletions_Starts+1,X
	SUB MapCompletions_Starts,X
	STA <Temp_Var9
	
	LDY #0
Map_RTH_Loop:

	; Get tile associated with this map link to check if it's
	; a normal level tile (thus chipping in 3 star coins
	; towards the total)
	JSR Map_GetTile_ByWorld
	
	LDA <Temp_Var10
	CMP #TILE_TOADHOUSE
	BNE Map_RTH_NotToadHouse


	TYA		; 'A' has our relative loop index
	PHA		; Save relative loop index
	
	ADD MapCompletions_Starts,X		; Offset to proper start position
	TAY
	LDA Map_Completions,Y
	AND #(~MCOMP_COMPLETE)		; Clear Toad House completion
	STA Map_Completions,Y


	; Restore relative loop index
	PLA
	TAY

Map_RTH_NotToadHouse:
	INY		; Y++
	CPY <Temp_Var9
	BLT Map_RTH_Loop	; While there's more start indicies, loop

	RTS

	; SB: Align DMC07 to nearest 64 byte boundary
 .AlignDMC07:	DMCAlign .AlignDMC07

DMC07:
	.byte $4A, $53, $55, $55, $55, $55, $55, $55, $55, $55, $AB, $4A, $55, $AA, $DA, $EE
	.byte $2D, $55, $82, $00, $01, $B5, $DD, $BE, $EF, $FB, $AE, $55, $97, $48, $00, $04
	.byte $00, $51, $AB, $DA, $FE, $DF, $BF, $6F, $2F, $09, $89, $00, $08, $00, $5A, $F5
	.byte $7D, $FF, $BE, $EF, $BB, $4A, $91, $20, $00, $00, $A4, $AA, $76, $DF, $BE, $7F
	.byte $7F, $37, $55, $22, $20, $02, $00, $28, $95, $FD, $BA, $7F, $FF, $F7, $56, $93
	.byte $44, $00, $04, $00, $A8, $6C, $BB, $FD, $FF, $FE, $ED, $AD, $54, $02, $04, $08
	.byte $80, $84, $AA, $ED, $FB, $BF, $7F, $DF, $75, $4A, $24, $08, $00, $20, $48, $96
	.byte $7A, $BF, $7F, $FF, $FE, $76, $A5, $48, $02, $04, $00, $90, $50, $AB, $7D, $FF
	.byte $BF, $EF, $EF, $56, $4A, $24, $40, $00, $04, $08, $95, $7B, $F7, $FE, $FB, $FE
	.byte $6D, $5B, $25, $82, $00, $08, $00, $22, $A9, $BD, $DB, $BF, $7F, $FF, $F6, $56
	.byte $2A, $41, $80, $00, $01, $82, $54, $AB, $F7, $FB, $FE, $EF, $DB, $AB, $AA, $84
	.byte $08, $10, $20, $00, $51, $65, $B7, $EF, $DF, $BF, $EF, $DB, $56, $4A, $22, $08
	.byte $02, $20, $08, $52, $DA, $BB, $EF, $FB, $F7, $BD, $DB, $AA, $52, $24, $08, $10
	.byte $20, $08, $49, $6D, $DB, $FD, $FB, $BE, $EF, $6D, $AB, $4A, $22, $41, $80, $20
	.byte $40, $92, $AA, $B6, $77, $FF, $BE, $6F, $DF, $DA, $4A, $25, $21, $82, $00, $41
	.byte $90, $A4, $5A, $BD, $FB, $BE, $6F, $DF, $DE, $6A, $55, $49, $88, $10, $08, $82
	.byte $84, $54, $55, $DB, $B7, $EF, $FB, $F6, $6D, $6B, $55, $8A, $84, $08, $82, $04
	.byte $21, $49, $55, $DB, $EE, $FB, $F6, $ED, $DB, $B6, $AA, $2A, $49, $82, $20, $48
	.byte $10, $92, $54, $B5, $DB, $DE, $7D, $EF, $DE, $AE, $AD, $2A, $95, $24, $41, $88
	.byte $20, $44, $92, $D2, $DA, $76, $7B, $F7, $ED, $ED, $B6, $56, $2D, $25, $49, $24
	.byte $48, $90, $10, $49, $A9, $6A, $DB, $6D, $DF, $BB, $B7, $6D, $5B, $55, $95, $54
	.byte $88, $84, $08, $91, $90, $4A, $69, $6D, $DB, $EE, $DD, $BB, $6D, $D7, $5A, $55
	.byte $2A, $49, $12, $22, $21, $12, $92, $4A, $55, $DB, $B6, $77, $7B, $B7, $5D, $DB
	.byte $AA, $AA, $2A, $49, $42, $22, $41, $12, $92, $2A, $B5, $DA, $B6, $B7, $DB, $BB
	.byte $6D, $5B, $AB, $AA, $52, $49, $92, $24, $44, $42, $92, $A4, $AA, $5A, $DB, $B6
	.byte $DB, $DB, $6D, $DB, $5A, $AD, $2A, $25, $15, $25, $24, $12, $92, $24, $95, $AA
	.byte $D6, $B6, $DB, $F6, $B6, $DB, $D6, $6A, $55, $55, $A9, $24, $49, $42, $22, $49
	.byte $92, $52, $55, $B5, $D5, $DE, $B6, $DB, $B6, $6D, $AB, $56, $A9, $2A, $29, $49
	.byte $92, $48, $92, $24, $29, $55, $D5, $DA, $EA, $6D, $B7, $6D, $DB, $56, $AD, $AA
	.byte $2A, $95, $92, $24, $49, $92, $48, $49, $AA, $AA, $AA, $AD, $B6, $ED, $6D, $DB
	.byte $B6, $55, $B5, $AA, $54, $A5, $92, $24, $49, $92, $24, $29, $A9, $AA, $5A, $B5
	.byte $6D, $DB, $B6, $5D, $DB, $6A, $55, $55, $55, $A5, $54, $92, $A2, $24, $92, $92
	.byte $4A, $A9, $55, $D5, $56, $BB, $B6, $6D, $D7, $B6, $AA, $55, $55, $A9, $2A, $25
	.byte $A9, $24, $49, $92, $52, $29, $55, $55, $AB, $B5, $6D, $DB, $6A, $DB, $DA, $AA
	.byte $5A, $55, $AA, $52, $29, $49, $25, $49, $49, $2A, $A9, $52, $D5, $AA, $B5, $AD
	.byte $B6, $6D, $6B, $AB, $B5, $AA, $AA, $AA, $52, $A9, $92, $92, $4A, $92, $92, $4A
	.byte $A9, $AA, $AA, $56, $6B, $5B, $6D, $6B, $5B, $AD, $AD, $AA, $AA, $2A, $55, $4A
	.byte $A5, $54, $92, $92, $54, $52, $95, $AA, $AA, $D5, $5A, $AD, $6B, $AB, $6D, $AD
	.byte $56, $AD, $AA, $4A, $55, $2A, $55, $52, $52, $49, $49, $A5, $54, $95, $5A, $D5
	.byte $AA, $AD, $B6, $B6, $D5, $D6, $AA, $55, $55, $55, $55, $A9, $52, $2A, $A5, $92
	.byte $92, $4A, $A9, $54, $A5, $55, $AD, $5A, $AD, $AD, $B6, $B6, $5A, $AB, $55, $55
	.byte $55, $95, $AA, $54, $4A, $A5, $54, $52, $2A, $A5, $4A, $55, $55, $B5, $5A, $AB
	.byte $B5, $D5, $DA, $6A, $AD, $5A, $55, $55, $55, $AA, $54, $A9, $52, $2A, $25, $95
	.byte $52, $A9, $52, $55, $D5, $AA, $D5, $5A, $AD, $D5, $DA, $6A, $AD, $5A, $55, $55
	.byte $A9, $4A, $55, $29, $95, $52, $29, $95, $2A, $A5, $AA, $2A, $AB, $AA, $D5, $5A
	.byte $AD, $D5, $DA, $AA, $AD, $5A, $55, $55, $A5, $AA, $54, $A9, $52, $AA, $54, $4A
	.byte $A5, $54, $A9, $AA, $AA, $6A, $D5, $AA, $B5, $5A, $AB, $B5, $5A, $B5, $AA, $55
	.byte $A9, $AA, $52, $A5, $4A, $95, $4A, $95, $52, $A5, $52, $55, $A9, $AA, $55, $B5
	.byte $6A, $AD, $DA, $AA, $D5, $AA, $55, $AB, $AA, $AA, $AA, $54, $A9, $2A, $55, $4A
	.byte $55, $29, $95, $2A, $55, $95, $55, $55, $55, $AB, $D6, $AA, $D5, $5A, $AD, $5A
	.byte $D5, $AA, $AA, $AA, $4A, $55, $A9, $52, $A5, $4A, $95, $2A, $55, $AA, $54, $55
	.byte $55, $55, $B5, $AA, $D5, $AA, $55, $6B, $B5, $6A, $55, $35, $55, $55, $55, $A9
DMC07_End

	; BEGIN UNUSED SPACE
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	; END UNUSED SPACE

DMC03:
	.byte $D5, $12, $87, $AA, $1F, $3F, $06, $E0, $F8, $71, $FC, $00, $A8, $FF, $FB, $0F
	.byte $00, $C0, $FF, $1F, $00, $A0, $FF, $3C, $0F, $00, $F8, $01, $FE, $FF, $01, $FC
	.byte $FF, $81, $43, $00, $80, $FF, $3F, $88, $03, $C0, $FF, $17, $C0, $FA, $FF, $FA
	.byte $71, $00, $C0, $F9, $FF, $07, $00, $90, $A7, $4E, $E9, $C0, $8F, $FE, $EF, $09
	.byte $00, $E8, $FF, $4F, $00, $00, $7C, $FF, $2F, $00, $F8, $7F, $E8, $17, $00, $FC
	.byte $3F, $00, $EC, $C0, $FF, $FF, $00, $80, $FF, $43, $0B, $10, $F8, $FF, $03, $00
	.byte $BE, $EB, $FF, $05, $00, $FF, $8B, $42, $18, $A5, $7F, $D7, $09, $80, $D5, $2F
	.byte $1D, $40, $B7, $FF, $07, $C0, $4E, $2F, $45, $96, $64, $BB, $8B, $C4, $AA, $72
DMC03_End

DMC08:
	.byte $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $05, $FC, $07, $F0, $FF
	.byte $2F, $09, $00, $00, $FE, $FF, $07, $80, $FF, $02, $5F, $F6, $2B, $30, $4A, $D8
	.byte $AF, $57, $04, $5A, $5D, $BB, $08, $AD, $2D, $55, $4D, $D5, $54, $AA, $EA, $BE
	.byte $02, $F8, $7F, $00, $00, $FE, $FF, $03, $F0, $FF, $00, $A0, $FF, $05, $F0, $17
	.byte $C0, $AB, $AF, $1B, $80, $E2, $5F, $A1, $E9, $15, $C9, $B2, $57, $55, $40, $ED
	.byte $5F, $11, $AC, $36, $55, $15, $F5, $56, $25, $D4, $F2, $07, $86, $E3, $2B, $F0
	.byte $FF, $3F, $00, $80, $FF, $7F, $00, $C0, $FF, $03, $00, $F0, $FF, $03, $80, $FF
	.byte $62, $81, $FF, $22, $78, $BD, $24, $09, $BD, $DD, $4A, $08, $FA, $3F, $80, $D5
	.byte $4B, $B6, $2A, $2B, $4D, $24, $3F, $E8, $EF, $00, $7C, $FF, $05, $00, $FF, $0F
	.byte $00, $C0, $FF, $1F, $00, $F0, $FF, $07, $F0, $1F, $28, $7E, $FE, $07, $00, $E0
	.byte $3F, $7E, $E0, $00, $8E, $FF, $00, $FE, $1F, $80, $2E, $FE, $E7, $07, $00, $FF
	.byte $8F, $1E, $00, $7E, $A0, $F8, $FF, $03, $00, $FE, $A3, $00, $FF, $02, $EF, $7F
	.byte $01, $00, $F0, $FF, $07, $80, $FF, $27, $80, $EB, $FF, $01, $00, $FD, $7F, $00
	.byte $F8, $7F, $02, $2C, $CE, $1F, $04, $46, $FE, $3F, $00, $F0, $3F, $70, $BE, $07
	.byte $F8, $0B, $44, $8F, $FF, $C0, $7A, $00, $07, $FA, $FF, $07, $00, $FC, $3F, $40
	.byte $FE, $40, $FF, $1F, $00, $80, $FF, $27, $00, $EC, $BF, $7A, $80, $FF, $0B, $00
	.byte $FF, $81, $BF, $00, $A7, $42, $FF, $0B, $A0, $EA, $3F, $E0, $C4, $D1, $ED, $20
	.byte $F4, $9F, $00, $F7, $03, $FB, $0B, $E0, $D3, $07, $E8, $EA, $57, $00, $7F, $C1
	.byte $AF, $78, $01, $A0, $FF, $2F, $E8, $00, $FE, $42, $57, $B7, $49, $44, $55, $6D
	.byte $AF, $58, $01, $DA, $FF, $15, $80, $AA, $FD, $07, $40, $FE, $52, $4B, $75, $2A
	.byte $B4, $55, $AB, $26, $A9, $BA, $58, $4A, $DB, $56, $95, $D0, $A6, $17, $2B, $D9
	.byte $B2, $52, $D5, $92, $DA, $D1, $96, $98, $B4, $4A, $7B, $27, $89, $6C, $29, $EA
	.byte $FD, $0A, $01, $DA, $FE, $17, $00, $F5, $BD, $44, $49, $ED, $AD, $04, $69, $FB
	.byte $04, $EA, $BD, $54, $92, $D0, $BE, $4B, $92, $DA, $92, $DA, $A4, $B6, $95, $A4
	.byte $AA, $DA, $5A, $12, $D5, $AA, $B7, $24, $29, $B5, $AD, $26, $B1, $2D, $A5, $55
	.byte $2B, $25, $B5, $DD, $44, $AA, $6A, $2B, $69, $A5, $DA, $B6, $24, $A8, $BD, $25
	.byte $A9, $B2, $DD, $48, $52, $6D, $AB, $52, $55, $25, $6D, $5B, $49, $AA, $AD, $2A
	.byte $49, $6D, $AB, $52, $53, $A5, $B2, $AD, $2A, $55, $55, $49, $6D, $57, $21, $B6
DMC08_End

; Rest of ROM bank was empty

