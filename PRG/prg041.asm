; Source generated by DCC6502 version v1.4
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg001.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------

	; CAUTION!! ObjectGrExt labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group Extended (i.e. objects starting at ID $E0) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- necessary in this bank due to short count
ObjectGrExt_InitJumpTable:
	.word ObjInit_Mouser	; Object $E0 - OBJ_BOSS_MOUSER
	.word ObjInit_BowserJr	; Object $E1 - OBJ_BOSS_BOWSERJR
	.word ObjInit_Wart		; Object $E2 - OBJ_BOSS_WART
	.word ObjInit_BigBoo	; Object $E3 - OBJ_BOSS_BIGBOO1
	.word ObjInit_BigBoo	; Object $E4 - OBJ_BOSS_BIGBOO2
	.word ObjInit_BigBoo	; Object $E5 - OBJ_BOSS_BIGBOO3
	.word ObjInit_Yoshi	; Object $E6 - OBJ_YOSHI
	.word ObjInit_Boomer	; Object $E7 - OBJ_BOSS_BOOMER
	.word ObjInit_Reznor	; Object $E8 - OBJ_BOSS_REZNOR
	.word ObjInit_Urchin	; Object $E9 - OBJ_URCHIN_V
	.word ObjInit_Urchin	; Object $EA - OBJ_URCHIN_H
	.word ObjInit_Gao		; Object $EB - OBJ_GAO
	.word ObjInit_Pokey		; Object $EC - OBJ_POKEY
	.word ObjInit_SandFill	; Object $ED - OBJ_SANDFILL_CTL
	.word ObjInit_Totomesu	; Object $EE - OBJ_BOSS_TOTOMESU
	.word ObjInit_Clyde		; Object $EF - OBJ_BOSS_CLYDE
	.word ObjInit_DelfinoSlots	; Object $F0 - OBJ_DELFINOSLOTS
	.word ObjInit_DoNothing	; Object $F1 - OBJ_PINATA
	.word ObjInit_Petey		; Object $F2 - OBJ_BOSS_PETEY
	.word ObjInit_Magiblot	; Object $F3 - OBJ_MAGIBLOT
	.word ObjInit_ArenaCtl	; Object $F4 - OBJ_ARENA_CTL
	.word ObjInit_Bleck		; Object $F5 - OBJ_BOSS_BLECK
	.word ObjInit_DoNothing	; Object $F6 - OBJ_BLECK_PROJ
	.word ObjInit_BattleCtl	; Object $F7 - OBJ_BATTLE_CTL
	.word ObjInit_DoNothing	; Object $F8
	.word ObjInit_DoNothing	; Object $F9
	.word ObjInit_DoNothing	; Object $FA
	.word ObjInit_DoNothing	; Object $FB
	.word ObjInit_DoNothing	; Object $FC
	.word ObjInit_DoNothing	; Object $FD
	.word ObjInit_DoNothing	; Object $FE
	.word ObjInit_DoNothing	; Object $FF

	; Bleh, hacky putting this here, but I'm out of space and this is free...
	
	; List of object IDs that Yoshi will not be able to eat at all
Yoshi_IgnoreObjectIDs:	.byte OBJ_FLAREUP, OBJ_BOSS_BOWSERJR, OBJ_ENDLEVELCARD, OBJ_CHECKPOINT, OBJ_CHECKPOINT_FORCE
Yoshi_IgnoreObjectIDs_End

	; Object group Extended (i.e. objects starting at ID $E0) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- necessary in this bank due to short count
ObjectGrExt_NormalJumpTable:
	.word ObjNorm_Mouser	; Object $E0 - OBJ_BOSS_MOUSER
	.word ObjNorm_BowserJr	; Object $E1 - OBJ_BOSS_BOWSERJR
	.word ObjNorm_Wart		; Object $E2 - OBJ_BOSS_WART
	.word ObjNorm_BigBoo	; Object $E3 - OBJ_BOSS_BIGBOO1
	.word ObjNorm_BigBoo	; Object $E4 - OBJ_BOSS_BIGBOO2
	.word ObjNorm_BigBoo	; Object $E5 - OBJ_BOSS_BIGBOO3
	.word ObjNorm_Yoshi		; Object $E6 - OBJ_YOSHI
	.word ObjNorm_Boomer	; Object $E7 - OBJ_BOSS_BOOMER
	.word ObjNorm_Reznor	; Object $E8 - OBJ_BOSS_REZNOR
	.word ObjNorm_Urchin	; Object $E9 - OBJ_URCHIN_V
	.word ObjNorm_Urchin	; Object $EA - OBJ_URCHIN_H
	.word ObjNorm_Gao		; Object $EB - OBJ_GAO
	.word ObjNorm_Pokey		; Object $EC - OBJ_POKEY
	.word ObjNorm_SandFill	; Object $ED - OBJ_SANDFILL_CTL
	.word ObjNorm_Totomesu	; Object $EE - OBJ_BOSS_TOTOMESU
	.word ObjNorm_Clyde		; Object $EF - OBJ_BOSS_CLYDE
	.word ObjNorm_DelfinoSlots	; Object $F0 - OBJ_DELFINOSLOTS
	.word ObjNorm_Pinata	; Object $F1 - OBJ_PINATA
	.word ObjNorm_Petey		; Object $F2 - OBJ_BOSS_PETEY
	.word ObjNorm_Magiblot	; Object $F3 - OBJ_MAGIBLOT
	.word ObjNorm_ArenaCtl	; Object $F4 - OBJ_ARENA_CTL
	.word ObjNorm_Bleck		; Object $F5 - OBJ_BOSS_BLECK
	.word ObjNorm_BleckProj	; Object $F6 - OBJ_BLECK_PROJ
	.word ObjNorm_BattleCtl	; Object $F7 - OBJ_BATTLE_CTL
	.word ObjNorm_DoNothing	; Object $F8
	.word ObjNorm_DoNothing	; Object $F9
	.word ObjNorm_DoNothing	; Object $FA
	.word ObjNorm_DoNothing	; Object $FB
	.word ObjNorm_DoNothing	; Object $FC
	.word ObjNorm_DoNothing	; Object $FD
	.word ObjNorm_DoNothing	; Object $FE
	.word ObjNorm_DoNothing	; Object $FF


	; Object group Extended (i.e. objects starting at ID $E0) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- necessary in this bank due to short count
ObjectGrExt_CollideJumpTable:
	.word OCSPECIAL_HIGHSCORE	; Object $E0 - OBJ_BOSS_MOUSER
	.word OCSPECIAL_HIGHSCORE	; Object $E1 - OBJ_BOSS_BOWSERJR
	.word OCSPECIAL_HIGHSCORE	; Object $E2 - OBJ_BOSS_WART
	.word OCSPECIAL_HIGHSCORE	; Object $E3 - OBJ_BOSS_BIGBOO1
	.word OCSPECIAL_HIGHSCORE	; Object $E4 - OBJ_BOSS_BIGBOO2
	.word OCSPECIAL_HIGHSCORE	; Object $E5 - OBJ_BOSS_BIGBOO3
	.word ObjHit_DoNothing	; Object $E6 - OBJ_YOSHI
	.word OCSPECIAL_HIGHSCORE	; Object $E7 - OBJ_BOSS_BOOMER
	.word ObjHit_Reznor	; Object $E8 - OBJ_BOSS_REZNOR
	.word ObjHit_DoNothing	; Object $E9 - OBJ_URCHIN_V
	.word ObjHit_DoNothing	; Object $EA - OBJ_URCHIN_H
	.word ObjHit_DoNothing	; Object $EB - OBJ_GAO
	.word ObjHit_DoNothing	; Object $EC - OBJ_POKEY
	.word ObjHit_DoNothing	; Object $ED - OBJ_SANDFILL_CTL
	.word ObjHit_DoNothing	; Object $EE - OBJ_BOSS_TOTOMESU
	.word ObjHit_DoNothing	; Object $EF - OBJ_BOSS_CLYDE
	.word ObjHit_DelfinoSlots	; Object $F0 - OBJ_DELFINOSLOTS
	.word ObjHit_Pinata	; Object $F1 - OBJ_PINATA
	.word ObjHit_DoNothing	; Object $F2 - OBJ_BOSS_PETEY
	.word ObjHit_DoNothing	; Object $F3 - OBJ_MAGIBLOT
	.word ObjHit_DoNothing	; Object $F4 - OBJ_ARENA_CTL
	.word ObjHit_DoNothing	; Object $F5 - OBJ_BOSS_BLECK
	.word ObjHit_DoNothing	; Object $F6 - OBJ_BLECK_PROJ
	.word ObjHit_DoNothing	; Object $F7 - OBJ_BATTLE_CTL
	.word ObjHit_DoNothing	; Object $F8
	.word ObjHit_DoNothing	; Object $F9
	.word ObjHit_DoNothing	; Object $FA
	.word ObjHit_DoNothing	; Object $FB
	.word ObjHit_DoNothing	; Object $FC
	.word ObjHit_DoNothing	; Object $FD
	.word ObjHit_DoNothing	; Object $FE
	.word ObjHit_DoNothing	; Object $FF

	
	; Object group Extended (i.e. objects starting at ID $E0) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- necessary in this bank due to short count
ObjectGrExt_Attributes:
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $E0 - OBJ_BOSS_MOUSER
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $E1 - OBJ_BOSS_BOWSERJR
	.byte OA1_PAL3 | OA1_HEIGHT48 | OA1_WIDTH48	; Object $E2 - OBJ_BOSS_WART
	.byte OA1_PAL0	; Object $E3 - OBJ_BOSS_BIGBOO1
	.byte OA1_PAL0	; Object $E4 - OBJ_BOSS_BIGBOO2
	.byte OA1_PAL0	; Object $E5 - OBJ_BOSS_BIGBOO3
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $E6 - OBJ_YOSHI
	.byte OA1_PAL0	; Object $E7 - OBJ_BOSS_BOOMER
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $E8 - OBJ_BOSS_REZNOR
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $E9 - OBJ_URCHIN_V
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $EA - OBJ_URCHIN_H
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $EB - OBJ_GAO
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $EC - OBJ_POKEY
	.byte OA1_PAL0	; Object $ED - OBJ_SANDFILL_CTL
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $EE - OBJ_BOSS_TOTOMESU
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $EF - OBJ_BOSS_CLYDE
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $F0 - OBJ_DELFINOSLOTS
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $F1 - OBJ_PINATA
	.byte OA1_PAL3 | OA1_HEIGHT48 | OA1_WIDTH32	; Object $F2 - OBJ_BOSS_PETEY
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $F3 - OBJ_MAGIBLOT
	.byte OA1_PAL0	; Object $F4 - OBJ_ARENA_CTL
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $F5 - OBJ_BOSS_BLECK
	.byte OA1_PAL2 | OA1_WIDTH16 | OA1_HEIGHT16	; Object $F6 - OBJ_BLECK_PROJ
	.byte OA1_PAL0	; Object $F7 - OBJ_BATTLE_CTL
	.byte OA1_PAL0	; Object $F8
	.byte OA1_PAL0	; Object $F9
	.byte OA1_PAL0	; Object $FA
	.byte OA1_PAL0	; Object $FB
	.byte OA1_PAL0	; Object $FC
	.byte OA1_PAL0	; Object $FD
	.byte OA1_PAL0	; Object $FE
	.byte OA1_PAL0	; Object $FF


	; Object group Extended (i.e. objects starting at ID $E0) second set attribute bits

	; Attribute bits for objects:
	;	Bits 0: If set, object is NOT a "shelled" enemy
	;	Bits 1: Subtly modifies Player detection response; see comments in PRG000_D205
	;	Bits 2: If set, object doesn't respond if stomped (indifferent, not same as attr 3, bit 5 which leads to hurting player)
	;	Bits 3: Object uses 16-bit X value (otherwise, Object_XHi will be zeroed)
	;	Bits 4-7: Pick root tile detection group offset (from Object_TileDetectOffsets)

	.org ObjectGroup_Attributes2	; <-- necessary in this bank due to short count
ObjectGrExt_Attributes2:
	.byte OA2_TDOGRP6	; Object $E0 - OBJ_BOSS_MOUSER
	.byte OA2_TDOGRP6 | OA2_NOSHELLORSQUASH	; Object $E1 - OBJ_BOSS_BOWSERJR
	.byte OA2_TDOGRP6 | OA2_NOSHELLORSQUASH | OA2_STOMPDONTCARE	; Object $E2 - OBJ_BOSS_WART
	.byte OA2_TDOGRP0	; Object $E3 - OBJ_BOSS_BIGBOO1
	.byte OA2_TDOGRP0	; Object $E4 - OBJ_BOSS_BIGBOO2
	.byte OA2_TDOGRP0	; Object $E5 - OBJ_BOSS_BIGBOO3
	.byte OA2_TDOGRP0	; Object $E6 - OBJ_YOSHI
	.byte OA2_TDOGRP0 | OA2_NOSHELLORSQUASH	; Object $E7 - OBJ_BOSS_BOOMER
	.byte OA2_TDOGRP6 | OA2_NOSHELLORSQUASH | OA2_STOMPDONTCARE	; Object $E8 - OBJ_BOSS_REZNOR
	.byte OA2_TDOGRP6 | OA2_NOSHELLORSQUASH | OA2_STOMPDONTCARE	; Object $E9 - OBJ_URCHIN_V
	.byte OA2_TDOGRP6 | OA2_NOSHELLORSQUASH | OA2_STOMPDONTCARE	; Object $EA - OBJ_URCHIN_H
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $EB - OBJ_GAO
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $EC - OBJ_POKEY
	.byte OA2_TDOGRP0 | OA2_NOSHELLORSQUASH | OA2_STOMPDONTCARE	; Object $ED - OBJ_SANDFILL_CTL
	.byte OA2_TDOGRP6 | OA2_STOMPDONTCARE	; Object $EE - OBJ_BOSS_TOTOMESU
	.byte OA2_TDOGRP6 | OA2_STOMPDONTCARE	; Object $EF - OBJ_BOSS_CLYDE
	.byte OA2_TDOGRP0	; Object $F0 - OBJ_DELFINOSLOTS
	.byte OA2_TDOGRP6 | OA2_NOSHELLORSQUASH | OA2_STOMPDONTCARE	; Object $F1 - OBJ_PINATA
	.byte OA2_TDOGRP11 | OA2_STOMPDONTCARE	; Object $F2 - OBJ_BOSS_PETEY
	.byte OA2_TDOGRP6 | OA2_NOSHELLORSQUASH	; Object $F3 - OBJ_MAGIBLOT
	.byte OA2_TDOGRP0 | OA2_NOSHELLORSQUASH | OA2_STOMPDONTCARE	; Object $F4 - OBJ_ARENA_CTL
	.byte OA2_TDOGRP6 | OA2_STOMPDONTCARE	; Object $F5 - OBJ_BOSS_BLECK
	.byte OA2_TDOGRP1 | OA2_NOSHELLORSQUASH | OA2_STOMPDONTCARE	; Object $F6 - OBJ_BLECK_PROJ
	.byte OA2_TDOGRP0 | OA2_NOSHELLORSQUASH | OA2_STOMPDONTCARE	; Object $F7 - OBJ_BATTLE_CTL
	.byte OA2_TDOGRP0	; Object $F8
	.byte OA2_TDOGRP0	; Object $F9
	.byte OA2_TDOGRP0	; Object $FA
	.byte OA2_TDOGRP0	; Object $FB
	.byte OA2_TDOGRP0	; Object $FC
	.byte OA2_TDOGRP0	; Object $FD
	.byte OA2_TDOGRP0	; Object $FE
	.byte OA2_TDOGRP0	; Object $FF


	; Object group Extended (i.e. objects starting at ID $E0) third set attribute bits

	; Attribute bits for objects:
	;	Bits 0-3: Determines what to do when gameplay halted (see Object_DoHaltedAction, most common is 5 / 0101)
	;	Bit 4: If set, enemy goes to "squashed" (state 7) after being stomped, otherwise it goes to "shelled" (state 3); in the case of being stomped by Kuribo's shoe or the Rabbit statue, squashed enemies still get sqashed, and otherwise they get "killed" (6)
	;	Bit 5: Object is NOT stompable (e.g. a spikey enemy, HURTS PLAYER, not same as attr 2 bit 2 which is just indifferent)
	;	Bit 6: The CollideJumpTable entry MAY contain the "special" entry; see CollideJumpTable; also "dies" into "shell" (state 3) (i.e. object "bumps" into shell when hit from beneath)
	;	Bit 7: If set, object cannot be tail attacked

	.org ObjectGroup_Attributes3	; <-- necessary in this bank due to short count
ObjectGrExt_Attributes3:
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $E0 - OBJ_BOSS_MOUSER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $E1 - OBJ_BOSS_BOWSERJR
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $E2 - OBJ_BOSS_WART
	.byte OA3_HALT_DONOTHING | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $E3 - OBJ_BOSS_BIGBOO1
	.byte OA3_HALT_DONOTHING | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $E4 - OBJ_BOSS_BIGBOO2
	.byte OA3_HALT_DONOTHING | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $E5 - OBJ_BOSS_BIGBOO3
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $E6 - OBJ_YOSHI
	.byte OA3_HALT_DONOTHING | OA3_TAILATKIMMUNE 	; Object $E7 - OBJ_BOSS_BOOMER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $E8 - OBJ_BOSS_REZNOR
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $E9 - OBJ_URCHIN_V
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $EA - OBJ_URCHIN_H
	.byte OA3_HALT_JUSTDRAW | OA3_SQUASH	; Object $EB - OBJ_GAO
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE	; Object $EC - OBJ_POKEY
	.byte OA3_HALT_DONOTHING | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE 	; Object $ED - OBJ_SANDFILL_CTL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $EE - OBJ_BOSS_TOTOMESU
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $EF - OBJ_BOSS_CLYDE
	.byte OA3_HALT_NORMALONLY	; Object $F0 - OBJ_DELFINOSLOTS
	.byte OA3_HALT_JUSTDRAWTALL | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $F1 - OBJ_PINATA
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $F2 - OBJ_BOSS_PETEY
	.byte OA3_HALT_NORMALONLY	; Object $F3 - OBJ_MAGIBLOT
	.byte OA3_HALT_DONOTHING | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $F4 - OBJ_ARENA_CTL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $F5 - OBJ_BOSS_BLECK
	.byte OA3_HALT_DONOTHING | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $F6 - OBJ_BLECK_PROJ
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE | OA3_NOTSTOMPABLE	; Object $F7 - OBJ_BATTLE_CTL
	.byte OA3_HALT_DONOTHING	; Object $F8
	.byte OA3_HALT_DONOTHING	; Object $F9
	.byte OA3_HALT_DONOTHING	; Object $FA
	.byte OA3_HALT_DONOTHING	; Object $FB
	.byte OA3_HALT_DONOTHING	; Object $FC
	.byte OA3_HALT_DONOTHING	; Object $FD
	.byte OA3_HALT_DONOTHING	; Object $FE
	.byte OA3_HALT_DONOTHING	; Object $FF


	; Object group Extended (i.e. objects starting at ID $E0) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- necessary in this bank due to short count
ObjectGrExt_PatTableSel:
	.byte OPTS_NOCHANGE	; Object $E0 - OBJ_BOSS_MOUSER
	.byte OPTS_NOCHANGE	; Object $E1 - OBJ_BOSS_BOWSERJR
	.byte OPTS_NOCHANGE	; Object $E2 - OBJ_BOSS_WART
	.byte OPTS_NOCHANGE	; Object $E3 - OBJ_BOSS_BIGBOO1
	.byte OPTS_NOCHANGE	; Object $E4 - OBJ_BOSS_BIGBOO2
	.byte OPTS_NOCHANGE	; Object $E5 - OBJ_BOSS_BIGBOO3
	.byte OPTS_SETPT5 | 30	; Object $E6 - OBJ_YOSHI
	.byte OPTS_SETPT5 | $0B	; Object $E7 - OBJ_BOSS_BOOMER
	.byte OPTS_SETPT5 | $20	; Object $E8 - OBJ_BOSS_REZNOR
	.byte OPTS_SETPT6 | $1B	; Object $E9 - OBJ_URCHIN_V
	.byte OPTS_SETPT6 | $1B	; Object $EA - OBJ_URCHIN_H
	.byte OPTS_SETPT5 | 86	; Object $EB - OBJ_GAO
	.byte OPTS_SETPT5 | 86	; Object $EC - OBJ_POKEY
	.byte OPTS_NOCHANGE	; Object $ED - OBJ_SANDFILL_CTL
	.byte OPTS_SETPT5 | 87	; Object $EE - OBJ_BOSS_TOTOMESU
	.byte OPTS_SETPT5 | 87	; Object $EF - OBJ_BOSS_CLYDE
	.byte OPTS_SETPT5 | 33	; Object $F0 - OBJ_DELFINOSLOTS
	.byte OPTS_SETPT5 | 33	; Object $F1 - OBJ_PINATA
	.byte OPTS_NOCHANGE	; Object $F2 - OBJ_BOSS_PETEY
	.byte OPTS_NOCHANGE	; Object $F3 - OBJ_MAGIBLOT
	.byte OPTS_NOCHANGE	; Object $F4 - OBJ_ARENA_CTL
	.byte OPTS_NOCHANGE	; Object $F5 - OBJ_BOSS_BLECK
	.byte OPTS_NOCHANGE	; Object $F6 - OBJ_BLECK_PROJ
	.byte OPTS_NOCHANGE	; Object $F7 - OBJ_BATTLE_CTL
	.byte OPTS_NOCHANGE	; Object $F8
	.byte OPTS_NOCHANGE	; Object $F9
	.byte OPTS_NOCHANGE	; Object $FA
	.byte OPTS_NOCHANGE	; Object $FB
	.byte OPTS_NOCHANGE	; Object $FC
	.byte OPTS_NOCHANGE	; Object $FD
	.byte OPTS_NOCHANGE	; Object $FE
	.byte OPTS_NOCHANGE	; Object $FF


	; Object group Extended (i.e. objects starting at ID $E0) "Kill Action"

	.org ObjectGroup_Attributes4	; <-- necessary in this bank due to short count
ObjectGrExt_Attributes4:
	.byte OA4_KA_NORMALANDKILLED	; Object $E0 - OBJ_BOSS_MOUSER
	.byte OA4_KA_NORMALSTATE | OA4_YOSHIIMMUNE	; Object $E1 - OBJ_BOSS_BOWSERJR
	.byte OA4_KA_NORMALANDKILLED	; Object $E2 - OBJ_BOSS_WART
	.byte OA4_KA_NORMALANDKILLED	; Object $E3 - OBJ_BOSS_BIGBOO1
	.byte OA4_KA_NORMALANDKILLED	; Object $E4 - OBJ_BOSS_BIGBOO2
	.byte OA4_KA_NORMALANDKILLED	; Object $E5 - OBJ_BOSS_BIGBOO3
	.byte OA4_KA_STANDARD	; Object $E6 - OBJ_YOSHI
	.byte OA4_KA_NORMALSTATE	; Object $E7 - OBJ_BOSS_BOOMER
	.byte OA4_KA_NORMALANDKILLED	; Object $E8 - OBJ_BOSS_REZNOR
	.byte OA4_KA_NORMALANDKILLED	; Object $E9 - OBJ_URCHIN_V
	.byte OA4_KA_NORMALANDKILLED	; Object $EA - OBJ_URCHIN_H
	.byte OA4_KA_STANDARD	; Object $EB - OBJ_GAO
	.byte OA4_KA_NORMALANDKILLED | OA4_FROZENCANTKICK | OA4_YOSHIIMMUNE	; Object $EC - OBJ_POKEY
	.byte OA4_KA_STANDARD	; Object $ED - OBJ_SANDFILL_CTL
	.byte OA4_KA_NORMALSTATE	; Object $EE - OBJ_BOSS_TOTOMESU
	.byte OA4_KA_NORMALSTATE	; Object $EF - OBJ_BOSS_CLYDE
	.byte OA4_KA_STANDARD	; Object $F0 - OBJ_DELFINOSLOTS
	.byte OA4_KA_STANDARD	; Object $F1 - OBJ_PINATA
	.byte OA4_KA_NORMALSTATE	; Object $F2 - OBJ_BOSS_PETEY
	.byte OA4_KA_POOFDEATH	; Object $F3 - OBJ_MAGIBLOT
	.byte OA4_KA_STANDARD	; Object $F4 - OBJ_ARENA_CTL
	.byte OA4_KA_STANDARD	; Object $F5 - OBJ_BOSS_BLECK
	.byte OA4_KA_STANDARD	; Object $F6 - OBJ_BLECK_PROJ
	.byte OA4_KA_STANDARD	; Object $F7 - OBJ_BATTLE_CTL
	.byte OA4_KA_STANDARD	; Object $F8
	.byte OA4_KA_STANDARD	; Object $F9
	.byte OA4_KA_STANDARD	; Object $FA
	.byte OA4_KA_STANDARD	; Object $FB
	.byte OA4_KA_STANDARD	; Object $FC
	.byte OA4_KA_STANDARD	; Object $FD
	.byte OA4_KA_STANDARD	; Object $FE
	.byte OA4_KA_STANDARD	; Object $FF


	; Object group Extended (i.e. objects starting at ID $E0) pattern index starts
	; These are used for all states except "normal"

OGE_POff .func (\1 - ObjectGrExt_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- necessary in this bank due to short count
ObjectGrExt_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OGE_POff(ObjPE0), OGE_POff(ObjPE1), OGE_POff(ObjPE2), OGE_POff(ObjPE3)
	.byte OGE_POff(ObjPE4), OGE_POff(ObjPE5), OGE_POff(ObjPE6), OGE_POff(ObjPE7)
	.byte OGE_POff(ObjPE8), OGE_POff(ObjPE9), OGE_POff(ObjPEA), OGE_POff(ObjPEB)
	.byte OGE_POff(ObjPEC), OGE_POff(ObjPED), OGE_POff(ObjPEE), OGE_POff(ObjPEF)
	.byte OGE_POff(ObjPF0), OGE_POff(ObjPF1), OGE_POff(ObjPF2), OGE_POff(ObjPF3)
	.byte OGE_POff(ObjPF4), OGE_POff(ObjPF5), OGE_POff(ObjPF6), OGE_POff(ObjPF7)
	.byte OGE_POff(ObjPF8), OGE_POff(ObjPF9), OGE_POff(ObjPFA), OGE_POff(ObjPFB)
	.byte OGE_POff(ObjPFC), OGE_POff(ObjPFD), OGE_POff(ObjPFE), OGE_POff(ObjPFF)
	
	; NOT USABLE
	.byte OGE_POff(ObjPFF), OGE_POff(ObjPFF), OGE_POff(ObjPFF), OGE_POff(ObjPFF)

	; Object group Extended (i.e. objects starting at ID $E0) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGrExt_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- necessary in this bank due to short count
ObjectGrExt_PatternSets:
	; (End restricted alignment space)
ObjPE0:
	.byte $C1, $C3, $C5, $C7	; Walk 1
	.byte $CD, $CF, $D1, $D3	; Walk 2
	.byte $DD, $DF, $E1, $E3	; Hurt
	.byte $C1, $C3, $C5, $D9	; Throw

ObjPE1:
	; Bowser Jr's faces only
	.byte $C1, $C3
	.byte $C5, $C7
	.byte $C9, $CB
ObjPE2:

WartPats_Eyes:
	; Wart normal eyes
	.byte $A9, $AB, $AD, $AF

	; Wart gagging eyes
	.byte $B9, $BB, $BD, $BF

WartPats_Mouth:
	; Wart closed mouth
	.byte $89, $8B, $8D, $8F

	; Wart open mouth
	.byte $99, $9B, $9D, $9F

WartPats_LeftFoot:
	; Left foot up
	.byte $A1, $A3
	
	; Left foot down
	.byte $B1, $B3
	
WartPats_RightFoot:
	; Right foot up
	.byte $A5, $A7
	
	; Rightfoot down
	.byte $B5, $B7

WartPats_Backside:
	.byte $93, $95, $97

ObjPE6:	
Yoshi_Trunks:
	.byte $81, $83	; 0 - Standing
	.byte $85, $87	; 1 - Walk 1
	.byte $89, $8B	; 2 - Walk 2
	.byte $8D, $8F	; 3 - Jump
	.byte $91, $93	; 4 - Tounge lurch
	
Yoshi_Heads:
	.byte $95, $97	; 0 - Normal
	.byte $99, $9B	; 1 - Jump / scared
	.byte $9D, $9F	; 2 - Mouth full
	.byte $A1, $A3	; 3 - Tounge out

Yoshi_Tounge:
	.byte $A5, $A7

	
ObjPE3:
ObjPE4:
ObjPE5:
ObjPE7:
	.byte $99, $99, $BB, $BB
ObjPE8:
	.byte $81, $83, $85, $87, $89, $8B, $8D, $8F, $81, $83, $85, $87
	
Player_PlatBegin:
	.byte $91, $93
ObjPE9:
ObjPEA:
	.byte $F1, $F3, $F5, $F7, $F9, $FB, $FD, $FF
ObjPEC:
	.byte $81, $83, $85, $87, $81, $83
ObjPEB:	
	.byte $91, $93, $95, $97, $99, $9B, $99, $9B, $99, $9B, $99, $9B
ObjPEE:
	.byte $81, $83, $91, $93, $87, $89, $97, $99, $87, $89, $97, $99
	
Totomesu_Rump:
	.byte $95, $8D, $9B, $8F, $9B, $8F

ObjPED:
ObjPEF:
	.byte $B1, $B3	; Mouth closed
	.byte $B5, $B7	; Mouth open
	.byte $B9, $BB	; Mouth gasp
	.byte $BD, $BF	; :(
	
Clyde_Body:
	.byte $A1, $A3, $A5, $A7, $A5, $A9
	
ObjPF0:
	.byte $81, $83, $85, $87, $89, $8B, $8D, $8F

ObjPF1:
	.byte $91, $93, $A1, $A3
	.byte $95, $97, $A5, $A7
	.byte $99, $9B, $A9, $AB
	
ObjPF2:
ObjPF3:
	.byte $71, $71, $85, $87
	.byte $71, $71, $89, $8B
	.byte $81, $83, $91, $93

ObjPF4:
ObjPF5:
	.byte $71, $C1, $C3, $C5, $C7, $71
	.byte $71, $D1, $D3, $D5, $D7, $71

	.byte $E1, $E3, $E5, $E7, $E9, $EB
	.byte $F1, $F3, $F5, $F7, $F9, $FB

ObjPF6:
	.byte $C9, $CB, $CD, $CF, $D9, $DB, $DD, $DF

ObjPF7:
ObjPF8:	
ObjPF9:
ObjPFA:
ObjPFB:
ObjPFC:
ObjPFD:
ObjPFE:
ObjPFF:

ObjInit_Mouser:
	JMP_THUNKA 42, ObjInit_Mouser42

Misc_FlipTowardsPlayer:	.byte SPR_HFLIP, $00

ObjNorm_Mouser:
	JMP_THUNKA 42, ObjNorm_Mouser42


	; Since Mouser needs an extra set of 8x16s on his right side...
Mouser_RightSprites:
	.byte $C9, $CB
	.byte $D5, $D7
	.byte $E5, $E7
	.byte $C9, $DB

Mouser_SprXOff:		.byte 16, -8	; +16 normally (as right sprite) or -8 if h-flipped (as left sprite)

Mouser_Draw:
	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of Mouser's sprites
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of Mouser's sprites

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ Mouser_NoHFlip	; If Mouser is not horizontally flipped, jump to Mouser_NoHFlip

	; To draw flipped, we need to move the "big" part of the Mouser sprite over by 8
	; To make sure it's syncing up with the horizontal vis checks, we'll shift the X
	; over AND rotate the bits over, preserving carry so we can get that back later.
	LDA Objects_X,X
	ADD #8
	STA Objects_X,X

	; Roll and save carry (will use vis checks for sprite column 2 and 3 instead of 1 and 2)
	ROL Objects_SprHVis,X
	PHP	; Save carry

Mouser_NoHFlip:

	JSR Object_Draw16x32Sprite

	; After the initial 16x32
	LDA Object_SprRAM,X
	ADD #16
	TAY

	; By default, make right-most sprites invisible; use $F8 hiding value
	LDA #$F8
	STA Sprite_RAM+$00,Y	; Top Right 
	STA Sprite_RAM+$04,Y	; Bottom Right

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ Mouser_NoHFlip2	; If Mouser is not horizontally flipped, jump to Mouser_NoHFlip

	; Undo the +8 we did earlier, restore the carry which we can use to determine visibility
	LDA Objects_X,X
	SUB #8
	STA Objects_X,X

	PLP	; Restore carry
	BCC Mouser_SprRightOK	; If sprite is not invisible, jump to Mouser_SprRightOK
	BCS Mouser_SprCont	; Otherwise, jump to Mouser_SprCont

Mouser_NoHFlip2:
	LDA Objects_SprHVis,X
	AND #%00100000
	BNE Mouser_SprCont	; If right-most sprite is invisible, jump to Mouser_SprCont

Mouser_SprRightOK:

	; If top sprite is invisible, bottom one is too, so do nothing
	LDA Objects_SprVVis,X
	AND #2
	BNE Mouser_SprCont	; If top sprite is invisible, both are invisible; jump to Mouser_SprCont

	; Set Y (normal)
	LDA Objects_SpriteY,X
	STA Sprite_RAM+$00,Y	; Top Right 

	LDA Objects_SprVVis,X
	AND #1
	BNE Mouser_SprCont	; If bottom sprite is invisible, jump to Mouser_SprCont

	LDA Objects_SpriteY,X
	ADD #16
	STA Sprite_RAM+$04,Y	; Bottom Right

Mouser_SprCont:
	; Pattern
	
	LDA Objects_Frame,X
	ASL A	; Two patterns per frame
	TAX
	
	LDA Mouser_RightSprites,X
	STA Sprite_RAM+$01,Y	
	LDA Mouser_RightSprites+1,X
	STA Sprite_RAM+$05,Y

	; Copy attributes
	LDA Sprite_RAM-$06,Y
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	; X = 1 if h-flipped, 0 if not
	AND #SPR_HFLIP
	ROL A
	ROL A
	ROL A
	TAX

	; Set X
	LDA Sprite_RAM-$0D,Y	; Left edge sprite X
	ADD Mouser_SprXOff,X
	STA Sprite_RAM+$03,Y	; top right
	STA Sprite_RAM+$07,Y	; bottom right

	; Pattern offsets

	; -$0F, -$0B, $01
	; -$07, -$03, $05

	LDX <SlotIndexBackup		 ; X = object slot index

	; If Mouser is vertically flipped, need to switch the additional sprites' patterns
	LDA Objects_FlipBits,X
	BPL Mouser_NoVFlip

	LDA Sprite_RAM+$01,Y
	PHA

	LDA Sprite_RAM+$05,Y
	STA Sprite_RAM+$01,Y

	PLA
	STA Sprite_RAM+$05,Y
	
Mouser_NoVFlip:
	RTS


ObjInit_BowserJr:
	JMP_THUNKA 42, ObjInit_BowserJr42

ObjNorm_BowserJr:
	JMP_THUNKA 42, ObjNorm_BowserJr42

	; Need to thunk because his attributes are on 41
BowserJr_DoVisChecks:
	JSR Object_DetermineHorzVis	
	JSR Object_DetermineVertVis
	JMP Object_CalcSpriteXY_NoHi


	; This just enables use of ObjectGrExt_PatternSets
BowserJr_DrawHead:
	JSR Object_ShakeAndCalcSprite

	LDA <Temp_Var4
	AND #~SPR_PAL3
	ORA #SPR_PAL1
	STA <Temp_Var4

	; Use last two standard sprites
	TYA
	ADD #(4 * 4)
	TAY

	JMP Object_Draw16x16Sprite


Wart_Draw16x16:
	LDA #2
	STA <Temp_Var1
	BNE Wart_DrawEntry

Wart_Draw32x16:

	LDA #4
	STA <Temp_Var1

Wart_DrawEntry:
	JSR Wart_DrawInit

WartDraw32x16_Loop:
	; Store Y
	LDA <Temp_Var2
	STA Sprite_RAM+$00,Y
	
	; Store pattern
	LDA ObjPE2,X	; Get next pattern
	STA Sprite_RAM+$01,Y
	
	; Store attributes
	LDA <Temp_Var3
	STA Sprite_RAM+$02,Y
	
	; Store X
	LDA <Temp_Var4
	STA Sprite_RAM+$03,Y
	
	; +8 for next sprite
	ADD #8
	STA <Temp_Var4
		
	; Next sprite!
	INY
	INY
	INY
	INY
	
	; Next pattern!
	INX

	DEC <Temp_Var1		; Temp_Var1--
	BNE WartDraw32x16_Loop	; While Temp_Var1 > 0, loop!

	RTS

Wart_DrawInit:
	; Backup 'X'
	TXA
	PHA
	
	; Get sprite Y/Attr/X -> Temp_Var2/3/4
	LDX <SlotIndexBackup
	LDA <Objects_SpriteY,X
	STA <Temp_Var2

	LDA <Objects_Var5,X
	CMP #5
	BNE Wart_DrawInit_NoCycle

	LDA Objects_Var6,X
	BEQ Wart_DrawInit_NoCycle
	
	AND #3
	BPL Wart_DrawInit_Cycle	; Jump (technically always) to Wart_DrawInit_NoCycle
	
Wart_DrawInit_NoCycle:
	LDA Objects_SprAttr,X
	
Wart_DrawInit_Cycle:
	ORA Objects_FlipBits,X
	STA <Temp_Var3
	
	LDA <Objects_SpriteX,X
	STA <Temp_Var4
	
	; Restore 'X'
	PLA
	TAX
	
	RTS


Wart_DrawBackside:
	LDA #3
	STA <Temp_Var1
	
	JSR Wart_DrawInit
	
	LDX #(WartPats_Backside - ObjPE2)
Wart_DrawBackside_Loop:
	; Store Y
	LDA <Temp_Var2
	STA Sprite_RAM+$00,Y

	; +16 for next sprite
	ADD #16
	STA <Temp_Var2

	; Store pattern
	LDA ObjPE2,X	; Get next pattern
	STA Sprite_RAM+$01,Y
	
	; Store attributes
	LDA <Temp_Var3
	STA Sprite_RAM+$02,Y
	
	; Store X
	LDA <Temp_Var4
	ADD #32
	STA Sprite_RAM+$03,Y
			
	; Next sprite!
	INY
	INY
	INY
	INY
	
	; Next pattern!
	INX

	DEC <Temp_Var1	; Temp_Var1--
	BNE Wart_DrawBackside_Loop	; While Temp_Var1 > 0, loop!

	LDX <SlotIndexBackup
	RTS

ObjInit_Wart:
	LDA #2
	STA Objects_HitCount,X
		
	RTS

ObjNorm_Wart:
	JMP_THUNKA 42, ObjNorm_Wart42

Wart_Draw:
	; Bear in mind that Bowser Jr is already stealing Wart's default
	; last 2 sprites...

	; 32x16 makes up eyes (4 sprites)	Object + 1
	; 32x16 makes up body (4 sprites)	Object + 2
	; 16x16 block that makes "left" foot (2 sprites)	Object + 1 ender
	; 16x16 block that makes "right" foot (2 sprites)	Object + 2 ender
	; 8x48 makes up rest (3 sprites)	Object + 0

	JSR Object_ShakeAndCalcSprite
	JSR Wart_DrawBackside

	JSR Object_ShakeAndCalcSprite
	
	; Object +1 sprites
	LDA #0
	JSR Object_StealAdjSprite

	; Draw Wart's eyes
	LDX <SlotIndexBackup

	LDA Objects_Var1,X
	ASL A
	ASL A
	ADD #(WartPats_Eyes - ObjPE2)
	TAX
	JSR Wart_Draw32x16


	; Left foot
	LDX <SlotIndexBackup
	
	; Feet appear at +32
	LDA <Objects_SpriteY,X
	ADD #32
	STA <Objects_SpriteY,X
	
	LDA Objects_Var3,X
	ASL A
	ADD #(WartPats_LeftFoot - ObjPE2)
	TAX
	JSR Wart_Draw16x16

	LDX <SlotIndexBackup

	; Mouth appears at -16
	LDA <Objects_SpriteY,X
	SUB #16
	STA <Objects_SpriteY,X

	; Object +2 sprites
	LDA #1
	JSR Object_StealAdjSprite
		
	; Draw Wart's mouth
	LDX <SlotIndexBackup
	
	LDA Objects_Var2,X
	ASL A
	ASL A
	ADD #(WartPats_Mouth - ObjPE2)
	TAX
	JSR Wart_Draw32x16

	; Right feet
	LDX <SlotIndexBackup

	; Feet appear at +16Y / +16X
	LDA <Objects_SpriteY,X
	ADD #16
	STA <Objects_SpriteY,X
	LDA <Objects_SpriteX,X
	ADD #16
	STA <Objects_SpriteX,X

	; Right foot
	LDA <Objects_Var4,X
	ASL A
	ADD #(WartPats_RightFoot - ObjPE2)
	TAX
	JSR Wart_Draw16x16


	LDX <SlotIndexBackup
	
	LDA <Objects_Var5,X
	CMP #5
	BGE Wart_Untouchable
	
	; Need to call this again to normalize detection
	JSR Object_ShakeAndCalcSprite
	LDX <SlotIndexBackup
		
	RTS

Wart_Untouchable:
	; Deliberately prevent Wart from being touched right now
	LDA #255
	STA Objects_SpriteX,X
	STA Objects_SpriteY,X
	RTS


ObjInit_Boomer:
	JSR PrepareNewObjectOrAbort
	
	LDA #OBJ_BOSS_BOWSERJR
	STA Level_ObjectID,X
	
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDA #SPR_PAL2
	STA Objects_SprAttr,X

	LDA #2
	STA Objects_Var6,X

	; Push Boomer's index to Bowser Jr
	LDA <SlotIndexBackup
	STA Objects_Var3,X

	TXA		; Jr's index -> 'A'
		
	LDX <SlotIndexBackup	; Restore Boomer's index

	STA Objects_Var10,X	; Jr's index -> Var8

	JSR Boomer_LockBowserJr

	LDA #140
	STA Objects_Timer,X
	STA Player_HaltTick

	LDA #142	; Boomer graphics!
	BNE ObjInit_BigBooBoomer_Cont	; Jump (technically always) to ObjInit_BigBooBoomer_Cont
	
ObjInit_BigBoo:
	LDA #64

ObjInit_BigBooBoomer_Cont:
	STA PatTable_BankSel	; Big Boo / Boomer graphics!

	; Set Player_PartDetEn (detect bottom 2 rows of tiles when Player Y >= 160)
	LDA #$01
	STA Player_PartDetEn

	; Enable display of 32 pixel partition and show sprites beneath the partition
	LDA #(UPDATERASTER_32PIXPART | UPDATERASTER_32PIXSHOWSPR)
	STA Update_Request	; Set Update_Request

	; No handle on a Para-Drybones yet
	LDA #$FF
	STA Objects_Var3,X

	; Backup starting X/Y
	LDA <Objects_X,X
	STA Objects_Var6,X
	
	LDA <Objects_Y,X
	STA Objects_Var7,X

	LDA #3
	STA Objects_HitCount,X

	RTS
	
BigBoo_YVelAccel:	.byte $01, -$01
BigBoo_YVelLimit:	.byte $10, -$10	
BigBoo_XVelAccel:	.byte -$01, $01
BigBoo_XVelLimit:	.byte -$08, $08

BigBoo_PatTables:	.byte 68, 64

ObjNorm_BigBoo:

	LDA <Objects_Var4,X
	BEQ BigBoo_Normal
	JMP BigBoo_GotHit

BigBoo_Normal:
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE BigBoo_NotDying	; If not dying, jump to Birdo_NotDying

	; Kill off frozen PDB
	LDY Objects_Var3,X
	LDA #OBJSTATE_KILLED
	STA Objects_State,Y

	LDA #OBJSTATE_NORMAL
	STA Objects_State,X
	
	; Hit state
	INC <Objects_Var4,X

	; Check if dead yet...
	DEC Objects_HitCount,X
	BNE BigBoo_NotDeadYet

	; Dead!
	INC <Objects_Var4,X

	JSR_THUNKA 42, Boss_DestroyOtherObjects

	LDA #1
	STA Level_TimerEn

	LDA #-$20
	STA <Objects_YVel,X
	LDA #0
	STA <Objects_XVel,X

BigBoo_NotDeadYet:
	JMP BigBoo_GotHit

BigBoo_NotDying:
	LDA <Counter_1
	AND #$03
	BNE BigBoo_NoChange

	; Var1 is vertical float direction
	LDY Objects_Var1,X
	LDA BigBoo_YVelAccel,Y
	ADD <Objects_YVel,X
	STA <Objects_YVel,X
	
	CMP BigBoo_YVelLimit,Y
	BNE BigBoo_NotYVelLimit		; If Big Boo hasn't hit his Y velocity limit yet, jump to BigBoo_NotYVelLimit
	
	; Reverse direction!
	TYA
	EOR #1
	STA Objects_Var1,X
	
BigBoo_NotYVelLimit:

	; Var2 is horizontal float direction
	LDY Objects_Var2,X
	LDA <Objects_XVel,X
	CMP BigBoo_XVelLimit,Y
	BEQ BigBoo_XVelLimitHit		; If Big Boo hit his Y velocity limit yet, jump to BigBoo_XVelLimitHit

	ADD BigBoo_XVelAccel,Y
	STA <Objects_XVel,X
	
BigBoo_XVelLimitHit:

	TYA
	BNE BigBoo_RightwardCheck
	
	; Big Boo leftward check...
	LDA <Objects_X,X
	CMP #$10
	BLT BigBoo_ReverseDirection		; If Big Boo has gone too far left, jump to BigBoo_ReverseDirection
	BGE BigBoo_NoChange				; Otherwise, jump to BigBoo_NoChange
	
BigBoo_RightwardCheck:
	LDA <Objects_X,X
	CMP #$B8
	BLT BigBoo_NoChange		; If Big Boo hasn't gone too far right, jump to BigBoo_NoChange

BigBoo_ReverseDirection:
	TYA
	EOR #1
	STA Objects_Var2,X
	

BigBoo_NoChange:
	JSR BigBoo_Common

	LDA BigBoo_PatTables,Y
	STA PatTable_BankSel	; Big Boo graphics!

	LDA <Objects_Var4,X
	BNE BigBoo_DontHurt

	LDA <Counter_1
	AND #$7F
	BNE BigBoo_NoPengCheck	; Only creating penguin suits every so often...

	JSR BigBoo_SpawnPenguinSuit	; Also spawn a penguin suit if the Player needs it

BigBoo_NoPengCheck:

	; Check the health of our Para-Drybones
	LDY Objects_Var3,X
	BMI BigBoo_PDB_Spawn	; If we don't have a handle on a Para-Drybones, create one!
	
	LDA Objects_State,Y
	CMP #OBJSTATE_NORMAL
	BEQ BigBoo_ParaDrybonesFlinger	; If our Para-Drybones is alive and well, jump to BigBoo_ParaDrybonesFlinger

BigBoo_PDB_Spawn:
	LDA <Counter_1
	AND #$7F
	BNE BigBoo_NoParaDBCheck	; Only creating Para-Drybones every so often...

	JSR BigBoo_SpawnPenguinSuit	; Also spawn a penguin suit if the Player needs it

	; If we get here, no living Para-Drybones was found!
	JSR BigBoo_SpawnParaDrybones	; ... so create a new one!

BigBoo_ParaDrybonesFlinger:
	LDA Objects_Var3,X		; Act on behalf of the PDB
	TAX
	
	LDA Objects_FrozenTimer,X
	BNE BigBoo_PDB_Frozen	; Don't move if frozen!

	LDY <SlotIndexBackup
	LDA Level_ObjectID,Y
	CMP #OBJ_BOSS_BIGBOO3
	BNE BigBoo_PDB_Frozen	; Only Big Boo 3, with paradrybones, needs to manually move him

	LDA Level_ObjectID,X
	CMP #OBJ_PARADRYBONES
	BNE BigBoo_PDB_Frozen	; Only need to boost Para-Drybones, nothing else!
	
	LDA #$10
	STA <Objects_XVel,X
	
	JSR Object_ApplyXVel	; Normally PDB doesn't use X velocity
	
BigBoo_PDB_Frozen:
	JSR Object_DeleteOffScreen
	LDX <SlotIndexBackup
	

BigBoo_NoParaDBCheck:
	; Needed for object detection...
	JSR Object_CalcSpriteXY_NoHi	
	JSR Object_HandleBumpUnderneath

BigBoo_DontHurt:
	RTS
	
BigBoo_Common:
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel

	; Big Boo Y Tracking
	LDA #$90
	SUB <Objects_Y,X
	STA Vert_Scroll_Off
	
	; Big Boo X Tracking
	LDA #$C0
	SUB <Objects_X,X
	STA Horz_Scroll_Off32PP

	LDA <Objects_X,X
	PHA
	ADD #32
	STA <Objects_X,X
	LDA <Objects_XHi,X
	PHA
	ADC #0
	STA <Objects_XHi,X

	JSR Level_ObjCalcXDiffs
	
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X
	RTS
	
	
BigBoo_SpawnParaDrybones:
	TXA
	TAY		; Big Boo's ID -> 'Y'
	
	JSR PrepareNewObjectOrAbort
		
	LDA Level_ObjectID,Y
	CMP #OBJ_BOSS_BIGBOO3
	BEQ BigBoo_SpawnPDB
		
	; Big Boo 1 or 2
	LDA #$84
	STA <Objects_Y,X
	
	LDA #OBJ_DRYBONES
	STA Level_ObjectID,X
	BNE BigBoo_SpawnCont	; Jump (technically always) to BigBoo_SpawnCont
	
BigBoo_SpawnPDB:
	; Big Boo 3 only
	LDA #$70
	STA <Objects_Y,X

	LDA #OBJ_PARADRYBONES
	STA Level_ObjectID,X

	; This Para-Drybones comes flying by
	LDA #$10
	STA <Objects_XVel,X
	
BigBoo_SpawnCont:
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X
	
	LDA #0
	STA <Objects_X,X
	STA <Objects_XHi,X
	
	LDA #1
	STA <Objects_YHi,X

	LDA #SPR_PAL2
	STA Objects_SprAttr,X
	
	; Regular Dry Bones needs facing info
	LDA #SPR_HFLIP
	STA Objects_FlipBits,X
	
	TXA		; X -> A ... we'll be storing a handle
	
	LDX <SlotIndexBackup	
	
	; Store a handle to this Para-Drybones
	STA Objects_Var3,X
		
	RTS


BigBoo_Dying:

	LDA <Objects_YHi,X
	BEQ BigBoo_StillDying
	LDA <Objects_Y,X
	CMP #$A0
	BGE BigBoo_Dead

BigBoo_StillDying:
	INC <Objects_YVel,X

	RTS

BigBoo_Dead:
	LDA <Objects_Var4,X
	CMP #3
	BEQ BigBoo_DeadCont
	CMP #4
	BEQ BigBoo_DeadFinish 

	LDA World_Num
	CMP #9
	BEQ BigBoo_NoFanfare	; World zero, no fanfare

	; Victory fanfare
	LDA Sound_QMusic1
	ORA #MUS1_BOSSVICTORY
	STA Sound_QMusic1

BigBoo_NoFanfare:
	; Halt vertical drop
	LDA #0
	STA <Objects_YVel,X
	
	; Only do this setup once
	INC <Objects_Var4,X
	BNE BigBoo_StillTimering
	
BigBoo_DeadCont:

	JSR DoTimeBonus	 ; Convert remaining time into score
	BNE BigBoo_StillTimering	 ; If not done converting, jump to PRG003_A910 (RTS)

	; Set timer to $40
	LDA #$40
	STA Objects_Var1,X
	
	INC <Objects_Var4,X

BigBoo_StillTimering:
	RTS
	
BigBoo_DeadFinish:
	LDA Level_ObjectID,X
	CMP #OBJ_BOSS_BIGBOO3
	BEQ BigBoo_EndWorld

	JMP Totomesu_DeadTimeout

BigBoo_EndWorld:
	JMP_THUNKC 30, Object_TriggerEndWorld


BigBoo_GotHit:
	JSR BigBoo_NoChange

	; Prevent further hits
	LDA #$FF
	STA <Objects_SpriteX,X
	STA <Objects_SpriteY,X

	LDA PatTable_BankSel
	ORA #2
	STA PatTable_BankSel

	LDA <Objects_Var4,X
	CMP #2
	BGE BigBoo_Dying

	LDA #0
	STA <Objects_XVel,X		; Halt X velocity
	STA <Objects_YVel,X		; Halt Y velocity
	STA Objects_Var1,X		; Reset direction
	STA Objects_Var2,X		; Reset direction

	LDA <Objects_X,X
	CMP Objects_Var6,X
	BLT BigBoo_ReturnR
	BEQ BigBoo_NoReturnLR
		
	; Return leftward
	DEC <Objects_X,X
	JMP BigBoo_NoReturnLR
	
BigBoo_ReturnR:
	INC <Objects_X,X
	
BigBoo_NoReturnLR:

	LDA <Objects_Y,X
	CMP Objects_Var7,X
	BLT BigBoo_VReturnR
	BEQ BigBoo_NoVReturnLR
		
	; Return leftward
	DEC <Objects_Y,X
	JMP BigBoo_NoVReturnLR
	
BigBoo_VReturnR:
	INC <Objects_Y,X
	
BigBoo_NoVReturnLR:

	LDA <Objects_X,X
	CMP Objects_Var6,X
	BNE BigBoo_NotHome	; Big Boo isn't back in position, jump to BigBoo_NotHome

	LDA <Objects_Y,X
	CMP Objects_Var7,X
	BNE BigBoo_NotHome	; Big Boo isn't back in position, jump to BigBoo_NotHome
	
	; Big Boo is back in home position... 
	LDY Objects_Timer,X
	BNE BigBoo_TimerRunning
		
	LDA #$80
	STA Objects_Timer,X
	TAY
	
BigBoo_TimerRunning:
	CPY #40
	BGE BigBoo_NotWavingYet

	TYA
	AND #8
	BNE BigBoo_NotWavingYet
	
	LDA PatTable_BankSel
	AND #~2
	STA PatTable_BankSel
	
	
BigBoo_NotWavingYet:
	CPY #1
	BNE BigBoo_NotHome
		
	; Timer expired!  Back to flying around!
	DEC <Objects_Var4,X

	; Clear old PDB handle
	LDA #$FF
	STA Objects_Var3,X
	
	LDA Level_ObjectID,X
	CMP #OBJ_BOSS_BIGBOO1
	BEQ BigBoo_NotHome		; Big Boo 1 does not spawn a buddy
	
	; Spawn a buddy!
	JSR BigBoo_SpawnBuddy
	LDX <SlotIndexBackup
	
BigBoo_NotHome:
	RTS
	

BigBoo_SpawnBuddy:
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

	JSR PrepareNewObjectOrAbort

	LDA RandomN
	AND #$7F
	ADD #32
	STA <Objects_X,X
	LDA #0
	STA <Objects_XHi,X
	
	LDA #$20
	STA <Objects_Y,X
	LDA #1
	STA <Objects_YHi,X
	
	LDA #OBJ_BOO
	STA Level_ObjectID,X

	LDA #SPR_PAL1
	STA Objects_SprAttr,X

	JSR Object_DetermineHorzVis
	JSR Object_DetermineVertVis
	JSR SpecialObj_FindEmptyAbort	 

	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y

	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; A "poof"
	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y

	; Poof counter"
	LDA #$17
	STA SpecialObj_Data,Y

	RTS
	
BigBoo_SpawnPenguinSuit:
	LDA <Player_Suit
	CMP #PLAYERSUIT_PENGUIN
	BEQ BigBoo_SPS_DoNothing

	LDY #4
BigBoo_PS_Loop:
	LDA Objects_State,Y
	CMP #OBJSTATE_NORMAL
	BNE BigBoo_PS_Loop_NotPS
	
	LDA Level_ObjectID,Y
	CMP #OBJ_POWERUP_STARMAN
	BNE BigBoo_PS_Loop_NotPS
	
	; Living penguin suit still exists; do nothing
BigBoo_SPS_DoNothing:
	RTS
	
BigBoo_PS_Loop_NotPS:
	DEY
	BPL BigBoo_PS_Loop
	
	; Need a penguin suit!
	JSR PrepareNewObjectOrAbort

	INC Objects_Frame,X
	INC Objects_Frame,X

	LDA #$78
	STA <Objects_X,X
	LDA #0
	STA <Objects_XHi,X
	
	LDA #$90
	STA <Objects_Y,X
	LDA #1
	STA <Objects_YHi,X
	
	LDA #-$40
	STA <Objects_YVel,X	
	
	LDA #OBJ_POWERUP_STARMAN
	STA Level_ObjectID,X

	LDA #(SPR_PAL2 | SPR_BEHINDBG)
	STA Objects_SprAttr,X
	
	LDX <SlotIndexBackup
	
	RTS


Boomer_PatTables:	.byte 142, 140

Boomer_LockBowserJr:
	LDY Objects_Var10,X
	
	LDA <Objects_X,X
	ADD #20
	STA Objects_X,Y
	LDA <Objects_XHi,X
	ADC #0
	STA Objects_XHi,Y
	
	LDA <Objects_Y,X
	SUB #24
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	SBC #0
	STA Objects_YHi,Y

	RTS

ObjNorm_Boomer:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ Boomer_DoNormal

	; Boomer died...
	LDA <Objects_Var4,X
	CMP #2
	BGE Boomer_DoNormal	; If Boomer is in a dying state, jump to Boomer_Normal
	
	; Start death state
	LDA #2
	STA <Objects_Var4,X
	
Boomer_DoNormal:
	JSR Boomer_LockBowserJr

	LDA <Objects_Var4,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Boomer_Intro	; 0
	.word Boomer_Normal	; 1
	.word Boomer_Dying	; 2

Boomer_Intro:
	LDA #-$08
	STA <Objects_YVel,X

	JSR BigBoo_Common
	
	LDA Boomer_PatTables+1
	STA PatTable_BankSel
	
	LDA Objects_Timer,X
	BNE Boomer_StillRising
	
	LDA #0
	STA <Objects_YVel,X
	
	INC <Objects_Var4,X
	
Boomer_StillRising:

	RTS

; Cannon offsets
Boomer_FireDelay:	.byte 20,160
Boomer_FireOffsetX:	.byte 48,16, 0, 32	; First half for facing right, second half facing left
Boomer_FireOffsetY:	.byte 16, 18
Boomer_FireXVel:	.byte $18, -$18
Boomer_FireSprAttr:	.byte SPR_PAL3 | SPR_HFLIP, SPR_PAL3

Boomer_YVelLimit:	.byte $12, -$12
Boomer_YVelDelta:	.byte $01, -$01
Boomer_XVelLimit:	.byte -$20, $20
Boomer_XVelDelta:	.byte -$01, $01

Boomer_BJr_FlipDir:	.byte SPR_HFLIP, 0

Boomer_Normal:
	;LDA Objects_ColorCycle,X
	;BNE Boomer_NotHit

	; A little manual implementation of hit testing... don't want to hurt Player, just be stompable
	;LDA <Player_YVel
	;BMI Boomer_NotHit	; If Player moving upward, jump to Boomer_NotHit

	;JSR Object_HitTest
	;BCC Boomer_NotHit	; If Player is not colliding with the object, jump to Boomer_NotHit

	;JSR Object_CalcCoarseYDiff
	;LDA <Temp_Var15
	;SUB #12
	;CMP #4
	;BGE Boomer_NotHit	; Not in stompable range, jump to Boomer_NotHit
	
	;DEC Objects_HitCount,X
	;BPL Boomer_NotDead
	
	; Boomer's dead...
	;LDA #OBJSTATE_KILLED
	;STA Objects_State,X
	
;Boomer_NotDead:
	; Play squish sound
	;LDA Sound_QPlayer
	;ORA #SND_PLAYERSWIM
	;STA Sound_QPlayer

	; Player Y Vel = -$30 (bounce off)
	;LDA #-$30
	;STA <Player_YVel

	;LDA #$40
	;STA Objects_ColorCycle,X
	
;Boomer_NotHit:
	JSR BigBoo_Common

	LDA Boomer_PatTables,Y
	STA PatTable_BankSel	; Boomer graphics!
	
	; Flip Bowser Jr as appropriate
	TYA
	PHA
	
	; Flip Bowser Jr the right way, assuming he's not spinning out
	LDA Boomer_BJr_FlipDir,Y
	STA <Temp_Var3
	
	LDY Objects_Var10,X		; Get BJr's handle

	LDA Objects_Var5,Y
	BEQ BoomerBowserJr_NotSpinOut	; If Bowser Jr is not spinning out, don't force flip, jump to BoomerBowserJr_NotSpinOut

	; Spinning out ... last hit?
	LDA Objects_Var6,Y
	BNE BoomerJr_NotDefeated	; If not, jump to BoomerJr_NotDefeated
	
	LDA RandomN
	AND #7
	SUB #4
	ASL A
	ASL A
	STA <Objects_XVel,X
	
	LDA RandomN+1
	AND #7
	SUB #4
	ASL A
	ASL A
	STA <Objects_YVel,X
	
	PLA
	RTS
	
BoomerBowserJr_NotSpinOut:
	; Set flip
	LDA <Temp_Var3
	STA Objects_FlipBits,Y
	
BoomerJr_NotDefeated:
	PLA
	ASL A
	TAY
	STY <Temp_Var3	; Temp_Var3 = 2 if facing left, 0 if facing right

	LDA Objects_Timer,X
	BNE Boomer_FireWait

	LDY Objects_Var1,X
	
	; Fire from other side next time
	LDA Objects_Var1,X
	EOR #1
	STA Objects_Var1,X
	
	LDA Boomer_FireOffsetY,Y
	STA <Temp_Var2
	LDA Boomer_FireDelay,Y
	STA Objects_Timer,X

	TYA
	ADD <Temp_Var3
	TAY
	LDA Boomer_FireOffsetX,Y
	STA <Temp_Var1
		
	JSR Boomer_FireBullet
	LDX <SlotIndexBackup
	
Boomer_FireWait:
	LDA <Counter_1
	AND #1
	BNE Boomer_SkipVel
	
	LDY Objects_Var2,X	; Direction
	LDA <Objects_YVel,X
	CMP Boomer_YVelLimit,Y
	BNE Boomer_YAccel

	; Boomer needs to flip direction...
	TYA
	EOR #1
	STA Objects_Var2,X

Boomer_YAccel:
	LDA <Objects_YVel,X
	ADD Boomer_YVelDelta,Y
	STA <Objects_YVel,X

	LDY Objects_Var5,X	; Direction
	LDA <Objects_XVel,X
	CMP Boomer_XVelLimit,Y
	BNE Boomer_XAccel

	; Boomer needs to flip direction...
	TYA
	EOR #1
	STA Objects_Var5,X

Boomer_XAccel:
	LDA <Objects_XVel,X
	ADD Boomer_XVelDelta,Y
	STA <Objects_XVel,X

Boomer_SkipVel:
	RTS


Boomer_FireBullet:

	; Temp_Var3 will be transformed into appropriate X velocity
	; Temp_Var4 holds facing direction for Bullet Bill
	LDA <Temp_Var3
	LSR A			; 0/1 normalized
	TAY
	LDA Boomer_FireSprAttr,Y
	STA <Temp_Var4
	
	LDA Boomer_FireXVel,Y
	STA <Temp_Var3

	TXA
	TAY

	JSR PrepareNewObjectOrAbort
		
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1
	
	LDA #OBJ_BULLETBILL
	STA Level_ObjectID,X
	
	LDA <Temp_Var3
	STA <Objects_XVel,X
	
	LDA Objects_X,Y
	ADD <Temp_Var1
	STA <Objects_X,X
	LDA Objects_XHi,Y
	ADC #0
	STA <Objects_XHi,X
	
	LDA Objects_Y,Y
	ADD <Temp_Var2
	AND #$F0		; Tile-align
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	ADC #0
	STA <Objects_YHi,X

	LDA <Temp_Var4
	STA Objects_FlipBits,X
	
	; Flags for alternate patterns, Bowser Jr Compatible
	INC Objects_Var6,X

	; Don't needlessly fail to spawn poof
	; NOTE: Would be more technically correct to run vis checks, but this is a fixed use case...
	LDA #0
	STA Objects_SprHVis,X
	STA Objects_SprVVis,X

	JSR SpecialObj_FindEmptyAbort	 

	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y

	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; A "poof"
	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y

	; Poof counter"
	LDA #$17
	STA SpecialObj_Data,Y

	RTS		 ; Return


Boomer_Dying:
	LDA #0
	STA <Objects_XVel,X
	STA <Objects_YVel,X
	
	LDA <Objects_X,X
	ADD #24
	STA <Objects_X,X
	LDA <Objects_XHi,X
	ADC #0
	STA <Objects_XHi,X

	LDA <Objects_Y,X
	ADD #24
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	ADC #0
	STA <Objects_YHi,X

	; Recycle Boom Boom's cool effect
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1
	JSR_THUNKA 3, Explode_Stars

	; Destroy remaining Bullet Bills or anything else that might be there
	JSR_THUNKA 42, Boss_DestroyOtherObjects

	RTS


	; For flipped and not flipped
YoshiHead_XOffs:	
	.byte -10,  10, -15,  15
YoshiHead_XHiOffs:	
	.byte $FF, $00, $FF, $00

YoshiHead_YOffs:	.byte -16,  -4
YoshiHead_YHiOffs:	.byte $FF, $FF

Yoshi_WalkFrames: 	.byte 0, 1, 2, 1

	; List of object IDs that Yoshi will hold in his mouth and spit out
Yoshi_HoldObjectIDs:	.byte OBJ_GREENSHELL, OBJ_TWIRLINGBUZZY, OBJ_TWIRLINGSPINY, OBJ_GREENTROOPA, OBJ_REDTROOPA, OBJ_PARATROOPAGREENHOP, OBJ_FLYINGREDPARATROOPA, OBJ_BUZZYBEATLE, OBJ_SPINY
Yoshi_HoldObjectIDs_End

ObjInit_Yoshi:
	; If Daredevil comet is active, sorry, no Yoshi!
	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BEQ Yoshi_Delete

	; If Player is already on a Yoshi, delete this one.
	LDA Player_Kuribo
	BNE Yoshi_Delete

	; Otherwise if another Yoshi exists, delete this one!
	LDY #4
Yoshi_InitSeekLoop:
	CPY <SlotIndexBackup
	BEQ Yoshi_SeekNotYoshi	; Don't delete yourself, Yoshi

	LDA Objects_State,Y
	BEQ Yoshi_SeekNotYoshi	; If this object is dead/empty, jump to Yoshi_SeekNotYoshi
	
	LDA Level_ObjectID,Y
	CMP #OBJ_YOSHI
	BNE Yoshi_SeekNotYoshi	; If this object isn't Yoshi, jump to Yoshi_SeekNotYoshi

	; Found a Yoshi!
	BEQ Yoshi_Delete

Yoshi_SeekNotYoshi:
	DEY
	BPL Yoshi_InitSeekLoop
	BMI Yoshi_OKToExist	; If you get here, Yoshi can spawn
	
Yoshi_Delete:
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

Yoshi_OKToExist:
	RTS

ObjNorm_Yoshi:
	; Yoshi is USUALLY palette 2...
	LDA #SPR_PAL2
	STA Objects_Var10,X

	LDA Level_Tileset
	CMP #10
	BNE Yoshi_NotAirship

	LDA Player_RescuePrincess
	BMI Yoshi_NotAirship	; Also not on WZ ending
	
	; Dirty, dirty hack... use alternate bank on Airship (for BJr Boss)
	LDA #144
	STA PatTable_BankSel+4

	; Use palette 3 here instead!
	LDA #SPR_PAL3
	STA Objects_Var10,X

Yoshi_NotAirship:
	LDA <Player_HaltGame
	BNE Yoshi_Halted

	LDA <Objects_Var4,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Yoshi_WaitForPlayer	; 0 - Yoshi standing, waiting for Player
	.word Yoshi_Panic			; 1 - Yoshi panicking and running around, waiting for Player
	.word Yoshi_PlayerRide		; 2 - Player riding Yoshi
	.word Yoshi_PanicInit		; 3 - Initialize panic state
	.word Yoshi_PanicInit		; 4 - Initialize panic state (workaround for race condition somewhere when losing Yoshi sometimes...)

Yoshi_Halted:
	JMP Yoshi_Draw

YoshiPanic_XVel:	.byte -$18, $18

Yoshi_PanicInit:
	; Kick off Yoshi
	LDA <Player_YVel
	BMI LoseYoshi_Bump
	
	LDA #-$10
	BNE LoseYoshi_Force
	
LoseYoshi_Bump:
	SUB #-$10
	
LoseYoshi_Force:
	STA <Player_YVel

	; Set Yoshi to panic state
	LDA #1
	STA <Objects_Var4,X

	; Timer to make sure Player doesn't just re-catch Yoshi instantly
	LDA #30
	STA Objects_Timer,X
	

Yoshi_Panic:
	JSR Yoshi_WaitForPlayer	; Mostly the same stuff
	
	; Just run around at a constant rate
	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	ASL A
	ASL A
	ROL A
	TAY
	LDA YoshiPanic_XVel,Y
	STA <Objects_XVel,X
	
	LDA <Counter_1
	LSR A
	AND #$03
	TAY
	LDA Yoshi_WalkFrames,Y
	STA Objects_Var1,X
	
	RTS

Yoshi_WaitForPlayer:
	JSR Object_DeleteOffScreen_N4

	; Stay green!
	LDA Objects_Var10,X
	STA Objects_SprAttr,X
	
	LDA Objects_Var11,X
	BNE Yoshi_KeepSomethingInMouth	; If Yoshi has something in his mouth, don't lose it, jump to Yoshi_KeepSomethingInMouth
	
	; Nothing on tounge
	LDA #$FF
	STA Objects_Var6,X

Yoshi_KeepSomethingInMouth:
	JSR Yoshi_Draw

	JSR Object_Move
	
	LDA Objects_DetStat,X
	AND #4
	BEQ Yoshi_NotHitFloor

	; Hit floor
	JSR Object_HitGround
	
	LDA <Objects_Var4,X
	BNE Yoshi_NotHitFloor
	
	; State 0 only -- jump!
	LDA #-$10
	STA <Objects_YVel,X

Yoshi_NotHitFloor:

	LDA Objects_DetStat,X
	AND #3
	BEQ Yoshi_NotHitWall

	; Reverse direction!
	LDA <Objects_XVel,X
	NEG
	STA <Objects_XVel,X
	
	LDA Objects_FlipBits,X
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X

Yoshi_NotHitWall:
	LDA Objects_Var11,X
	BEQ Yoshi_NothingInMouth	; If Yoshi has nothing in his mouth, jump to Yoshi_NothingInMouth

	; Yoshi has something in his mouth, make sure it's shown
	LDA #2
	BNE Yoshi_SetHeadFrame	; Jump (technically always) to Yoshi_SetHeadFrame

Yoshi_NothingInMouth:

	; Normally just do a toggle between regular head and nose up
	LDA <Counter_1
	AND #$40
	ROL A
	ROL A
	ROL A
	
Yoshi_SetHeadFrame:
	STA Objects_Var2,X

	LDA <Player_YVel
	BMI Yoshi_NoPlayerTouch		; If Player is moving upward, jump to Yoshi_NoPlayerTouch
	BEQ Yoshi_NoPlayerTouch		; If Player is not vertically moving, jump to Yoshi_NoPlayerTouch

	; Player is moving downward...

	LDA Objects_Timer,X
	BNE Yoshi_NoPlayerTouch		; If timer is active, don't catch Yoshi...

	LDA Player_EndLevel
	BNE Yoshi_NoPlayerTouch		; If Player is at goal, don't let him catch Yoshi

	JSR Object_HitTest
	BCC Yoshi_NoPlayerTouch		; If Player didn't jump onto Yoshi's back, jump to Yoshi_NoPlayerTouch
		
	; Yoshi!
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer
	
	; Set Player_Kuribo with this object slot +1
	TXA
	ADD #1
	STA Player_Kuribo
	
	; Go to ride state
	LDA #2
	STA <Objects_Var4,X
	
Yoshi_NoPlayerTouch:

	; Slow down, Yoshi
	LDA <Objects_XVel,X
	BEQ Yoshi_Stopped
	BMI Yoshi_SlowNeg

	; Positive slowdown...
	SUB #$01
	BMI Yoshi_Stop
	BPL Yoshi_SpeedSet

Yoshi_SlowNeg:
	ADD #$01
	BPL Yoshi_Stop
	BMI Yoshi_SpeedSet

Yoshi_Stop:
	LDA #0
	
Yoshi_SpeedSet:
	STA <Objects_XVel,X

Yoshi_Stopped:
	RTS
	
Yoshi_PlayerRide:

	; Normal colors...
	LDA Objects_Var10,X
	STA Objects_SprAttr,X
	
	LDA Player_StarInv
	BEQ Yoshi_NotInv

	; Rotate~
	AND #$03
	STA Objects_SprAttr,X

Yoshi_NotInv:
	; If Player holds UP and pushes 'A', get off Yoshi!
	LDA Player_InWater
	BNE Yoshi_NoGetOff

	
	LDA <Pad_Holding
	AND #PAD_UP
	BEQ Yoshi_NoGetOff
	BIT <Pad_Input
	BPL Yoshi_NoGetOff
	
	LDA #-$30
	STA <Player_YVel

	LDA <Player_Y
	SUB #16
	STA <Player_Y
	LDA <Player_YHi
	SBC #0
	STA <Player_YHi

	LDA #0
	STA <Objects_Var4,X
	STA Player_Kuribo
	STA Objects_Var1,X
	STA Objects_Var2,X
	STA <Objects_Var5,X
	BNE Yoshi_NoGetOff
	JMP Yoshi_WaitForPlayer

Yoshi_NoGetOff:
	; Prevent Player from attacking  while on Yoshi
	INC Player_DisTailAtk

	; Lock Yoshi onto Player's X/Y
	LDA <Player_X
	STA <Objects_X,X
	LDA <Player_XHi
	STA <Objects_XHi,X
	LDA <Player_Y
	ADD #16
	STA <Objects_Y,X
	LDA <Player_YHi
	ADC #0
	STA <Objects_YHi,X

	LDA <Player_XVel
	STA <Objects_XVel,X
	LDA <Player_YVel
	STA <Objects_YVel,X

	; Follow flip direction of Player
	LDA <Player_FlipBits
	STA Objects_FlipBits,X

	; Add to leg animation based on Player movement, if any
	LDA <Objects_XVel,X
	BNE Yoshi_HMove
	
	; Yoshi not horizontally moving; zero out the legs
	LDA #0
	STA Objects_Var3,X
	BEQ Yoshi_NoHMove	; Jump (technically always) to Yoshi_NoHMove
	
Yoshi_HMove:
	; Use the velocity as a rapid addition
	BPL Yoshi_HMove_NotNeg
	
	; Absolute value!
	NEG
	
Yoshi_HMove_NotNeg:
	LSR A
	LSR A
	LSR A
	ADD Objects_Var3,X
	STA Objects_Var3,X

Yoshi_NoHMove:

	LDA <Objects_Var5,X
	BEQ Yoshi_NoTounge
	
	JSR Yoshi_ToungeOut
	
Yoshi_NoTounge:
	JSR Yoshi_Draw

	; Normal head
	LDA #0
	STA Objects_Var2,X

	; Legs based on Var3
	LDA Objects_Var3,X
	LSR A
	LSR A
	LSR A
	LSR A
	AND #$03
	TAY
	LDA Yoshi_WalkFrames,Y
	STA Objects_Var1,X

	LDA <Objects_YVel,X
	BEQ Yoshi_NoVertMove
	
	; And spread legs
	LDA #2
	STA Objects_Var1,X
	
	LDA <Objects_YVel,X
	BPL Yoshi_NotMovingUp

	; Moving upward; use nose up
	INC Objects_Var1,X
	INC Objects_Var2,X
	
Yoshi_NotMovingUp:

Yoshi_NoVertMove:

	LDA Objects_Timer,X
	BNE Yoshi_MouthOpen	; If timer active, jump to Yoshi_MouthOpen

	; If tounge out, don't ... redo it
	LDA <Objects_Var5,X
	BNE Yoshi_DisTounge

	; Something different if holding in mouth!
	LDA Objects_Var11,X
	BNE Yoshi_HoldInMouth		; If Yoshi's got something in his mouth, spit it out!~

	BIT <Pad_Input
	BVC Yoshi_DisTounge	; If Player is not pressing 'B', jump to Yoshi_DisTounge
	
	LDA #$20
	STA <Objects_Var5,X

	LDA #SND_PLAYERSWIM
	STA Sound_QPlayer

Yoshi_DisTounge:
	RTS
	
Yoshi_MouthOpen:
	CMP #1
	BNE Yoshi_MouthNotClosing		; If Yoshi is not about to close his mouth, jump to Yoshi_MouthNotClosing

	; Mouth about to close; release old object (allow damage from it once again)
	LDA #$FF
	STA Objects_Var6,X

Yoshi_MouthNotClosing:

	; Keep mouth agape
	LDA #3
	STA Objects_Var2,X

	RTS
	
Yoshi_HoldInMouth:
	LDY Objects_Var6,X
	
	; Lock onto Yoshi...
	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y
	
	; Keep object way up high off-screen...
	LDA #0
	STA Objects_Y,Y
	LDA #$FF
	STA Objects_YHi,Y
	
	LDA #2
	STA Objects_Var2,X
	
	BIT <Pad_Input
	BVC Yoshi_DisTounge	; If Player is not pressing 'B', jump to Yoshi_DisTounge

	; Yoshi's got something in his mouth; spit it out!
	
	; Clear the "in mouth" holding flag
	LDA #0
	STA Objects_Var11,X

	; Set object to approximately Yoshi's mouth level
	LDA <Objects_Y,X
	SUB #12
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	SBC  #0
	STA Objects_YHi,Y
		
	; "Kicked" state
	LDA #OBJSTATE_KICKED
	STA Objects_State,Y
	
	; Set object spit velocity
	LDA #$30
	BIT Player_FlipBits
	BVS Yoshi_SpitRight
	
	LDA #-$30
	
Yoshi_SpitRight:
	STA Objects_XVel,Y
	
	; Object will fly out
	LDA #-$10
	STA Objects_YVel,Y
	
	; Spit sound
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer
	
	; Hold mouth agape for a bit...
	LDA #$10
	STA Objects_Timer,X
	
	RTS

Yoshi_Draw:

	; Var1 = Body frame
	; Var2 = Head frame

	; Set head X/Y offsets
	LDY #0
	
	LDA Objects_Var1,X
	CMP #4
	BNE Yoshi_NotToungeFrame

	INY

Yoshi_NotToungeFrame:
	LDA YoshiHead_YOffs,Y
	STA <Temp_Var11
	LDA YoshiHead_YHiOffs,Y
	STA <Temp_Var12

	; 'Y' needs to be multiplied by 2 here
	TYA
	ASL A
	TAY

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ YoshiDraw_NotHFlipped
	
	INY
	
YoshiDraw_NotHFlipped:
	LDA YoshiHead_XOffs,Y
	STA <Temp_Var9
	LDA YoshiHead_XHiOffs,Y
	STA <Temp_Var10


	; Draw head of Yoshi's head
	LDA Objects_Var2,X
	ADD #(Yoshi_Heads - ObjPE6) / 2
	STA Objects_Frame,X

	LDA #8
	STA Temp_VarNP0

	JSR Yoshi_DrawOffsetSprite

	; Draw trunk of Yoshi's body
	LDA Objects_Var1,X
	ADD #(Yoshi_Trunks - ObjPE6) / 2
	STA Objects_Frame,X

	JSR Object_DetermineHorzVis
	JSR Object_DetermineVertVis
	JSR Object_ShakeAndDraw

	LDX <SlotIndexBackup

	RTS

Yoshi_DrawOffsetSprite:
	LDA <Objects_X,X
	PHA
	ADD <Temp_Var9
	STA <Objects_X,X
	LDA <Objects_XHi,X
	PHA
	ADC <Temp_Var10
	STA <Objects_XHi,X

	LDA <Objects_Y,X
	PHA
	ADD <Temp_Var11
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	PHA
	ADC <Temp_Var12
	STA <Objects_YHi,X

	JSR Object_DetermineHorzVis
	JSR Object_DetermineVertVis
	JSR Object_ShakeAndCalcSprite
	
	TYA
	ADD Temp_VarNP0
	TAY

	JSR Object_Draw16x16Sprite

	LDX <SlotIndexBackup
	
	; Little hackish, but if Temp_VarNP0 = 16, we're drawing the tounge, 
	; so we need to check for object-to-object collision as appropriate
	; to see if the tounge caught anything...
	; We need to do this here since the sprite X/Y is appropriate!
	LDA Temp_VarNP0
	CMP #16
	BNE Yoshi_NotDrawingTounge

	JSR Yoshi_ToungeHandle
	
Yoshi_NotDrawingTounge:
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X
	
	RTS

Yoshi_ToungeOut:

	DEC <Objects_Var5,X
	BNE Yoshi_StillTounging

	LDY Objects_Var6,X
	BMI Yoshi_ToungeNothing		; If didn't catch anything on tounge, jump to Yoshi_ToungeNothing

	LDA Level_ObjectID,Y
	
	; Check if this object should be held in mouth rather than just swallowed
	LDY #(Yoshi_HoldObjectIDs_End - Yoshi_HoldObjectIDs - 1)
Yoshi_OnToungeCheck:
	CMP Yoshi_HoldObjectIDs,Y
	BNE Yoshi_NotHoldObject

	; Got a shelled object, we handle this case a little differently!
	INC Objects_Var11,X		; Flag that we're holding
	RTS						; That's it for now...

Yoshi_NotHoldObject:
	DEY						; Y--
	BPL Yoshi_OnToungeCheck	; While Y >= 0, loop

Yoshi_NoEatShell:
	LDY Objects_Var6,X

	; Got something...!!
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,Y

	LDA #SND_LEVELCOIN
	STA Sound_QLevel1

	INC Coins_Earned ; One more coin earned
	INC Coins_ThisLevel	 ; One more coin earned this level

	; Nothing on tounge anymore
	LDA #$FF
	STA Objects_Var6,X

Yoshi_ToungeNothing:
	RTS

Yoshi_StillTounging:
	; Body/head frame set
	LDA #4
	STA Objects_Var1,X
	LDA #3
	STA Objects_Var2,X

	; Calculate tounge X off
	LDA <Objects_Var5,X
	CMP #$10
	BLT YoshiToungeXOff_NoNegate
	
	LDA #$20
	SUB <Objects_Var5,X
	
YoshiToungeXOff_NoNegate:
	STA <Temp_Var1
	ASL A
	ADD <Temp_Var1
	STA <Temp_Var9
	
	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BNE YoshiToungeXOff_NoFlip
	
	LDA <Temp_Var9
	NEG
	STA <Temp_Var9
	
YoshiToungeXOff_NoFlip:
	BMI YoshiToungeXOff_Neg
	LDA #$00
	BEQ YoshiToungeXOff_OK
YoshiToungeXOff_Neg:
	LDA #$FF
YoshiToungeXOff_OK:
	STA <Temp_Var10
	
	LDA #-4
	STA <Temp_Var11
	LDA #$FF
	STA <Temp_Var12


	; Draw tounge
	LDA #(Yoshi_Tounge - ObjPE6) / 2
	STA Objects_Frame,X

	LDA Objects_SprAttr,X
	PHA
	LDA #SPR_PAL1
	STA Objects_SprAttr,X

	LDA #16
	STA Temp_VarNP0
	JSR Yoshi_DrawOffsetSprite

	PLA
	STA Objects_SprAttr,X

	RTS


Yoshi_ToungeHandle:
	LDA Objects_Var6,X
	BPL Yoshi_UpdateTounge	; If we've already got something on the tounge, jump to Yoshi_UpdateTounge
	
	; Do object-to-object collision test!
	INC Obj2Obj_FlagNoHitChk	; Detect ANYTHING!
	JSR Object_CalcBoundBox2	; Calculate THIS object's bounding box
	LDX #5
	JSR PRG000_DC0B		; Cheat entry a little; lets us scan for powerups too!
	DEC Obj2Obj_FlagNoHitChk	; Clear the flag

	; Store the object index into Temp_VarNP0 if collided, else $FF
	LDA #$FF
	BCC Yoshi_ToungeNoHit
	
	; Impact!  

	; FIXME this doesn't work for some reason?
	; Immediately pull back tounge (don't push enemy outward) if tounge was still emerging
	;LDA <Objects_Var5,X
	;CMP #$10
	;BGE Yoshi_NoToungeReverse
	
	;SUB #$10
	;STA <Objects_Var5,X

;Yoshi_NoToungeReverse:

	LDX #(Yoshi_IgnoreObjectIDs_End - Yoshi_IgnoreObjectIDs - 1)
Yoshi_IgnoreObject_Loop:
	; Is the object on Yoshi's tounge on our ignore list?
	LDA Yoshi_IgnoreObjectIDs,X
	CMP Level_ObjectID,Y
	BNE Yoshi_IgnoreObject_NoIgnore	; If not an ignored object ID, jump to Yoshi_IgnoreObject_NoIgnore
	
	; Ignored object ID found!
	LDA #$FF	; Nothing on tounge
	BNE Yoshi_ToungeNoHit	; Jump (technically always) to Yoshi_ToungeNoHit

Yoshi_IgnoreObject_NoIgnore:
	DEX			; X--
	BPL Yoshi_IgnoreObject_Loop	; While X >= 0, loop!
	
	; Keep index!
	TYA
	
Yoshi_ToungeNoHit:
	LDX <SlotIndexBackup
	STA Objects_Var6,X

	RTS

Yoshi_UpdateTounge:

	TAY		; Caught object -> 'Y'
	
	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y
	LDA <Objects_Y,X
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	STA Objects_YHi,Y

	RTS

ObjInit_Reznor:

	LDA #MUS2B_BOSS
	STA Sound_QMusic2

	; Reznor uses all 8 object slots ... 4 Reznors, 4 Reznor platforms
	; So first we need to reconfigure...

	LDA <Objects_Y,X
	STA <Temp_Var1
	LDA <Objects_YHi,X
	STA <Temp_Var2

	LDA <Objects_X,X
	STA <Temp_Var3
	LDA <Objects_XHi,X
	STA <Temp_Var4

	LDX #7
Player_InitReznors:
	LDA #OBJ_BOSS_REZNOR
	STA Level_ObjectID,X
	
	JSR Level_PrepareNewObject
	
	CPX #4
	BLT ReznorInit_NotPlatform	; If X < 4, this is NOT a Reznor platform, jump to ReznorInit_NotPlatform
	
	; "Reznor" objects 4+ are actually platforms...
	INC Objects_Var1,X	; Set platform mode
	
ReznorInit_NotPlatform:

	; Set palette 3
	LDA #SPR_PAL3
	STA Objects_SprAttr,X

	; Set to normal state
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Each Reznor/platform needs to be offset circularly...
	TXA
	AND #3
	CLC
	ROR A
	ROR A
	ROR A	; Should now be 0, 64, 128, 192
	STA Objects_Var7,X

	LDA <Temp_Var1
	STA <Objects_Y,X
	LDA <Temp_Var2
	STA <Objects_YHi,X

	LDA <Temp_Var3
	STA <Objects_X,X
	LDA <Temp_Var4
	STA <Objects_XHi,X

	DEX	; X--
	BPL Player_InitReznors

	LDX <SlotIndexBackup
	
	RTS


	; Base offset of platform is +32, lower numbers for bump effect
ReznorPlatform_BumpOffY:	.byte 32, 31, 31, 29, 29, 29, 28, 27, 27, 27, 27, 27, 27, 27, 27, 28, 29, 29, 29, 31, 31
ReznorPlatform_BumpOffY_End

Reznor_DoReznor:
	JSR Level_ObjCalcXDiffs

	LDA Objects_Timer,X
	CMP #1
	BNE Reznor_NoMouthReset
	
	; Close mouth
	LDA #0
	STA Objects_Frame,X

Reznor_NoMouthReset:
	TXA
	ROR A	; bit 0 -> carry
	ROR A	; bit 1 -> carry, bit 0 -> 7
	ROR A	; bit 1 -> 7, bit 0 -> 6
	ADD Level_NoStopCnt
	BNE Reznor_NoSpitFire
	
	JSR Reznor_SpitFire
	
Reznor_NoSpitFire:

	; Face Player
	LDA Misc_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	; The actual Reznors have different behavior
	JMP Reznor_Draw

Reznor_SpitFire:

	; Offset not used
	LDA #0
	STA <Temp_Var1
	
	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot or don't come back!

	; If we get here, Reznor's gonna spit!
	
	; Timer to close mouth later
	LDA #16
	STA Objects_Timer,X
	
	; Open mouth
	LDA #1
	STA Objects_Frame,X
	
	; Venus fire trap code is good enough for me!
Reznor_SpitFireThunk:
	JMP_THUNKA 5, Reznor_SpitFire5

ObjNorm_Reznor:
	LDA <Player_HaltGame
	BNE Reznor_Halted

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ Reznor_Normal

Reznor_Halted:
	; Reznor is dying or something, just draw
	JMP Reznor_Draw

Reznor_Normal:
	LDA Objects_Var1,X
	BEQ Reznor_DoReznor		; If this is Reznor, not a platform, jump to Reznor_DoReznor

	; The first platform will act as end-of-boss controller...
	CPX #4
	BNE Reznor_ControllerDoneJmp	; If not the controller, jump to Reznor_ControllerDoneJmp

	LDA Objects_Var3,X
	JSR ReznorCtl_Do
	
Reznor_ControllerDoneJmp:
	JMP Reznor_ControllerDone	; After doing controller task, jump to Reznor_ControllerDone
	
ReznorCtl_Do:
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word ReznorCtl_CheckReznorDead	; 0
	.word ReznorCtl_EndLevel		; 1
	.word ReznorCtl_DeadTimeout		; 2

ReznorCtl_CheckReznorDead:
	; Controller needs to check if all Reznors are dead...
	LDY #3
Reznor_CheckDeadLoop:

	LDA Objects_State,Y
	CMP #OBJSTATE_DEADEMPTY
	BNE Reznor_NotDead	; At least one Reznor is still alive, jump to Reznor_NotDead

	DEY							; Y--
	BPL	Reznor_CheckDeadLoop	; While Y >= 0, loop!

	LDA World_Num
	CMP #9
	BEQ Reznor_NoFanfare	; No fanfare on World Zero

	; Victory fanfare
	LDA Sound_QMusic1
	ORA #MUS1_BOSSVICTORY
	STA Sound_QMusic1

Reznor_NoFanfare:
	LDA #1
	STA Level_TimerEn

	; Next state
	INC Objects_Var3,X

Reznor_NotDead:	

	LDA <Objects_Var4,X
	CMP #128
	BGE Reznor_NotBustingFloor	; If we've already busted the whole floor, jump to Reznor_NotBustingFloor

	; The timer will be active while busting the floor
	; Will bust a block at 4-1
	LDA Objects_Timer,X
	BEQ Reznor_NotBustingFloor	; If timer hasn't started, we're not busting floors, jump to Reznor_NotBustingFloor
	CMP #5
	BGE Reznor_NotBustingFloor		; If timer >= 5, jump to Reznor_NotBustingFloor

	; 0123456789ABCDEF
	;        LR
	
	; Even numbers bust "right" (X = 128, 144, 160...)
	; Odd numbers bust "left" (X = 112, 96, 80...)
	
	; 0/1 bust top
	; 2/3 bust bottom
	
	; Var4 counts what round we're on, up to 8 we stop
	
	SUB #1	; Basing 0 to 3
	PHA	; Save timer value
	PHA	; Save timer value
	
	; Set vertical position by value...
	AND #2
	ASL A
	ASL A
	ASL A	; Now 0 or 16
	ADD #112
	STA <Temp_Var1
	
	LDA <Objects_Y,X
	ADD <Temp_Var1
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	ADC #0
	STA Level_BlockChgYHi

	PLA	; Restore timer value
	
	; Set horizontal position by value
	AND #1
	BNE Reznor_BustLeft

	; Reznor bust right...
	LDA <Objects_Var4,X
	ADD #16
	STA <Temp_Var1
	
	LDA <Objects_X,X
	ADD <Temp_Var1
	STA Level_BlockChgXLo
	LDA <Objects_XHi,X
	ADC #0
	STA Level_BlockChgXHi
	
	
	JMP Reznor_BustDone
	
Reznor_BustLeft:
	LDA <Objects_X,X
	SUB <Objects_Var4,X
	STA Level_BlockChgXLo
	LDA <Objects_XHi,X
	SBC #0
	STA Level_BlockChgXHi	
	
Reznor_BustDone:
	LDA #CHNGTILE_DELETETOBG
	STA Level_ChgTileEvent

	JSR_THUNKA 1, PRG001_BC6D

	PLA ; Restore timer value
	BNE Reznor_NoBustTimerReset
	
	; Offset 16 in horizontal direction for next block change
	LDA <Objects_Var4,X
	ADD #16
	STA <Objects_Var4,X
	
	; Need to reset busting timer!
	LDA #80		; ?
	STA Objects_Timer,X
		
Reznor_NoBustTimerReset:

Reznor_NotBustingFloor:
	RTS

ReznorCtl_EndLevel:
	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BNE Reznor_NotDDComet
	
	LDY #7
Reznor_CometLoop:
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,Y

	DEY
	CPY #5
	BGE Reznor_CometLoop

	JMP_THUNKC 30, Level_EndComet

Reznor_NotDDComet:
	JSR DoTimeBonus	 ; Convert remaining time into score
	BNE ReznorCtl_StillTimering	 ; If not done converting, jump to PRG003_A910 (RTS)

	; Set timer to $40
	LDA #$40
	STA Objects_Timer,X
	
	; Next state
	INC Objects_Var3,X

ReznorCtl_StillTimering:
	RTS


ReznorCtl_DeadTimeout:
	LDA Objects_Timer,X
	BNE Reznor_StillTimering

	LDA World_Num
	CMP #9
	BNE Reznor_NoWZeroExit

	LDA #3
	STA <Temp_Var1
	JSR ArenaCtl_ExitBoss
	JMP Object_Delete

Reznor_NoWZeroExit:
	; Exit to map!
	JSR_THUNKA 42, ExitLevel_InvalidateCP37
	
Reznor_StillTimering:
	RTS

Reznor_ControllerDone:
	LDA Level_NoStopCnt
	AND #1
	BNE Reznor_NoRotate

	INC Objects_Var7,X

Reznor_NoRotate:
	LDA Objects_Var7,X
	STA <Temp_Var1

	; Take advantage of the Boo Loop code!
	JSR_THUNKA 3, BooLoop_GetOffsetXY_TV1

	; Divide Y offset by 2
	LDA <Temp_Var2
	ASR A
	STA <Temp_Var2
	LDA <Temp_Var1
	ROR A
	STA <Temp_Var1

	LDA <Objects_Var5,X
	BEQ ReznorPlatform_NotBumping	; If Var5 = 0, platform is not doing its bump effect, jump to ReznorPlatform_NotBumping
	
	; Otherwise, decrement!
	SUB #1
	STA <Objects_Var5,X

ReznorPlatform_NotBumping:
	TAY	; -> 'Y' Bump offset
	
	LDA <Temp_Var1
	ADD ReznorPlatform_BumpOffY,Y
	STA <Temp_Var1
	LDA <Temp_Var2
	ADC #0
	STA <Temp_Var2

	; Platform X-8
	LDA <Temp_Var3
	SUB #8
	STA <Temp_Var3
	LDA <Temp_Var4
	SBC #0
	STA <Temp_Var4
	

	; Divide X offset by 2
	LDA <Temp_Var4
	ASR A
	STA <Temp_Var4
	LDA <Temp_Var3
	ROR A
	STA <Temp_Var3

	; Offset Y
	LDA <Objects_Y,X
	PHA
	ADD <Temp_Var1
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	PHA
	ADC <Temp_Var2
	STA <Objects_YHi,X
	
	; Offset X
	LDA <Objects_X,X
	PHA
	ADD <Temp_Var3
	STA <Objects_X,X
	LDA <Objects_XHi,X
	PHA
	ADC <Temp_Var4
	STA <Objects_XHi,X

	JSR Reznor_Draw

	
	LDA Objects_Var2,X
	BEQ ReznorPlatform_NoStick	; If platform is not in "stick" mode, jump to ReznorPlatform_NoStick

	; Sticky
	DEC Objects_Var2,X

	LDA <Player_YVel
	BMI ReznorPlatform_NoStick	; If Player is moving upward, jump to ReznorPlatform_NoStick

	JSR Object_HitTest
	BCC ReznorPlatform_HitCheckSkip
	
	JSR Player_StandOnReznorPlatform
	
	JMP ReznorPlatform_HitCheckSkip

ReznorPlatform_NoStick:
	JSR Object_HitTestRespond

ReznorPlatform_HitCheckSkip:
	; Platform should back up its present X/Y for a calculation
	; of Player movement later...
	LDA <Objects_X,X
	STA Objects_Var10,X
	LDA <Objects_XHi,X
	STA Objects_Var11,X

	LDA <Objects_Y,X
	STA Objects_Var12,X
	LDA <Objects_YHi,X
	STA Objects_Var13,X


	; Reznors are dummies with their movement and forced to their respective platforms
	
	LDA Objects_State-4,X
	CMP #OBJSTATE_NORMAL
	BNE Reznor_NotNormalNoFix	; Don't mess with a dying Reznor, jump to Reznor_NotNormalNoFix
	
	LDA <Objects_X,X
	ADD #8
	STA <Objects_X-4,X
	LDA <Objects_XHi,X
	ADC #0
	STA <Objects_XHi-4,X

	LDA <Objects_Y,X
	SUB #32
	STA <Objects_Y-4,X
	LDA <Objects_YHi,X
	SBC #0
	STA <Objects_YHi-4,X

Reznor_NotNormalNoFix:
	PLA
	STA <Objects_XHi,X
	PLA 
	STA <Objects_X,X

	PLA
	STA <Objects_YHi,X
	PLA 
	STA <Objects_Y,X

	RTS
	
	
Reznor_Draw:

	LDA Objects_Var1,X
	BNE Reznor_DrawPlatform	; If this is actually a Reznor platform, jump to Reznor_DrawPlatform

	; Draw Reznor
	JSR Object_DetermineHorzVis
	JSR Object_DetermineVertVis
	JSR Object_CalcSpriteXY_NoHi
	JMP Object_Draw16x32Sprite


Reznor_DrawPlatform:

	; Draw Platform
	
	; Force 32x16 viz check
	LDY #2
	JSR Object_DetermineHorzVisY
	LDY #0
	JSR Object_DetermineVertVisY

	LDA #(Player_PlatBegin - ObjPE8) / 2
	STA Objects_Frame,X
	
	JSR Object_ShakeAndDraw
	
	
	; Second half of the platform will steal the unused 2 Reznor sprites
	
	LDX #(Player_PlatBegin - ObjectGrExt_PatternSets)
	
	; Horizontally flip second half
	LDA <Temp_Var3
	ORA #SPR_HFLIP
	STA <Temp_Var3
	
	; X +16
	LDA <Temp_Var2
	ADD #16
	STA <Temp_Var2
	
	; Take the sprites Reznor isn't using
	LDA #0
	JSR Object_StealAdjSprite
	TYA
	ADD #(4 * 4)		; Four sprites in; we want the last two sprites
	TAY
	
	JSR Object_Draw16x16Sprite

	LDX <SlotIndexBackup

	RTS


ObjHit_Reznor:

	; Test if Player is standing on top of platform

	LDA <Player_SpriteY
	ADD #24
	CMP <Objects_SpriteY,X
	BGE PRG041_BABE	 ; If Player's bottom is beneath object's top, jump to PRG041_BABE

	LDA <Player_YVel
	BMI PRG041_BABD	 ; If Player is moving upward, jump to PRG041_BABD

	JSR Player_StandOnReznorPlatform	 ; Stand on platform
	SEC		 ; Set carry (collided)

PRG041_BABD:
	RTS		 ; Return

PRG041_BABE:

	; Check if Player is hitting off bottom of platform

	LDA #-$08	; A = -8 unless small or ducking

	LDY <Player_Suit
	BEQ PRG041_BAC9	 ; If Reznor is small, jump to PRG041_BAC9

	LDY Player_IsDucking
	BEQ PRG041_BACB	 ; If Reznor is NOT ducking, jump to PRG041_BACB

PRG041_BAC9:
	LDA #$08	 ; A = 8 if small or ducking

PRG041_BACB:
	ADD <Player_SpriteY
	CMP <Objects_SpriteY,X
	BLT PRG041_BADC	 ; If Player's Sprite top is near object's top, jump to PRG041_BADC

	LDA <Player_YVel
	BPL PRG041_BADA	 ; If Player is falling, jump to PRG041_BADA

	; Player hits head off platform
	LDA #$10
	STA <Player_YVel
	
	; Start bump effect
	LDA #(ReznorPlatform_BumpOffY_End - ReznorPlatform_BumpOffY)
	STA <Objects_Var5,X

	; Kill Reznor, if still present
	LDA Objects_State-4,X	; Reznor is -4 index
	CMP #OBJSTATE_NORMAL
	BEQ Reznor_Kill		; If Reznor is not dead, jump to Reznor_Kill
	
	; Reznor's already dead, just play bump sound
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer
	
	BNE PRG041_BADA	; Jump (technically always) to PRG041_BADA

Reznor_Kill:

	; Start floor busting timer on controller (object index 4) if not already started
	INC Objects_HitCount	; Not really using hit count, might as well use it horribly
	LDA Objects_HitCount
	CMP #2
	BNE Reznor_AlreadyBusting
	
	LDA #40
	STA Objects_Timer+4

Reznor_AlreadyBusting:
	TXA
	PHA
	SUB #4
	TAX
	STA <SlotIndexBackup	; Ew hack

	; Kill reznor!
	JSR Enemy_Kill

	PLA
	STA <SlotIndexBackup	; Ew hack
	TAX

PRG041_BADA:
	CLC		 ; Clear carry (no collision)
	RTS		 ; Return

PRG041_BADC:
	SEC
	RTS
	
Player_StandOnReznorPlatform:

	; Set Player to object's Y - 31
	LDA <Objects_Y,X	 
	SUB #29
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	; Flag Player as NOT mid-air
	LDY #$00
	STY <Player_InAir

	LDA <Objects_X,X
	SUB Objects_Var10,X
	BPL PRG041_AA7B	

	DEY		 ; Y = -1 (provides a sort of carry if Player's X Velocity caused one)

PRG041_AA7B:
	; Add to Player_X, with carry
	ADD <Player_X
	STA <Player_X
	TYA
	ADC <Player_XHi
	STA <Player_XHi

PRG041_AA85:

	; Mark that Player has touched platform for later direct updating
	INC Objects_Var2,X

	RTS		 ; Return

ObjInit_Urchin:

	; Centering
	LDA <Objects_X,X
	ADD #4
	STA <Objects_X,X

	; Urchin is really only meant for being underwater, this will fix a stupid splash when killed
	INC Objects_InWater,X

	; Urchin runs a state of going back and forth, depending on type of Urchin
	LDA Level_ObjectID,X
	SUB #OBJ_URCHIN_V
	ASL A
	STA <Objects_Var4,X		; Will be 0 or 2, adequate index for Urchin_X/YVel

	RTS

Urchin_XVel:	.byte  $00,  $00, -$08,  $08
Urchin_YVel:	.byte -$08,  $08,  $00,  $00

ObjNorm_Urchin:

	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	LSR A
	AND #1
	STA Objects_Frame,X

	JSR Urchin_Draw

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE Urchin_DoNothing	; If Urchin killed, jump to Urchin_DoNothing (RTS)

	LDA <Player_HaltGame
	BNE Urchin_DoNothing	; If gameplay halted, jump to Urchin_DoNothing (RTS)

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA Objects_Timer,X
	BEQ Urchin_Moving		; If Timer = 0, jump to Urchin_Moving
	CMP #1
	BNE Urchin_Cont	; If Timer <> 1, jump to Urchin_Cont
	
	; About to start moving again, switch direction
	LDA <Objects_Var4,X
	EOR #1
	STA <Objects_Var4,X
		
Urchin_Moving:
	; Set velocities
	LDY <Objects_Var4,X		; Y = speed setting index
	LDA Urchin_XVel,Y
	STA <Objects_XVel,X
	LDA Urchin_YVel,Y
	STA <Objects_YVel,X

	JSR Object_Move

	LDA <Objects_DetStat,X
	BEQ Urchin_Cont	; If haven't hit anything, jump to Urchin_Cont

	; Hit something... go into wait state
	LDA #$40
	STA Objects_Timer,X

Urchin_Cont:
	JSR Player_HitEnemy


Urchin_DoNothing:
	RTS

	
Urchin_Draw:
	JSR Object_Draw16x32Sprite
	
	; Patch in right side...
	
	LDA Objects_SprHVis,X
	AND #%00100000
	BNE UrchinDraw_Invis	; If the right-most side is invisible, jump to UrchinDraw_Invis (RTS)

	; Top
	LDA Objects_SprVVis,X
	LSR A
	STA <Temp_Var5
	BCS UrchinDraw_Invis	; If top is invisible, jump to UrchinDraw_Invis (RTS)

	; 'Y' += 8 (Sprite RAM 2 sprites over)
	TYA
	ADD #$08
	TAY	

	; Y
	LDA Objects_SpriteY,X
	STA Sprite_RAM+$00,Y

	; X
	LDA Sprite_RAM-$09,Y
	ADD #8
	STA Sprite_RAM+$03,Y

	; Bottom
	
	LDA <Temp_Var5
	LSR A
	BCS UrchinDraw_Invis	; If bottom is invisible, jump to UrchinDraw_Invis (RTS)
	
	; Y
	LDA Objects_SpriteY,X
	ADD #16
	STA Sprite_RAM+$04,Y

	; X
	LDA Sprite_RAM-$09,Y
	ADD #8
	STA Sprite_RAM+$07,Y

	; Both are HFLIP and PAL2
	LDA #(SPR_HFLIP | SPR_PAL2)
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	; Pattern
	LDX <Temp_Var6	 ; X = Temp_Var6 (starting tile)
	LDA ObjectGroup_PatternSets,X	; Get first sprite pattern index
	STA Sprite_RAM+$01,Y	; -> Sprite RAM
	LDA ObjectGroup_PatternSets+2,X	; Get second sprite pattern index
	STA Sprite_RAM+$05,Y	; -> Sprite RAM

	LDX <SlotIndexBackup
UrchinDraw_Invis:
	RTS


Gao_TickValues:	.byte $20, $40	; Pause before firing, pause after firing

ObjInit_Gao:
	LDA Gao_TickValues
	STA Objects_Timer,X
	RTS

ObjNorm_Gao:
	JSR Gao_Draw
	JSR Object_HandleBumpUnderneath

	JSR Level_ObjCalcXDiffs

	; Face Player
	LDA Misc_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	LDA Objects_Timer,X
	BNE Gao_Timeout

	; Going by frame (kinda hackish)
	; If at frame 0 with expired timer, go to frame 1 and spit
	; If at frame 1 with expired timer, just go back to frame 0
	LDY Objects_Frame,X
	BNE Gao_NoSpit

	JSR Object_AnySprOffscreen
	BNE Gao_NoSpit		; Don't actually do spit if partially off-screen	

	JSR Level_ObjCalcYDiffs
	LDA <Temp_Var16
	ADD #16
	CMP #16
	PHP
	
	; Only spit on frame 0...
	; Offset not used
	LDA #0
	STA <Temp_Var1
	
	JSR Gao_SpitFire
	
	; Special: If Player is approximately vertically the same, spit straight
	PLP
	BGE Gao_PlayerNotMiddle
	
	LDA #0
	STA SpecialObj_YVel,Y
	
Gao_PlayerNotMiddle:
	; Spit fire
	LDA #SND_PLAYERFIRE
	STA Sound_QPlayer
	
	LDY #0
		
Gao_NoSpit:
	LDA Gao_TickValues,Y
	STA Objects_Timer,X
	
	; Flip frame
	TYA
	EOR #1
	STA Objects_Frame,X

Gao_Timeout:
	JMP Object_DeleteOffScreen

Gao_Draw:
	JSR Object_DetermineHorzVis
	JSR Object_DetermineVertVis
	JMP Object_ShakeAndDraw

Gao_SpitFire:
	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot or don't come back!

	; Venus fire trap code is good enough for me!
	JMP Reznor_SpitFireThunk


EnemyEnterXVel41:	.byte -$08, $08


ObjInit_Pokey:

	; Get last scroll direction so we know which way to face
	LDY Scroll_LastDir

	; Enemy charges at Player the same
	LDA EnemyEnterXVel41,Y
	STA <Objects_XVel,X

	LDA #0
	STA Objects_SprHVis,X
	STA Objects_SprVVis,X

	; Temp_Var8 will usually hold the "previous index", but initialized to 
	; impossible $FF just as a starting value (note that the lower nibble
	; being $F is still valuable as it will indicate "no prior" on the first
	; segment we create, the upper nibble is kind of arbitrary other than
	; a "BMI" instruction)
	LDA #$FF
	STA <Temp_Var8

	; For as many special objects (body segments) as we can, up to 3, keep pushing Pokey up...
	LDA #3
	STA <Temp_Var1
Pokey_SpawnBodySegs_Loop:

	JSR Pokey_SpawnBodySeg

	DEC <Temp_Var1
	BNE Pokey_SpawnBodySegs_Loop
	
	RTS

Pokey_SpawnBodySeg:
	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot or don't come back!

	; Room for another body segment...

	LDA #SOBJ_POKEYBODY
	STA SpecialObj_ID,Y

	; Set X/Y
	; Generate offset Y
	LDA <Objects_Y,X
	SUB Objects_Var1,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #0
	STA SpecialObj_YHi,Y

	LDA <Objects_X,X
	STA SpecialObj_XLo,Y
	LDA <Objects_XHi,X
	STA SpecialObj_Var3,X	; Var 3 represents an "X Hi"


	; Inform body segment of parent
	TXA
	STA SpecialObj_Var1,Y
	
	; Record body segment's Y offset
	LDA Objects_Var1,X
	STA SpecialObj_Var2,Y
	
	
	; The "Data" of the body segment is to link to its prior (high nibble)
	; and next (low nibble) so the body can collapse...
	LDA <Temp_Var8	; Get the previous index
	BMI PokeyBodySeg_NoPrev		; If we haven't had a previous body segment yet (i.e. this is the first one), jump to PokeyBodySeg_NoPrev
	
	; Inform previous segment of this new next segment...
	TAX				; Previous body segment index -> 'X'
	STY <Temp_Var9	; Current body segment index -> Temp_Var9
	
	; Set previous segment's prior/next pair
	LDA SpecialObj_Data,X
	AND #$F0		; Clear the "next" link
	ORA <Temp_Var9	; Apply the new next
	STA SpecialObj_Data,X
	
	; Resume...
	LDX <SlotIndexBackup
	
PokeyBodySeg_NoPrev:
	LDA <Temp_Var8	; Get previous index
	
	; Move to upper nibble (this segment will store the previous index as this one's prior)
	ASL A
	ASL A
	ASL A
	ASL A
	
	ORA #$0F	; Set "no next segment" to this segment (until we know better)
	STA SpecialObj_Data,Y	; Store the linkage
	
	; Move Pokey head up by 16 (affects sprite draw only, real Pokey base is always at ground level)
	LDA Objects_Var1,X
	ADD #16
	STA Objects_Var1,X

	; Update Temp_Var8 for next time...
	STY <Temp_Var8

	RTS
	
ObjNorm_Pokey:
	JSR Pokey_Draw

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE Pokey_Dying

	LDA <Player_HaltGame
	BNE Pokey_DyingOffsetClear

	JSR Player_HitEnemy

	LDA <Counter_1
	AND #$08
	ASL A
	ASL A
	ASL A
	STA Objects_FlipBits,X

	JSR Object_Move
	
	LDA Objects_DetStat,X
	AND #$04
	BEQ Pokey_NoFloorHit
	
	JSR Object_HitGround
	
Pokey_NoFloorHit:

	LDA Objects_DetStat,X
	AND #$03
	BEQ Pokey_NoWallHit

	; Hit wall, turn around
	LDA <Objects_XVel,X
	NEG
	STA <Objects_XVel,X

Pokey_NoWallHit:
	JMP Object_DeleteOffScreen

Pokey_Dying:

	; If Pokey is dying, make sure to offset the head to 
	; the segment offset and clear it out...
	LDA Objects_Var1,X
	BEQ Pokey_DyingOffsetClear

	; Apply as permanent Y offset
	LDA <Objects_Y,X
	SUB Objects_Var1,X
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SUB #0
	STA <Objects_YHi,X

	LDA #0
	STA Objects_Var1,X

	LDA Objects_QSandCtr,X
	BEQ Pokey_DyingOffsetClear	; If Pokey did not die of quicksand, jump to Pokey_DyingOffsetClear
	
	; Final hack: Since Pokey died in Quicksand, we need to actually 
	; reset his death so the head can land appropriately
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X
	LDA #0
	STA Objects_QSandCtr,X

Pokey_DyingOffsetClear:
	RTS

Pokey_Draw:
	; Var1 gives a fake offset to Pokey's head to compensate for body segments
	LDA <Objects_Y,X
	PHA
	SUB Objects_Var1,X
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	PHA
	SBC #0
	STA <Objects_YHi,X

	JSR Gao_Draw

	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X
	RTS

ObjInit_SandFill:
	JSR SandFill_CheckPlugSolid
	BLT SandFill_NotPlugged		; If not on a solid tile, not plugged, jump to SandFill_NotPlugged

	; Plugged! Use alternate wait state...
	LDA #5
	STA <Objects_Var4,X

SandFill_NotPlugged:
	RTS
	
ObjNorm_SandFill:

	; This object is demanding since it needs to do a LOT of tile-changing!
	; As such, it will yield every other tick and if any tile change is
	; active to try to prevent any contention...
	LDA <Player_HaltGame
	BNE SandFill_DoNothing	; If gameplay halted, jump to SandFill_DoNothing
	
	LDA Level_ChgTileEvent
	BNE SandFill_DoNothing	; If tile change already queued, jump to SandFill_DoNothing
	
	TXA
	ADD <Counter_1
	LSR A
	AND #1
	BNE SandFill_DoNothing	; Every other frame, jump to SandFill_DoNothing
	
	LDA <Objects_Var4,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word SandFill_WaitActivation	; 0 - Waiting for activation
	.word SandFill_InitialFall		; 1 - Place initial "sandfall" tile
	.word SandFill_SeekFloor		; 2 - Keep placing sand tiles until we hit floor...
	.word SandFill_Fill				; 3 - Begin filling container until sides fail
	.word SandFill_OweMidChange		; 4 - If after state 2 we hit a "quicksand top" tile, we need to change that to a mid
	.word SandFill_WaitPlug			; 5 - Alternate use; if placed over a solid tile (presumably brick), will not move until not solid

SandFill_DoNothing:
	RTS


SandFill_InitialFall:
	LDA #0
	STA <Temp_Var1
	STA <Temp_Var2
	STA <Temp_Var3
	STA <Temp_Var4
	LDA #CHNGTILE_QUICKSAND_TOP9
	JSR SandFill_ChangeTile
	
	INC <Objects_Var4,X
	
	JMP SandFill_Advance

SandFill_SeekFloor:

	JSR Object_DetectTile
	JSR SandFill_CheckTileSolidity
		
	BLT SandFill_NoHitFloor

	LDA #CHNGTILE_QUICKSAND_MID9
	STA Level_ChgTileEvent

	; Hit floor, change state
	INC <Objects_Var4,X

	LDA Level_Tile
	CMP #TILE9_QUICKSAND_TOP
	BNE SandFill_NotHitQSandTop
	
	; If we hit a quicksand top tile, we owe a mid tile change (special case)
	LDA #4
	STA <Objects_Var4,X
	
SandFill_NotHitQSandTop:
	; Clear left/right stop bits
	LDA #$00
	STA Objects_Var1,X
	
	RTS
		
SandFill_NoHitFloor:
	LDA #SND_LEVELSANDFILL
	STA Sound_QLevel2

	; Count number of rows we have descended so we can know later when to stop!
	INC Objects_Var2,X
	
	LDA #0
	STA <Temp_Var1
	STA <Temp_Var2
	STA <Temp_Var3
	STA <Temp_Var4

	LDA #CHNGTILE_QUICKSAND_MID9
	JSR SandFill_ChangeTile
	
SandFill_Advance:
	LDA <Objects_Y,X
	ADD #16
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	ADC #0
	STA <Objects_YHi,X
	
	RTS

SandFill_CheckTileSolidity_Lim:
	; Alternate entry with hack for going horizontally off-screen
	; Only works if the tile check was the manual calculation one
	LDA ObjTile_DetXHi
	BMI SandFill_CTSQuickSandOverride
	
	; Looking for solid tiles OR other quicksand tiles
SandFill_CheckTileSolidity:
	LDA <Level_Tile
	
	; Hitting quicksand tiles is also considered a valid stop point
	CMP #TILE9_QUICKSAND_TOP
	BEQ SandFill_CTSQuickSandOverride
	CMP #TILE9_QUICKSAND_MID
	BEQ SandFill_CTSQuickSandOverride
	
Magiblot_CheckTileSolidity:
	PHA
	
	ASL A		 
	ROL A		 
	ROL A		 ; Upper 2 bits shift right 6, effectively
	AND #%00000011	 ; Keep these bits, i.e. "tile quadrant"
	TAY		 ; Y = quadrant of last detected tile
	
	PLA
	CMP Tile_AttrTable,Y

SandFill_CTSQuickSandOverride:
	RTS
	
	; Execute tile change, with:
	;	Temp_Var1/2 - X Offset
	;	Temp_Var3/4 - Y Offset
	;	'A' - target tile
SandFill_ChangeTile:
	PHA		; Save input value

	LDA <Objects_X,X
	ADD <Temp_Var1
	AND #$F0
	STA Level_BlockChgXLo
	LDA <Objects_XHi,X
	ADC <Temp_Var2
	STA Level_BlockChgXHi
	
	LDA <Objects_Y,X
	ADD <Temp_Var3
	AND #$F0
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	ADC <Temp_Var4
	STA Level_BlockChgYHi

	PLA		; Restore input value
	ORA #$80	; Change attributes too!
	STA Level_ChgTileEvent
	
SandFill_Wait:
	RTS

	; Based on Var3 bit 7 -- unset = left, set = right
SandFill_StopBits:		.byte %10000000, %01000000

SandFill_Terminate:
	; We've reached the top!
	JMP Object_Delete

SandFill_Fill:

	LDA Objects_Var2,X
	BMI SandFill_Terminate

	LDA #SND_LEVELSANDFILL
	STA Sound_QLevel2

	LDA #0
	STA <Temp_Var1
	STA <Temp_Var2
	
	; Var1 - Bit 7 set = stop going left, bit 6 set = stop going right
	; Var3 - Last filled row, bit 7 is side toggle (0 left, 1 right)
	; Var6 - Current block left
	; Var7 - Current block right

	; Offset row
	LDA Objects_Var3,X
	AND #$7F	; Bit 7 specifies side
	JSR SandFill_Mul16
	
	; -16 - (Var3 * 16)
	LDA #-16
	SUB <Temp_Var8
	STA <Temp_Var3
	LDA #$FF
	SUB <Temp_Var9
	STA <Temp_Var4

	LDA <Objects_Y,X
	ADD <Temp_Var3
	STA ObjTile_DetYLo
	LDA <Objects_YHi,X
	ADC <Temp_Var4
	STA ObjTile_DetYHi


	; Offset column
	LDA Objects_Var3,X
	ROL A
	ROL A	; 0 if going left, 1 if going right
	AND #1
	STA <Temp_Var5	; -> Temp_Var5
	BNE SandFill_DoRight

	; Left side...
	LDA Objects_Var1,X
	BMI SandFill_SkipTile	; If bit 7 set, not going left anymore, jump to SandFill_SkipTile
	
	LDA Objects_Var6,X
	NEG
	SUB #1		; Offset one block from center
		
	INC Objects_Var6,X

	JMP SandFill_SetTile

SandFill_DoRight:

	LDA Objects_Var1,X
	AND #%01000000
	BNE SandFill_SkipTile	; If bit 6 set, not going right anymore, jump to SandFill_SkipTile

	LDA Objects_Var7,X
	ADD #1		; Offset one block from center
		
	INC Objects_Var7,X

SandFill_SetTile:

	JSR SandFill_Mul16

	; Set multiplication output into tile change coordinates
	LDA <Temp_Var8
	STA <Temp_Var1
	LDA <Temp_Var9
	STA <Temp_Var2

	; We'll be using a tile replacement of "Quicksand top and middle" by default
	LDA #CHNGTILE_SANDTOPMID
	BNE SandFill_SetFill

SandFill_FirstRow:
	LDA #CHNGTILE_QUICKSAND_TOP9
	
SandFill_SetFill:
	JSR SandFill_ChangeTile

	; Calculate tile detection X offsets
	LDA <Objects_X,X
	ADD <Temp_Var8
	STA ObjTile_DetXLo
	LDA <Objects_XHi,X
	ADC <Temp_Var9
	STA ObjTile_DetXHi

	JSR Object_DetectTileManual
	JSR SandFill_CheckTileSolidity_Lim	; BGE jump means 'hit solid', so BLT is false case
	BLT SandFill_SkipTile	; If we haven't hit a solid wall, jump to SandFill_SkipTile

	; Tile-side index -> 'Y'
	LDY <Temp_Var5

	; Stop this direction
	LDA Objects_Var1,X
	ORA SandFill_StopBits,Y
	STA Objects_Var1,X

	; Cancel tile change
	LDY #0
	STY Level_ChgTileEvent

	AND #%11000000
	CMP #%11000000
	BNE SandFill_SkipTile

	; This row has ended, need to reset and move up one
	LDA #0
	STA Objects_Var1,X
	STA Objects_Var6,X
	STA Objects_Var7,X

	; Next row!
	INC Objects_Var3,X

	; One less row to the op...
	DEC Objects_Var2,X

SandFill_SkipTile:	

	LDA Level_ChgTileEvent
	CMP #(CHNGTILE_SANDTOPMID | $80)	; Changing attribute flag is set
	BNE SandFill_NotUsingBigChange	; Only concerned if trying to do CHNGTILE_SANDTOPMID...

	LDA ObjTile_DetYLo
	ADD #16
	STA ObjTile_DetYLo
	LDA ObjTile_DetYHi
	ADC #0
	STA ObjTile_DetYHi
	JSR Object_DetectTileManual


	CMP #TILE9_QUICKSAND_TOP
	BEQ SandFill_NotUsingBigChange

	LDA #(CHNGTILE_QUICKSAND_TOP9 | $80)
	STA Level_ChgTileEvent

SandFill_NotUsingBigChange:
	; Toggle side
	LDA Objects_Var3,X
	EOR #$80
	STA Objects_Var3,X
		
	RTS

	; Multiplying by 16, lower byte -> Temp_Var8, higher byte -> Temp_Var9
SandFill_Mul16:
	PHA
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var8
	
	PLA
	ASR A
	ASR A
	ASR A
	ASR A
	STA <Temp_Var9
	RTS

SandFill_OweMidChange:

	; We need to change the tile below to a sand mid tile to make everything look right
	LDA #0
	STA <Temp_Var1
	STA <Temp_Var2
	STA <Temp_Var3
	STA <Temp_Var4

	LDA #CHNGTILE_QUICKSAND_MID9
	JSR SandFill_ChangeTile
	
	; Resume normal operations
	LDA #2
	STA <Objects_Var4,X
	
	RTS
	
SandFill_WaitPlug:

	JSR SandFill_CheckPlugSolid
	BGE SandFill_WaitActivation		; If not on a solid tile, not plugged, jump to SandFill_WaitActivation

	; Start dumping!
	LDA #2
	STA <Objects_Var4,X

SandFill_WaitActivation:
	JMP Object_DeleteOffScreen_N4

SandFill_CheckPlugSolid:
	LDA <Objects_X,X
	STA ObjTile_DetXLo
	LDA <Objects_XHi,X
	STA ObjTile_DetXHi
	LDA <Objects_Y,X
	STA ObjTile_DetYLo
	LDA <Objects_YHi,X
	STA ObjTile_DetYHi

	JSR Object_DetectTileManual
	JMP SandFill_CheckTileSolidity

ObjInit_Totomesu:

	LDA #MUS2B_BOSS
	STA Sound_QMusic2

	LDA #$30
	STA Objects_HitCount,X

	LDA #$80
	STA Objects_Timer,X

	INC Objects_IsGiant,X
	INC Objects_Frame,X

	RTS

ObjNorm_Totomesu:
	JSR Totomesu_Draw

	LDA <Player_HaltGame
	BNE Totomesu_StillFlashing	; If gameplay halted, jump to Totomesu_StillFlashing

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ Totomesu_NotDying

	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDA #$FF
	STA Objects_SpriteX,X
	STA Objects_SpriteY,X
	
	LDA #0
	STA <Objects_XVel,X
	STA <Objects_YVel,X

	LDA <Objects_Var5,X
	CMP #4
	BGE Totomesu_NotDying

	JMP Totomesu_Kill

Totomesu_NotDying:

	JSR Totomesu_Move

	LDA <Objects_Var5,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Totomesu_Normal		; 0: Totomesu spit fire attack
	.word Totomesu_MouthOpen	; 1: Shut yo mouth
	.word Totomesu_Leap			; 2: Leap to the other side!
	.word Totomesu_WaitLeapLand	; 3: Waiting for leap landing
	.word Totomesu_Die			; 4: Flash and then kick off
	.word Totomesu_FallWait		; 5: Waiting to fall off-screen
	.word Totomesu_EndLevel		; 6: Count out time for exit...
	.word Totomesu_DeadTimeout	; 7: Same old stuff...

Totomesu_EndLevel:
	JMP_THUNKA 42, Mouser_EndLevel

Totomesu_DeadTimeout:
	JMP_THUNKA 42, Mouser_DeadTimeout
		
Totomesu_Die:

	LDA #1
	STA Objects_Frame,X

	LDA #0
	STA <Objects_YVel,X
	LDA #0
	STA <Objects_XVel,X

	LDA Objects_ColorCycle,X
	BNE Totomesu_StillFlashing

	; Okay!
	LDA #-$20
	STA <Objects_YVel,X
	
	LDA #SND_PLAYERKICK
	STA Sound_QPlayer

	INC <Objects_Var5,X

Totomesu_StillFlashing:
	RTS

Totomesu_FallWait:
	
	LDA <Objects_YHi,X
	BEQ Totomesu_StillFlashing
	LDA <Objects_Y,X
	CMP #$B0
	BLT Totomesu_StillFlashing

	LDA World_Num
	CMP #9
	BEQ Totomesu_NoFanfare	; No fanfare on World Zero

	; Victory fanfare
	LDA Sound_QMusic1
	ORA #MUS1_BOSSVICTORY
	STA Sound_QMusic1

Totomesu_NoFanfare:
	INC <Objects_Var5,X
	
	RTS


Totomesu_Normal:
	LDA Objects_Timer,X
	BNE Totomesu_NoSpit	; If timer not expired, jump to Totomesu_NoSpit

	LDA #$10
	STA Objects_Timer,X

	LDA RandomN
	AND #$3F
	ADD $20
	NEG
	STA <Objects_YVel,X

	JSR Totomesu_SpitFire
	
	LDA #1
	STA Objects_Frame,X
	INC <Objects_Var5,X

Totomesu_NoSpit:
	RTS

Totomesu_MouthOpen:
	LDA Objects_Timer,X
	BNE Totomesu_NoSpit
	
	LDA #$80
	STA Objects_Timer,X
	
	LDA #0
	STA Objects_Frame,X
	DEC <Objects_Var5,X

	RTS

Totomesu_FireSpitXVel:	.byte $20, -$20

Totomesu_SpitFire:
	LDY <SlotIndexBackup
	JSR PrepareNewObjectOrAbort
		
	LDA #SND_LEVELFLAME
	STA Sound_QLevel2
	
	LDA #OBJ_BOSSATTACK
	STA Level_ObjectID,X

	; Set object state to normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDA Objects_X,Y
	ROL A
	ROL A
	AND #1
	TAY
	LDA Totomesu_FireSpitXVel,Y
	STA <Objects_XVel,X
	LDY <SlotIndexBackup

	LDA Objects_X,Y
	ADD #8
	STA <Objects_X,X
	LDA Objects_XHi,Y
	ADC #0
	STA <Objects_XHi,X
	
	LDA Objects_Y,Y
	ADD #12
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	ADC #0
	STA <Objects_YHi,X

	LDA #$02
	STA <Objects_Var5,X
	STA <Objects_Var4,X

	LDA #SPR_PAL1
	STA Objects_SprAttr,X

	LDX <SlotIndexBackup
	RTS		 ; Return

Totomesu_Move:
	JSR Object_Move
	
	LDA <Objects_Var5,X
	CMP #3
	BLT Totomesu_StillAlive
	
	; Dying...
	RTS
	
Totomesu_StillAlive:
	LDA Objects_DetStat,X
	AND #$04
	BEQ Totomesu_NotHitFloor

	LDA Objects_Var1,X
	BNE Totomesu_AlreadyOnFloor

	LDA <Player_InAir
	BNE Totomesu_NotGroundFX	 ; If Player is in the air, jump to PRG004_AA2F

	INC <Player_InAir ; Flag Player as in the air ...

	; "Vibrationally disable" Player
	LDA #$20
	STA Player_VibeDisable

	; Bounce Player a little
	LDA #-$10
	STA <Player_YVel

	DEC <Player_Y	 ; Player_Y--

	LDY <Player_Y	; Y = Player_Y
	INY		; Reset the Y back to where it was
	BNE Totomesu_NotGroundFX	; If the Player's Y low was not zero, we have nothing to worry about; jump to PRG004_AA2F

	DEC <Player_YHi	 ; Otherwise, we essentially have a carry (but DEC doesn't set carry)

Totomesu_NotGroundFX:

	; Vibrate level!
	LDA #$0c
	STA Level_Vibration

	; Ba-boom! sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA #0
	STA Objects_Frame,X

	INC Objects_Var1,X

Totomesu_AlreadyOnFloor:
	JSR Object_HitGround
	JMP Totomesu_Cont

Totomesu_NotHitFloor:

	; Flag as not on floor
	LDA #0
	STA Objects_Var1,X

Totomesu_Cont:
	LDA Objects_ColorCycle,X
	BNE Totomesu_PlayerNoHit

	JSR Object_HandleBumpUnderneath

	LDA Objects_PlayerHitStat,X
	BEQ Totomesu_PlayerNoHit	 ; If Player is not hitting Totomesu at all, jump to Totomesu_PlayerNoHit (RTS)

	LDA <Player_YVel
	BMI Totomesu_PlayerNoHit	 ; If Player is moving upward, jump to Totomesu_PlayerNoHit (RTS)

	; Play squish sound
	LDA #SND_PLAYERSWIM
	STA Sound_QPlayer

	; Get 1000, 2000, or 4000 points
	INC Objects_Var2,X
	LDA Objects_Var2,X	; 1, 2, 3
	ADD #$08
	JSR Score_PopUp

	; Player Y Vel = -$30 (bounce off)
	LDA #-$30
	STA <Player_YVel
	
	LDA Objects_Var2,X	; 1, 2, 3
	CMP #3
	BLT Totomesu_NotDead

	; 3 stomps, we're done
	; Dead!

Totomesu_Kill:	
	LDA #4
	STA <Objects_Var5,X

	JSR_THUNKA 42, Boss_DestroyOtherObjects

	LDA #1
	STA Level_TimerEn

	LDA #$80
	STA Objects_ColorCycle,X

	RTS

Totomesu_NotDead:
	LDA #$FF
	STA Objects_ColorCycle,X
	
	; Jump to state 2
	LDA #2
	STA <Objects_Var5,X
	
	LDA #$40
	STA Objects_Timer,X

Totomesu_PlayerNoHit:
	RTS

Totomesu_LeapXVel:	.byte $40, -$40

Totomesu_Leap:
	LDA Objects_Timer,X
	BNE Totomesu_NoLeapYet

	; Leap at timer expiration based on side of screen
	LDA <Objects_X,X
	ROL A
	ROL A
	AND #1
	TAY
	LDA Totomesu_LeapXVel,Y
	STA <Objects_XVel,X
	
	LDA #-$50
	STA <Objects_YVel,X

	INC <Objects_Var5,X
	LDA #1
	STA Objects_Frame,X

Totomesu_NoLeapYet:
	RTS

Totomesu_WaitLeapLand:
	LDA <Objects_X,X
	CMP #8
	BGE Totomesu_NotOutboundLeft

	; Out of bounds left...
	LDA #8
	STA <Objects_X,X
	LDA #0
	STA <Objects_XVel,X

Totomesu_NotOutboundLeft:
	CMP #224
	BLT Totomesu_NotOutboundRight
	
	LDA #224
	STA <Objects_X,X
	LDA #0
	STA <Objects_XVel,X
	
Totomesu_NotOutboundRight:

	LDA Objects_DetStat,X
	AND #$04
	BEQ Totomesu_NotLanded

	LDA #0
	STA <Objects_Var5,X
	STA <Objects_XVel,X
	STA <Objects_YVel,X

Totomesu_NotLanded:
	RTS

Totomesu_Draw:

	LDA <Objects_X,X
	AND #$80
	EOR #$80
	LSR A
	STA Objects_FlipBits,X	

	LDA <Objects_X,X
	PHA
	ADD #16
	STA <Objects_X,X
	LDA <Objects_XHi,X
	PHA
	ADC #0
	STA <Objects_XHi,X

	LDA <Objects_Y,X
	PHA
	ADD #16
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	PHA
	ADC #0
	STA <Objects_YHi,X

	LDA Objects_Frame,X
	ASL A
	ADD #(Totomesu_Rump - ObjectGrExt_PatternSets)
	PHA

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of Totomesu's butt sprites
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of Totomesu's butt sprites
	JSR Object_ShakeAndCalcSprite

	PLA
	TAX

	TYA
	ADD #16
	TAY
	JSR Object_Draw16x16Sprite
	LDX <SlotIndexBackup

	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	LDY #2
	JSR Object_DetermineHorzVisY	 ; Determine horizontal visibility of Totomesu's sprites
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of Totomesu's sprites
	JSR Object_Draw16x32Sprite

	LDA Objects_FlipBits,X	
	AND #SPR_HFLIP
	BEQ Totomesu_NotHFlipped
	
	; HFlip: Reverse sprite patterns regular drill...
	LDY Object_SprRAM,X
		
	LDA Sprite_RAM+$09,Y
	PHA
	LDA Sprite_RAM+$11,Y
	STA Sprite_RAM+$09,Y
	PLA
	STA Sprite_RAM+$11,Y

	LDA Sprite_RAM+$0D,Y
	PHA
	LDA Sprite_RAM+$15,Y
	STA Sprite_RAM+$0D,Y
	PLA
	STA Sprite_RAM+$15,Y

	; NOT SAFE
	LDA Sprite_RAM+$03,Y
	ADD #16
	STA Sprite_RAM+$03,Y
	LDA Sprite_RAM+$07,Y
	ADD #16
	STA Sprite_RAM+$07,Y
	
Totomesu_NotHFlipped:
	RTS
	
ObjInit_Clyde:
	INC Objects_IsGiant,X

	LDA #$40
	STA Objects_HitCount,X

	RTS
	
ObjNorm_Clyde:
	JSR Level_ObjCalcXDiffs

	; Face Player
	LDA Misc_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	JSR Cylde_Draw

	LDA <Player_HaltGame
	BNE Totomesu_NotHFlipped	; If gameplay halted, jump to Totomesu_NotHFlipped (RTS)

	JSR Clyde_Common

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ Clyde_NotDying

	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDA #$FF
	STA Objects_SpriteX,X
	STA Objects_SpriteY,X
	
	LDA #0
	STA <Objects_XVel,X
	STA <Objects_YVel,X

	LDA <Objects_Var5,X
	CMP #4
	BGE Clyde_NotDying

	JMP Clyde_Kill

Clyde_NotDying:

	LDA <Objects_Var5,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Clyde_Normal			; 0: Clyde spit fire attack
	.word Clyde_Hit				; 1: Clyde got stomped, flash a bit, then dive in the sand
	.word Clyde_DigSeek			; 2: Clyde digging around seeking player
	.word Clyde_Emerge			; 3: Clyde lunges from the ground, then lands
	.word Clyde_Die				; 4: Oof!
	.word Clyde_FallWait		; 5: Dig down shamefully
	
Clyde_Normal:
	LDA Objects_Timer,X
	BNE Clyde_TimerAct

	; Timer reset
	LDA #$80
	STA Objects_Timer,X

Clyde_TimerAct:
	CMP #$40
	BGE Clyde_Slither

	AND #$08
	LSR A
	LSR A
	LSR A
	STA Objects_Frame,X	; Open/close mouth
	BEQ Clyde_DoNothing

	LDA Objects_Timer,X
	AND #7
	BNE Clyde_DoNothing
	
	LDA #SND_PLAYERFIRE
	STA Sound_QPlayer

	JSR Clyde_SpitFire

Clyde_DoNothing:
	RTS
	
Clyde_Slither:

	LDY #2
	JMP Clyde_SeekPlayer
	
Clyde_Hit:
	LDA Objects_Timer,X
	BEQ Clyde_InSand
	
	CMP #$20
	BGE Clyde_Gasp

	LDA #0
	STA Objects_Frame,X
	STA Objects_ColorCycle,X
	
Clyde_DigDown:
	JSR Clyde_DigPoofEffect

	LDA #(SPR_PAL3 | SPR_BEHINDBG)
	STA Objects_SprAttr,X

	; Dive in the sand!
	INC <Objects_YVel,X
	JSR Object_ApplyYVel
	
	JMP Clyde_DoNothing

Clyde_DigPoofEffect:
	LDA SndCur_Level2
	BNE Clyde_NoDigSound
	
	LDA #SND_BOOMERANG
	STA Sound_QLevel2

	LDY #0
	JSR Clyde_DigPoof
	INY
	JSR Clyde_DigPoof

Clyde_NoDigSound:
	LDA <Objects_X,X
	STA SpecialObj_XLo
	ADD #16
	STA SpecialObj_XLo+1
	

	RTS

;Clyde_DigPoof_XOff:	.byte 4, 12

Clyde_DigPoof:	
	;LDA <Objects_X,X
	;ADD Clyde_DigPoof_XOff,Y
	;STA SpecialObj_XLo,Y
		
	LDA #$98
	STA SpecialObj_YLo,Y
	LDA #1
	STA SpecialObj_YHi,Y

	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y

	; Poof counter"
	LDA #$17
	STA SpecialObj_Data,Y

	RTS

Clyde_Gasp:
	LDA #2
	STA Objects_Frame,X

	RTS

Clyde_InSand:
	LDA #0
	STA <Objects_YVel,X
	INC <Objects_Var5,X
	
	LDA #$C0
	STA Objects_Timer,X	
	
	RTS

Clyde_SpitFireXOff:	.byte 3, 24

Clyde_SpitFire:
	; X offset
	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	ROL A
	ROL A
	ROL A
	TAY
	LDA Clyde_SpitFireXOff,Y
	STA <Temp_Var1

	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot or don't come back!

	LDA <Objects_X,X
	ADD <Temp_Var1
	STA SpecialObj_XLo,Y

	; Y offset
	LDA #0
	STA <Temp_Var1

	; Venus fire trap code is good enough for me!
	JSR_THUNKA 5, Clyde_SpitFire5

	LDA SpecialObj_XVel,Y
	ASL A
	STA SpecialObj_XVel,Y
	LDA SpecialObj_YVel,Y
	ASL A
	STA SpecialObj_YVel,Y
	
	RTS

Clyde_DigSeek_XVel:	.byte -$18, $18, -$04, $04

Clyde_DigSeek:
	LDA Objects_Timer,X
	BEQ Clyde_Lunge

	JSR Clyde_DigPoofEffect
	
	LDY #0
	JSR Clyde_SeekPlayer
	
	RTS
	
Clyde_SeekPlayer:
	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15
	ADD #2
	BPL Clyde_DigSeek_Right

	INY

Clyde_DigSeek_Right:
	LDA Clyde_DigSeek_XVel,Y
	STA <Objects_XVel,X
	
	JSR Object_ApplyXVel

	RTS

Clyde_Lunge:
	LDA #SND_LEVELAIRSHIP
	STA Sound_QLevel2

	LDA #-$70
	STA <Objects_YVel,X
	LDA #0
	STA <Objects_XVel,X

	INC <Objects_Var5,X

	RTS

Clyde_Emerge:
	JSR Object_Move
	LDA Objects_DetStat,X
	AND #04
	BEQ Clyde_EmergeNotOnFloor
	
	JSR Object_HitGround
	
	LDA #0
	STA <Objects_Var5,X

	LDA #$40
	STA Objects_Timer,X

Clyde_EmergeNotOnFloor:
	RTS

Cylde_Draw:
	JSR Object_ShakeAndCalcSprite
	
	; Clyde's head
	JSR Object_Draw16x16Sprite
	
	; Clyde's upper body
	TYA
	ADD #8
	TAY

	; X+=16
	LDA <Temp_Var2
	ADD #16
	STA <Temp_Var2

	LDX #(Clyde_Body - ObjectGrExt_PatternSets)
	JSR Object_Draw16x16Sprite

	; Clyde's lower body
	TYA
	ADD #8
	TAY

	; Y+=16
	LDA <Temp_Var1
	ADD #16
	STA <Temp_Var1

	LDA <Counter_1
	AND #8
	BNE Clyde_Tail2

	INX
	INX
	
Clyde_Tail2:
	INX
	INX
	JSR Object_Draw16x16Sprite
	
	LDA <Temp_Var3
	AND #SPR_HFLIP
	BEQ Cylde_NoHFlip
	
	; 'Y' (sprite index) is currently set for lower body
	
	; H-Flip lower body
	LDA Sprite_RAM+$03,Y
	SUB #16
	STA Sprite_RAM+$03,Y
	LDA Sprite_RAM+$07,Y
	SUB #16
	STA Sprite_RAM+$07,Y
	
	; H-Flip upper body
	LDA Sprite_RAM-$0F,Y	; $0F, $0B, $07, $03
	PHA
	LDA Sprite_RAM-$07,Y
	STA Sprite_RAM-$0F,Y
	PLA
	STA Sprite_RAM-$07,Y

	LDA Sprite_RAM-$0B,Y
	PHA
	LDA Sprite_RAM-$03,Y
	STA Sprite_RAM-$0B,Y
	PLA
	STA Sprite_RAM-$03,Y
	
Cylde_NoHFlip:
	; Clyde's belly
	JSR Object_GetRandNearUnusedSpr
	BEQ CyldeDraw_NoFreeSpr
	
	; Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y
	
	; Pattern
	LDA #$AD
	STA Sprite_RAM+$01,Y
	
	; Palette
	LDA <Temp_Var3
	ORA <Temp_Var4
	STA Sprite_RAM+$02,Y
	
	; X
	CLC
	LDA <Temp_Var3
	AND #SPR_HFLIP
	ROL A
	ROL A
	ROL A	; 0/1
	TAX
	
	LDA <Temp_Var2
	ADD ClydeFlipGut_XOff,X
	STA Sprite_RAM+$03,Y
	
CyldeDraw_NoFreeSpr:
	LDX <SlotIndexBackup
	RTS

ClydeFlipGut_XOff:	.byte -8, 0

Clyde_Common:
	LDA Objects_ColorCycle,X
	BNE Clyde_PlayerNoHit

	LDA <Objects_Var5,X
	CMP #4
	BGE Clyde_PlayerNoHit	; If in death throes, jump to Clyde_PlayerNoHit

	JSR Object_HandleBumpUnderneath

	LDA Objects_PlayerHitStat,X
	BEQ Clyde_PlayerNoHit	 ; If Player is not hitting Clyde at all, jump to Clyde_PlayerNoHit (RTS)

	LDA <Objects_Var5,X
	BNE Clyde_HurtPlayer	; If not in "normal" state, hurt player!

	LDA <Player_YVel
	BMI Clyde_PlayerNoHit	 ; If Player is moving upward, jump to Clyde_PlayerNoHit (RTS)

	; Play squish sound
	LDA #SND_PLAYERSWIM
	STA Sound_QPlayer

	; Get 1000, 2000, or 4000 points
	INC Objects_Var2,X
	LDA Objects_Var2,X	; 1, 2, 3
	ADD #$08
	JSR Score_PopUp

	; Player Y Vel = -$30 (bounce off)
	LDA #-$30
	STA <Player_YVel
	
	LDA Objects_Var2,X	; 1, 2, 3
	CMP #3
	BLT Clyde_NotDead

	; 3 stomps, we're done
	; Dead!

Clyde_Kill:	
	LDA #4
	STA <Objects_Var5,X

	JSR_THUNKA 42, Boss_DestroyOtherObjects

	LDA #1
	STA Level_TimerEn

	LDA #$80
	STA Objects_ColorCycle,X

	RTS

Clyde_NotDead:
	LDA #$FF
	STA Objects_ColorCycle,X
	
	; Jump to state 1
	LDA #1
	STA <Objects_Var5,X
	
	LDA #$40
	STA Objects_Timer,X

Clyde_PlayerNoHit:
	RTS

Clyde_HurtPlayer:
	JMP Player_GetHurt

Clyde_Die:

	LDA #2
	STA Objects_Frame,X

	LDA #0
	STA <Objects_YVel,X
	LDA #0
	STA <Objects_XVel,X

	LDA Objects_ColorCycle,X
	BNE Clyde_StillFlashing

	LDA #3
	STA Objects_Frame,X

	; Okay!	
	INC <Objects_Var5,X

	LDA #$20
	STA Objects_Timer,X

Clyde_StillFlashing:
	RTS

Clyde_FallWait:
	JSR Clyde_DigDown

	LDA Objects_Timer,X
	BNE Clyde_StillFlashing
	
	JMP Object_Delete

ObjInit_DelfinoSlots:
	JMP_THUNKA 42, ObjInit_DelfinoSlots42
	
ObjNorm_DelfinoSlots:
	JMP_THUNKA 42, ObjNorm_DelfinoSlots42

ObjHit_DelfinoSlots:
	JMP_THUNKA 42, ObjHit_DelfinoSlots42

DelfinoSlot_DrawSlot:
	; Temp_Var1 is the Y offset
	
	LDA <Objects_Y,X
	PHA
	ADD <Temp_Var1
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	PHA
	ADC #0
	STA <Objects_YHi,X

	JSR Object_DetermineHorzVis
	JSR Object_DetermineVertVis
	JSR Object_ShakeAndCalcSprite

	LDX <SlotIndexBackup	; X = object slot index

	; Restore Y
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	LDA <Temp_Var13
	ASL A		 
	ADD #(ObjPF0 - ObjectGrExt_PatternSets)
	STA <Temp_Var6	 ; Temp_Var6 += object's frame
	TAX		 ; -> 'X'

	; Top sprite
	LDA <Temp_Var9
	STA <Temp_Var4
	LDY <Temp_Var11
	JSR Object_Draw16x16Sprite	 ; Draw sprite

	LSR <Temp_Var5	 ; Objects_SprVVis

	; 'Y' += 8 (Sprite RAM 2 sprites over)
	TYA
	ADD #$08
	TAY	

	LDA <Temp_Var14
	ASL A		 
	ADD #(ObjPF0 - ObjectGrExt_PatternSets)
	STA <Temp_Var6	 ; Temp_Var6 += object's frame
	TAX		 ; -> 'X'

	LDA #16
	ADD <Temp_Var1	 ; Sprite Y
	STA <Temp_Var1	 ; Temp_Var1 += 16

	; Bottom sprite
	LDA <Temp_Var10
	STA <Temp_Var4
	LDY <Temp_Var12
	JSR Object_Draw16x16Sprite	 ; Draw sprite

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA <Player_YVel
	BPL DelfinoReel_PlayerNotUpward

	JSR Object_HitTestRespond

DelfinoReel_PlayerNotUpward:
	RTS		 ; Return

PinataToss_XVel:	.byte $70, -$70

ObjNorm_Pinata:
	JSR Object_DeleteOffScreen
	JSR Object_Draw16x32Sprite
	JSR Object_HitTestRespond

	LDA <Objects_Var4,X
	BEQ Pinata_TossWait
	
	; Tossing...
	
	LDA Objects_Timer,X
	BNE Pinata_DoNothing
	
	LDA Objects_Frame,X
	CMP #1
	BNE Pinata_Toss		; If not on frame 1 (presumably 2), jump to Pinata_Toss
	
	; Reset timer
	LDA #$20
	STA Objects_Timer,X
	
	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	ROL A
	ROL A
	ROL A
	TAY
	LDA PinataToss_XVel,Y
	STA <Player_XVel
	LDA #$-70
	STA <Player_YVel
	STA Player_InAir

	LDA #SND_LEVELAIRSHIP
	STA Sound_QLevel2

	LDA <Vert_Scroll
	CMP #$EF
	BNE PinataToss_NotBottom

	DEC <Vert_Scroll

PinataToss_NotBottom:
	LDA #1
	STA Player_GravityEffect

	LDA #0
	STA Player_HaltTick
		
	; Go to frame 2
	INC Objects_Frame,X
	BNE Pinata_DoNothing
	
Pinata_Toss:
	LDA #0
	STA Objects_Frame,X
	STA <Objects_Var4,X

	; Cool down
	LDA #$40
	STA Objects_Timer,X

	BNE	Pinata_DoNothing

Pinata_TossWait:
	; Face Player
	JSR Level_ObjCalcXDiffs
	LDA Misc_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

Pinata_DoNothing:
	RTS

ObjHit_Pinata:
	;LDA Player_HaltTick
	;BEQ Pinata_NoUpdateFace

	;LDA <Pad_Holding
	;AND #%00000011
	;TAY

	;LDA Misc_FlipTowardsPlayer-1,Y
	;STA Objects_FlipBits,X

;Pinata_NoUpdateFace:
	LDA Objects_Timer,X
	BNE Pinata_AlreadyTossing

	LDA <Objects_Var4,X
	BNE Pinata_AlreadyTossing
	
	; Begin tossing
	INC <Objects_Var4,X
	INC Objects_Frame,X

	LDA #$ff
	STA Player_HaltTick
	
	LDY #PF_SLIDE_SMALL
	LDA <Player_Suit
	BEQ Pinata_ThrowSmall
	
	LDY #PF_SLIDE_BIG
	
Pinata_ThrowSmall:
	STY Player_Frame
	
	LDA Objects_FlipBits,X
	STA Player_FlipBits
	
	;LDA <Objects_X,X
	;ADD #8
	;STA <Player_X
	;LDA <Objects_XHi,X
	;ADC #0
	;STA <Player_XHi
	
	LDA <Objects_Y,X
	SUB #8
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #0
	STA <Player_YHi

	LDA #$20
	STA Objects_Timer,X
	
Pinata_AlreadyTossing:
	RTS

ObjInit_Petey:

	; Give Petey 10 fireball hits
	LDA #10
	STA Objects_HitCount,X

	INC Objects_IsGiant,X

	RTS

ObjNorm_Petey:
	JMP_THUNKA 42, ObjNorm_Petey42

ObjInit_Magiblot:
	LDA #249
	STA PatTable_BankSel+4

	INC Objects_IsGiant,X

	TXA
	AND #1
	STA Objects_Var2,X

	RTS
	
	
	; Var1 - Hand position
	; Var2 - Horizontal player seek 4 / -4
	; Var3 - Vertical player seek
ObjNorm_Magiblot:
	LDA <Objects_Var5,X
	CMP #2
	BLT Magiblot_NoDrawState

	JSR Magiblot_Draw
	
Magiblot_NoDrawState:
	LDA <Player_HaltGame
	BNE Magiblot_Halted

	LDA <Objects_Var5,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Magiblot_PrepSeek		; 0: Prepare to seek
	.word Magiblot_Seek			; 1: Magiblot seeking landing spot
	.word Magiblot_PrepAppear	; 2: Preparing to appear
	.word Magiblot_Appear		; 3: Magiblot appearing!
	.word Magiblot_PoofUp		; 4: Magiblot de-balling
	.word Magiblot_Fire			; 5: Fire at Player!
	.word Magiblot_Wait			; 6: Magiblot wait a second
	.word Magiblot_PoofDown		; 7: Magiblot balling
	.word Magiblot_PrepAppear	; 8: Preparing to disappear
	.word Magiblot_Appear		; 9: Magiblot disappearing!
	.word Magiblot_WaitToVanish	; 10: 

Magiblot_Halted:
	RTS

	
Magiblot_HOffset:	.byte 4 * 16, -2 * 16
Magiblot_HOffsetHi:	.byte $00,    $FF
Magiblot_VOffset:	.byte 0 * 16, 1 * 16, -1 * 16, 2 * 16, -2 * 16, 3 * 16, -3 * 16, 4 * 16, -4 * 16, 5 * 16, -5 * 16, 6 * 16, -6 * 16
Magiblot_VOffsetHi:	.byte $00,    $00,    $FF,     $00,    $FF,     $00,    $FF,     $00,    $FF,     $00,    $FF,     $00,    $FF

Magiblot_PrepSeek:
	LDA Objects_Timer,X
	BNE MPS_StillTimering

	LDA Objects_Var2,X
	EOR #1
	STA Objects_Var2,X
	
	LDA #-1		; Starting at -1 due to preincrement
	STA Objects_Var3,X

	; Next state
	INC <Objects_Var5,X
	
MPS_StillTimering:
	RTS

Magiblot_Seek:
	; Pick a space +4 / -4 tiles from Mario (alternate)
	; Starting in middle, scan 4 rows above then 4 rows below looking for a solid tile
	; If solid found, make sure clearance of two tiles above as not solid
	; Whichever of the finds is closer to Mario vertically, go with it
	
	
	; Offset from Player's X
	LDY Objects_Var2,X

	LDA <Player_X
	ADD Magiblot_HOffset,Y
	AND #$F0
	STA ObjTile_DetXLo
	LDA <Player_XHi
	ADC Magiblot_HOffsetHi,Y
	STA ObjTile_DetXHi
	
	; Offset from Player's Y
	LDA Objects_Var3,X
	ADD #1
	CMP #(Magiblot_VOffsetHi - Magiblot_VOffset)
	BGE Magiblot_Reset		; If out of range vertical checks, jump to Magiblot_Reset
	
	STA Objects_Var3,X
	TAY
	
	LDA <Player_Y
	ADD Magiblot_VOffset,Y
	AND #$F0
	STA ObjTile_DetYLo
	LDA <Player_YHi
	ADC Magiblot_VOffsetHi,Y
	STA ObjTile_DetYHi
	
	JSR Magiblot_CheckAndMoveUp
	BLT Magiblot_NotAcceptable		; If checked tile is NOT solid, jump to Magiblot_NotAcceptable
	
	JSR Magiblot_CheckAndMoveUp
	BGE Magiblot_NotAcceptable		; If tile above check IS solid, jump to Magiblot_NotAcceptable

	JSR Magiblot_CheckAndMoveUp
	BGE Magiblot_NotAcceptable		; If tile above check IS solid, jump to Magiblot_NotAcceptable
	
	; Found a landing spot!
	
	LDA ObjTile_DetXLo
	STA <Objects_X,X
	LDA ObjTile_DetXHi
	STA <Objects_XHi,X
	LDA ObjTile_DetYLo
	ADD #16
	STA <Objects_Y,X
	LDA ObjTile_DetYHi
	ADC #0
	STA <Objects_YHi,X
	
	; Next state (appear)
	INC <Objects_Var5,X
	RTS
	
Magiblot_Reset:
	; Previous state (reset)
	DEC <Objects_Var5,X
	
Magiblot_NotAcceptable:
	RTS

Magiblot_CheckAndMoveUp:
	JSR Object_DetectTileManual
	JSR Magiblot_CheckTileSolidity
	PHP

	LDA ObjTile_DetYLo
	SUB #16
	STA ObjTile_DetYLo
	LDA ObjTile_DetYHi
	SBC #0
	STA ObjTile_DetYHi
	
	PLP
	RTS

Magiblot_Draw:
	JSR Object_DetermineHorzVis
	JSR Object_DetermineVertVis
	JSR Object_ShakeAndCalcSprite
	
	TYA
	ADD #8
	TAY
	
	JSR Object_Draw16x32SpriteCS
		
	LDX <SlotIndexBackup
	LDA Objects_Frame,X
	CMP #2
	BNE Magiblot_NoHands	; Only frame 2 has the hands!
	
	; Var1 is hand position, multiply by 4
	LDA Objects_Var1,X
	ASL A
	ASL A
	TAX
	
	; Draw hands...
	JSR Magiblot_DrawHands
	
Magiblot_NoHands:
	LDX <SlotIndexBackup
	RTS

Magiblot_DrawHands:
	; Sprite offset (0 or 4)
	LDA #0
	STA <Temp_Var5
	
	JSR Magiblot_HandLoop
	
	INX
	INX

	; Next sprite
	LDA #4
	STA <Temp_Var5
	
Magiblot_HandLoop:
	
	; X offset
	LDA Magiblot_HandXOff,X
	STA <Temp_Var1
	LDA Magiblot_HandXOff+1,X
	STA <Temp_Var2
	
	; Y offset
	LDA Magiblot_HandYOff,X
	STA <Temp_Var3
	LDA Magiblot_HandYOff+1,X
	STA <Temp_Var4
	
	TXA
	PHA
	
	JSR Magiblot_DrawHand
	
	PLA
	TAX
	
	RTS

	; With left hand at smaller radius than right,
	; turn down, then back up, like he's "throwing"
	
Magiblot_HandXOff:
	; 	Left	Right
	.word -$08,	 $10		; 0
	.word -$0A,  $12		; 1
	.word -$09,  $10		; 2
	.word -$0C,  $08		; 3
	.word -$0F,  $04		; 4
	.word -$11,	-$04		; 5

Magiblot_HandYOff:
	; 	Left	Right
	.word  $08,  $08		; 0
	.word  $06,  $04		; 1
	.word -$01, -$02		; 2
	.word -$02, -$05		; 3
	.word -$03, -$07		; 4
	.word  $06,  $06		; 5

Magiblot_DrawHand:	
	LDX <SlotIndexBackup

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ Magiblot_NoHFlipHand

	LDA #8
	SUB <Temp_Var1
	STA <Temp_Var1
	LDA #0
	SBC <Temp_Var2
	STA <Temp_Var2

Magiblot_NoHFlipHand:
	; Calc relative X for hand
	LDA <Objects_X,X
	ADD <Temp_Var1
	STA <Temp_Var10		; X
	LDA <Objects_XHi,X
	ADC <Temp_Var2
	STA <Temp_Var11		; XHi

	; Calc relative Y for hand
	LDA <Objects_Y,X
	ADD <Temp_Var3
	STA <Temp_Var12		; Y
	LDA <Objects_YHi,X
	ADC <Temp_Var4
	STA <Temp_Var13		; YHi

	LDY #$F8

	LDA <Temp_Var10
	CMP <Horz_Scroll
	LDA <Temp_Var11
	SBC <Horz_Scroll_Hi
	BNE Magiblot_HandOffH	 ; If sprite is horizontally off-screen

	LDA <Temp_Var12
	ADD #16
	PHA		 ; Save object Y + 16

	LDA <Temp_Var13
	ADC #$00	 ; Apply carry
	STA <Temp_Var14	 ; -> Temp_Var14

	PLA		 ; Restore special object Y + 16

	CMP Level_VertScroll

	LDA <Temp_Var14
	SBC Level_VertScrollH
	STA <Temp_Var14	; Temp_Var14 = 0 if special object is on same screen...

	BNE Magiblot_HandOffH	 ; If Temp_Var14 <> 0 (not on same screen), jump to Magiblot_HandOffH


	LDA <Temp_Var12
	SUB <Vert_Scroll
	TAY

Magiblot_HandOffH:
	STY <Temp_Var12	; Y
	
	LDA Object_SprRAM,X
	ADD <Temp_Var5
	TAY

	LDA <Temp_Var12
	STA Sprite_RAM+$00,Y
	
	LDA #$8D
	STA Sprite_RAM+$01,Y

	LDA <Temp_Var5
	ASL A	; 8
	ASL A	; 10
	ASL A	; 20 
	ASL A	; 40
	ORA #SPR_PAL1
	STA Sprite_RAM+$02,Y

	LDA <Temp_Var10
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y
	
	LDX <SlotIndexBackup
	RTS


Magiblot_PrepAppear:
	LDA #0
	STA Objects_Frame,X

	LDA #-$30
	STA <Objects_YVel,X
	
	INC <Objects_Var5,X
	RTS

Magiblot_Appear:
	LDA <Objects_YHi,X
	CMP #2
	BGE Magiblot_TooLow

	JSR Object_Move

	LDA Objects_DetStat,X
	AND #$04
	BEQ Magiblot_NotOnFloor

	JSR Object_HitGround
	
Magiblot_TooLow:
	LDA #$10
	STA Objects_Timer,X
	
	INC <Objects_Var5,X

Magiblot_NotOnFloor:
	RTS


Magiblot_PoofUp:
	LDA Objects_Timer,X
	PHA
	AND #$07
	BNE Magiblot_NoChange
	
	INC Objects_Frame,X
	
Magiblot_NoChange:
	PLA
	BNE Magiblot_StillTimering

	LDA #$03
	STA Objects_Timer,X
	
	INC <Objects_Var5,X
	
Magiblot_StillTimering:
	RTS
	
	
Magiblot_Fire:
	JSR Object_HandleBumpUnderneath
	JSR Level_ObjCalcXDiffs

	; Face Player
	LDA Misc_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	LDA Objects_Timer,X
	BNE Magiblot_FireWait

	LDA #$03
	STA Objects_Timer,X
	
	INC Objects_Var1,X
	LDA Objects_Var1,X
	CMP #((Magiblot_HandYOff - Magiblot_HandXOff) / 4) - 1
	BLT Magiblot_FireWait

	JSR_THUNKA 3, Magiblot_ShootFire

	LDA #$1F
	STA Objects_Timer,X

	INC <Objects_Var5,X
Magiblot_FireWait:
	RTS


Magiblot_Wait:
	JSR Object_HandleBumpUnderneath	 ; Handle object getting hit from underside 

	LDA Objects_Timer,X
	BNE Magiblot_FireWait

	LDA #0
	STA Objects_Var1,X

	LDA #$10
	STA Objects_Timer,X
	
	INC <Objects_Var5,X

	RTS


Magiblot_PoofDown:
	LDA Objects_Timer,X
	PHA
	AND #$07
	BNE Magiblot_NoChange2
	
	DEC Objects_Frame,X
	
Magiblot_NoChange2:
	PLA
	BNE Magiblot_StillTimering2

	LDA #$03
	STA Objects_Timer,X
	
	INC <Objects_Var5,X
	
Magiblot_StillTimering2:
	RTS


Magiblot_WaitToVanish:
	LDA #0
	STA <Objects_Var5,X
	RTS
	
ObjInit_ArenaCtl:
	LDA Level_ArenaData
	CMP #$FF
	BNE OIAC_NotDone
	
	; Complete! Raise pipe...
	LDA #1
	STA Level_PipeRaiseData
	
	; Shhh
	LDA #$80
	STA Sound_QMusic1
	
	JMP Object_Delete
	
OIAC_NotDone:
	RTS


ArenaDest	.macro
	.byte \1	; Tileset
	.word \2	; Layout
	.word \3	; Object
	.byte \4	; Jct Y (mods the screen we're on)
	.byte \5	; Jct X (mods the screen we're on)
	.byte 0		; Reserved (pads to 8 bytes)
	.endm

Arena_Destinations:
	ArenaDest	 4, W2F1EL, W2F1EO, $20, $84 	; 0
	ArenaDest	 2, W2F2AL, W2F2AO, $60, $88 	; 1
	ArenaDest	 5, W3BBL,  W3BB2O, $60, $20 	; 2
	ArenaDest	 2, W4F1DL, W4F1DO, $60, $80 	; 3
	ArenaDest	 9, W5PB1L, W5PB1O, $50, $80 	; 4
	ArenaDest	 3, W6F2BossL, W6F2BossO, $50, $10 	; 5
	ArenaDest	 2, W7FBL, W7FBO, $50, $80 	; 6
	ArenaDest	15, W8BCastlCL, W8BCastlCO, $20, $8B 	; 7
	ArenaDest	15, WZFinalCL, WZFinalCO, $60, $70	; 8 (Used for returning from arena boss)
	ArenaDest	15, WZFinalCL, WZFinalCO, $50, $70	; 8 (Used for returning from arena boss final)

ObjNorm_ArenaCtl:

	; Calculate the pipe index based on Player's position
	
	; If result of this is negative, player is on "upper pipes"
	; Otherwise, lower pipes...
	LDA <Player_Y
	SUB <Objects_Y,X
	AND #$80
	LSR A
	LSR A
	STA <Temp_Var1
	
	LDA <Player_X
	AND #%11000000
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var1
	TAY		; Y = 0, 8, 16, ..., 56

	
	JSR ArenaCtl_SetDestination
	
	;LDA Arena_CompleteBit,Y

	RTS


ArenaCtl_SetDestination:
	; Tileset
	LDA Arena_Destinations,Y
	STA Level_AltTileset

	; Layout
	LDA Arena_Destinations+1,Y
	STA Level_AltLayout
	LDA Arena_Destinations+2,Y
	STA Level_AltLayout+1

	; Objects
	LDA Arena_Destinations+3,Y
	STA Level_AltObjects
	LDA Arena_Destinations+4,Y
	STA Level_AltObjects+1
	
	TXA
	PHA
	
	LDX <Horz_Scroll_Hi
	
	; Jct Y
	LDA Arena_Destinations+5,Y
	STA Level_JctYLHStart,X

	; Jct X
	LDA Arena_Destinations+6,Y
	STA Level_JctXLHStart,X

	PLA
	TAX

	RTS


ArenaCtl_ExitBoss:
	
	; Junction just like a door!
	LDA #3
	STA Level_JctCtl_Req ; Set appropriate value to Level_JctCtl_Req

	; Some bosses set this...
	LDA #0
	STA LevelJctBQ_Flag
	
	; Set arena completion bit!
	LDY <Temp_Var1
	
	LDA Arena_CompleteBit,Y
	STA <Temp_Var1
	
	LDA Level_ArenaData
	ORA <Temp_Var1
	STA Level_ArenaData

	LDY #(8 * 8)	; Standard exit destination
	
	CMP #$FF
	BNE ACEB_NotFinal
	
	LDY #(9 * 8)	; Standard exit destination
	
ACEB_NotFinal
	JSR ArenaCtl_SetDestination
	
Bleck_Fake:
	RTS

ObjInit_Bleck:
	JMP_THUNKA 42, ObjInit_Bleck42

ObjNorm_Bleck:
	LDA #250
	STA PatTable_BankSel+5

	LDA <Objects_Var5,X
	CMP #$FF
	BEQ Bleck_Fake	; "Fake" Bleck object just keeps a slot occupied for sake of stealing sprites from it

	JMP_THUNKA 42, ObjNorm_Bleck42

Bleck_FrameBase:
	.byte 0, 12, 24, 36

	; Offsets the PatternSet array by hflip
Bleck_OffsetByHFlip:	.byte 0, 3

	; On switching halves, the PatternSet correction value
Bleck_FixOffsetByHFlip:	.byte 9, 15

Bleck_Draw:
	LDA Objects_ColorCycle,X
	AND #3
	STA <Temp_Var9

	; Offsets to help fit bounding box better
	LDA <Objects_X,X
	PHA
	SUB #8
	STA <Objects_X,X
	LDA <Objects_XHi,X
	PHA
	SBC #0
	STA <Objects_XHi,X

	JSR Object_DetermineHorzVis
	JSR Object_DetermineVertVis
	JSR Object_ShakeAndCalcSprite

	; Temp_Var13 = 0 (no hflip) or 3 (hflip)
	; Temp_Var14 = 9 / 6
	LDX <SlotIndexBackup
	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	ASL A
	ROL A
	ROL A
	TAX
	LDA Bleck_OffsetByHFlip,X
	STA <Temp_Var13
	LDA Bleck_FixOffsetByHFlip,X
	STA <Temp_Var14
	
	; Calculate pattern offset by frame
	LDX <SlotIndexBackup
	LDA Objects_Frame,X
	TAX
	LDA Bleck_FrameBase,X 
	ADD <Temp_Var13
	ADD #(ObjPF5 - ObjectGrExt_PatternSets)
	TAX

	; Halves
	LDA #1
	STA <Temp_Var12

	; Rows
	LDA #1
	STA <Temp_Var11

Bleck_DrawLoop:
	LDA <Temp_Var5	; Check sprite vertical visibility
	LSR A		
	BCS BDVOff	; If this sprite is off-screen, jump to BDVOff (RTS)

	LDA <Temp_Var8	; Check horizontal sprite visibility
	ASL A		; Left shift flags value
	STA <Temp_Var10	; -> Temp_Var10

	LDA <Temp_Var1	; Sprite Y
	BCS BD_LeftOff	; If sprite is horizontally off-screen, jump to BD_LeftOff

	STA Sprite_RAM+$00,Y	 ; Set sprite Y in RAM

BD_LeftOff:
	BIT <Temp_Var10	 
	BMI BD_RightOff	 ; If this sprite is off-screen, jump to BD_RightOff

	STA Sprite_RAM+$04,Y	 ; Set sprite Y in RAM

BD_RightOff:
	BVS BD_CenterOff	 ; If this sprite is off-screen, jump to BD_CenterOff

	STA Sprite_RAM+$08,Y	 ; Set sprite Y in RAM

BD_CenterOff:
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y	 ; Set sprite X in RAM
	ADD #$08
	STA Sprite_RAM+$07,Y	 ; Set sprite X in RAM (+8)
	ADD #$08
	STA Sprite_RAM+$0B,Y	 ; Set sprite X in RAM (+16)

	; Set each of the sprite's patterns
	LDA ObjectGroup_PatternSets,X
	STA Sprite_RAM+$01,Y
	LDA ObjectGroup_PatternSets+1,X
	STA Sprite_RAM+$05,Y
	LDA ObjectGroup_PatternSets+2,X
	STA Sprite_RAM+$09,Y

	; Set each sprite's attributes
	LDA <Temp_Var9
	ORA <Temp_Var3
	ORA <Temp_Var4		 ; Combine attributes
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y
	STA Sprite_RAM+$0A,Y

	BIT <Temp_Var3
	BVC BDVOff	 ; If sprite is not horizontally flipped, jump to BDVOff

	; Swap end sprites patterns
	LDA Sprite_RAM+$01,Y
	PHA	
	LDA Sprite_RAM+$09,Y
	STA Sprite_RAM+$01,Y
	PLA	
	STA Sprite_RAM+$09,Y

BDVOff:
	LDA <Temp_Var1
	ADD #16
	STA <Temp_Var1

	TYA
	ADD #(4 * 3)
	TAY
	
	TXA
	ADD #6
	TAX

	DEC <Temp_Var11		; Temp_Var11--
	BPL Bleck_DrawLoop	; While Temp_Var11 >= 0 (another row), loop!
	
	LDA <Temp_Var12
	BEQ Bleck_DrawDone
	
	; Switch to other half
	
	; Y - 32 (restore it)
	LDA <Temp_Var1
	SUB #32
	STA <Temp_Var1

	; X + 24
	LDA <Temp_Var2
	ADD #24
	STA <Temp_Var2

	; Second half visibility
	ASL <Temp_Var8
	ASL <Temp_Var8
	ASL <Temp_Var8

	; Reset row counter
	LDA #1
	STA <Temp_Var11

	TXA
	SUB <Temp_Var14
	TAX
	
	DEC <Temp_Var12		; Temp_Var12--
	JMP Bleck_DrawLoop	; While Temp_Var12 >= 0 (the other half), loop!

Bleck_DrawDone:
	LDX <SlotIndexBackup

	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	RTS		 ; Return
	

ObjNorm_BleckProj:
	JMP_THUNKA 42, ObjNorm_BleckProj42

ObjInit_BattleCtl:	
	JMP_THUNKA 42, ObjInit_BattleCtl42

ObjNorm_BattleCtl:
	JMP_THUNKA 42, ObjNorm_BattleCtl42
