; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg005.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup04 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $04 (i.e. objects starting at ID $90) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup04_InitJumpTable:
	.word ObjInit_RotatePlatform	; Object $90 - OBJ_TILTINGPLATFORM
	.word ObjInit_RotatePlatform	; Object $91 - OBJ_TWIRLINGPLATCWNS
	.word ObjInit_RotatePlatform	; Object $92 - OBJ_TWIRLINGPLATCW
	.word ObjInit_RotatePlatformPer	; Object $93 - OBJ_TWIRLINGPERIODIC
	.word ObjInit_Spark			; Object $94 - OBJ_SPARK_CW
	.word ObjInit_Spark			; Object $95 - OBJ_SPARK_CCW
	.word ObjInit_Spark			; Object $96 - OBJ_SPARK_CW_FAST
	.word ObjInit_Spark			; Object $97 - OBJ_SPARK_CCW_FAST
	.word ObjInit_ClimbingKoopa	; Object $98 - OBJ_CLIMBINGKOOPA_G
	.word ObjInit_ClimbingKoopa	; Object $99 - OBJ_CLIMBINGKOOPA_R
	.word ObjInit_ClimbingKoopa	; Object $9A - OBJ_CLIMBINGKOOPA_GB
	.word ObjInit_ClimbingKoopa	; Object $9B - OBJ_CLIMBINGKOOPA_RB
	.word ObjInit_DoNothing		; Object $9C
	.word ObjInit_FireJetUpward	; Object $9D - OBJ_FIREJET_UPWARD
	.word ObjInit_Podoboo		; Object $9E - OBJ_PODOBOO
	.word ObjInit_ParaBeetle	; Object $9F - OBJ_PARABEETLE
	.word ObjInit_GreenPiranha	; Object $A0 - OBJ_GREENPIRANHA
	.word ObjInit_GreenPiranhaFlip	; Object $A1 - OBJ_GREENPIRANHA_FLIPPED
	.word ObjInit_RedPiranha	; Object $A2 - OBJ_REDPIRANHA
	.word ObjInit_RedPiranhaFlip	; Object $A3 - OBJ_REDPIRANHA_FLIPPED
	.word ObjInit_GreenPiranha	; Object $A4 - OBJ_GREENPIRANHA_FIRE
	.word ObjInit_GreenPiranhaFlip	; Object $A5 - OBJ_GREENPIRANHA_FIREC
	.word ObjInit_RedPiranha	; Object $A6 - OBJ_VENUSFIRETRAP
	.word ObjInit_RedPiranhaFlip	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.word ObjInit_DoNothing		; Object $A8 - OBJ_ARROWONE
	.word ObjInit_DoNothing		; Object $A9 - OBJ_ARROWANY
	.word ObjInit_DoNothing	; Object $AA
	.word ObjInit_DoNothing	; Object $AB 
	.word ObjInit_FireJetLeft	; Object $AC - OBJ_FIREJET_LEFT
	.word ObjInit_RockyWrench	; Object $AD - OBJ_ROCKYWRENCH
	.word ObjInit_BoltLift		; Object $AE - OBJ_BOLTLIFT
	.word ObjInit_Sun		; Object $AF - OBJ_ENEMYSUN
	.word ObjInit_BigCannonBall	; Object $B0 - OBJ_BIGCANNONBALL
	.word ObjInit_FireJetRight	; Object $B1 - OBJ_FIREJET_RIGHT
	.word ObjInit_FireJetUpsideDown	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.word ObjInit_ObjB3		; Object $B3 


	; Object group $04 (i.e. objects starting at ID $90) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup04_NormalJumpTable:
	.word ObjNorm_TiltingPlatform	; Object $90 - OBJ_TILTINGPLATFORM
	.word ObjNorm_TwirlingPlatCWNS	; Object $91 - OBJ_TWIRLINGPLATCWNS
	.word ObjNorm_TwirlingPlatCW	; Object $92 - OBJ_TWIRLINGPLATCW
	.word ObjNorm_TwirlingPlatCW	; Object $93 - OBJ_TWIRLINGPERIODIC
	.word ObjNorm_Spark			; Object $94 - OBJ_SPARK_CW
	.word ObjNorm_Spark			; Object $95 - OBJ_SPARK_CCW
	.word ObjNorm_Spark			; Object $96 - OBJ_SPARK_CW_FAST
	.word ObjNorm_Spark			; Object $97 - OBJ_SPARK_CCW_FAST
	.word ObjNorm_ClimbingKoopa	; Object $98 - OBJ_CLIMBINGKOOPA_G
	.word ObjNorm_ClimbingKoopa	; Object $99 - OBJ_CLIMBINGKOOPA_R
	.word ObjNorm_ClimbingKoopa	; Object $9A - OBJ_CLIMBINGKOOPA_GB
	.word ObjNorm_ClimbingKoopa	; Object $9B - OBJ_CLIMBINGKOOPA_RB
	.word ObjNorm_DoNothing		; Object $9C
	.word ObjNorm_FireJet		; Object $9D - OBJ_FIREJET_UPWARD
	.word ObjNorm_Podoboo		; Object $9E - OBJ_PODOBOO
	.word ObjNorm_ParaBeetle	; Object $9F - OBJ_PARABEETLE
	.word ObjNorm_Piranha		; Object $A0 - OBJ_GREENPIRANHA
	.word ObjNorm_Piranha		; Object $A1 - OBJ_GREENPIRANHA_FLIPPED
	.word ObjNorm_Piranha		; Object $A2 - OBJ_REDPIRANHA
	.word ObjNorm_Piranha		; Object $A3 - OBJ_REDPIRANHA_FLIPPED
	.word ObjNorm_Piranha		; Object $A4 - OBJ_GREENPIRANHA_FIRE
	.word ObjNorm_Piranha		; Object $A5 - OBJ_GREENPIRANHA_FIREC
	.word ObjNorm_Piranha		; Object $A6 - OBJ_VENUSFIRETRAP
	.word ObjNorm_Piranha		; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.word ObjNorm_ArrowPlatform	; Object $A8 - OBJ_ARROWONE
	.word ObjNorm_ArrowPlatform	; Object $A9 - OBJ_ARROWANY
	.word ObjNorm_DoNothing	; Object $AA 
	.word ObjNorm_DoNothing	; Object $AB 
	.word ObjNorm_FireJet		; Object $AC - OBJ_FIREJET_LEFT
	.word ObjNorm_RockyWrench	; Object $AD - OBJ_ROCKYWRENCH
	.word ObjNorm_BoltLift		; Object $AE - OBJ_BOLTLIFT
	.word ObjNorm_Sun		; Object $AF - OBJ_ENEMYSUN
	.word ObjNorm_BigCannonBall	; Object $B0 - OBJ_BIGCANNONBALL
	.word ObjNorm_FireJet		; Object $B1 - OBJ_FIREJET_RIGHT
	.word ObjNorm_FireJet		; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.word ObjNorm_ObjB3		; Object $B3


	; Object group $04 (i.e. objects starting at ID $90) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup04_CollideJumpTable:
	.word ObjHit_DoNothing	; Object $90 - OBJ_TILTINGPLATFORM
	.word ObjHit_DoNothing	; Object $91 - OBJ_TWIRLINGPLATCWNS
	.word ObjHit_DoNothing	; Object $92 - OBJ_TWIRLINGPLATCW
	.word ObjHit_DoNothing	; Object $93 - OBJ_TWIRLINGPERIODIC
	.word ObjHit_DoNothing	; Object $94 - OBJ_SPARK_CW
	.word ObjHit_DoNothing	; Object $95 - OBJ_SPARK_CCW
	.word ObjHit_DoNothing	; Object $96 - OBJ_SPARK_CW_FAST
	.word ObjHit_DoNothing	; Object $97 - OBJ_SPARK_CCW_FAST
	.word ObjHit_DoNothing	; Object $98 - OBJ_CLIMBINGKOOPA_G
	.word ObjHit_DoNothing	; Object $99 - OBJ_CLIMBINGKOOPA_R
	.word ObjHit_DoNothing	; Object $9A - OBJ_CLIMBINGKOOPA_GB
	.word ObjHit_DoNothing	; Object $9B - OBJ_CLIMBINGKOOPA_RB
	.word ObjHit_DoNothing	; Object $9C
	.word ObjHit_DoNothing	; Object $9D - OBJ_FIREJET_UPWARD
	.word ObjHit_DoNothing	; Object $9E - OBJ_PODOBOO
	.word ObjHit_DoNothing	; Object $9F - OBJ_PARABEETLE
	.word ObjHit_DoNothing	; Object $A0 - OBJ_GREENPIRANHA
	.word ObjHit_DoNothing	; Object $A1 - OBJ_GREENPIRANHA_FLIPPED
	.word ObjHit_DoNothing	; Object $A2 - OBJ_REDPIRANHA
	.word ObjHit_DoNothing	; Object $A3 - OBJ_REDPIRANHA_FLIPPED
	.word ObjHit_DoNothing	; Object $A4 - OBJ_GREENPIRANHA_FIRE
	.word ObjHit_DoNothing	; Object $A5 - OBJ_GREENPIRANHA_FIREC
	.word ObjHit_DoNothing	; Object $A6 - OBJ_VENUSFIRETRAP
	.word ObjHit_DoNothing	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.word ObjHit_DoNothing	; Object $A8 - OBJ_ARROWONE
	.word ObjHit_DoNothing	; Object $A9 - OBJ_ARROWANY
	.word ObjHit_DoNothing	; Object $AA 
	.word ObjHit_DoNothing	; Object $AB
	.word ObjHit_DoNothing	; Object $AC - OBJ_FIREJET_LEFT
	.word ObjHit_DoNothing	; Object $AD - OBJ_ROCKYWRENCH
	.word ObjHit_DoNothing	; Object $AE - OBJ_BOLTLIFT
	.word ObjHit_DoNothing	; Object $AF - OBJ_ENEMYSUN
	.word $0000	; Object $B0 - OBJ_BIGCANNONBALL
	.word $0000	; Object $B1 - OBJ_FIREJET_RIGHT
	.word $0000	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.word $0000	; Object $B3 

	
	; Object group $04 (i.e. objects starting at ID $90) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup04_Attributes:
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $90 - OBJ_TILTINGPLATFORM
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $91 - OBJ_TWIRLINGPLATCWNS
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $92 - OBJ_TWIRLINGPLATCW
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $93 - OBJ_TWIRLINGPERIODIC
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $94 - OBJ_SPARK_CW
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $95 - OBJ_SPARK_CCW
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $96 - OBJ_SPARK_CW_FAST
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $97 - OBJ_SPARK_CCW_FAST
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $98 - OBJ_CLIMBINGKOOPA_G
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $99 - OBJ_CLIMBINGKOOPA_R
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $9A - OBJ_CLIMBINGKOOPA_GB
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $9B - OBJ_CLIMBINGKOOPA_RB
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $9C
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH16	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $9E - OBJ_PODOBOO
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $9F - OBJ_PARABEETLE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A0 - OBJ_GREENPIRANHA
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A1 - OBJ_GREENPIRANHA_FLIPPED
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A2 - OBJ_REDPIRANHA
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A3 - OBJ_REDPIRANHA_FLIPPED
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A4 - OBJ_GREENPIRANHA_FIRE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A5 - OBJ_GREENPIRANHA_FIREC
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $A8 - OBJ_ARROWONE
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $A9 - OBJ_ARROWANY
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $AA 
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $AB
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $AC - OBJ_FIREJET_LEFT
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $AD - OBJ_ROCKYWRENCH
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $AE - OBJ_BOLTLIFT
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $AF - OBJ_ENEMYSUN
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH16	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $B3

	; Object group $04 (i.e. objects starting at ID $90) second set attribute bits

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup04_Attributes2:
	.byte OA2_TDOGRP0	; Object $90 - OBJ_TILTINGPLATFORM
	.byte OA2_TDOGRP0	; Object $91 - OBJ_TWIRLINGPLATCWNS
	.byte OA2_TDOGRP0	; Object $92 - OBJ_TWIRLINGPLATCW
	.byte OA2_TDOGRP0	; Object $93 - OBJ_TWIRLINGPERIODIC
	.byte OA2_STOMPDONTCARE | OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $94 - OBJ_SPARK_CW
	.byte OA2_STOMPDONTCARE | OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $95 - OBJ_SPARK_CCW
	.byte OA2_STOMPDONTCARE | OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $96 - OBJ_SPARK_CW_FAST
	.byte OA2_STOMPDONTCARE | OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $97 - OBJ_SPARK_CCW_FAST
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $98 - OBJ_CLIMBINGKOOPA_G
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $99 - OBJ_CLIMBINGKOOPA_R
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $9A - OBJ_CLIMBINGKOOPA_GB
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $9B - OBJ_CLIMBINGKOOPA_RB
	.byte OA2_TDOGRP0	; Object $9C
	.byte OA2_TDOGRP0	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OA2_TDOGRP0	; Object $9E - OBJ_PODOBOO
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $9F - OBJ_PARABEETLE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A0 - OBJ_GREENPIRANHA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A1 - OBJ_GREENPIRANHA_FLIPPED
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A2 - OBJ_REDPIRANHA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A3 - OBJ_REDPIRANHA_FLIPPED
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A4 - OBJ_GREENPIRANHA_FIRE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A5 - OBJ_GREENPIRANHA_FIREC
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OA2_TDOGRP0	; Object $A8 - OBJ_ARROWONE
	.byte OA2_TDOGRP0	; Object $A9 - OBJ_ARROWANY
	.byte OA2_TDOGRP0	; Object $AA 
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $AB
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $AC - OBJ_FIREJET_LEFT
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $AD - OBJ_ROCKYWRENCH
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP10	; Object $AE - OBJ_BOLTLIFT
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $AF - OBJ_ENEMYSUN
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP0	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OA2_TDOGRP0	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OA2_TDOGRP0	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OA2_TDOGRP11	; Object $B3

	; Object group $04 (i.e. objects starting at ID $90) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup04_Attributes3:
	.byte OA3_HALT_NORMALONLY 	; Object $90 - OBJ_TILTINGPLATFORM
	.byte OA3_HALT_NORMALONLY 	; Object $91 - OBJ_TWIRLINGPLATCWNS
	.byte OA3_HALT_NORMALONLY 	; Object $92 - OBJ_TWIRLINGPLATCW
	.byte OA3_HALT_NORMALONLY 	; Object $93 - OBJ_TWIRLINGPERIODIC
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $94 - OBJ_SPARK_CW
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $95 - OBJ_SPARK_CCW
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $96 - OBJ_SPARK_CW_FAST
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $97 - OBJ_SPARK_CCW_FAST
	.byte OA3_HALT_NORMALONLY	; Object $98 - OBJ_CLIMBINGKOOPA_G
	.byte OA3_HALT_NORMALONLY	; Object $99 - OBJ_CLIMBINGKOOPA_R
	.byte OA3_HALT_NORMALONLY	; Object $9A - OBJ_CLIMBINGKOOPA_GB
	.byte OA3_HALT_NORMALONLY 	; Object $9B - OBJ_CLIMBINGKOOPA_RB
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $9C
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $9E - OBJ_PODOBOO
	.byte OA3_HALT_NORMALONLY 	; Object $9F - OBJ_PARABEETLE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A0 - OBJ_GREENPIRANHA
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A1 - OBJ_GREENPIRANHA_FLIPPED
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A2 - OBJ_REDPIRANHA
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A3 - OBJ_REDPIRANHA_FLIPPED
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A4 - OBJ_GREENPIRANHA_FIRE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A5 - OBJ_GREENPIRANHA_FIREC
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $A8 - OBJ_ARROWONE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $A9 - OBJ_ARROWANY
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $AA
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $AB
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $AC - OBJ_FIREJET_LEFT
	.byte OA3_HALT_NORMALONLY 	; Object $AD - OBJ_ROCKYWRENCH
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $AE - OBJ_BOLTLIFT
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $AF - OBJ_ENEMYSUN
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $B3


	; Object group $04 (i.e. objects starting at ID $90) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup04_PatTableSel:
	.byte OPTS_SETPT6 | $4F	; Object $90 - OBJ_TILTINGPLATFORM
	.byte OPTS_SETPT6 | $4F	; Object $91 - OBJ_TWIRLINGPLATCWNS
	.byte OPTS_SETPT6 | $4F	; Object $92 - OBJ_TWIRLINGPLATCW
	.byte OPTS_SETPT6 | $4F	; Object $93 - OBJ_TWIRLINGPERIODIC
	.byte OPTS_NOCHANGE	; Object $94 - OBJ_SPARK_CW (SB: Done manually in ObjNorm_Spark)
	.byte OPTS_NOCHANGE	; Object $95 - OBJ_SPARK_CCW (SB: Done manually in ObjNorm_Spark)
	.byte OPTS_NOCHANGE	; Object $96 - OBJ_SPARK_CW_FAST (SB: Done manually in ObjNorm_Spark)
	.byte OPTS_NOCHANGE	; Object $97 - OBJ_SPARK_CCW_FAST (SB: Done manually in ObjNorm_Spark)
	.byte OPTS_SETPT5 | $1F	; Object $98 - OBJ_CLIMBINGKOOPA_G
	.byte OPTS_SETPT5 | $1F	; Object $99 - OBJ_CLIMBINGKOOPA_R
	.byte OPTS_SETPT5 | $1F	; Object $9A - OBJ_CLIMBINGKOOPA_GB
	.byte OPTS_SETPT5 | $1F	; Object $9B - OBJ_CLIMBINGKOOPA_RB
	.byte OPTS_NOCHANGE	; Object $9C
	.byte OPTS_SETPT6 | $37	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OPTS_NOCHANGE	; Object $9E - OBJ_PODOBOO (SB: Done manually in ObjNorm_Podoboo)
	.byte OPTS_SETPT5 | $0E	; Object $9F - OBJ_PARABEETLE
	.byte OPTS_SETPT6 | $4F	; Object $A0 - OBJ_GREENPIRANHA
	.byte OPTS_SETPT6 | $4F	; Object $A1 - OBJ_GREENPIRANHA_FLIPPED
	.byte OPTS_SETPT6 | $4F	; Object $A2 - OBJ_REDPIRANHA
	.byte OPTS_SETPT6 | $4F	; Object $A3 - OBJ_REDPIRANHA_FLIPPED
	.byte OPTS_SETPT6 | $4F	; Object $A4 - OBJ_GREENPIRANHA_FIRE
	.byte OPTS_SETPT6 | $4F	; Object $A5 - OBJ_GREENPIRANHA_FIREC
	.byte OPTS_SETPT6 | $4F	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OPTS_SETPT6 | $4F	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OPTS_SETPT5 | $5A	; Object $A8 - OBJ_ARROWONE
	.byte OPTS_SETPT5 | $5A	; Object $A9 - OBJ_ARROWANY
	.byte OPTS_SETPT5 | $36	; Object $AA 
	.byte OPTS_SETPT5 | $36	; Object $AB
	.byte OPTS_SETPT6 | $37	; Object $AC - OBJ_FIREJET_LEFT
	.byte OPTS_SETPT5 | $36	; Object $AD - OBJ_ROCKYWRENCH
	.byte OPTS_SETPT5 | $36	; Object $AE - OBJ_BOLTLIFT
	.byte OPTS_SETPT5 | $32	; Object $AF - OBJ_ENEMYSUN
	.byte OPTS_SETPT5 | $36	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OPTS_SETPT6 | $37	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OPTS_SETPT6 | $37	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OPTS_SETPT5 | $0B	; Object $B3


	; Object group $04 (i.e. objects starting at ID $90) "Kill Action"

	.org ObjectGroup_Attributes4	; <-- help enforce this table *here*
ObjectGroup04_Attributes4:
	.byte OA4_KA_STANDARD	; Object $90 - OBJ_TILTINGPLATFORM
	.byte OA4_KA_STANDARD	; Object $91 - OBJ_TWIRLINGPLATCWNS
	.byte OA4_KA_STANDARD	; Object $92 - OBJ_TWIRLINGPLATCW
	.byte OA4_KA_STANDARD	; Object $93 - OBJ_TWIRLINGPERIODIC
	.byte OA4_KA_STANDARD	; Object $94 - OBJ_SPARK_CW
	.byte OA4_KA_STANDARD	; Object $95 - OBJ_SPARK_CCW
	.byte OA4_KA_STANDARD	; Object $96 - OBJ_SPARK_CW_FAST
	.byte OA4_KA_STANDARD	; Object $97 - OBJ_SPARK_CCW_FAST
	.byte OA4_KA_NORMALANDKILLED	; Object $98 - OBJ_CLIMBINGKOOPA_G
	.byte OA4_KA_NORMALANDKILLED	; Object $99 - OBJ_CLIMBINGKOOPA_R
	.byte OA4_KA_NORMALANDKILLED	; Object $9A - OBJ_CLIMBINGKOOPA_GB
	.byte OA4_KA_NORMALANDKILLED	; Object $9B - OBJ_CLIMBINGKOOPA_RB
	.byte OA4_KA_STANDARD	; Object $9C
	.byte OA4_KA_STANDARD	; Object $9D - OBJ_FIREJET_UPWARD
	.byte OA4_KA_JUSTDRAWMIRROR | OA4_POOFFROZEN	; Object $9E - OBJ_PODOBOO
	.byte OA4_KA_JUSTDRAW16X16	; Object $9F - OBJ_PARABEETLE
	.byte OA4_KA_POOFDEATH | OA4_FROZENCANTKICK	; Object $A0 - OBJ_GREENPIRANHA
	.byte OA4_KA_POOFDEATH | OA4_FROZENCANTKICK	; Object $A1 - OBJ_GREENPIRANHA_FLIPPED
	.byte OA4_KA_POOFDEATH | OA4_FROZENCANTKICK	; Object $A2 - OBJ_REDPIRANHA
	.byte OA4_KA_POOFDEATH | OA4_FROZENCANTKICK	; Object $A3 - OBJ_REDPIRANHA_FLIPPED
	.byte OA4_KA_POOFDEATH | OA4_FROZENCANTKICK	; Object $A4 - OBJ_GREENPIRANHA_FIRE
	.byte OA4_KA_POOFDEATH | OA4_FROZENCANTKICK	; Object $A5 - OBJ_GREENPIRANHA_FIREC
	.byte OA4_KA_POOFDEATH | OA4_FROZENCANTKICK	; Object $A6 - OBJ_VENUSFIRETRAP
	.byte OA4_KA_POOFDEATH | OA4_FROZENCANTKICK	; Object $A7 - OBJ_VENUSFIRETRAP_CEIL
	.byte OA4_KA_STANDARD	; Object $A8 - OBJ_ARROWONE
	.byte OA4_KA_STANDARD	; Object $A9 - OBJ_ARROWANY
	.byte OA4_KA_STANDARD	; Object $AA
	.byte OA4_KA_STANDARD	; Object $AB
	.byte OA4_KA_STANDARD	; Object $AC - OBJ_FIREJET_LEFT
	.byte OA4_KA_NORMALANDKILLED	; Object $AD - OBJ_ROCKYWRENCH
	.byte OA4_KA_STANDARD	; Object $AE - OBJ_BOLTLIFT
	.byte OA4_KA_NORMALANDKILLED	; Object $AF - OBJ_ENEMYSUN
	.byte OA4_KA_NORMALANDKILLED	; Object $B0 - OBJ_BIGCANNONBALL
	.byte OA4_KA_STANDARD	; Object $B1 - OBJ_FIREJET_RIGHT
	.byte OA4_KA_STANDARD	; Object $B2 - OBJ_FIREJET_UPSIDEDOWN
	.byte OA4_KA_NORMALANDKILLED	; Object $B3


	; Object group $04 (i.e. objects starting at ID $90) pattern index starts
	; These are used for all states except "normal"

OG4_POff .func (\1 - ObjectGroup04_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup04_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG4_POff(ObjP90), OG4_POff(ObjP91), OG4_POff(ObjP92), OG4_POff(ObjP93)
	.byte OG4_POff(ObjP94), OG4_POff(ObjP95), OG4_POff(ObjP96), OG4_POff(ObjP97)
	.byte OG4_POff(ObjP98), OG4_POff(ObjP99), OG4_POff(ObjP9A), OG4_POff(ObjP9B)
	.byte OG4_POff(ObjP9C), OG4_POff(ObjP9D), OG4_POff(ObjP9E), OG4_POff(ObjP9F)
	.byte OG4_POff(ObjPA0), OG4_POff(ObjPA1), OG4_POff(ObjPA2), OG4_POff(ObjPA3)
	.byte OG4_POff(ObjPA4), OG4_POff(ObjPA5), OG4_POff(ObjPA6), OG4_POff(ObjPA7)
	.byte OG4_POff(ObjPA8), OG4_POff(ObjPA9), OG4_POff(ObjPAA), OG4_POff(ObjPAB)
	.byte OG4_POff(ObjPAC), OG4_POff(ObjPAD), OG4_POff(ObjPAE), OG4_POff(ObjPAF)
	.byte OG4_POff(ObjPB0), OG4_POff(ObjPB1), OG4_POff(ObjPB2), OG4_POff(ObjPB3)


	; Object group $04 (i.e. objects starting at ID $90) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup04_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup04_PatternSets:
	; (End restricted alignment space)

ObjP90:
ObjP91:
ObjP92:
ObjP93:
ObjP94:
ObjP95:
ObjP96:
ObjP97:
	.byte $AD, $AD, $AF, $AF, $AD, $AD
ObjP98:
ObjP99:
ObjP9A:
ObjP9B:
	.byte $A9, $AB, $AD, $AF, $A1, $A3, $A5, $A7
CK_Shell:	.byte $81, $83	; Climbing Koopa's shell
	
ObjP9C:
ObjP9E:
ObjPA8:
ObjPA9:
ObjPAC:
ObjPB1:
	.byte $8D, $8D, $8F, $8F, $B5, $B5
ObjPB3:
	.byte $BD, $BD, $BB, $BB, $BD, $BD, $99, $99
ObjPB0:
	.byte $A5, $A7, $A5, $A7
ObjP9D:
ObjPB2:
	.byte $DD, $71, $DF, $71, $D9, $71, $DB, $71, $CD, $D3, $CF, $D5, $71, $71, $71, $71, $CB, $D1
ObjPA0:
ObjPA1:
ObjPA2:
ObjPA3:
	.byte $E1, $E1, $E3, $E3, $E5, $E5, $E3, $E3, $E1, $E1, $71, $71, $E5, $E5, $71, $71
ObjPA4:
ObjPA5:
ObjPA6:
ObjPA7:
	.byte $F1, $F3, $E3, $E3, $F5, $F7, $E3, $E3, $F1, $F3, $71, $71, $F5, $F7, $71, $71
ObjP9F:
	.byte $B1, $B3, $B5, $B7, $B1, $B3
ObjPAF:
	.byte $99, $99, $9B, $9B, $93, $93, $95, $95
ObjPAE:
	.byte $81, $81, $83, $83, $85, $85, $87, $87
ObjPAD:
	.byte $91, $93, $8D, $8F, $89, $8B, $B3, $B5, $97, $9B, $99, $99, $9B, $97, $99, $99
ObjPAB:
	.byte $A5, $A7
ObjPAA:
; Note to self: Remember, until the label!
	.byte $A9, $71

ObjInit_Podoboo:

	; Start at X + 8
	LDA <Objects_X,X
	ADD #$08
	STA <Objects_X,X

	; Var5 = Original Y
	LDA <Objects_Y,X
	STA <Objects_Var5,X

	; Var4 = Original Y Hi
	LDA <Objects_YHi,X
	STA <Objects_Var4,X

	RTS		 ; Return

	; The higher Podoboo goes, the less velocity it has
	;
	; NOTE: Where it becomes positive, these are actual values
	; sent into Timer3, and the Y velocity used is still -$80
Podoboo_YVelByHeight:
	.byte -$10, -$24, -$30, -$38, -$40, -$48, -$4E, -$54, -$5A, -$60, -$66, -$6A, -$6E, -$74, -$78, -$7C, -$80, $04, $08, $0C, $10, $14

ObjNorm_Podoboo:
	LDA PatTable_BankSel+4
	CMP #31
	BEQ Podoboo_FenceAltPattern	; If fence enemy sprites are active, jump to Podoboo_FenceAltPattern
	
	; pattern bank 18 normally
	LDY #18
	STY PatTable_BankSel+4

Podoboo_FenceAltPattern:
	LDA Objects_Timer,X
	BEQ PRG005_A259	 ; If timer expired, jump to PRG005_A259

	; Objects_SprHVis = Timer (screwy way to make Podoboo invisible until timer expires)
	STA Objects_SprHVis,X

	CMP #$01
	BNE PRG005_A258	 ; If timer <> 1, jump to PRG005_A258 (RTS)

PRG005_A250:
	JSR Object_DetermineHorzVis	; Determine ACTUAL horizontal visibility

	; Podoboo splashes coming out of the lava
	LDA #$13
	JSR Podoboo_Splash

PRG005_A258: 
	RTS		 ; Return

PRG005_A259:
	LDA <Player_HaltGame
	BEQ PRG005_A260	 ; If gameplay is not halted, jump to PRG005_A260

	JMP PRG005_A2E1	 ; Otherwise, jump to PRG005_A2E1

PRG005_A260:
	JSR Player_HitEnemy	 ; Do Player to Podoboo collision

	LDA #$00	; A = $00 (no flip)

	LDY <Objects_YVel,X
	BMI PRG005_A26B	 ; If Podobo is moving upward, jump to PRG005_A26B

	LDA #SPR_VFLIP	 ; A = SPR_VFLIP (vertically flip)

PRG005_A26B:
	STA Objects_FlipBits,X	 ; Set appropriate flip

	LDA <Counter_1
	AND #$03
	BNE PRG005_A283	 ; 1:4 ticks proceed, otherwise, jump to PRG005_A283

	; Cycle frame 0-2
	INC Objects_Frame,X	; Frame++

	LDA Objects_Frame,X
	CMP #$03
	BNE PRG005_A283	 ; If frame <> 3, jump to PRG005_A283

	; Reset frame to zero
	LDA #$00
	STA Objects_Frame,X

PRG005_A283:
	LDA <Objects_YVel,X
	BMI PRG005_A2C9	 ; If Podoboo is moving upward, jump to PRG005_A2C9

	JSR Object_WorldDetectN1	 ; Detect against world

	LDA Object_TileFeet2
	CMP #TILE15_LAVATOP
	BEQ Podoboo_HitLavaAlt
	CMP #TILE2_LAVATOP
	BNE PRG005_A2C9	 	; If Podoboo has not hit the lava, jump to PRG005_A2C9

Podoboo_HitLavaAlt:
	LDA <Objects_Y,X
	SUB <Objects_Var5,X
	STA <Temp_Var1
	LDA <Objects_YHi,X
	SBC <Objects_Var4,X
	LSR A	
	ROR <Temp_Var1
	LDA <Temp_Var1
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = Podoboo's relative height as an index

	LDA Podoboo_YVelByHeight,Y	 ; Get Y Velocity by height
	BMI PRG005_A2AF	 ; If this is a negative value, jump to PRG005_A2AF

	STA Objects_Timer3,X	; Otherwise, the value actually goes into Timer3

	LDA #-$80	 ; Use velocity of -$80

PRG005_A2AF:
	STA <Objects_YVel,X	 ; Set Podoboo's Y velocity

	LDA <Objects_Y,X
	PHA		 ; Save Y
	SBC #$04
	STA <Objects_Y,X ; Subtract 4 from Y

	JSR PRG005_A250		; Splash and determine horizontal visibility

	; Restore Y
	PLA	
	STA <Objects_Y,X

	LDA RandomN,X
	AND #$3f
	ORA #$40
	STA Objects_Timer,X	 ; Set Podoboo's timer to $40 - $7F

	RTS		 ; Return

PRG005_A2C9:
	JSR Object_ApplyYVel_NoLimit	; Apply Y velocity

	LDA Objects_Timer3,X
	BNE PRG005_A2DE	 ; If Timer3 not expired, jump to PRG005_A2DE

	LDA <Objects_YVel,X
	BMI PRG005_A2D9	 ; If Podoboo is moving upward, jump to PRG005_A2D9

	CMP #$70
	BGE PRG005_A2DE	 ; If Podoboo is falling >= $70, jump to PRG005_A2DE

PRG005_A2D9:

	; +2 to Podoboo's Y Velocity (Gravity)
	ADD #$02
	STA <Objects_YVel,X

PRG005_A2DE:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

PRG005_A2E1:
	JMP Object_ShakeAndDrawMirrored	 ; Draw Podoboo and don't come back!!


SpinyEgg_TowardsPlayer:	.byte $0A, -$0A



	;		       0 D   1 L   2 U   3 R
Spark_XVel:	.byte  $00, -$10,  $00,  $10
Spark_YVel:	.byte  $10,  $00, -$10,  $00

	;		    	   0 D   1 L   2 U   3 R
Spark_XOff:		.byte   -1,    0,   16,   15
Spark_XOffHi:	.byte  $FF,  $00,  $00,  $00

	;		    	   0 D   1 L   2 U   3 R
Spark_YOff:		.byte    0,   -1,    0,   16
Spark_YOffHi:	.byte  $00,  $FF,  $00,  $00


ObjInit_Spark:
	
	; Objects_Var1 will be 0 for clockwise Spark and 2 for counterclockwise Spark
	LDA Level_ObjectID,X
	;SUB #OBJ_SPARK_CW		; Doesn't need to be relative since we're just checking bits
	PHA		; Save it
	ASL A	; Shift up 1 (multiply by 2); this will be useful in indexing differently
	AND #2	; Only caring about whether CCW
	STA Objects_Var1,X	; -> Var1

	; Objects_Var2 will be set for fast Spark
	PLA		; Restore it
	AND #2	; Check for fast
	STA Objects_Var2,X	; -> Var2

	; Based on where we find a solid tile will determine our initial travel direction
	LDA #3
	STA <Temp_Var15	; Temp_Var1 = 3 (checking all possible directions)
Spark_InitLoop:

	LDY <Temp_Var15
	JSR Spark_SolidTraceTileCheck
	BGE Spark_TracerFound	; If Spark has found a solid tracer tile, jump to Spark_TracerFound

	DEC <Temp_Var15		; Temp_Var1--
	BNE Spark_InitLoop	; While Temp_Var1 > 0, loop!

	; Note: If we drop out here, Temp_Var1 = 0, which is fine

Spark_TracerFound:
	LDA <Temp_Var15
	STA <Objects_Var5,X		; Set Spark's initial direction

	RTS


ObjNorm_Spark:

	; Hack: "PatTableSel" cannot support a bank value over 127, so must do so manually

	LDA #134
	STA PatTable_BankSel+4

	LDA <Objects_Var5,X		; Get direction
	PHA		; Save it
	PHA		; Save it

	; X velocity can be reversed for CCW Spark; Var1 determines this
	ADD Objects_Var1,X
	AND #3	; Wrap around
	TAY						; -> 'Y'
	
	LDA Spark_XVel,Y
	LDY Objects_Var2,X	; Check if fast Spark
	BEQ Spark_NotFastH	; If this is not a fast Spark, jump to Spark_NotFastH
	
	; Fast Spark!
	ASL A
	
Spark_NotFastH:
	STA <Objects_XVel,X
	
	; Restore proper direction index (no change on Y velocity)
	PLA
	TAY		; -> 'Y'
	
	; Set Y velocity
	LDA Spark_YVel,Y
	LDY Objects_Var2,X	; Check if fast Spark
	BEQ Spark_NotFastV	; If this is not a fast Spark, jump to Spark_NotFastV
	
	; Fast Spark!
	ASL A
	
Spark_NotFastV:
	STA <Objects_YVel,X

	; 0 = Down
	; 1 = Left
	; 2 = Up
	; 3 = Right

	JSR Object_DeleteOffScreen_N2	 ; Delete object if it falls off-screen
	JSR Object_HandleBumpUnderneath
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel
	JSR Object_ShakeAndDrawMirrored
	
	; Check if spark is on a new tile alignment
	PLA						; Get direction
	TAY						; -> 'Y'
	AND #1					; Determine whether L/R or U/D
	BEQ SparkUD_AlignCheck	; If not odd, this is up/down, jump to SparkUD_AlignCheck

	; Left/right alignment check; looking at X
	LDA <Objects_X,X
	JMP Spark_AlignCheck	; Jump to Spark_AlignCheck
	
SparkUD_AlignCheck:
	; Up/down alignment check; looking at Y
	LDA <Objects_Y,X

Spark_AlignCheck:
	AND #$0F	; Checking lower bits of X or Y
	BNE Spark_NotTracerEnd	; If Spark has not yet reached a new alignment, jump to Spark_NotTracerEnd
	
	; Spark has reached a new alignment; check to see if he's still tracing a tile
	JSR Spark_SolidTraceTileCheck
	BGE Spark_NotTracerEnd	; As long as the tile remains solid, jump to Spark_NotTracerEnd

	; Tile is not solid!  Change to next direction!
	LDA <Objects_Var5,X
	ADD #1
	AND #3
	STA <Objects_Var5,X
	
	JMP Spark_NoWorldImpact	; Jump to Spark_NoWorldImpact
	
Spark_DetStatReact:
	;     0 D  1 L  2 U  3 R
	.byte $04, $02, $08, $01	; Clockwise
	.byte $04, $01, $08, $02	; Counterclockwise
	
Spark_NotTracerEnd:

	; For more complex geometry, see if Spark runs into a floor/wall/ceiling

	JSR Object_WorldDetectN1
	
	LDA Objects_Var1,X
	ASL A
	STA <Temp_Var1	; Temp_Var1 = 0 or 4, depending on whether CW or CCW
	
	LDA <Objects_Var5,X		; Get direction
	ADD <Temp_Var1			; Offset by CW or CCW
	TAY		; -> 'Y'
	
	LDA <Objects_DetStat,X
	AND Spark_DetStatReact,Y
	BEQ Spark_NoWorldImpact
	
	LDA <Objects_Var5,X
	SUB #1
	AND #3
	STA <Objects_Var5,X
	

Spark_NoWorldImpact:

	; Toggle Spark frame
	LDA <Counter_1
	LSR A
	LSR A
	AND #1
	STA Objects_Frame,X

	RTS


Spark_SolidTraceTileCheck:
	TYA
	PHA		; Save 'Y'
	
	; CCW Spark will use opposite offsets on the X coordinate; use Var1 to determine
	ADD Objects_Var1,X
	AND #3		; Wrap around
	TAY		; -> 'Y'

	LDA <Objects_X,X
	ADD Spark_XOff,Y
	STA ObjTile_DetXLo
	LDA <Objects_XHi,X
	ADC Spark_XOffHi,Y
	STA ObjTile_DetXHi
	
	PLA
	TAY		; Restore 'Y'
	
	LDA <Objects_Y,X
	ADD Spark_YOff,Y
	STA ObjTile_DetYLo
	LDA <Objects_YHi,X
	ADC Spark_YOffHi,Y
	STA ObjTile_DetYHi
	
	JSR Object_DetectTileManual

	LDY Level_Tileset
	CPY #2
	BNE Spark_NotFortCheck	; If tileset <> 2, jump to Spark_NotFortCheck
	
	; In SMB2, Spark for some reason followed the climbable chains,
	; so we'll mimic that.  This implementation is not complete.
	; A full implementation requires a hack in Object_WorldDetect and
	; I don't think that's worth the trouble... this will work as long
	; as Spark has solid corner tiles to hit off of.
	LDA <Level_Tile
	SUB #TILE2_HANGGLOBE_GLOBE
	CMP #$FE	; The two tiles will be $FE (-2) and $FF (-1)
	BGE Spark_TileOverride	; If it's one of the climables, jump to Spark_TileOverride
	
Spark_NotFortCheck:

	; Also need to check for vines then
	LDA <Level_Tile
	CMP #TILE1_VINE
	BEQ Spark_TileOverride	; If a vine, jump to Spark_TileOverride

	; Calculate quadrant
	PHA		; Save tile
	
	ASL A
	ROL A
	ROL A
	AND #$03
	TAY		 ; Y = tile quadrant
		
	PLA		; Restore tile
	CMP Tile_AttrTable,Y	; Compare against solidity check table (BGE for solid)
	
Spark_TileOverride:
	RTS


ObjInit_ObjB3:

	JSR Level_ObjCalcXDiffs

	; Set X velocity towards Player
	LDA SpinyEgg_TowardsPlayer,Y
	STA <Objects_XVel,X

	RTS		 ; Return


ObjB3_AttrByFrame:	.byte $03, $01, $02, $01
	
ObjNorm_ObjB3:

	; Strange object... hurts Player, can be killed, appears able to be "bounced" off a sideways bounce block

	LDA Level_NoStopCnt
	LSR A
	LSR A
	AND #$03
	STA Objects_Frame,X	 ; Set frame 0 to 3

	TAY		 	 ; Y = 0 to 3
	LDA ObjB3_AttrByFrame,Y
	STA Objects_SprAttr,X	 ; Set attribute by frame

	JSR Object_ShakeAndDraw	 ; Draw thing

	; Clear horizontal and vertical flip bits on first sprite
	LDA Sprite_RAM+$02,Y
	AND #$3f
	STA Sprite_RAM+$02,Y

	; Set horizontal and vertical flip bits on second sprite
	ORA #$c0
	STA Sprite_RAM+$06,Y

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG005_A34A	 ; If object state is not Normal, jump to PRG005_A34A

	LDA <Player_HaltGame
	BNE PRG005_A34A	 ; If gameplay halted, jump to PRG005_A34A

	LDA <Counter_1
	LSR A
	NOP
	NOP
	AND #$01
	STA Objects_Frame,X	 ; Toggle frame 0 or 1

	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JSR Player_HitEnemy	 	; Do Player to "thing" collision
	JSR Object_Move	 		; Do standard movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG005_A34F	 ; If object did not hit floor, jump to PRG005_A34F

	JSR Object_HitGround	; Align to floor

	LDA Objects_Timer,X
	BNE PRG005_A34A	 ; If timer not expired, jump to PRG005_A34A

	LDA LRBounce_Vel
	CMP <Objects_Var4,X
	BEQ PRG005_A34A	 ; If bounced different, jump to PRG005_A34A

	JSR PRG005_A355	 ; Turn around

PRG005_A34A:

	; Lock in how object was bounced so it can't be bounced the same again
	LDA LRBounce_Vel
	STA <Objects_Var4,X

PRG005_A34F:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ ObjInit_BigCannonBall	 ; If object did not hit wall, jump to ObjInit_BigCannonBall (RTS)


PRG005_A355:

	; Set timer to $20
	LDA #$20
	STA Objects_Timer,X

	JSR Object_AboutFace	 ; Turn around
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyXVel	 ; Apply Y velocity

ObjInit_BigCannonBall:
	RTS		 ; Return

ObjNorm_BigCannonBall:
	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JSR BigCannonBall_Draw	 	; Draw the big cannon ball

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE ObjInit_BigCannonBall	; If big cannon ball's state is not Normal, jump to ObjInit_BigCannonBall (RTS)

	LDA <Player_HaltGame
	BNE ObjInit_BigCannonBall	; If gameplay halted, jump to ObjInit_BigCannonBall (RTS)

	JSR Object_ApplyXVel	 ; Apply X velocity
	JMP Player_HitEnemy	 ; Do Player to Big Cannon Ball collision and don't come back!

BigCannonBall_Draw:
	LDA #$00
	STA Objects_Frame,X	; Set frame to zero
	STA Objects_FlipBits,X	; No flip

	; horizontal visibility bits -> Temp_VarNP0
	LDA Objects_SprHVis,X
	STA Temp_VarNP0

	LDA <Objects_X,X
	PHA		 ; Save big cannon ball's X
	ADD #$08	 
	STA <Objects_X,X ; +8 to big cannon ball's X

	LDA <Objects_XHi,X
	PHA		 ; Save big cannon ball's X Hi
	ADC #$00	 ; Apply carry
	STA <Objects_XHi,X	 ; Update big cannon ball's X Hi

	ASL Objects_SprHVis,X
	JSR Object_Draw16x32Sprite	 ; Draw center of big cannon ball

	; Restore X/Hi
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	JSR Object_CalcSpriteXY_NoHi

	LDA Objects_SprVVis,X
	BNE PRG005_A429	 	; If any sprite of the big cannon ball is vertically off-screen, jump to PRG005_A429 (RTS)

	; Temp_Var1 = big cannon ball's Sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	LDY Object_SprRAM,X	 ; Y = Sprite RAM offset

	LDA Temp_VarNP0
	BMI PRG005_A3F3	 ; If this sprite is horizontally off-screen, jump to PRG005_A3F3

	; Add 8 to Sprite Y for left edge sprite (vertically centered)
	LDA <Temp_Var1
	ADD #$08
	STA Sprite_RAM+$10,Y

PRG005_A3F3:
	LDA Temp_VarNP0
	AND #%00010000
	BNE PRG005_A402	 ; If this sprite is horizontally off-screen, jump to PRG005_A402

	; Add 8 to Sprite Y for right edge sprite (vertically centered)
	LDA <Temp_Var1
	ADD #$08
	STA Sprite_RAM+$14,Y

PRG005_A402:
	; Set palette select 3 and vertical flip for lower sprites
	LDA #(SPR_VFLIP | SPR_PAL3)
	STA Sprite_RAM+$0A,Y
	STA Sprite_RAM+$0E,Y

	; Left edge sprite pattern
	LDA #$a3
	STA Sprite_RAM+$11,Y

	; Right edge sprite pattern
	LDA #$b1
	STA Sprite_RAM+$15,Y

	; Set palette select 3 for edge sprites
	LDA #SPR_PAL3
	STA Sprite_RAM+$12,Y
	STA Sprite_RAM+$16,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	; Set Sprite X for edge sprites
	LDA <Objects_SpriteX,X
	STA Sprite_RAM+$13,Y
	ADD #24
	STA Sprite_RAM+$17,Y

PRG005_A429:
	RTS		 ; Return

ObjInit_FireJetUpward:

	; Start +15 Y
	LDA <Objects_Y,X
	ADD #15
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	ADC #$00
	STA <Objects_YHi,X
	RTS		 ; Return

ObjInit_FireJetUpsideDown:

	; Start at Y - 1
	DEC <Objects_Y,X 
	LDA <Objects_Y,X
	CMP #$ff
	BNE PRG005_A442
	DEC <Objects_YHi,X
PRG005_A442:

	RTS		 ; Return

FireJet_TimerReload:
	.byte $78, $08, $08, $60, $02, $02

FireJet_Frame:
	.byte -$01, $00, $01, $02, $01, $00

ObjNorm_FireJet:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA <Player_HaltGame
	BNE PRG005_A47F	 ; If gameplay is halted, jump to PRG005_A47F

	LDA Objects_Timer,X
	BNE PRG005_A47F	 ; If timer is not expired, jump to PRG005_A47F

	; Timer expired...

	INC <Objects_Var4,X	 ; Var4++

	LDA <Objects_Var4,X
	CMP #$06
	BLT PRG005_A465	 ; If Var4 < 6, jump to PRG005_A465

	LDA #$00	 ; A = 0 (reset Var4)

PRG005_A465:
	STA <Objects_Var4,X	 ; Update Var4

	TAY		 ; -> 'Y'

	; Reload the Flame Jet timer
	LDA FireJet_TimerReload,Y
	STA Objects_Timer,X

	CPY #$03
	BNE PRG005_A47F	 ; If Var4 <> 3, jump to PRG005_A47F

	LDA SndCur_Level2
	BNE PRG005_A47F	 ; If a sound is already playing out of the "Level2" set, jump to PRG005_A47F (flame sound not priority)

	; Flame sound
	LDA Sound_QLevel2
	ORA #SND_LEVELFLAME
	STA Sound_QLevel2

PRG005_A47F:
	LDA Level_ObjectID,X
	CMP #OBJ_FIREJET_UPWARD
	BEQ PRG005_A48D	 ; If upward jet, jump to PRG005_A48D

	CMP #OBJ_FIREJET_UPSIDEDOWN
	BEQ PRG005_A4F6	 ; If downward jet, jump to PRG005_A4F6

	JMP PRG005_A581	 ; Jump to PRG005_A581

PRG005_A48D:

	; Upward jet

	LDA <Objects_X,X
	PHA		 ; Save X

	LDY <Objects_Var4,X
	BEQ PRG005_A4F2	 ; If Var4 = 0, jump to PRG005_A4F2

	LDA Level_NoStopCnt
	LSR A

	CPY #$03
	BEQ PRG005_A49F	 ; If Var4 = 3, jump to PRG005_A49F

	; Divide further otherwise!
	LSR A
	LSR A
	LSR A

PRG005_A49F:
	LSR A	

	LDA #$00	; A = $00 (No flip, Var4 < 3)

	BLT PRG005_A4A6	 ; If Var4 < 3, jump to PRG005_A4A6

	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (Horizontal flip, otherwise)

PRG005_A4A6:
	STA Objects_FlipBits,X	 ; Set proper flip

	CPY #$03
	BEQ PRG005_A4BB	 ; If Var4 = 3, jump to PRG005_A4BB

	; Var4 <> 3...

	LDA #$04	; A = $04

	LDY Objects_FlipBits,X
	BEQ PRG005_A4B6	 ; If not flipped, jump to PRG005_A4B6

	LDA #-$04	 ; A = -$04

PRG005_A4B6:
	ADD <Objects_X,X
	STA <Objects_X,X ; Apply offset to X

PRG005_A4BB:
	LDY <Objects_Var4,X	 ; Y = Var4

	LDA FireJet_Frame,Y
	PHA		 ; Save frame value
	STA Objects_Frame,X	 ; -> Frame

	JSR Object_Draw16x32Sprite	 ; Draw bottom of flame

	PLA		 ; Restore frame value
	ADD #$06	 ; +6
	STA Objects_Frame,X	 ; Set as new frame value

	LDA <Objects_Y,X
	PHA		 ; Save Y
	SUB #16
	STA <Objects_Y,X	 ; Subtract 16 from Y
	LDA <Objects_YHi,X
	PHA		 ; Save Y Hi
	SBC #$00
	STA <Objects_YHi,X

	LDA Object_SprRAM,X
	ADD #16		; 4 sprites forward
	STA Object_SprRAM,X

	JSR Object_ShakeAndDraw	; Draw top of flame

	; Restore Y/Hi
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	JSR FireJet_PlayerHitTest	 ; Do Player to Fire Jet collision

PRG005_A4F2:

	; Restore X
	PLA
	STA <Objects_X,X

	RTS		 ; Return

PRG005_A4F6:

	; Downward jet

	; Vertically flip
	LDA #SPR_VFLIP
	STA Objects_FlipBits,X


	LDA <Objects_X,X
	PHA		 ; Save X

	LDY <Objects_Var4,X
	BEQ PRG005_A565	 ; If Var4 = 0, jump to PRG005_A565

	LDA Level_NoStopCnt
	LSR A
	CPY #$03
	BEQ PRG005_A50D	 ; If Var4 = 3, jump to PRG005_A50D

	; Divide further otherwise!
	LSR A
	LSR A
	LSR A

PRG005_A50D:
	LSR A

	LDA #SPR_VFLIP	; A = SPR_VFLIP (Vertical flip only, Var4 < 3)

	BLT PRG005_A514	 ; If Var4 < 3, jump to PRG005_A514

	LDA #(SPR_HFLIP | SPR_VFLIP)	 ; A = (Horizontal and Vertical flip, otherwise)

PRG005_A514:
	STA Objects_FlipBits,X	 ; Set proper flip


	CPY #$03
	BEQ PRG005_A52B	 ; If Var4 = 3, jump to PRG005_A52B

	; Var4 <> 3...

	LDA Objects_FlipBits,X
	ASL A
	ASL A	; will set carry if horizontally flipped

	LDA #$04	; A = $04
	BCC PRG005_A526	; If horizontally flipped, jump to PRG005_A526

	LDA #-$04	 ; A = -$04

PRG005_A526:
	ADD <Objects_X,X
	STA <Objects_X,X ; Apply offset to X

PRG005_A52B:

	LDY <Objects_Var4,X	 ; Y = Var4

	LDA FireJet_Frame,Y
	PHA		 ; Save frame value
	STA Objects_Frame,X	 ; -> Frame

	JSR Object_Draw16x32Sprite	 ; Draw bottom of flame

	PLA		 ; Restore frame value
	ADD #$06	 ; +6
	STA Objects_Frame,X	 ; Set as new frame value

	LDA <Objects_Y,X
	PHA		 ; Save Y
	ADD #32
	STA <Objects_Y,X	 ; Add 32 to Y
	LDA <Objects_YHi,X
	PHA		 ; Save Y Hi
	ADC #$00
	STA <Objects_YHi,X

	LDA Object_SprRAM,X
	ADD #16		; 4 sprites forward
	STA Object_SprRAM,X

	JSR Object_ShakeAndDraw	; Draw top of flame

	; Restore Y/Hi
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	JSR Object_CalcSpriteXY_NoHi
	JSR FireJet_PlayerHitTest	 ; Do Player to Fire Jet collision

PRG005_A565:

	; Restore X
	PLA
	STA <Objects_X,X

PRG005_A568:
	RTS		 ; Return

FireJetLR_Patterns:
	.byte $71, $71, $71, $F3, $F5, $F7, $01, $01, $71, $E9, $EB, $ED, $EF, $F1, $01, $01
	.byte $FF, $C1, $C3, $C5, $C7, $C9, $01, $01

PRG005_A581:

	; Left or Right Fire jet here...

	; Temp_Var16 = 0
	LDA #$00
	STA <Temp_Var16

	LDY <Objects_Var4,X
	BEQ PRG005_A568	 ; If Var4 = 0, jump to PRG005_A568 (RTS)

	LDA FireJet_Frame,Y
	STA Objects_Frame,X	 ; -> Frame

	JSR Object_CalcSpriteXY_NoHi

	; Temp_Var1 = Sprite Y - 1
	LDA <Objects_SpriteY,X
	SUB #$01
	STA <Temp_Var1

	; Temp_Var2 = Sprite X
	LDA <Objects_SpriteX,X	
	STA <Temp_Var2	

PRG005_A59D:
	LDA <Temp_Var2
	JSR FireJetLR_SpriteVisibleTest
	BCS PRG005_A605	 ; If sprite is not visible, jump to PRG005_A605

	LDA <Temp_Var16
	ASL A	
	ASL A	
	ADC Object_SprRAM,X
	TAY		 ; Y = Sprite RAM offset

	; Set Sprite Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Set Sprite X
	LDA <Temp_Var2	
	STA Sprite_RAM+$03,Y

	; Counter value -> Temp_Var3
	LDA Level_NoStopCnt
	STA <Temp_Var3

	LDA <Objects_Var4,X
	LSR <Temp_Var3
	CMP #$03
	BEQ PRG005_A5C9	 ; If Var4 = 3, jump to PRG005_A5C9

	; Otherwise, divide it further
	LSR <Temp_Var3
	LSR <Temp_Var3
	LSR <Temp_Var3

PRG005_A5C9:
	LSR <Temp_Var3

	PHP		 ; Save process status

	LDA Level_ObjectID,X
	TAX		 ; This Fire Jet's ID -> 'X'

	LDA #SPR_PAL1	; Use palette select 1

	CPX #OBJ_FIREJET_RIGHT
	BNE PRG005_A5D8	 ; If this is not a rightward fire jet, jump to PRG005_A5D8

	LDA #(SPR_HFLIP | SPR_PAL1)	 ; Use horizontal flip and palette select 1

PRG005_A5D8:
	PLP		 ; Restore process status

	BCC PRG005_A5DD	 ; Periodically jump to PRG005_A5DD

	ORA #(SPR_VFLIP | SPR_PAL1)	 ; Apply vertical flip (and palette select 1, though that's needless)

PRG005_A5DD:
	STA Sprite_RAM+$02,Y	 ; Set sprite attribute

	LDX <SlotIndexBackup		 ; X = object slot index

	; Temp_Var15 = Temp_Var16 (sprite ram offset)
	LDA <Temp_Var16
	STA <Temp_Var15

	LDA Level_ObjectID,X
	CMP #OBJ_FIREJET_RIGHT
	BNE PRG005_A5F4	 ; If this is not a rightward fire jet, jump to PRG005_A5F4

	; Otherwise, Temp_Var15 = 5 - Temp_Var16
	LDA #$05
	SUB <Temp_Var16
	STA <Temp_Var15

PRG005_A5F4:
	LDA Objects_Frame,X
	ASL A
	ASL A
	ASL A
	ADC <Temp_Var15
	TAX		 ; X = appropriate fire jet pattern index

	; Set pattern for this sprite
	LDA FireJetLR_Patterns,X
	STA Sprite_RAM+$01,Y

	LDX <SlotIndexBackup		 ; X = object slot index

PRG005_A605:

	; Temp_Var2 (Sprite X) += 8 (next sprite over)
	LDA <Temp_Var2
	ADD #$08
	STA <Temp_Var2

	INC <Temp_Var16	 ; Temp_Var16

	LDA <Temp_Var16
	CMP #$06
	BNE PRG005_A59D	 ; If this is not the sixth fire jet sprite, jump to PRG005_A59D

FireJet_PlayerHitTest:
	LDA <Objects_Var4,X
	CMP #$03
	BNE PRG005_A61D	 ; If Var4 <> 3, jump to PRG005_A61D (RTS)

	JSR Player_HitEnemy	 ; Do Player to Fire Jet collision

PRG005_A61D:
	RTS		 ; Return


ObjInit_RedPiranhaFlip:
	LDY #$21	 ; Y = $21

	LDA #16		; Start at Y + 16
	BNE PRG005_A628	 ; Jump (technically always) to PRG005_A628

ObjInit_GreenPiranhaFlip:
	LDY #$19	 ; Y = $19

	; X += 8
	LDA #$08

PRG005_A628:
	ADD <Objects_Y,X
	STA <Objects_Y,X

	; Start vertically flipped
	LDA #SPR_VFLIP
	STA Objects_FlipBits,X

	BNE PRG005_A63A	 ; Jump (technically always) to PRG005_A63A

ObjInit_RedPiranha:
	LDY #33	; Y = 33	
	BNE PRG005_A63A	; Jump (technically always) to PRG005_A63A

ObjInit_GreenPiranha:
	LDY #25	; Y = 25

PRG005_A63A:
	; Var5 = original Y
	LDA <Objects_Y,X
	STA <Objects_Var5,X

	TYA
	STA Objects_TargetingYVal,X	 ; Objects_TargetingYVal = 25 if green, 33 if red

	; Objects_Var1 = 9 or 17
	SUB #16
	STA Objects_Var1,X

	; Var7 = Original Y Hi
	LDA <Objects_YHi,X
	STA Objects_Var7,X

	; X += 8
	LDA <Objects_X,X
	ADD #$08
	STA <Objects_X,X

	RTS		 ; Return

Piranha_Style:

	; Bit 0: Set for "ceiling" (vertically flipped) version of Piranha
	; Bit 7: Set for fire spitting type

	.byte $00	; OBJ_GREENPIRANHA
	.byte $01	; OBJ_GREENPIRANHA_FLIPPED
	.byte $00	; OBJ_REDPIRANHA
	.byte $01	; OBJ_REDPIRANHA_FLIPPED
	.byte $80	; OBJ_GREENPIRANHA_FIRE
	.byte $81	; OBJ_GREENPIRANHA_FIREC
	.byte $80	; OBJ_VENUSFIRETRAP
	.byte $81	; OBJ_VENUSFIRETRAP_CEIL

Piranha_FacePlayerFlip:	.byte SPR_HFLIP, $00
Piranha_VFlip:	.byte $00, SPR_VFLIP

ObjNorm_Piranha:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA <Objects_Var4,X

	LDY Objects_FlipBits,X
	BPL PRG005_A66E	 ; If not vertically flipped, jump to PRG005_A66E

	ADD #$02	 ; A = Var4 + 2

PRG005_A66E:
	AND #$03
	BNE PRG005_A67D

	JSR Object_CalcSpriteXY_NoHi

	; Objects_SprHVis = 1 (?)
	LDA #$01
	STA Objects_SprHVis,X

	JMP PRG005_A78F	 ; Jump to PRG005_A78F

PRG005_A67D:
	JSR Level_ObjCalcXDiffs

	; Face Player
	LDA Objects_FlipBits,X
	AND #~SPR_HFLIP
	ORA Piranha_FacePlayerFlip,Y
	STA Objects_FlipBits,X

	; Sprite RAM += 8 (two sprites over)
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	; Toggle frame 0/1
	LDA Objects_Var3,X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	LDA Level_ObjectID,X
	SUB #OBJ_GREENPIRANHA
	TAY		 ; Y = relative Piranha index

	; Load Var2 with appropriate value
	LDA Piranha_Style,Y
	STA Objects_Var2,X
	AND #$01	; Only concerned with bit 0 (set for "ceiling" type) here
	STA <Temp_Var2

	LDA <Objects_Var5,X	; Original Y
	SUB <Objects_Y,X	; - Current Y

	LDY <Temp_Var2
	BEQ PRG005_A6C0	 ; If Temp_Var2 = 0, jump to PRG005_A6C0

	CMP Objects_Var1,X
	BLT PRG005_A6CA	 ; If the Y difference < low Y difference, jump to PRG005_A6C4
	BGE PRG005_A6C4	 ; Otherwise, jump to PRG005_A6C4

PRG005_A6C0:
	CMP #$11
	BGE PRG005_A6CA	 ; If the Y difference >= $11, jump to PRG005_A6CA

PRG005_A6C4:

	; Frame += 2
	INC Objects_Frame,X
	INC Objects_Frame,X

PRG005_A6CA:
	JSR Object_Draw16x32Sprite	; Draw Piranha

	JSR Level_ObjCalcYDiffs
	STY <Temp_Var1		 ; Store Player's relative position value -> Temp_Var1

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	LDA Objects_Var2,X
	BMI PRG005_A6FD	 ; If Var2 is negative, jump to PRG005_A6FD

	LDA Objects_FlipBits,X
	BMI PRG005_A6EE	 ; If Piranha is vertically flipped, jump to PRG005_A6EE

	LDA Sprite_RAM+$02,Y
	AND #~SPR_HFLIP
	STA Sprite_RAM+$02,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y

	BNE PRG005_A712	 ; Jump (technically always) to PRG005_A712

PRG005_A6EE:
	LDA Sprite_RAM+$0A,Y
	AND #~SPR_HFLIP
	STA Sprite_RAM+$0A,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$0E,Y

	BNE PRG005_A72E	 ; Jump (technically always) to PRG005_A72E

PRG005_A6FD:
	LDA Objects_FlipBits,X
	BMI PRG005_A71E	 ; If vertically flipped, jump to PRG005_A71E

	LDX <Temp_Var1		; X = Temp_Var1

	LDA Sprite_RAM+$02,Y
	AND #~SPR_VFLIP
	ORA Piranha_VFlip,X
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

PRG005_A712:

	LDA #SPR_PAL2	; Palette select 2
	STA Sprite_RAM+$0A,Y

	LDA #(SPR_HFLIP | SPR_PAL2)	; Horizontal flip and Palette select 2
	STA Sprite_RAM+$0E,Y

	BNE PRG005_A738	 ; Jump (technically always) to PRG005_A738

PRG005_A71E:
	LDX <Temp_Var1		; X = Temp_Var1

	LDA Sprite_RAM+$0A,Y
	AND #~SPR_VFLIP
	ORA Piranha_VFlip,X
	STA Sprite_RAM+$0A,Y
	STA Sprite_RAM+$0E,Y

PRG005_A72E:
	LDA #(SPR_VFLIP | SPR_PAL2)	; Vertical flip and Palette select 2 
	STA Sprite_RAM+$02,Y

	LDA #(SPR_HFLIP | SPR_VFLIP | SPR_PAL2)	; Horizontal and vertical flip and palette select 2
	STA Sprite_RAM+$06,Y

PRG005_A738:
	LDX <SlotIndexBackup		 ; X = object slot index


	; The following adds the masking sprite over the bottom of the Piranha,
	; the trick used to make it appear as if it is emerging from the pipe..

	LDA Objects_SprVVis,X
	BNE PRG005_A78F	 ; If any sprite is vertically off-screen, jump to PRG005_A78F

	; Temp_Var1 = 1
	LDA #$01
	STA <Temp_Var1

	LDA Objects_Var2,X
	AND #$01
	BEQ PRG005_A74F	 ; If Var2 bit 0 not set, jump to PRG005_A74F

	; Otherwise, load Temp_Var1 = Var1
	LDA Objects_Var1,X
	STA <Temp_Var1

PRG005_A74F:
	LDA Objects_SprHVis,X
	BMI PRG005_A760	 ; If leftmost sprite is horizontally off-screen, jump to PRG005_A760

	; Set Sprite Y at Origin Y - Temp_Var1, made relative to scroll
	LDA <Objects_Var5,X
	SUB <Temp_Var1	
	SUB Level_VertScroll
	STA Sprite_RAM-$08,Y

PRG005_A760:
	LDA Objects_SprHVis,X	
	AND #$40
	BNE PRG005_A773	 ; If the second from left sprite is horizontally off-screen, jump to PRG005_A773

	; Set Sprite Y at Origin Y - Temp_Var1, made relative to scroll
	LDA <Objects_Var5,X
	SUB <Temp_Var1
	SUB Level_VertScroll
	STA Sprite_RAM-$04,Y

PRG005_A773:
	
	; Mask sprite pattern
	LDA #$77
	STA Sprite_RAM-$07,Y
	STA Sprite_RAM-$03,Y

	; Mask sprite attribute
	LDA #$22
	STA Sprite_RAM-$06,Y
	STA Sprite_RAM-$02,Y

	; Copy Sprite X
	LDA Sprite_RAM+$03,Y
	STA Sprite_RAM-$05,Y

	; Copy Sprite X
	LDA Sprite_RAM+$07,Y
	STA Sprite_RAM-$01,Y

PRG005_A78F:
	LDA <Player_HaltGame
	BEQ PRG005_A794	 ; If gameplay is not halted, jump to PRG005_A794

	RTS		 ; Return

PRG005_A794:
	JSR Player_HitEnemy	 ; Do Player to Piranha collision

	INC Objects_Var3,X	 ; Var3++

	LDA <Objects_Var4,X
	AND #$03	; Keep internal state counter 0-3

	JSR DynJump

	.word Piranha_HideInPipe
	.word Piranha_Emerge
	.word Piranha_Attack
	.word Piranha_Retract

Piranha_Emerge:

	; Var5 = original Y 
	; Var7 = original Y Hi

	LDA <Objects_Var5,X		; Original Y
	SUB Objects_TargetingYVal,X	; subtract TargetingYVal
	PHA				; Save it

	LDA Objects_Var7,X
	SBC #$00
	STA <Temp_Var1			; Temp_Var1 = Original Y Hi, carry applied

	PLA		 ; Restore the Original Y difference
	CMP <Objects_Y,X
	LDA <Temp_Var1
	SBC <Objects_YHi,X
	BCS PRG005_A824	 ; Basically if Piranha is at his Y and Y Hi highest point, jump to PRG004_B7F0

	LDA #-$10	 ; A = -$10
	BNE PRG005_A7DC	 ; Jump (technically always) to PRG005_A7DC

Piranha_Retract:

	LDA <Objects_Y,X
	ADD #$01
	PHA		 ; Save Y + 1

	LDA <Objects_YHi,X
	ADC #$00
	STA <Temp_Var1	 ; Temp_Var1 = carry applied to Y Hi

	PLA		 ; Restore Y + 1

	CMP <Objects_Var5,X
	LDA <Temp_Var1	
	SBC Objects_Var7,X
	BCS PRG005_A824	 ; Basically if Piranha is at his Y and Y Hi origin, jump to PRG005_A824

	LDA #$10	 ; A = $10

PRG005_A7DC:
	; Piranha is not fully extended/retracted...

	STA <Objects_YVel,X	 ; Set Y velocity as appropriate
	JMP Object_ApplyYVel_NoLimit	 ; Apply Y velocity and don't come back!!


Piranha_Attack:

	; TIP: For Var2, see Piranha_Style
	LDA Objects_Var2,X	 
	BPL PRG005_A808	 ; If this is not a fire spitting type of Piranha, jump to PRG005_A808

	; Fire spitting piranha...

	LDA Objects_FlipBits,X
	BMI PRG005_A808	 ; If Piranha is vertically flipped, jump to PRG005_A808

	; Var3 = 0
	LDA #$00
	STA Objects_Var3,X

	LDA Objects_Timer,X

	CMP #$10
	BEQ PRG005_A805	 ; If timer = $10, jump to PRG005_A805

	CMP #$40
	BNE PRG005_A808	 ; If timer <> $40, jump to PRG005_A808

PRG005_A805:
	JSR Piranha_SpitFire	 ; Spit fireball at Player

PRG005_A808:
	LDA Objects_Timer,X
	BNE PRG005_A877	 ; If timer not expired, jump to PRG005_A877 (RTS)

	LDA Objects_FlipBits,X
	BPL PRG005_A824	 ; If piranha is not vertically flipped, jump to PRG005_A824

	LDA Objects_Var2,X
	LSR A
	BCS PRG005_A824	 ; If this is a ceiling piranha, jump to PRG005_A824

	; Non-ceiling piranha only...

	JSR Level_ObjCalcXDiffs

	LDA <Temp_Var16
	ADD #$1b
	CMP #$37
	BLT PRG005_A833	 ; If Player is too close, jump to PRG005_A833

PRG005_A824:
	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	LDA #$30	; A = $30

	LDY Level_ObjectID,X
	CPY #OBJ_GREENPIRANHA_FIRE
	BLT PRG005_A830	 ; If this is a red piranha, jump to PRG005_A830

	ASL A		; A = $60

PRG005_A830:
	STA Objects_Timer,X	 ; Set timer

PRG005_A833:
	RTS		 ; Return


Piranha_HideInPipe:
	LDA Objects_Var2,X	 
	BPL PRG005_A85B	 ; If this is not a fire spitting piranha, jump to PRG005_A85B

	LDA Objects_FlipBits,X
	BPL PRG005_A85B	 ; If piranha is not vertically flipped, jump to PRG005_A85B

	; Var3 = 0
	LDA #$00
	STA Objects_Var3,X

	LDA Objects_Timer,X

	CMP #$10
	BEQ PRG005_A858	 ; If timer = $10, jump to PRG005_A805

	CMP #$40
	BNE PRG005_A85B	 ; If timer <> $40, jump to PRG005_A808

PRG005_A858:
	JSR Piranha_SpitFire	 ; Spit fireball at Player

PRG005_A85B:
	LDA Objects_Timer,X
	BNE PRG005_A877	 ; If timer not expired, jump to PRG005_A877

	LDA Objects_FlipBits,X
	BMI PRG005_A824	 ; If piranha is vertically flipped, jump to PRG005_A824

	LDA Objects_Var2,X
	LSR A
	BCS PRG005_A824	 ; If this is a ceiling piranha, jump to PRG005_A824

	; Non-ceiling piranha only...

	JSR Level_ObjCalcXDiffs

	LDA <Temp_Var16
	ADD #$1b
	CMP #$37
	BGE PRG005_A824	 ; If Player is too far, jump to PRG005_A833

PRG005_A877:
	RTS		 ; Return

PiranhaFireball_YVel:	.byte $0B, $05
PiranhaFireball_XVel:	.byte $0B, $0E

Piranha_SpitFire:
	LDY #$00	 ; Y = 0

	LDA Objects_FlipBits,X
	BPL PRG005_A885	 ; If piranha is not vertically flipped, jump to PRG005_A885

	LDY #16		 ; Y = 16

PRG005_A885:
	STY <Temp_Var1	 ; Temp_Var1 = 0 or 16

	LDY #$03	 ; Y = 3
	JSR SpecialObj_FindEmptyAbortY	 ; Find an empty slot from special object slot 0 to 3 or don't come back!

Reznor_SpitFire5:
	; Set X offset
	LDA <Objects_X,X
	ADD #$03
	STA SpecialObj_XLo,Y

Clyde_SpitFire5:
	; Set Y offset
	LDA <Objects_Y,X
	ADD <Temp_Var1
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA SpecialObj_YHi,Y

	; Piranha fireball
	LDA #SOBJ_PIRANHAFIREBALL
	STA SpecialObj_ID,Y

	STY <Temp_Var1		 ; Special object slot index -> Temp_Var1

	; Y difference -> Temp_Var6
	JSR Level_ObjCalcYDiffs
	STY <Temp_Var6	

	; X difference -> Temp_Var7
	JSR Level_ObjCalcXDiffs
	STY <Temp_Var7	

	LDX #$00	 ; X = 0 (Player is close)

	LDA <Temp_Var16
	ADD #$50
	CMP #$a0
	BLT PRG005_A8C0	 ; If Player is close, jump to PRG005_A8C0

	INX		 ; X = 1 (Player is far)

PRG005_A8C0:
	LDY <Temp_Var1		 ; Y = special object slot index

	LDA PiranhaFireball_YVel,X

	LSR <Temp_Var6
	BCC PRG005_A8CC	 ; If Y differance is not negative, jump to PRG005_A8CC

	JSR Negate	 ; Otherwise, negate the loaded Y velocity

PRG005_A8CC:
	STA SpecialObj_YVel,Y	 ; Set fireball Y velocity

	LDA PiranhaFireball_XVel,X

	LSR <Temp_Var7
	BCC PRG005_A8D9	 ; If X difference is not negative, jump to PRG005_A8D9

	JSR Negate	 ; Otherwise negate the loaded X velocity

PRG005_A8D9:
	STA SpecialObj_XVel,Y	 ; Set fireball X velocity

	LDA #$00
	STA SpecialObj_XVelFrac,Y
	STA SpecialObj_YVelFrac,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return


	; Returns carry set if not visible, carry clear if is visible
	; Very similar to ChainChomp_LinkVisibleTest
FireJetLR_SpriteVisibleTest:

	; Backup X, Y, A
	STX <Temp_Var4
	STY <Temp_Var3
	STA <Temp_Var2

	LDX <SlotIndexBackup		 ; X = object slot index


	LDA Objects_SprVVis,X
	BNE PRG005_A97E	 ; If any sprite is vertically off-screen, jump to PRG005_A97E

	LDY #$40	 ; Y = $40

	LDA <Objects_SpriteX,X
	BMI PRG005_A971	 ; If on right half, jump to PRG005_A971

	LDY #$c0	 ; Y = $C0

PRG005_A971:
	CPY <Temp_Var2
	EOR Objects_SprHVis,X
	BMI PRG005_A97C
	BCC PRG005_A97E	
	BCS PRG005_A981

PRG005_A97C:
	BCC PRG005_A981

PRG005_A97E:
	SEC		 ; Set carry (sprite not visible)
	BCS PRG005_A982	 ; Jump (technically always) to PRG005_A982

PRG005_A981:
	CLC		 ; Clear carry (sprite visible)

PRG005_A982:
	; Restore Y, A, X
	LDY <Temp_Var3
	LDA <Temp_Var2
	LDX <Temp_Var4

	RTS		 ; Return

ObjInit_FireJetLeft:
	DEC <Objects_Y,X	 ; Start at Y - 1
	LDY <Objects_Y,X
	INY
	BNE ObjInit_FireJetRight
	DEC <Objects_YHi,X	 ; Apply carry

ObjInit_FireJetRight:
	RTS		 ; Return

RockyWrench_FlipBits:	.byte $60, $20

ObjInit_RockyWrench:
	INC <Objects_Var4,X	 ; Var4 = 1 (keeps Rocky alive)

Rocky_FacePlayer:
	JSR Level_ObjCalcXDiffs

	; Set flip towards Player
	LDA RockyWrench_FlipBits,Y
	STA Objects_FlipBits,X	

	RTS		 ; Return

	; Timer reload values for Rocky by his internal state
Rocky_TimerReload:
	.byte $00, $20, $16, $20, $20, $10

ObjNorm_RockyWrench:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG005_A9B1	 ; If Rocky's state is Normal, jump to PRG005_A9B1

	JMP Rocky_Draw	 ; Draw Rocky and don't come back!

PRG005_A9B1:

	; Set Rocky's priority
	LDA Objects_FlipBits,X
	ORA #SPR_BEHINDBG
	STA Objects_FlipBits,X

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	; Sprite RAM +8 (Two sprites over)
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	JSR Object_ShakeAndDraw	 ; Draw Rocky

	LDA Objects_Frame,X
	CMP #$01
	BNE PRG005_A9F7	 ; If frame <> 1, jump to PRG005_A9F7

	JSR Object_AnySprOffscreen
	BNE PRG005_A9F7	 ; If any of Rocky's sprites are off-screen, jump to PRG005_A9F7

	; Set Rocky's held wrench Y
	LDA <Objects_SpriteY,X
	SUB #$08
	STA Sprite_RAM-$08,Y

	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA #$00	; A = 0

	BCS PRG005_A9E7	 ; If Rocky is horizontally flipped, jump to PRG005_A9E7

	LDA #$08	; A = 8

PRG005_A9E7:

	; Offset Rocky's Wrench X
	ADD <Objects_SpriteX,X
	STA Sprite_RAM-$05,Y

	; Rocky's Wrench pattern
	LDA #$a1
	STA Sprite_RAM-$07,Y

	; Palette select 1
	LDA #SPR_PAL1
	STA Sprite_RAM-$06,Y

PRG005_A9F7:
	LDA <Player_HaltGame
	BNE PRG005_AA38	 ; If gameplay is halted, jump to PRG005_AA38

	JSR Rocky_KillOrStandOn	 ; Kill Rocky or stand on top of him

	LDA <Objects_Var5,X	 ; Var5 is internal state

	JSR DynJump
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!! 

	.word Rocky_FaceAndPopup	; 0: After timer, Rocky pops up and faces Player
	.word Rocky_WaitTimer		; 1: Just waiting for timer to expire
	.word Rocky_RiseUp		; 2: Rocky rises up
	.word Rocky_ReadyThrowWrench	; 3: Gets ready to throw wrench
	.word Rocky_WrenchToss		; 4: Toss the wrench
	.word Rocky_DieOrWaitRevive	; 5: Rocky is dead if Var4 = 0, otherwise delay until revive
	.word Rocky_Killed		; 6: Rocky's killed state

Rocky_FaceAndPopup:
	LDA Objects_Timer,X	 
	BNE PRG005_AA38	 ; If timer not expired, jump to PRG005_AA38 (RTS)

	JSR Rocky_FacePlayer	 ; Rocky faces Player
 
	; Rocky "pops up" to look for Player
	LDA <Objects_Y,X
	ADD #$08
	AND #$f0
	SUB #$06
	STA <Objects_Y,X
	BCS Rocky_WaitTimer
	DEC <Objects_YHi,X	 ; Apply carry

	; Wait for timer to expire, go to next state, reload timer
Rocky_WaitTimer: 

	LDA Objects_Timer,X
	BNE PRG005_AA38	 ; If timer not expired, jump to PRG005_AA38 (RTS)

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	LDY <Objects_Var5,X	 
	LDA Rocky_TimerReload,Y	 ; Load timer value by internal state
	STA Objects_Timer,X	 ; Set timer

PRG005_AA38:
	RTS		 ; Return

Rocky_RiseUp:
	; Set frame 0 and advance state after timer expires
	LDA #$00	 
	JSR Rocky_UpdFrameAdvIntState

	LDA Objects_Timer,X
	LSR A
	BCS PRG005_AA4D	 ; Every other tick, jump to PRG005_AA4D (RTS)

	; Move up one pixel
	DEC <Objects_Y,X
	LDY <Objects_Y,X
	INY	
	BNE PRG005_AA4D
	DEC <Objects_YHi,X
PRG005_AA4D:

	RTS		 ; Return


Rocky_ReadyThrowWrench:
	LDA #$01 	; Ready to throw frame

Rocky_UpdFrameAdvIntState:
	STA Objects_Frame,X	  ; Update frame
	JMP Rocky_WaitTimer	 ; Wait for timer to expire and advance state afterward

Rocky_WrenchToss:

	; Set frame 2 (thrown wrench) and advance state after timer expires
	LDA #$02
	JSR Rocky_UpdFrameAdvIntState

	LDA Objects_Timer,X
	CMP #$1f
	BNE PRG005_AA65	 ; 1:32 ticks proceed, otherwise jump to PRG005_AA65

	JSR Rocky_ThrowWrench	 ; Throw Wrench 

PRG005_AA65:
	RTS		 ; Return

Rocky_DieOrWaitRevive:
	LDA Objects_Timer,X	  
	BNE PRG005_AA7F	 ; If timer not expired, jump to PRG005_AA7F

	LDA <Objects_Var4,X
	BNE PRG005_AA75	 ; If Var4 <> 0 (Rocky will come back, otherwise he's gone forever), jump to PRG005_AA75

	; Set Rocky's state to Dead/Empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	RTS		 ; Return

PRG005_AA75:
	; Go back to initial internal state
	LDA #$00
	STA <Objects_Var5,X

	; Set timer to $40
	LDA #$40
	STA Objects_Timer,X

	RTS		 ; Return

PRG005_AA7F:

	; +1 to Rocky's Y
	INC <Objects_Y,X
	BNE PRG005_AA85	
	INC <Objects_YHi,X
PRG005_AA85:

	; Frame = 0
	LDA #$00
	STA Objects_Frame,X

	RTS		 ; Return

Rocky_Killed:
	LDA Objects_Timer,X	  
	BNE PRG005_AA96	 ; If timer not expired, jump to PRG005_AA96

	; Set Rocky state to Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	RTS		 ; Return

PRG005_AA96:

	; Set frame to 3
	LDA #$03
	STA Objects_Frame,X

	RTS		 ; Return

Rocky_KillOrStandOn:
	LDA <Objects_Var5,X
	CMP #$06
	BEQ PRG005_AAE8	 ; If Var5 = 6, jump to PRG005_AAE8 (RTS)

	; Bumps up the kill Tally so Rocky's base score is 200 pts IF he gets bumped from underneath
	; But that never happens??
	INC Kill_Tally
	JSR Object_HandleBumpUnderneath
	DEC Kill_Tally

	LDA Objects_PlayerHitStat,X
	BEQ PRG005_AAE8	; If Player has not collided with Rocky, jump to PRG005_AAE8

	LDA <Player_YVel
	BMI PRG005_AAE8	 ; If Player is moving upward, jump to PRG005_AAE8 (RTS)

	CMP #$10
	BGE PRG005_AACA	 ; If Player is falling faster than $10, jump to PRG005_AACA

	; Player not falling fast enough; stand on top of Rocky

	; Flag Player as not mid-air
	LDA #$00
	STA <Player_InAir

	; Set Player at Rocky's Y - 31
	LDA <Objects_Y,X
	SUB #31
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	RTS		 ; Return

PRG005_AACA:

	; Rocky got stepped on!

	; Var5 = 6
	LDA #$06
	STA <Objects_Var5,X

	; Timer = $0C
	LDA #$0c
	STA Objects_Timer,X

	; Bounce Rocky a bit
	LDA #-$30
	STA <Player_YVel

	; Kill sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; Score for the kill!
	LDA Kill_Tally
	INC Kill_Tally
	JSR Score_Get100PlusPts

PRG005_AAE8:
	RTS		 ; Return

Rocky_WrenchYVel:	.byte $00, -$10, -$20, -$10, $00, -$10, -$20, -$10

Rocky_ThrowWrench:

	; Rocky's wrench throw

	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot or don't come back!

	; Set Wrench at Rocky's Y - 8
	LDA <Objects_Y,X
	SUB #$08
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	LDA Level_AScrlHVel
	CMP #$0e

	LDA #$10	; A = $10 (horizontal velocity < $0E)

	BLT PRG005_AB13		; If autoscroll horizontal velocity < $0E, jump to PRG005_AB13

	LDA #$18	; A = $18 (otherwise)

PRG005_AB13:
	STA <Temp_Var3		 ; -> Temp_Var3

	LDA Objects_FlipBits,X
	ASL A
	ASL A

	STY <Temp_Var1	 ; Special object slot index -> Temp_Var1

	LDA <Temp_Var3
	BCS PRG005_AB22	 ; If Rocky is horizontally flipped, jump to PRG005_AB22

	LDA #-$10

PRG005_AB22:
	STA SpecialObj_XVel,Y	 ; Set appropriate X velocity of wrench

	LDA RandomN,X
	AND #$07
	TAY		 ; Y = 0 to 7, random

	; Set Rocky's Wrench Y Velocity
	LDA Rocky_WrenchYVel,Y
	LDY <Temp_Var1	
	STA SpecialObj_YVel,Y

	; Rocky's Wrench ID
	LDA #SOBJ_WRENCH
	STA SpecialObj_ID,Y

	RTS		 ; Return

Rocky_Draw:
	LDY #$02	 ; Y = 2

	LDA Level_NoStopCnt
	AND #$10
	BEQ PRG005_AB43	 ; 16 ticks on, 16 ticks off; jump to PRG005_AB43

	INY		 ; Y = 3

PRG005_AB43:
	TYA		 ; A = 2 or 3

	STA Objects_Frame,X	 ; Set frame to 2 or 3

	; Set Rocky's priority
	LDA #SPR_BEHINDBG
	STA Objects_FlipBits,X

	JMP Object_DrawTallAndHFlip	 ; Draw Rocky and don't come back!

ObjInit_BoltLift:

	; Set at Y - 1
	LDA <Objects_Y,X
	SUB #$01
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X

PRG005_AB5C:
	RTS		 ; Return

PRG005_AB5D:	.byte $60, $70, $80, $90, $A0, $B0, $C0, $D0

ObjNorm_BoltLift:
	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JSR Object_ShakeAndDraw	 	; Draw left half of bolt lift

	LDA Objects_SprHVis,X
	PHA		 ; Save horizontal visibility bits

	; Shift over visibility to draw second half
	ASL A
	ASL A
	STA Objects_SprHVis,X

	LDA <Objects_X,X
	PHA		 	; Save object X
	ADD #16
	STA <Objects_X,X 	; Add 16 to bolt lift's X

	LDA <Objects_XHi,X
	PHA			; Save object X Hi
	ADC #$00
	STA <Objects_XHi,X 	; Apply carry

	; Two sprites over
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	JSR Object_ShakeAndDraw	 ; Draw right half of bolt lift

	; Restore XHi / X / horizontal visibility bits
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X
	PLA
	STA Objects_SprHVis,X

	JSR Object_CalcSpriteXY_NoHi

	LDA <Player_HaltGame
	BNE PRG005_AB5C	 ; If gameplay is halted, jump to PRG005_AB5C

	LDA <Objects_XVel,X
	BEQ PRG005_ABC9	 ; If bolt lift is not moving horizontally, jump to PRG005_ABC9
	BPL PRG005_ABA9	 ; If bolt lift is moving to the right, jump to PRG005_ABA9

	JSR Negate	 ; Otherwise, negate the X velocity (absolute velocity)

PRG005_ABA9:
	ASL A
	ASL A
	ASL A
	ASL A		 	; Divide absolute value of X velocity by 16
	ADC #$60	 	; A = $60 to $6F
	ADC Objects_Var7,X	; Add Var7
	STA Objects_Var7,X	; -> Var7

	BCC PRG005_ABC9	 	; If no overflow, jump to PRG005_ABC9

	LDA <Objects_XVel,X
	ASL A

	LDA #$01	 ; A = 1
	BCC PRG005_ABC0	 ; If X velocity is not negative, jump to PRG005_ABC0
	LDA #-$01	 ; A = -1 

PRG005_ABC0:
	ADD Objects_Frame,X	; Add current frame value
	AND #$03	 	; Modulus 3 (frame capped into 0 to 3)
	STA Objects_Frame,X	; -> Frame

PRG005_ABC9:
	LDA <Objects_Var5,X
	BEQ PRG005_ABD0	 ; If Var5 = 0, jump to PRG005_ABD0

	JMP PRG005_AC57	 ; Jump to PRG005_AC57 (indirect to Object_Move)

PRG005_ABD0:
	LDA <Counter_1
	AND #$07
	BNE PRG005_ABE2	 ; 1:8 ticks proceed, otherwise jump to PRG005_ABE2

	LDA <Objects_XVel,X
	BEQ PRG005_ABE2	 ; If bolt is not moving horizontally, jump to PRG005_ABE2
	BPL PRG005_ABE0	 ; If bolt is moving to the right, jump to PRG005_ABE0

	; Bolt moving to the left; slow down
	INC <Objects_XVel,X
	INC <Objects_XVel,X	; This is just to overcome the DEC that follows, so really only one INC

PRG005_ABE0:

	; Bolt moving to the right; slow down
	DEC <Objects_XVel,X

PRG005_ABE2:
	JSR Bolt_CheckOnThread	 ; Checks if bolt is on thread tile; if not, Var5 = 1

	JSR Object_WorldDetectN1
	LDA Object_TileWall2
	CMP #TILE10_BOLT_H
	BNE PRG005_ABF5	 	; If bolt has not hit thread end tile, jump to PRG005_ABF5

	; Bolt hit thread end, halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	INC <Objects_DetStat,X	 ; DetStat++ (bad use of this var :P)

PRG005_ABF5:
	JSR Bolt_ToBoltCollide	; Bolt-to-bolt intersection response

	JSR Object_ApplyXVel	; Apply X velocity

	LDA <Objects_XVel,X
	BEQ PRG005_AC04	 	; If bolt is not moving horizontally, jump to PRG005_AC04

	LDA Objects_Timer,X
	BNE PRG005_AC56	 	; If timer not expired, jump to PRG005_AC56 (RTS)

PRG005_AC04:
	JSR Object_CalcSpriteXY_NoHi

	JSR Object_HitTest
	BCC PRG005_AC56	 	; If Player isn't touching bolt, jump to PRG005_AC56 (RTS)

	LDA <Player_SpriteY
	ADC #23
	CMP <Objects_SpriteY,X
	BGE PRG005_AC36	 	; If Player is lower than the top of bolt, jump to PRG005_AC36

	LDA <Player_YVel
	BMI PRG005_AC35		; If Player is moving upward, jump to PRG005_AC35 (RTS)

	LDA <Objects_DetStat,X	; Bad use of this var
	BNE PRG005_AC20	 	; If bolt hit end of thread, jump to PRG005_AC20

	; Bolt moves to the right
	LDA #$05
	STA <Objects_XVel,X

PRG005_AC20:

	LDA #$10
	STA Objects_Timer,X	; Set timer to $10
	STA Player_AllowAirJump	; Lets Player jump off bolt

	LDA #$00
	STA <Player_YVel	; Halt Player's vertical movement
	STA <Player_InAir	; Flag Player as not mid-air

	; Set Player to top of bolt
	LDA <Objects_Y,X
	SUB #30
	STA <Player_Y

PRG005_AC35:
	RTS		 ; Return

PRG005_AC36:
	LDA #-4		; A = -4

	LDY <Player_Suit
	BNE PRG005_AC3E	 ; If Player is not small, jump to PRG005_AC3E

	LDA #12	 	; A = 12

PRG005_AC3E:
	ADD <Player_SpriteY	; Offset Player Y
	CMP <Objects_SpriteY,X
	BLT PRG005_AC52		; If Player is not hitting head off bolt, jump to PRG005_AC52

	LDA <Player_YVel
	BPL PRG005_AC51	 ; If Player is moving downard, jump to PRG005_AC51 (RTS)
	
	; Move bolt backward
	LDA #-$05
	STA <Objects_XVel,X

	; Player bumped head off bolt!
	LDA #$10
	STA <Player_YVel

PRG005_AC51:
	RTS		 ; Return

PRG005_AC52:

	; Halt horizontal movement
	LDA #$00
	STA <Player_XVel

PRG005_AC56:
	RTS		 ; Return

PRG005_AC57:
	JMP Object_Move	; Do standard movements and don't come back!

Bolt_CheckOnThread:
	LDA #-30	 ; A = -30 (X offset for bolt moving to the right)

	LDY <Objects_XVel,X
	BEQ PRG005_AC93	 ; If bolt is not moving horizontally, jump to PRG005_AC93
	BPL PRG005_AC64	 ; If bolt is moving to the right, jump to PRG005_AC64

	LDA #30		 ; A = 30 (X offset for bolt moving to the left)

PRG005_AC64:
	LDY #$00	 ; Y = $00 (16-bit sign extension)
	CMP #$00
	BGS PRG005_AC6B	 ; If decided value is non-negative ($1E), jump to PRG005_AC6B
	DEY		 ; Y = $FF (16-bit sign extension)

PRG005_AC6B:
	STA <Temp_Var1	 ; A = -30 or 30

	LDA <Objects_X,X
	PHA		 ; Save bolt's X
	ADD <Temp_Var1	 ; Add decided value
	STA <Objects_X,X ; -> bolt's X

	LDA <Objects_XHi,X
	PHA		 ; Save bolt's X Hi
	TYA		 ; sign extension -> 'A'
	ADC <Objects_XHi,X	 ; Apply sign
	STA <Objects_XHi,X	 ; -> X Hi

	JSR Object_WorldDetectN1

	; Restore X/Hi
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	LDA Object_TileWall2
	CMP #TILE10_BOLT_H
	BEQ PRG005_AC93	 ; If bolt lift has hit a thread end tile, jump to PRG005_AC93

	CMP #TILE10_THREAD_H
	BEQ PRG005_AC93	 ; If bolt lift is running along the thread, jump to PRG005_AC93

	; Bolt is run into the end
	INC <Objects_Var5,X	 ; Var5 = 1

PRG005_AC93:
	RTS		 ; Return

Bolt_ToBoltCollide:
	LDA Objects_SprVVis,X 
	BNE PRG005_AD06	 ; If any sprite of the bolt is vertically off-screen, jump to PRG005_AD06 (RTS)

	LDA Objects_SprHVis,X
	AND #%11000000
	CMP #%11000000
	BEQ PRG005_AD06	 ; If left two sprites are off-screen, jump to PRG005_AD06 (RTS)

	JSR Object_CalcBoundBox2
	TXA
	BEQ PRG005_AD06	 ; If this is object slot 0, jump to PRG005_AD06 (RTS)

	DEX		 ; X-- (consider previous object)

PRG005_ACA9:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG005_AD01	 ; If state is not Normal, jump to PRG005_AD01 (skip this object)

	LDA Level_ObjectID,X
	CMP #OBJ_BOLTLIFT
	BNE PRG005_AD01	 ; If this is not another bolt lift, jump to PRG005_AD01 (skip this object)

	LDA Objects_SprVVis,X
	BNE PRG005_AD01	 ; If this other bolt is vertically off-screen, jump to PRG005_AD01 (skip this object)

	LDA Objects_SprHVis,X
	AND #%11000000
	CMP #%11000000
	BEQ PRG005_AD01	 ; If this other bolt is horizontally off-screen, jump to PRG005_AD01 (skip this object)

	JSR Object_CalcSpriteXY_NoHi
	JSR Object_CalcBoundBox
	JSR ObjectObject_Intersect
	BCC PRG005_AD01	 ; If the two bolts are colliding with eachother, jump to PRG005_AD01 (skip this object)

	LDY <SlotIndexBackup	 ; Y = current bolt's object slot index

	LDA <Objects_X,X
	SUB Objects_X,Y
	PHA		 ; Save X difference of two bolts

	LDA <Objects_XHi,X
	SBC Objects_XHi,Y
	STA <Temp_Var1	 ; Temp_Var1 = difference of X His

	ROL <Temp_Var2	 ; Pushes sign bit

	PLA		 ; Restore X difference

	ADC #$80
	LDA <Temp_Var1
	ADC #$00
	BNE PRG005_AD01	 ; If bolts haven't hit, jump to PRG005_AD01 (skip this object)

	LSR <Temp_Var2

	LDA #-$01	 ; A = -$01
	BCS PRG005_ACF3	 

	LDA #$01	 ; A = $01

PRG005_ACF3:

	STX <Temp_Var16		 ; Backup this other bolt's index

	LDX <SlotIndexBackup	 ; X = original bolt object slot index
	STA <Objects_XVel,X	 ; Set this bolt's X velocity

	PHA		 ; ?? doesn't do anything useful (see immediately below)

	LDX <Temp_Var16	 ; Restore this other bolt's index 

	PLA		 ; ?? doesn't do anything useful (see immediately above)

	EOR #$ff	 ; The opposite value 

	STA <Objects_XVel,X	 ; Store opposing value into the other bolt

PRG005_AD01:
	DEX		 ; X-- (previous object)
	BPL PRG005_ACA9	 ; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

PRG005_AD06:
ObjInit_Sun:
	RTS		 ; Return

Sun_VelAccel:	.byte $08, $F8, $08, $F8
Sun_VelLimits:	.byte $40, $C0, $40, $C0
	
ObjNorm_Sun:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG005_AD1E	 ; If sun's state is Normal, jump to PRG005_AD1E

	; Set frame to 1
	LDA #$01
	STA Objects_Frame,X

	JMP Sun_Draw	 ; Draw Sun and don't come back

PRG005_AD1E:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA Objects_Var7,X
	BEQ PRG005_AD29	 ; If Var7 = 0 (initial internal state), jump to PRG005_AD29

	JSR Player_HitEnemy	 ; Do Player to Sun collision

PRG005_AD29
	LDA <Player_HaltGame
	BNE PRG005_AD41	 ; If gameplay halted, jump to PRG005_AD41

	LDY #$00	 ; Y = $00 (16-bit sign extension)
	BNE PRG005_AD48	 ; Jump technically NEVER to PRG005_AD48

	LDA Level_ScrollDiffH
	BPL PRG005_AD37	 ; If the screen scroll difference is positive, jump to PRG005_AD37

	DEY		 ; Y = $FF (16-bit sign extension)

PRG005_AD37:
	ADD <Objects_X,X ; Sun moves by horizontal scroll
	STA <Objects_X,X ; Update X position

	TYA		 ; Sign extension -> 'A'
	ADC <Objects_XHi,X	 ; Apply carry
	STA <Objects_XHi,X	 ; Update XHi

PRG005_AD41:
	JSR Sun_Draw	 ; Draw the Sun

	LDA <Player_HaltGame
	BNE PRG005_AD7D	 ; If gameplay halted, jump to PRG005_AD7D (RTS)

PRG005_AD48:
	LDY #$00	 ; Y = 0

	LDA <Counter_1
	AND #%00001100
	BEQ PRG005_AD51	 ; 12 ticks on, 12 ticks off; jump to PRG005_AD51

	INY		 ; Y = 1

PRG005_AD51:
	TYA		 
	STA Objects_Frame,X	 ; Periodically use frame 0 or 1

	LDA Objects_Var7,X	 ; Var7 is internal state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!! 
	.word Sun_WaitFarEnough		; 0: Waits until screen has 
	.word Sun_WaitThenAttackRight	; 1: Does circling movements and then starts attack to the right
	.word Sun_WaitAndResetTimer20	; 2: Resets timer to $20 after it expires
	.word Sun_WaitForUpperReturn	; 3: Waits for the Sun to make his way back up to the top
	.word Sun_WaitThenAttackLeft	; 4: Does circling movements and then starts attack to the left
	.word Sun_WaitAndResetTimer20	; 5: Resets timer to $20 after it expires
	.word Sun_WaitForUpperReturn2	; 6: Waits for the Sun to make his way back up to the top

Sun_WaitFarEnough:
	LDA #$00	 
	STA Objects_Frame,X	 ; Hold Sun in frame 0

	;LDA <Objects_XHi,X
	;CMP #$05
	;BNE PRG005_AD7D	 ; If Sun has not yet reached the fifth screen, jump to PRG005_AD7D

	; We're on the fifth screen...

	LDA <Objects_X,X
	CMP #176
	BLT PRG005_AD7D	 ; If the sun is less than 176 pixels across on the fifth screen, jump to PRG005_AD7D

	JSR PRG005_ADF6	 ; Prepare to enter internal state 1

PRG005_AD7D:
	RTS		 ; Return


Sun_WaitThenAttackRight:
	JSR Sun_DoMovement	 ; Do sun's circling movement

	LDA Objects_Timer,X
	BNE PRG005_AD96	 ; If timer not expired, jump to PRG005_AD96 (RTS)

	INC Objects_Var7,X	 ; Next internal state

	; Sun launches down and to the right!

	; Set Y velocity to $40
	LDA #$40
	STA <Objects_YVel,X

	; Set X velocity to $14
	LDA #$14
	STA <Objects_XVel,X

PRG005_AD91:
	; Set timer to $10
	LDA #$10
	STA Objects_Timer,X

PRG005_AD96:
	RTS		 ; Return

Sun_WaitThenAttackLeft:
	JSR Sun_DoMovement	 ; Do sun's circling movement

	LDA Objects_Timer,X
	BNE PRG005_ADAD		; If timer not expired, jump to PRG005_ADAD

	INC Objects_Var7,X	 ; Var7++ (next internal state)

	; Set Y velocity to $40
	LDA #$40
	STA <Objects_YVel,X

	; Set X velocity to -$14
	LDA #-$14
	STA <Objects_XVel,X

	JMP PRG005_AD91	; Jump to PRG005_AD91

PRG005_ADAD:
	RTS		 ; Return

Sun_TimerReload:	.byte $40, $60, $80, $A0
	
Sun_WaitForUpperReturn:
	JSR Object_ApplyXVel	  	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	; Apply Y Velocity

	DEC <Objects_YVel,X	; Sun slows down and moves upward

	LDA <Objects_Y,X
	CMP #16
	BGE PRG005_ADE3	 ; If Sun's Y >= 16, jump to PRG005_ADE3 (RTS)

	; Lock Sun Y at 16
	LDA #16
	STA <Objects_Y,X

	INC Objects_Var7,X	 ; Var7++ (next internal state)

	; Set directions
	LDA #$01
	STA Objects_TargetingYVal,X
	STA Objects_TargetingXVal,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	; Set Y Vel to -$40
	LDA #-$40
	STA <Objects_YVel,X

PRG005_ADD7:
	LDA RandomN,X
	AND #$03
	TAY		 ; Y = random 0 to 3

	; Reload the sun with a randomly selected timer value
	LDA Sun_TimerReload,Y
	STA Objects_Timer,X

PRG005_ADE3:
	RTS		 ; Return


Sun_WaitForUpperReturn2:
	JSR Object_ApplyXVel	 	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	; Apply Y velocity

	DEC <Objects_YVel,X	; Sun slows down and moves upward

	LDA <Objects_Y,X
	CMP #16
	BGE PRG005_AE10	 ; If Sun's Y >= 16, jump to PRG005_AE10 (RTS)

	; Lock Sun Y at 16
	LDA #16
	STA <Objects_Y,X

PRG005_ADF6:

	; Set internal state to 1
	LDA #$01
	STA Objects_Var7,X

	; Objects_TargetingYVal = 1
	LDA #$01
	STA Objects_TargetingYVal,X

	; Objects_TargetingXVal = 0
	LDA #$00
	STA Objects_TargetingXVal,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	; Set Y Vel = -$40
	LDA #-$40
	STA <Objects_YVel,X

	JMP PRG005_ADD7	; Jump to PRG005_ADD7

PRG005_AE10:
	RTS		 ; Return

Sun_WaitAndResetTimer20:
	LDA Objects_Timer,X	  
	BNE PRG005_AE21	 ; If timer not expired, jump to PRG005_AE21

	INC Objects_Var7,X	 ; Var7++ (next internal state)

	LDY Objects_Var7,X	; ??

	; Set timer to $20
	LDA #$20
	STA Objects_Timer,X

PRG005_AE21:
	RTS		 ; Return

Sun_DoMovement:
	JSR Object_ApplyXVel	  	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	; Apply Y velocity

	; Objects_TargetingXVal is used as a horizontal direction here
	LDA Objects_TargetingXVal,X
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA <Objects_XVel,X
	CMP Sun_VelLimits,Y
	BNE PRG005_AE39	 ; If Sun is not at his X Vel limit, jump to PRG005_AE39

	INC Objects_TargetingXVal,X	 ; Otherwise, change horizontal direction
	INY		 ; Y++

PRG005_AE39:
	ADD Sun_VelAccel,Y	 ; Apply acceleration to X velocity
	STA <Objects_XVel,X	 ; Update X velocity

	; Objects_TargetingYVal is used as a vertical direction here
	LDA Objects_TargetingYVal,X
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA <Objects_YVel,X
	CMP Sun_VelLimits,Y
	BNE PRG005_AE50	 ; If Sun is not at his X Vel limit, jump to PRG005_AE50

	INC Objects_TargetingYVal,X	 ; Otherwise, change vertical direction
	INY		 ; Y++

PRG005_AE50:
	ADD Sun_VelAccel,Y	 ; Apply acceleration to Y velocity
	STA <Objects_YVel,X	 ; Update Y velocity

PRG005_AE56:
	RTS		 ; Return

Sun_Patterns:		.byte $97, $91
Sun_SpriteYOffs:	.byte $08, $00

Sun_Draw:
	LDA Objects_FlipBits,X
	AND #~SPR_BEHINDBG	 ; Clear priority bit

	LDY Objects_Var7,X
	BNE PRG005_AE67	 ; If Var7 <> 0, jump to PRG005_AE67

	ORA #SPR_BEHINDBG	 ; Set priority bit

PRG005_AE67:
	STA Objects_FlipBits,X	 ; Update attributes
 
	LDA Objects_SprHVis,X
	STA Temp_VarNP0	 ; Sprite horizontal visibility -> Temp_VarNP0

	LDA <Objects_X,X
	PHA		 ; Save Sun's X

	ADD #$08
	STA <Objects_X,X ; Set Sun's X + 8

	LDA <Objects_XHi,X
	PHA		 ; Save Sun's X Hi

	ADC #$00	 ; Apply carry
	STA <Objects_XHi,X	 ; Update X Hi

	ASL Objects_SprHVis,X

	JSR Object_DrawTallAndHFlip	 ; Draw's middle of sun

	; Restore X/Hi
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	; Left and right edges of sun...

	JSR Object_CalcSpriteXY_NoHi

	LDY Object_SprRAM,X	 ; Y = Sprite RAM offset

	LDA Objects_SprVVis,X
	BNE PRG005_AE56	 ; If Sun is vertically off-screen, jump to PRG005_AE56 (RTS)

	; Sun's Sprite Y -> Temp_Var1
	LDA <Objects_SpriteY,X
	STA <Temp_Var1	

	LDA Objects_Frame,X
	TAX		 ; Frame -> 'X'

	LDA Temp_VarNP0
	BMI PRG005_AEAC	 ; If sprite is horizontally off-screen, jump to PRG005_AEAC

	; Set Sprite Y
	LDA <Temp_Var1	
	ADD Sun_SpriteYOffs,X
	STA Sprite_RAM+$10,Y

PRG005_AEAC:
	LDA Temp_VarNP0	
	AND #%00010000
	BNE PRG005_AEBC	 ; If this sprite is horizontally off-screen, jump to PRG005_AEBC

	; Set Sprite Y
	LDA <Temp_Var1
	ADD Sun_SpriteYOffs,X
	STA Sprite_RAM+$14,Y

PRG005_AEBC:

	; Set sun patterns
	LDA Sun_Patterns,X
	STA Sprite_RAM+$11,Y
	STA Sprite_RAM+$15,Y

	; Keep all sun bits except vertical flip from first sprite -> Temp_Var15 and four sprites over
	LDA Sprite_RAM+$02,Y
	AND #~SPR_VFLIP
	STA <Temp_Var15
	STA Sprite_RAM+$12,Y

	; Keep all sun bits except vertical flip from second sprite -> Temp_Var16 and four sprites over
	LDA Sprite_RAM+$06,Y
	AND #~SPR_VFLIP
	STA <Temp_Var16
	STA Sprite_RAM+$16,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	; Sun Sprite X -> Temp_Var2 and sprite
	LDA <Objects_SpriteX,X
	STA <Temp_Var2
	STA Sprite_RAM+$13,Y

	; +24 for right edge sprite
	ADD #24
	STA Sprite_RAM+$17,Y

	LDA Objects_Frame,X
	BEQ PRG005_AF28	 ; If frame = 0, jump to PRG005_AF28 (RTS)

	JSR Object_GetRandNearUnusedSpr

	; Set lower left sprite at Sprite Y + 16
	LDA <Temp_Var1
	ADD #16
	STA Sprite_RAM+$00,Y

	; Set lower left Sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; Vertically flip lower left sprite
	LDA <Temp_Var15
	ORA #SPR_VFLIP
	STA Sprite_RAM+$02,Y

	; Lower left sprite pattern
	LDA #$91
	STA Sprite_RAM+$01,Y

	JSR Object_GetRandNearUnusedSpr

	; Set lower right sprite Y + 16
	LDA <Temp_Var1
	ADD #16
	STA Sprite_RAM+$00,Y

	; Set lower right sprite X
	LDA <Temp_Var2
	ADD #24
	STA Sprite_RAM+$03,Y

	; Set lower right sprite attributes
	LDA <Temp_Var16
	ORA #SPR_VFLIP
	STA Sprite_RAM+$02,Y

	; Lower right sprite pattern
	LDA #$91
	STA Sprite_RAM+$01,Y

PRG005_AF28:
	RTS		 ; Return

ArrowPlat_XVel:
	.byte  $00	; Platform Type 0 (Up)
	.byte -$08	; Platform Type 1 (Left)
	.byte  $00	; Platform Type 2 (Up)
	.byte  $08	; Platform Type 3 (Right)

ArrowPlat_YVel:
	.byte -$08	; Platform Type 0 (Up)
	.byte  $00	; Platform Type 1 (Left)
	.byte -$08	; Platform Type 2 (Up)
	.byte  $00	; Platform Type 3 (Right)

ObjNorm_ArrowPlatform:
	JSR ArrowPlat_Draw	 ; Draw the arrow platform

	LDA <Objects_SpriteY,X
	CMP #200
	BLT PRG005_AF40	 ; If the SpriteY < 200, jump to PRG005_AF40

PRG005_AF3A:
	; Otherwise, set platform state to 0 (Dead/Empty)
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

PRG005_AF3F:
	RTS		 ; Return

PRG005_AF40:
	LDA <Player_HaltGame
	BNE PRG005_AF3F	 ; If gameplay is halted, jump to PRG005_AF3F (RTS)

	LDA Level_NoStopCnt
	AND #$03
	BNE PRG005_AF4F	 ; Proceed 1:4 ticks, otherwise jump to PRG005_AF4F

	DEC <Objects_Var5,X	 ; Var5-- (the arrow platform "life" ticker)
	BEQ PRG005_AF3A	 	; If Var5 = 0, jump to PRG005_AF3A

PRG005_AF4F:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDY <Objects_Var4,X	 ; Y = Var4 (Arrow Platform type)

	; Set Arrow Platform's X velocity
	LDA ArrowPlat_XVel,Y
	STA <Objects_XVel,X

	; Set Arrow Platform's Y velocity
	LDA ArrowPlat_YVel,Y
	STA <Objects_YVel,X

	JSR Object_ApplyYVel_NoLimit	; Apply Y velocity
	JSR Object_ApplyXVel	 	; Apply X velocity

	; Arrow platform is always X Hi = 0 (arrow platforms are only going to work in "vertical" levels)
	; SB: Not necessarily anymore...
	;LDA #$00
	;STA <Objects_XHi,X

	JSR Object_HitTest
	BCC PRG005_AFE2	 ; If Player is not touching arrow platform, jump to PRG005_AFE2

	LDA <Player_SpriteY
	ADD #24
	CMP <Objects_SpriteY,X
	BGE PRG005_AFE3	 ; If Player Y + 24 is lower than the arrow platform Y, jump to PRG005_AFE3

	LDA <Player_YVel
	BMI PRG005_AFE2	 ; If arrow platform is moving upward, jump to PRG005_AFE2

	LDY Level_ObjectID,X
	CPY #OBJ_ARROWANY
	BNE PRG005_AF98	 ; If this is not the multi-directional arrow platform, jump to PRG005_AF98

	CMP #$10
	BLT PRG005_AF98	 ; If Player's Y Velocity < $10 (speed required to trigger direction change), jump to PRG005_AF98

	; Play the direction switch sound
	LDA #SND_MAPPATHMOVE
	STA Sound_QMap

	; Timer = 8
	LDA #$08
	STA Objects_Timer,X

	; Var4 = (Var4 + 1) % 3 (increment and capped 0 to 3)
	LDA <Objects_Var4,X
	ADD #$01
	AND #$03
	STA <Objects_Var4,X

PRG005_AF98:

	LDA #$00
	STA <Player_YVel	; Halt Player's vertical movement
	STA <Player_InAir	; Flag Player as not in air

	LDA #$01
	STA ArrowPlat_IsActive	; Flag arrow platform as active

	; Set Player's Y as arrow platform's Y - 31
	LDA <Objects_Y,X
	SUB #31
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	LDY #$00	 ; Y = 0 (16-bit sign extension)

	LDA Object_XVelCarry
	BPL PRG005_AFB8	 ; If platform X velocity carried, jump to PRG005_AFB8

	DEY		 ; Y = $FF (16-bit sign extension)

PRG005_AFB8:
	ADD <Player_X		 ; Add carry value to Player X
	STA <Player_X		 ; Update Player X

	TYA		 ; Sign extension -> 'A'

	ADC <Player_XHi		 ; Apply carry
	STA <Player_XHi		 ; Update Player X Hi

	JSR ArrowPlat_CheckWorldCollide
	BLT PRG005_AFE2	 ; If arrow platform is not going to run into solid, jump to PRG005_AFE2 (RTS)

	STA <Temp_Var1	 ; Store detected tile -> Temp_Var1

	; Set state to Dead/Empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	LDY Level_TilesetIdx
	LDA SpikesEnable,Y
	CMP #$ff
	BEQ PRG005_AFE2	; If there's no spikes in the active tileset, jump to PRG005_AFE2

	SUB <Temp_Var1	 ; Subtract the detected tile
	CMP #$02
	BGE PRG005_AFE2	 ; If this is not a spike tile, jump to PRG005_AFE2 (RTS)

	JSR Player_GetHurt	 ; Player got pushed into spikes; hurt him!

PRG005_AFE2:
	RTS		 ; Return

PRG005_AFE3:
	LDA #-$08

	LDY <Player_Suit
	BNE PRG005_AFEB	 ; If Player is not small, jump to PRG005_AFEB

	LDA #$08	 ; A = 8

PRG005_AFEB:
	ADD <Player_SpriteY
	CMP <Objects_SpriteY,X
	BLT PRG005_AFFB	 ; If Player's head is sufficiently beneath the platform, jump to PRG005_AFFB

	LDA <Player_YVel
	BPL PRG005_AFFA	 ; If Player is moving downward, jump to PRG005_AFFA

	; Player's YVel = $10 (bump head off platform)
	LDA #$10
	STA <Player_YVel

PRG005_AFFA:
	RTS		 ; Return

PRG005_AFFB:
	LDA <Objects_XVel,X
	BEQ PRG005_B012	 ; If arrow platform is not moving horizontally, jump to PRG005_B012

	LDA <Player_X
	SUB <Objects_X,X
	EOR <Objects_XVel,X
	BMI PRG005_B00D	 ; If Player is not in "front" of moving platform, jump to PRG005_B00D

	; Player gets pushed by platform
	LDA <Objects_XVel,X
	STA <Player_XVel

	RTS		 ; Return

PRG005_B00D:

	; Halt Player's horizontal movement (just ran into side)
	LDA #$00
	STA <Player_XVel

	RTS		 ; Return

PRG005_B012:
	JMP PRG005_B6BA	 ; Jump to PRG005_B6BA (make platform solid from the sides)

ArrowPlat_Patterns:
	.byte $A3, $A5, $A7, $A9	; Type 0 (Up)
	.byte $A3, $AB, $AD, $A9	; Type 1 (Left)
	.byte $A3, $A5, $A7, $A9	; Type 2 (Up)
	.byte $A9, $AD, $AB, $A3	; Type 3 (Right)
	.byte $A3, $AF, $AF, $A9	; Type 4 (mid-direction-change)

ArrowPlat_Attrs:
	.byte $02, $02, $02, $42, $02

	; A mask that decides the "flicker" rate of the arrow platform as it disappears
ArrowPlat_FlickerMask:	.byte $02, $02, $04, $04

ArrowPlat_Draw:
	JSR Object_CalcSpriteXY_NoHi

	LDA Level_7Vertical
	BEQ ArrowPlat_HVisCheck		; SB: If level is NOT vertical, jump to ArrowPlat_HVisCheck

	; SB: Interesting that this was here originally, like they were considering handling
	; horizontal visibility but dropped it; perhaps the arrow lifts didn't always just
	; blindly wrap the screen?  (We'll keep the behavior for vertical nonetheless.)
	LDA #$00
	STA Objects_SprHVis,X

	BEQ ArrowPlat_DrawCont	; Jump (technically always) to ArrowPlat_DrawCont

ArrowPlat_HVisCheck:
	JSR Object_DetermineHorzVis	; Determine ACTUAL horizontal visibility

ArrowPlat_DrawCont:
	; Var5 is the platform's "life ticks"

	LDA <Objects_Var5,X
	CMP #$20
	BGE PRG005_B04C	 ; If Var5 >= $20 (not flickering away yet), jump to PRG005_B04C

	LSR A
	LSR A
	LSR A		; Divide Var5 by 8
	TAY		 ; Y = 0 to 3

	LDA Level_NoStopCnt
	AND ArrowPlat_FlickerMask,Y
	BEQ PRG005_B0A0	 ; If masking results in zero, jump to PRG005_B0A0 (RTS)

PRG005_B04C:

	; Temp_Var2 = Sprite X
	LDA <Objects_SpriteX,X
	STA <Temp_Var2

	LDY <Objects_Var4,X	; Y = Var4

	LDA Objects_Timer,X
	BEQ PRG005_B059		; If timer expired, jump to PRG005_B059

	LDY #$04	 	; Y = 4 (platform is mid-direction-change)

PRG005_B059:
	STY <Temp_Var3		; Temp_Var3 = Var4 or 4 (arrow platform type)

	LDY Object_SprRAM,X	 ; Y = Sprite RAM offset

	; Temp_Var1 = 0
	LDA #$00
	STA <Temp_Var1

PRG005_B062:
	; SB: Handle horizontal visibility
	ASL Objects_SprHVis,X
	BCS ArrowPlat_SkipSpr

	; Set Sprite Y
	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$00,Y

ArrowPlat_SkipSpr:
	; Set Sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; +8 (next sprite over)
	ADD #$08
	STA <Temp_Var2

	LDA <Temp_Var3
	ASL A
	ASL A		; Multiply type by 4 to get to pattern start
	ADC <Temp_Var1	; This particular pattern of the loop
	TAX		 ; X = proper index into ArrowPlat_Patterns

	; Set the pattern for this sprite of the arrow platform
	LDA ArrowPlat_Patterns,X
	STA Sprite_RAM+$01,Y

	LDX <Temp_Var3	 ; X = Temp_Var3 (arrow platform type index)

	LDA ArrowPlat_Attrs,X

	CPX #$04
	BNE PRG005_B08F	 ; If arrow platform is in mid-direction-change, jump to PRG005_B08F

	LDX <Temp_Var1	 ; X = this loop index
	CPX #$02
	BNE PRG005_B08F	 ; If this is the second up direction state, jump to PRG005_B08F

	; Second "up" arrow platform only

	LDA #(SPR_HFLIP | SPR_PAL2)	 ; Palette select 2 and horizontal flip

PRG005_B08F:
	STA Sprite_RAM+$02,Y	 ; Set sprite attribute

	LDX <SlotIndexBackup		 ; X = object slot index

	INY
	INY
	INY
	INY	; Y += 4 (next sprite)

	INC <Temp_Var1	 ; Temp_Var1++

	LDA <Temp_Var1
	CMP #$04
	BNE PRG005_B062	 ; If Temp_Var1 <> 4, loop!

PRG005_B0A0:
	RTS		 ; Return

ArrowPlat_CheckWorldCollide:
	; SB: Not handling world tile collisions in non-vertical mode
	LDA Level_7Vertical
	BNE ArrowPlat_CheckWorldCollideV	; If this is a vertical level, jump to ArrowPlat_CheckWorldCollideV
	
	; Non-vertical... currently not implemented
	CMP #1	; Fake out on return
	RTS

ArrowPlat_CheckWorldCollideV:
	; NOTE: This only works for "vertical" levels

	LDA #$06	 ; Y = $06 (Player not ducking and not small)
 
	LDY Player_IsDucking
	BNE PRG005_B0AC	 ; If Player is ducking, jump to PRG005_B0AC

	LDY <Player_Suit
	BNE PRG005_B0AE	 ; If Player is not small, jump to PRG005_B0AE

PRG005_B0AC:
	LDA #$12	 ; Y = $12 (Player ducking or small)

PRG005_B0AE:

	ADC <Player_Y	; Add Player Y
	AND #$f0	; Align to tile grid vertically
	STA <Temp_Var3	; -> Temp_Var3

	LDA <Player_YHi
	ADC #$00
	CMP #16
	BGE PRG005_B0DD	 ; If Player Y Hi >= 16 (Player is really low) jump to PRG005_B0DD

	; Tile_Mem address high byte
	ADC #HIGH(Tile_Mem)
	STA <Temp_Var2

	LDA <Player_X
	ADD #$08	; Center Player X
	LSR A
	LSR A
	LSR A
	LSR A		; Divide by 16 (tile grid column value)
	ORA <Temp_Var3	; "OR" in the vertical position
	STA <Temp_Var1  ; Temp_Var1 is a row/column grid position

	LDY #$00	 ; Y = 0

	LDA [Temp_Var1],Y ; Get the tile here
	PHA		 ; Save it

	ASL A
	ROL A
	ROL A
	AND #$03
	TAY		 ; Y = tile quadrant

	PLA		 ; Restore tile proper

	CMP Tile_AttrTable+4,Y	 ; Test if this tile is one of the solid ceiling/wall tiles
	RTS		 ; Return

PRG005_B0DD:
	CLC		 ; Clear carry
	RTS		 ; Return

Parabeetle_FlipByXVel:
	LDA #$00	 ; A = $00 (no flip)

	LDY <Objects_XVel,X
	BMI PRG005_B0E7	 ; If Parabeetle is moving to the left, jump to PRG005_B0E7

	LDA #SPR_HFLIP	 ; Otherwise, A = SPR_HFLIP (horizontal flip)

PRG005_B0E7:
	STA Objects_FlipBits,X	 ; Set flip

	RTS		 ; Return

ParaBeetle_XVelTowardsPlayer:	.byte $08, -$08

ObjInit_ParaBeetle:
	JSR Level_ObjCalcXDiffs

	; Start out flying towards Player
	LDA ParaBeetle_XVelTowardsPlayer,Y
	STA <Objects_XVel,X

PRG005_B0F5:
	RTS		 ; Return


ObjNorm_ParaBeetle:
	LDA <Objects_XVel,X
	BPL PRG005_B0FD	 ; If Parabeetle is not moving to the left, jump to PRG005_B0FD

	JSR Negate	 ; Negate X velocity (get absolute value)

PRG005_B0FD:
	CMP #$10

	LDA #SPR_PAL1	 ; A = 1 (palette select 1 for "slow" Parabeetles)

	BLT PRG005_B105	 ; If absolute value of X velocity < $10, jump to PRG005_B105

	ADC #$00	 ; A = 2 (palette select 2 for "fast" Parabeetles) (ADC's is an unclear way to get A = 2 :P) 

PRG005_B105:
	STA Objects_SprAttr,X	 ; Set sprite attribute

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	JSR Parabeetle_FlipByXVel	 ; Face correct direction based on travel

	; Toggle frame 0/1
	LDA Objects_Var3,X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR Object_ShakeAndDraw	 ; Draw Parabeetle

	LDA <Player_HaltGame
	BNE PRG005_B0F5	 ; If gameplay halted, jump to PRG005_B0F5 (RTS)

	INC Objects_Var3,X	 ; Var3++

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity
	JSR Object_ApplyXVel	 	; Apply X velocity

	; Temp_VarNP0 = Player hit status bits (previous frame's detection status)
	LDA Objects_PlayerHitStat,X
	STA Temp_VarNP0	

	; I'm not sure the reason for the modification of "Kill_Tally" here...
	; Maybe at one time this was just another stompable enemy?

	; This pattern of INC then DEC is used e.g. for Rocky Wrench to make his baseline score 200 pts

	INC Kill_Tally	 ; Kill_Tally++ (??)

	JSR Player_HitEnemy	 ; Do Player to Parabeetle hit detection

	DEC Kill_Tally	 ; Kill_Tally-- (??)

	LDA Objects_PlayerHitStat,X
	BEQ PRG005_B1A8	 ; If no collision, jump to PRG005_B1A8

	CMP Temp_VarNP0	
	BEQ PRG005_B14C	 ; If detection status hasn't changed from last frame, jump to PRG005_B14C

	LDA #$0C

	LDY <Player_Suit
	BEQ PRG005_B14A	 ; If Player is small, jump to PRG005_B14A

	LDA #$14	; Parabeetle moves down further for non-small Player

PRG005_B14A:
	STA <Objects_YVel,X	 ; Set Y velocity as appropriate

PRG005_B14C:

	; Var3 += 2
	INC Objects_Var3,X
	INC Objects_Var3,X

	LDA #-$0C

	LDY <Player_Suit
	BNE PRG005_B15A	 ; If Player is NOT small, jump to PRG005_B15A

	LDA #-$10	; Parabeetle can go upward faster if Player is small

PRG005_B15A
	CMP <Objects_YVel,X
	BGS PRG005_B162	 ; If Parabeetle is at his limit, jump to PRG005_B162

	; Accelerate upward!
	DEC <Objects_YVel,X
	DEC <Objects_YVel,X	; Double decrement to overcome the INC below

PRG005_B162:
	INC <Objects_YVel,X	; Parabeetle starts to droop

	; Let's Player jump off Parabeetle 
	LDA #$05
	STA Player_AllowAirJump

	LDA <Player_YVel
	BMI PRG005_B1A7	 ; If Player is moving upward, jump to PRG005_B1A7 (RTS)

	LDY #$00	 ; Y = $00 (16-bit sign extension)

	LDA Object_XVelCarry
	BPL PRG005_B175	 ; If there's not a negative carry from X velocity, jump to PRG005_B175

	DEY		 ; Y = $FF (16-bit sign extension)

PRG005_B175:
	ADD <Player_X	; Offset Player's X
	STA <Player_X	; Set it!

	; Carry to X Hi
	TYA
	ADC <Player_XHi
	STA <Player_XHi

	; Set Player at Parabeetle Y - 27
	LDA <Objects_Y,X
	SUB #27
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	; Clear Player's Y velocity and "in air" flags
	LDA #$00
	STA <Player_YVel
	STA <Player_InAir

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG005_B1A7	 ; If Player is not pressing left or right, jump to PRG005_B1A7 (RTS)

	JSR Fish_FixedYIfAppro	 ; ?? Also a strange thing to call, would align parabeetles with the vertical scroll in a raster-effect

	LDA <Player_XVel
	BEQ PRG005_B1A7	 ; If Player's X Velocity = 0, jump to PRG005_B1A7 (RTS)

	BPL PRG005_B1A5	 ; If Player's X Velocity is positive, jump to PRG005_B1A5

	; Negative Player velocity...

	; Double INC to overcome the DEC
	INC <Player_XVel
	INC <Player_XVel

PRG005_B1A5:
	DEC <Player_XVel

PRG005_B1A7:
	RTS		 ; Return

PRG005_B1A8:
	LDA <Objects_YVel,X
	BEQ PRG005_B1B4	 ; If Parabeetle's Y Velocity = 0, jump to PRG005_B1B4 (RTS)

	BPL PRG005_B1B2	 ; If Parabeetle's Y Velocity is positive, jump to PRG005_B1B2

	; Negative Parabeetle velocity...

	; Double INC to overcome the DEC
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG005_B1B2:
	DEC <Objects_YVel,X

PRG005_B1B4:
	RTS

ObjInit_RotatePlatformPer:
	LDA #$02
	STA Objects_FlipBits,X

ObjInit_RotatePlatform:
	LDA #$00
	STA <Objects_VarBSS,X
	STA <Objects_Var5,X
	STA Objects_Var7,X

	; Set at Y - 12
	LDA <Objects_Y,X
	SUB #12
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X

	RTS		 ; Return


ObjNorm_TwirlingPlatCWNS:
	; NOTE: I admit, I'm just not interested enough in how these gadgets work to bother
	; working out their rather complex algorithm.  I'll leave this as an exercise for
	; one of the more rabid types out there... just making it relocatable like everything
	; else, but if you wanted to actually know what it does, you're out of luck today...

	; Var5 = $30
	LDA #$30
	STA <Objects_Var5,X

PRG005_B1D5:
	JSR Platform_SplitVar5
	JSR PRG005_B40A	
	JSR PRG005_SUB_B4BB

	JMP PRG005_B270	 ; Jump to PRG005_B270

PRG005_B1E1:	.byte $20, $50, $20, $50
PRG005_B1E5:	.byte $F8, $08, $08, $F8
PRG005_B1E9:	.byte $00, $40, $00, $C0

ObjNorm_TwirlingPlatCW:
	; NOTE: I admit, I'm just not interested enough in how these gadgets work to bother
	; working out their rather complex algorithm.  I'll leave this as an exercise for
	; one of the more rabid types out there... just making it relocatable like everything
	; else, but if you wanted to actually know what it does, you're out of luck today...

	JSR PRG005_B1D5

	LDA <Player_HaltGame
	BNE PRG005_B21A	 ; If gameplay halted, jump to PRG005_B21A (RTS)

	LDA <Objects_Var4,X
	AND #$01
	ORA Objects_FlipBits,X
	TAY

	LDA Objects_Timer,X
	BNE PRG005_B209		; If timer not expired, jump to PRG005_B209

	LDA PRG005_B1E1,Y
	STA Objects_Timer,X

	INC <Objects_Var4,X

PRG005_B209:
	AND #$00		; ... interesting ...
	BNE PRG005_B21A		; This jump will never be taken..

	LDA <Objects_Var5,X
	CMP PRG005_B1E9,Y
	BEQ PRG005_B21A	 

	ADD PRG005_B1E5,Y
	STA <Objects_Var5,X

PRG005_B21A:
	RTS		 ; Return

PRG005_B21B:	.byte $18, $18, $17, $17, $16, $15, $14, $13, $11, $0F, $0D, $0B, $09, $07, $05, $02, $00
PRG005_B22C:	.byte $00, $01, $01, $02, $FF, $FF, $FE, $00, $FF, $FF, $FE, $01, $01, $02

TiltPlat_XVelAccel:	.byte $01, -$01
TiltPlat_XVelLimit:	.byte $10, -$10


ObjNorm_TiltingPlatform:
	; NOTE: I admit, I'm just not interested enough in how these gadgets work to bother
	; working out their rather complex algorithm.  I'll leave this as an exercise for
	; one of the more rabid types out there... just making it relocatable like everything
	; else, but if you wanted to actually know what it does, you're out of luck today...

	LDA Objects_Timer,X
	BNE PRG005_B266	 ; If timer not expired, jump to PRG005_B266

	LDA <Counter_1
	AND #$01
	BNE PRG005_B266	 ; Every other tick, jump to PRG005_B266

	LDY Objects_Var7,X	 ; Y = Var7

	; Accelerate!
	LDA <Objects_XVel,X
	ADD TiltPlat_XVelAccel,Y
	STA <Objects_XVel,X

	CMP TiltPlat_XVelLimit,Y
	BNE PRG005_B266		; If tilting platform has not reached velocity limit, jump to PRG005_B266

	; Invert Var7
	LDA Objects_Var7,X
	EOR #$01
	STA Objects_Var7,X

	; Set timer to $A0
	LDA #$a0
	STA Objects_Timer,X

PRG005_B266:

	; XVel = 0
	LDA #$00
	STA <Objects_XVel,X

	JSR PRG005_SUB_B3CF
	JSR PRG005_SUB_B4BB

PRG005_B270:
	JSR Object_DeleteOffScreen_N2	; Delete object if it falls off screen

	LDA Player_OffScreen
	BNE PRG005_B2C5

	LDA Level_ObjectID,X
	SUB #$90
	STA <Temp_Var15
	LDY #$06

PRG005_B282:
	STY <Temp_Var1		  
	CPY #$06
	BNE PRG005_B28D

	LDA <Temp_Var7
	JMP PRG005_B294


PRG005_B28D:
	TYA		  
	ASL A
	ASL A
	ADD Object_SprRAM,X

PRG005_B294:
	STA <Temp_Var16		  
	LDA <Player_Y
	SUB Level_VertScroll
	ADD #$18
	LDY <Player_YVel
	BPL PRG005_B2A6

	SUB #$10

PRG005_B2A6:
	LDY <Temp_Var16		  
	SUB Sprite_RAM+$00,Y
	CMP #$09
	BCS PRG005_B2C0

	LDA <Player_X
	SUB <Horz_Scroll
	ADD #$08
	SUB Sprite_RAM+$03,Y
	CMP #$09
	BCC PRG005_B2C6


PRG005_B2C0:
	LDY <Temp_Var1		  
	DEY
	BPL PRG005_B282

PRG005_B2C5:
	RTS

PRG005_B2C6:
	LDA <Player_IsDying		  
	BNE PRG005_B2C5

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG005_B2C0

	LDA <Temp_Var15
	BEQ PRG005_B33E

	LDA <Objects_Var5,X
	BNE PRG005_B303

	LDA <Player_YVel
	BPL PRG005_B2E2

	LDA #$00
	STA <Player_YVel
	RTS

PRG005_B2E2:
	LDA <Pad_Holding		  
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG005_B2F4

	LDA <Player_XVel
	BEQ PRG005_B2F4

	BPL PRG005_B2F2

	INC <Player_XVel
	INC <Player_XVel

PRG005_B2F2:
	DEC <Player_XVel		  

PRG005_B2F4:
	LDA #$00	  
	STA <Player_YVel
	STA <Player_InAir
	JSR PRG005_B3B1

	LDA #$10
	STA Player_AllowAirJump
	RTS

PRG005_B303:
	LDA <Objects_Var5,X	  
	LDY <Temp_Var1
	CPY #$04
	BCC PRG005_B30D

	EOR #$80

PRG005_B30D:
	ASL A		  
	BCS PRG005_B331

	LDA <Temp_Var6
	ASL A
	ASL A
	ASL A
	STA <Player_YVel
	LDA <Temp_Var5
	EOR #$ff

PRG005_B31B:
	ASL A		  
	ASL A
	ASL A
	BPL PRG005_B328

	CMP #$c0
	BCS PRG005_B32E

	LDA #$c0
	BNE PRG005_B32E


PRG005_B328:
	CMP #$40	  
	BCC PRG005_B32E

	LDA #$40

PRG005_B32E:
	STA <Player_XVel		  
	RTS

PRG005_B331:
	LDA <Temp_Var5		  
	JSR PRG005_B31B

	LDA <Temp_Var6
	ASL A
	ASL A
	ASL A
	STA <Player_YVel
	RTS

PRG005_B33E:
	LDY <Temp_Var1		  
	LDA <Objects_VarBSS,X
	CMP #$10
	BCC PRG005_B34F

	CMP #$30
	BCS PRG005_B34F

	TYA
	ADD #$07
	TAY

PRG005_B34F:
	LDA <Player_YVel		  
	BMI PRG005_B359

	LDA <Counter_1
	AND #$03
	BNE PRG005_B369


PRG005_B359:
	LDA PRG005_B22C,Y	  
	LDY <Player_YVel
	BPL PRG005_B364

	JSR Negate
	ASL A

PRG005_B364:
	ADD <Objects_Var5,X
	STA <Objects_Var5,X

PRG005_B369:
	LDA <Temp_Var5		  
	EOR <Temp_Var6
	BPL PRG005_B375

	LDA <Temp_Var5
	BPL PRG005_B379

	BMI PRG005_B37C


PRG005_B375:
	LDA <Temp_Var5		  
	BPL PRG005_B37C


PRG005_B379:
	JSR Negate	  

PRG005_B37C:
	LDY <Player_YVel		  
	BPL PRG005_B38B

	JSR Negate
	ASL A
	STA <Player_XVel
	LDA #$00
	STA <Player_YVel
	RTS

PRG005_B38B:
	LDY #$20	  
	STA <Temp_Var1
	ASL <Temp_Var1
	ROR A
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	ADD <Player_XVel
	ADD <Objects_XVel,X
	STA <Player_XVel
	BPL PRG005_B3A7

	JSR Negate
	LDY #$e0

PRG005_B3A7:
	CMP #$20	  
	BCC PRG005_B3AD

	STY <Player_XVel

PRG005_B3AD:
	LDA #$10	  
	STA <Player_YVel

PRG005_B3B1:
	LDY <Temp_Var16		  
	LDA <Player_Y
	PHA
	LDA Sprite_RAM+$00,Y
	ADD Level_VertScroll
	SUB #$18
	STA <Player_Y
	PLA
	CMP <Player_Y
	BCS PRG005_B3C9

	DEC <Player_YHi

PRG005_B3C9:
	LDA #$08	  
	STA Player_AllowAirJump
	RTS


PRG005_SUB_B3CF:
	JSR Platform_SplitVar5	 

	LDA <Objects_VarBSS,X	 ; A value 0-63

	ADD #$07	; Add 7
	AND #$3f	; Cap 0-63 again

	LDY <Objects_Var5,X	 ; Y = Var5
	BMI PRG005_B3EC	 ; If Var5 is negative, jump to PRG005_B3EC

	CMP #$10
	BLT PRG005_B3F8	 ; If Var5 < $10, jump to PRG005_B3F8

	CMP #$18
	BGE PRG005_B3EC	 ; If Var5 >= $18, jump to PRG005_B3EC

	; VarBSS = 8
	LDA #$08
	STA <Objects_VarBSS,X

	JMP PRG005_B3F4	 ; Jump to PRG005_B3F8

PRG005_B3EC:
	AND #$20
	BEQ PRG005_B3F8	

	; VarBSS = $38
	LDA #$38
	STA <Objects_VarBSS,X

PRG005_B3F4:

	; Var5 = 0
	LDA #$00
	STA <Objects_Var5,X

PRG005_B3F8:
	LDA <Counter_1
	AND #$07
	BNE PRG005_B40A	 ; 1:8 ticks we proceed, otherwise jump to PRG005_B40A

	LDA <Objects_Var5,X
	BEQ PRG005_B40A	 ; If Var5 = 0, jump to PRG005_B40A
	BMI PRG005_B408	 ; If Var5 < 0, jump to PRG005_B408

	DEC <Objects_Var5,X	 ; Var5--
	BPL PRG005_B40A	 ; Jump to PRG005_B40A

PRG005_B408:
	INC <Objects_Var5,X	 ; Var5++

PRG005_B40A:
	LDA <Objects_VarBSS,X
	AND #$0f
	TAY		 ; Y = 0 to 15

	LDA PRG005_B21B,Y
	STA <Temp_Var10	 ; Temp_Var10 = PRG005_B21B[Y]

	TYA		 ; Y = 0 to 15 again

	EOR #$ff
	AND #$0f
	ADD #$01
	TAY

	LDA PRG005_B21B,Y
	STA <Temp_Var9	 ; Temp_Var9 = PRG005_B21B[Y]

	LDA <Objects_VarBSS,X
	AND #$10
	BEQ PRG005_B432

	LDA <Temp_Var9
	PHA
	LDA <Temp_Var10
	STA <Temp_Var9
	PLA
	STA <Temp_Var10

PRG005_B432:
	LDA <Temp_Var10		  
	CMP #$03
	BCS PRG005_B444

	LSR A
	STA <Temp_Var2
	STA <Temp_Var6
	LDA #$00
	STA <Temp_Var4
	JMP PRG005_B460

PRG005_B444:
	LDY #$ff

	SEC
PRG005_B447:
	SBC #$03
	INY
	BCS PRG005_B447

	ADC #$03
	STA <Temp_Var4
	STY <Temp_Var2
	STY <Temp_Var4
	STY <Temp_Var6
	TAY
	BEQ PRG005_B460

	INC <Temp_Var2
	DEY
	BEQ PRG005_B460

	INC <Temp_Var6

PRG005_B460:
	LDA <Temp_Var9		  
	CMP #$03
	BCS PRG005_B472

	LSR A
	STA <Temp_Var1
	STA <Temp_Var5
	LDA #$00
	STA <Temp_Var3
	JMP PRG005_B48C

PRG005_B472:
	LDY #$ff	  

	SEC
PRG005_B475:
	SBC #$03	  
	INY
	BCS PRG005_B475

	ADC #$03
	STY <Temp_Var1
	STY <Temp_Var3
	STY <Temp_Var5
	TAY
	BEQ PRG005_B48C

	INC <Temp_Var1
	DEY
	BEQ PRG005_B48C

	INC <Temp_Var5

PRG005_B48C:
	LDA <Objects_VarBSS,X	  
	AND #$30
	BEQ PRG005_B4B4

	CMP #$10
	BEQ PRG005_B49D

	CMP #$30
	BEQ PRG005_B4B7

	JSR PRG005_B4B7

PRG005_B49D:
	LDX #$01	  

PRG005_B49F:
	LDA <Temp_Var1,X
	JSR Negate
	STA <Temp_Var1,X
	LDA <Temp_Var3,X
	JSR Negate
	STA <Temp_Var3,X
	LDA <Temp_Var5,X
	JSR Negate
	STA <Temp_Var5,X

PRG005_B4B4:
	LDX <SlotIndexBackup		  
	RTS



PRG005_B4B7:
	LDX #$00	 ; X = 0
	BEQ PRG005_B49F	 ; Jump (technically always) to PRG005_B49F

PRG005_SUB_B4BB:
	JSR Object_GetRandNearUnusedSpr
	JSR PRG005_SUB_B596

	; Draws any of the tilting/rotating platforms

	LDY Object_SprRAM,X
	LDA <Temp_Var14
	STA Sprite_RAM+$00,Y
	ADD <Temp_Var1
	STA Sprite_RAM+$04,Y
	ADD <Temp_Var3
	STA Sprite_RAM+$08,Y
	ADD <Temp_Var5
	STA Sprite_RAM+$0C,Y
	LDA <Temp_Var14
	SUB <Temp_Var1
	STA Sprite_RAM+$10,Y
	SUB <Temp_Var3
	STA Sprite_RAM+$14,Y
	SUB <Temp_Var5
	LDY <Temp_Var7
	STA Sprite_RAM+$00,Y
	LDY Object_SprRAM,X
	LDA <Temp_Var15
	STA Sprite_RAM+$03,Y
	ADD <Temp_Var2
	STA Sprite_RAM+$07,Y
	ADD <Temp_Var4
	STA Sprite_RAM+$0B,Y
	ADD <Temp_Var6
	STA Sprite_RAM+$0F,Y
	LDA <Temp_Var15
	SUB <Temp_Var2
	STA Sprite_RAM+$13,Y
	SUB <Temp_Var4
	STA Sprite_RAM+$17,Y
	SUB <Temp_Var6
	LDY <Temp_Var7
	STA Sprite_RAM+$03,Y
	LDY Object_SprRAM,X
	LDX #$06

PRG005_B526:
	CPX #$00	  
	BNE PRG005_B52C

	LDY <Temp_Var7

PRG005_B52C:
	LDA Sprite_RAM+$00,Y	  
	CMP #$c2
	BCS PRG005_B53A

	LDA <Temp_Var13
	AND PRG005_B58F,X
	BEQ PRG005_B541


PRG005_B53A:
	LDA #$f8	  
	STA Sprite_RAM+$00,Y
	BNE PRG005_B551


PRG005_B541:
	LDA #$01	  
	CPX #$06
	BNE PRG005_B549

	LDA #$02

PRG005_B549:
	STA Sprite_RAM+$02,Y	  
	LDA #$ed
	STA Sprite_RAM+$01,Y

PRG005_B551:
	INY		  
	INY
	INY
	INY
	DEX
	BPL PRG005_B526

	LDX <SlotIndexBackup
	RTS


	; The lower nibble of Var5 is shifted left 4 bits, Temp_Var1 is added, and this is returned as Temp_Var1
	; The upper nibble of Var5 is arithmetically shifted right 4 bits and added to VarBSS which is capped to 0-63
Platform_SplitVar5:
	LDA <Player_HaltGame
	BNE PRG005_B581	 ; If gameplay is halted, jump to PRG005_B581

	LDA Objects_Var5,X
	PHA		 ; Save Var5

	ASL A
	ASL A
	ASL A
	ASL A			; Var5 * 16
	ADD Objects_Var1,X	; + Var1
	STA Objects_Var1,X 	; -> Temp_Var1

	PLA		 ; Restore Var5

	PHP		 ; Save process status

	LSR A
	LSR A
	LSR A
	LSR A		; Var5 / 16

	; Essentially the following makes it an arithmetic shift
	CMP #$08
	BLT PRG005_B57A	 ; If result < 8, jump to PRG005_B57A

	ORA #$f0	 ; Otherwise, make negative 
PRG005_B57A:
	PLP		 ; Restore process status

	; Add VarBSS and cap result to 0-63
	ADC <Objects_VarBSS,X
	AND #$3f
	STA <Objects_VarBSS,X

PRG005_B581:
	RTS		 ; Return

PRG005_B582:
	.byte $05, $03, $01, $01, $03, $05

PRG005_B588:	.byte $80, $40, $20, $10, $08, $04, $02
PRG005_B58F:	.byte $80, $40, $20, $02, $04, $08, $10

PRG005_SUB_B596:
	LDA #$00
	STA <Temp_Var13
	STA <Temp_Var11
	LDA <Temp_Var2
	ADD <Temp_Var4
	ADD <Temp_Var6
	STA <Temp_Var12
	PHA
	LDA <Objects_X,X
	SUB <Temp_Var12
	STA <Temp_Var12
	PLA
	BPL PRG005_B5B3

	DEC <Temp_Var11

PRG005_B5B3:
	LDA <Objects_XHi,X	  
	SBC <Temp_Var11
	STA <Temp_Var11
	LDY #$00

PRG005_B5BB:
	LDA <Temp_Var12		  
	CMP <Horz_Scroll
	LDA <Temp_Var11
	SBC <Horz_Scroll_Hi
	BEQ PRG005_B5CC

	LDA PRG005_B588,Y
	ORA <Temp_Var13
	STA <Temp_Var13

PRG005_B5CC:
	STX <Temp_Var15		  
	LDX PRG005_B582,Y
	LDA <Temp_Var1,X
	PHA
	ADD <Temp_Var12
	STA <Temp_Var12
	LDX <Temp_Var15
	STY <Temp_Var16
	LDY #$00
	PLA
	BPL PRG005_B5E3

	DEY

PRG005_B5E3:
	TYA		  
	ADC <Temp_Var11
	STA <Temp_Var11
	LDY <Temp_Var16
	INY
	CPY #$07
	BNE PRG005_B5BB

	LDA <Objects_X,X
	SUB <Horz_Scroll
	STA <Temp_Var15
	LDA <Objects_Y,X
	SUB Level_VertScroll
	STA <Temp_Var14
	LDA <Objects_YHi,X
	ADC #$00
	CMP #$01
	BNE PRG005_B60C

	LDA <Temp_Var14
	CMP #$e0
	BCC PRG005_B610


PRG005_B60C:
	LDA #$ff	  
	STA <Temp_Var13

PRG005_B610:
	RTS

BigQBlock_PlayerPushXVel:	.byte $04, -$04

PRG005_B6BA:

	; NOTE: Arrow platform uses this code too

	JSR Level_ObjCalcXDiffs
	INY	; Makes this value agree with Player pressing left/right on pad

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	STA <Temp_Var1	 ; Temp_Var1 = non-zero if Player is pressing left or right

	LDA #$00	; Halt Player if he presses direction "into" the Big ? Block

	CPY <Temp_Var1
	BNE PRG005_B6CD	 ; If Player is doing that, jump to PRG005_B6CD

	LDA BigQBlock_PlayerPushXVel-1,Y	 ; Get direction of Player away from block

PRG005_B6CD:
	STA <Player_XVel	 ; Set Player's velocity appropriately

PRG005_B6CF:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_SpawnObjsAndBounce
;
; This spawns new objects as the screen scrolls, and also
; incidentally handles spawning the "bounced block" effect object
; if the Player just bounced off such a block... kind of weird to
; put those together, but I guess it has to go somewhere...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_SpawnObjsAndBounce:
	; Do scene-change-reset, if needed
	; NOTE!! Does NOT return here if it did!
	JSR Level_DoChangeReset	

	LDA Player_Bounce
	BEQ PRG005_B826	 ; If Player is not bouncing, jump to PRG005_B826

	; If we're going to do a Player bounce, a special effect of the block
	; bouncing is performed as an object.  This uses the reserved object
	; slots of 6 or 7.  If neither is free, no bounce for the Player!

	LDX #$06	 ; X = 6
	LDA Objects_State,X
	BEQ PRG005_B80D	 ; If object slot is "dead/empty", jump to PRG005_B80D

	INX		 ; X = 7

	LDA Objects_State,X
	BEQ PRG005_B80D	 ; If object slot is "dead/empty", jump to PRG005_B80D

	; Slot 6 & 7 are occupied; no bounce for you!
	LDA #$00
	STA Player_Bounce ; Player_Bounce = 0

	JMP PRG005_B826	 ; Jump to PRG005_B80D

PRG005_B80D:

	; Found a free slot (6 or 7)

	LDY #OBJ_BOUNCEDOWNUP	 ; Y = OBJ_BOUNCEDOWNUP (up/down bounce effect block)

	LDA Player_BounceDir
	AND #$7f
	CMP #$02
	BLS PRG005_B81A	 ; If Player is bouncing down/up, jump to PRG005_B81A

	LDY #OBJ_BOUNCELEFTRIGHT ; Y = OBJ_BOUNCELEFTRIGHT (left/right bounce effect block)

PRG005_B81A:

	; Store appropriate object ID
	TYA
	STA Level_ObjectID,X

	; Set object state to 1
	LDA #OBJSTATE_INIT
	STA Objects_State,X

	JMP PRG005_B831	 ; Jump to PRG005_B831 (RTS)

PRG005_B826:
	LDA Level_7Vertical
	BEQ PRG005_B82E	 ; If level is NOT vertical, jump to PRG005_B82E

	JMP Level_ObjectsSpawnByScrollV	 ; Spawn objects as screen scrolls

PRG005_B82E:
	JMP Level_ObjectsSpawnByScroll	 ; Spawn objects as screen scrolls

PRG005_B831:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_ObjectsSpawnByScroll
;
; Spawns object while screen scrolls (how it goes from static 
; level data to dynamic stuff on the screen)
; Non-vertical variant of Level_ObjectsSpawnByScrollV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; This defines the values used as "look ahead" when screen is moving
	; Basically the values are $110 (one screen over + 16)
	; and -$20 (32 pixels to the left)
LOSBS_LookAhead:	.byte 16, -32
LOSBS_LookAheadHi:	.byte $01, $FF	; sign extensions

Level_ObjectsSpawnByScroll:
	LDY <Scroll_LastDir	 

	LDA <Horz_Scroll
	ADD LOSBS_LookAhead,Y
	AND #$f0
	STA <Temp_Var6	 ; Temp_Var6 = Horz_Scroll + LOSBS_LookAhead[Y] (appropriate "look ahead" values)

	LDA <Horz_Scroll_Hi
	ADC LOSBS_LookAheadHi,Y
	STA <Temp_Var7	 ; Temp_Var7 = "look ahead" high part

	CMP <Level_Width
	BEQ PRG005_B852	
	BLT PRG005_B852	 ; If the "high part" is <= the level width, jump to PRG005_B852

	JMP PRG005_B956	 ; Otherwise, at the end, jump to PRG005_B956 (RTS)

PRG005_B852:
	LDX <Temp_Var7	 ; X = "look ahead" high part

	LDA Level_ObjIdxStartByScreen,X	 ; Get starting Level_Objects index for this screen
	BMI PRG005_B872	 ; If no objects on this screen, jump to PRG005_B872 (RTS)
 
	STA <Temp_Var2	 ; Starting index -> Temp_Var2
	TAX		 ; -> 'X'

	ASL A		 
	ADD <Temp_Var2	 ; Multiply by 3 (get to appropriate object)
	TAY		 ; -> 'Y'

	DEY		 ; Y-- (offset to object column, decrement to counteract Y += 3 on first pass)
	DEX		 ; X-- (basically to counteract following INX on first pass) 

PRG005_B863:
	INX		 ; X++ (next object index)

	INY
	INY
	INY		 ; Y += 3 (next object, aligned to "column" element)

	LDA Level_Objects,Y	 ; Get object column
	LSR A
	LSR A
	LSR A
	LSR A		 ; Divide by 16 to get "screen" (16 columns per screen)
	CMP <Temp_Var7	 
	BEQ PRG005_B873	 ; If object is on this "look ahead" screen, jump to PRG005_B873

PRG005_B872:
	RTS		 ; Return

PRG005_B873:

	LDA Level_Objects-1,Y	 ; Get object ID (we're aligned by column, hence -1)
	CMP #$ff	 
	BEQ PRG005_B872	 ; If this is the terminator, jump to PRG005_B872 (RTS)

	LDA Level_ObjectsSpawned,X
	CMP #$00	 
	BMI PRG005_B863	 ; If this object is already currently spawned, jump to PRG005_B863 (skip to next object)

	LDA Level_Objects,Y	 ; Get object column
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 ; Multiply by 16 (make pixel position)
	CMP <Temp_Var6	 
	BNE PRG005_B863	 ; If object not equal to "look ahead" low component, jump to PRG005_B863 (skip to next object)

	; Object should be spawned...

	STX <Temp_Var2		 ; Backup object index -> Temp_Var2
	STA <Temp_Var1		 ; Backup pixel X position -> Temp_Var1

	LDA Level_Objects-1,Y	 ; Get object ID

	; SB: NEW: Extended bank objects
	CMP #OBJ_EXTBANK_BEGIN
	BLT PRG005_B89C		; If this is NOT an extended bank object, jump to PRG005_B89C	
	JMP ObjSpawn_StdBegin		; Otherwise, jump to ObjSpawn_StdBegin
	
PRG005_B89C:
	CMP #OBJ_BONUSCONTROLLER
	BNE PRG005_B8B3	 	; If object ID <> OBJ_BONUSCONTROLLER, jump to PRG005_B8B3

	LDA Level_Objects+1,Y	 ; Get object row
	PHA		 ; Save it

	; Set the bonus type by whether it is on an odd/even row (Even = 1; White Toad House, Odd = 2; UNKNOWN MAPOBJ_UNK0C thing!!)
	AND #$01	  ; Check if on odd/even row
	TAX		  ; -> 'X'
	INX		  ; X++
	STX Map_BonusType ; -> Map_BonusType

	; Set the bonus value by the actual row it is on
	; NOTE: Thus White Toad House will always be an even number of coins
	PLA		 ; Restore row
	AND #$7f	 ; Trim bit 7
	STA Map_BonusCoinsReqd ; -> Map_BonusCoinsReqd
	BPL PRG005_B8BE	 ; Jump (technically always) to PRG005_B8BE (mark self as spawned so it never re-triggers)

PRG005_B8B3:
	CMP #OBJ_AUTOSCROLL
	BNE PRG005_B8CB	 ; If object ID <> OBJ_AUTOSCROLL, jump to PRG005_B8CB

	TYA		 ; Level_Objects index -> 'A'
	PHA		 ; Save it

	JSR ObjAutoScroller_Init ; Initialization code for OBJ_AUTOSCROLL

	PLA
	TAY		 ; Restore Level_Objects index

PRG005_B8BE:
	LDX <Temp_Var2	 ; Restore object index

	LDA Level_ObjectsSpawned,X
	ORA #$80	 
	STA Level_ObjectsSpawned,X	; Mark object as already spawned (even though technically it isn't, but prevents re-triggering)

	JMP PRG005_B863	 ; Jump to PRG005_B863 (next object)

PRG005_B8CB:
	LDA Level_Objects-1,Y	 ; Get object ID
	CMP #OBJ_TREASURESET
	BNE PRG005_B8DB	 ; If object ID <> OBJ_TREASURESET, jump to PRG005_B8DB

	; Set Level_TreasureItem by what row it was placed on
	LDA Level_Objects+1,Y	 ; Get object row
	STA Level_TreasureItem 	; Level_TreasureItem = row
	JMP PRG005_B8BE	 	; Jump to PRG005_B8BE (mark self as spawned so it never re-triggers)

PRG005_B8DB:

	; OBJ_FENCE_CTL/OBJ_TOUCHWARP/OBJ_ALTLEVELMOD
	LDX #(ObjPrioSpecObj_MatchEnd - ObjPrioSpecObj_MatchIDs - 1)
PrioSpecObj_Match_IDLoop:
	CMP ObjPrioSpecObj_MatchIDs,X
	BEQ Spawn_PrioSpecObj
	
	DEX		; X--
	BPL PrioSpecObj_Match_IDLoop	; While X >= 0, loop!

	; Not a priority special object...
	LDX <Temp_Var2	 ; Restore object index
	JMP Spawn_NotPrioSpecObj

Spawn_PrioSpecObj:
	TYA		 ; Level_Objects index -> 'A'
	PHA		 ; Save it

	JSR ObjPrioSpecObj_Init ; Initialization code for OBJ_FENCE_CTL/OBJ_ALTLEVELMOD/OBJ_TOUCHWARP

	PLA
	TAY		 ; Restore Level_Objects index

	JMP PRG005_B8BE	 	; Jump to PRG005_B8BE (mark self as spawned)

Spawn_NotPrioSpecObj:
	CMP #OBJ_ACTIONSWITCH
	BNE Spawn_NotActSw	; If this is not an action switch, jump to Spawn_NotActSw

	; Action Switch set!
	LDA Level_Objects+1,Y	 ; Get object row
	STA Level_ActSwEvent	; -> Level_ActSwEvent

	; NOTE: NOT marking as spawned because we want support for multiple switches within a level, if desired
	LDX <Temp_Var2	 ; Restore object index
	JMP PRG005_B863	 ; Jump to PRG005_B863 (next object)

Spawn_NotActSw:
	CMP #OBJ_CHEEPCHEEPBEGIN
	BLT PRG005_B909	 ; If object ID < OBJ_CHEEPCHEEPBEGIN, jump to PRG005_B909

	; All object IDs higher than OBJ_CHEEPCHEEPBEGIN are handled specially:


PRG005_B8F3:
	CMP #OBJ_CFIRE_BULLETBILL
	BLT PRG005_B902	 ; If object ID < OBJ_CFIRE_BULLETBILL, jump to PRG005_B902

	; Object ID >= OBJ_CFIRE_BULLETBILL...

	SBC #OBJ_CFIRE_BULLETBILL	 ; Zero base it
	ADD #$01	 ; +1 (because zero means "empty/unused" in Cannon Fire)

	JSR CannonFire_Init	 ; Initialize the Cannon Fire

	JMP PRG005_B863	 ; Jump to PRG005_B863 (next object)

PRG005_B902:

	; Trigger Level_Event
	SUB #(OBJ_CHEEPCHEEPBEGIN-1)	; Base at 1
	STA Level_Event	 		; Set Level_Event

	RTS		 ; Return

PRG005_B909:

	CMP #OBJ_CHECKPOINT
	BNE ObjSpawn_NotCP
	
	; This is a checkpoint, but don't spawn it if Player already got it in this level!
	LDX Player_Current
	LDA LevCP_ByPlayer,X
	TAX		; X = offset to this Player's checkpoint data
	
	LDA LevCP_ActiveID
	CMP LevCP_ID,X
	BEQ PRG005_B956		; If Player already got checkpoint in this level, jump to PRG005_B956 (RTS)
	BNE ObjSpawn_StdBegin	; Otherwise, jump to ObjSpawn_StdBegin

ObjSpawn_NotCP:

	SUB #OBJ_PIPERAISE1
	CMP #4
	BGE ObjSpawn_StdBegin	; If this is not one of the pipe raise placeholders, jump to ObjSpawn_StdBegin
	
	; Check if we even need to spawn this!
	TAX
	LDA Level_PipeRaiseData				; Current pipe rise data
	AND PipeRaise_AlreadyRaisedBits,X	; Check if this pipe is already risen
	BNE PRG005_B956		; If pipe is already risen, jump to PRG005_B956 (RTS)

ObjSpawn_StdBegin:

	; Standard object spawn begin...

	LDX #$04	 ; X = 4
PRG005_B913:
	LDA Objects_State,X	
	BEQ PRG005_B91E	 ; If this object slot is "dead/empty", jump to PRG005_B91E
	DEX		 ; X--
	BPL PRG005_B913	 ; While X >= 0, loop!


	; If we get here, there's no free slots... is this a priority object?

	LDA Level_Objects-1,Y	 ; Get object ID 

	; Basically the end level card gets priority and will ALWAYS
	; spawn into slot 5, regardless of what was there previously.
	; (Normal objects are in lower slots so this generally should
	; not be too noticeable.)
	
	CMP #OBJ_ENDLEVELCARD
	BNE ObjSpawn_NotGoal	 ; If object ID <> OBJ_ENDLEVELCARD, jump to ObjSpawn_NotGoal

	; SB: Changing to 5 to avoid bounce blocks glitching out
	; Will remove power-ups but oh well
	LDX #$05	 ; X = 5
	BNE PRG005_B91E	 ; Jump (technically always) to PRG005_B91E (skip looking for empty slot, force 5)

ObjSpawn_NotGoal:
	CMP #OBJ_CHECKPOINT
	BNE ObjSpawn_NotCP2
	
	; SB: Checkpoint gets priority in slot 6.
	; This may screw up bounce blocks, so beware.
	LDX #$06
	BNE PRG005_B91E	 ; Jump (technically always) to PRG005_B91E (skip looking for empty slot, force 6)

ObjSpawn_NotCP2:
	SUB #OBJ_PIPERAISE1
	CMP #4
	BGE ObjSpawn_NotPipeRaise	; If this is not one of the pipe raise placeholders, jump to ObjSpawn_NotPipeRaise
	
	; Otherwise, priority spawn into slot 6
	LDX #$06
	BNE PRG005_B91E	 ; Jump (technically always) to PRG005_B91E (skip looking for empty slot, force 6)

ObjSpawn_NotPipeRaise:

	; Not a priority object, no slots free

	JMP PRG005_B956	 ; Jump to PRG005_B956 (RTS)

PRG005_B91E:

	; Set object X
	LDA <Temp_Var1
	STA <Objects_X,X
	LDA <Temp_Var7
	STA <Objects_XHi,X

	INY		 ; Y++ (different way of getting at row, I guess)

	; Upper 4 bits shifted right (high Y)
	LDA Level_Objects,Y	 ; Get object row
	AND #$f0	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA <Objects_YHi,X

	; Lower 4 bits shifted left (low Y)
	LDA Level_Objects,Y	 ; Get object row
	AND #$0f	 
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 
	STA <Objects_Y,X

	DEY		 
	DEY		 ; Y -= 2 (at object ID now)

	; Set object ID
	LDA Level_Objects,Y
	STA Level_ObjectID,X

	LDY <Temp_Var2			; Object index -> 'Y'

	; Mark this object as spawned
	LDA Level_ObjectsSpawned,Y
	ORA #$80
	STA Level_ObjectsSpawned,Y

	TYA		 ; Object index -> 'A'

	; Store original spawn index
	STA Objects_SpawnIdx,X

	; Set object state to 1
	LDA #OBJSTATE_INIT
	STA Objects_State,X

PRG005_B956:
	RTS		 ; Return

	; OBJ_AUTOSCROLL specific initialization
	; Placing it on row $60 causes it to activate "water line" mode
	; This mode is used in 3-2 to have water tiles at the bottom
	; of the level.  Sprites do not appear below the line.  Only really
	; looks right when there's no vertical scrolling.
ObjAutoScroller_Init:
	LDA Level_Objects+1,Y	; Get object row
	CMP #$60	 	
	BNE PRG005_B964	 	; If object is NOT on row $60, jump to PRG005_B964

	LDA #UPDATERASTER_WATERLINE
	STA Update_Request	 ; Update_Request = UPDATERASTER_WATERLINE

	RTS		 ; Return

PRG005_B964:
	PHA		 ; Save object row 

	; Clear auto scroll variables
	LDY #$14	 ; Y = $14
	LDA #$00	 ; A = 0
PRG005_B969:
	STA AScroll_Anchor-1,Y	 ; Clear this auto scroll variable
	DEY		 ; Y--
	BNE PRG005_B969	 ; While Y <> 0, loop!

	PLA		 ; Restore object row

	PHA		 ; Save object row

	AND #$0f	 ; Cap 0 - 15
	TAY		 ; -> 'Y'

	PLA		 ; Restore object row

	LSR A
	LSR A
	LSR A
	LSR A		 ; Divide by 16

	STA Level_AScrlSelect
	CMP #$03	 
	BGE PRG005_B98E	 ; If Level_AScrlSelect >= 3 (Likely but not necessarily one of the Airships), jump to PRG005_B98E

	CMP #$01	 
	BNE PRG005_B988	 ; If Level_AScrlSelect <> 1 (World 3 Airship), jump to PRG005_B988

	TYA
	ORA #$10
	TAY		 ; New base for Y index at $10

PRG005_B988:

	; SB: Table moved out of common space PRG000 to PRG009 to make room
	; But that makes it inaccessible here, so made a thunk subroutine...
	;LDA AScroll_HorizontalInitMove,Y
	;STA Level_AScrlVar	 ; -> Level_AScrlVar
	JSR_THUNKA 9, AScroll_Set_Level_AScrlVar

PRG005_B98E:
	STY Level_AScrlLimitSel	 ; Y -> Level_AScrlLimitSel

	LDA <Vert_Scroll
	STA Level_AScrlPosV	 ; Level_AScrlPosV = Vert_Scroll

	INC Level_HAutoScroll	 ; Level_HAutoScroll = 1 (enable auto horizontal scroll!)
	RTS		 ; Return


ObjLRFlags:	.byte SPR_HFLIP, $00	; If Player is to right of object vs left, stored into Objects_FlipBits


CannonFire_Init:
	STA <Temp_Var16	 ; Store index value (1+)
	TXA		 ; -> 'X'
	PHA		 ; Save it too


	LDA CannonFire_ID+7
	PHA		 ; Backup last Cannon Fire ID

	LDA CannonFire_Parent+7
	PHA		 ; Backup last Cannon Fire parent index

	; Move over all current Cannon Fires
	LDX #$06	 ; X = 6
PRG005_BA54:
	LDA CannonFire_ID,X
	STA CannonFire_ID+1,X
	LDA CannonFire_YHi,X
	STA CannonFire_YHi+1,X
	LDA CannonFire_Y,X	
	STA CannonFire_Y+1,X	
	LDA CannonFire_XHi,X	
	STA CannonFire_XHi+1,X	
	LDA CannonFire_X,X	
	STA CannonFire_X+1,X	
	LDA CannonFire_Parent,X	
	STA CannonFire_Parent+1,X	
	LDA CannonFire_Timer,X	
	STA CannonFire_Timer+1,X	
	LDA CannonFire_Var,X	
	STA CannonFire_Var+1,X	
	LDA CannonFire_Timer2,X	
	STA CannonFire_Timer2+1,X	

	DEX		 ; X--
	BPL PRG005_BA54	 ; While X >= 0, loop

	PLA		 ; Restore last Cannon Fire Parent index
	TAX		 ; -> 'X'

	PLA		 ; Restore last Cannon Fire ID
	BEQ PRG005_BA9A	 ; If last Cannon Fire ID = 0 (this slot was not previously in use), jump to PRG005_BA9A

	; Mark the parent creator object as NOT spawned since this cannon fire slot is being overwritten
	LDA Level_ObjectsSpawned,X
	AND #$7f
	STA Level_ObjectsSpawned,X

PRG005_BA9A:
	; Upper 4 bits shifted right -> CannonFire_YHi (high Y)
	LDA Level_Objects+1,Y	 ; Get object row
	AND #$f0	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA CannonFire_YHi

	; Upper 4 bits shifted left -> CannonFire_Y (low Y)
	LDA Level_Objects+1,Y	 ; Get object row
	AND #$0f	
	ASL A		
	ASL A		
	ASL A		
	ASL A		
	STA CannonFire_Y

	LDA <Temp_Var7	
	STA CannonFire_XHi	 ; CannonFire_XHi = (pixel high X of object)

	LDA <Temp_Var1	
	STA CannonFire_X	 ; CannonFire_X = (pixel X position of object)

	LDA #$00
	STA CannonFire_Var	; Clear Cannon Fire variable
	STA CannonFire_Timer2	; Clear Cannon Fire timer 2

	LDA #$60

	LDX <Temp_Var16	 ; X = Temp_Var16 (ID of Cannon Fire)

	CPX #CFIRE_4WAY
	BNE PRG005_BACE	 ; If X <> 4, jump to PRG005_BACE

	LDA #$00	 ; Otherwise, A = 0

PRG005_BACE:
	STA CannonFire_Timer	 ; CannonFire_Timer = $00 or $60, depending on whether we're a 4-Way cannon

	LDX <Temp_Var2		 ; Restore object index
	STX CannonFire_Parent	 ; CannonFire_Parent = Temp_Var2

	; Mark this object as spawned
	LDA Level_ObjectsSpawned,X
	ORA #$80	
	STA Level_ObjectsSpawned,X

	LDA <Temp_Var16	
	STA CannonFire_ID

	PLA		 ; Restore input index value
	TAX		 ; -> 'X'

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_ObjectsSpawnByScrollV
;
; Spawns object while screen scrolls (how it goes from static 
; level data to dynamic stuff on the screen)
; Vertical variant of Level_ObjectsSpawnByScroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; This defines the values used as "look ahead" when screen is moving
	; Basically the values are $110 (one screen over + 16)
	; and -$20 (32 pixels to the left)
LOSBSV_LookAhead:	.byte -32, 32
LOSBSV_LookAheadHi:	.byte $FF, $01	; sign extensions

Level_ObjectsSpawnByScrollV:
	LDY <Scroll_LastDir

	LDA Level_VertScroll
	ADD LOSBSV_LookAhead,Y
	AND #$f0	 
	STA <Temp_Var6	 ; Temp_Var6 = Vert_Scroll + LOSBSV_LookAhead[Y] (appropriate "look ahead" values)

	LDA Level_VertScrollH
	ADC LOSBSV_LookAheadHi,Y
	STA <Temp_Var7		 ; Temp_Var7 = "look ahead" high part

	LDY <Level_Width
	CMP VertLevel_ScreenH+1,Y
	BLT PRG005_BB12	 ; If the "high part" is < the level high size, jump to PRG005_BB12
	BNE PRG005_BB0F	 ; If the "high part" is otherwise not equal, jump to PRG005_BB0F

	LDA <Temp_Var6
	CMP VertLevel_ScreenL+1,Y
	BLT PRG005_BB12	 ; If the lookahead low part is < the level low size, jump to PRG005_BB12

PRG005_BB0F:
	JMP PRG005_BB9A	 ; Jump to PRG005_BB9A (RTS)

PRG005_BB12:
	LDX <Temp_Var7		 ; X = "look ahead" high part
	LDA Level_ObjIdxStartByScreen,X	 	 ; Get starting Level_Objects index for this screen
	BMI PRG005_BB2F	 ; If no objects on this screen, jump to PRG005_BB2F (RTS)



	STA <Temp_Var2	 ; Starting index -> Temp_Var2
	TAX		 ; -> 'X'

	ASL A		 
	ADD <Temp_Var2	 ; Multiply by 3 (get to appropriate object)
	TAY		 ; -> 'Y'

PRG005_BB21:
	INY
	INY
	INY		 ; Y += 3 (next object, aligned to "row" element)

	LDA Level_Objects,Y	 ; Get object row
	LSR A
	LSR A
	LSR A
	LSR A		 ; Divide by 16 to get "screen" (16 rows per screen)
	CMP <Temp_Var7	 
	BEQ PRG005_BB30	 ; If object is on this "look ahead" screen, jump to PRG005_BB30

PRG005_BB2F:
	RTS		 ; Return

PRG005_BB30:
	LDA Level_Objects-2,Y
	CMP #$ff	 
	BEQ PRG005_BB2F	 ; If this is the terminator, jump to PRG005_B82F (RTS)

	LDA Level_ObjectsSpawned,X
	INX		 ; X++
	CMP #$00
	BMI PRG005_BB21	 ; If this object is already currently spawned, jump to PRG005_BB21 (skip to next object)

	LDA Level_Objects,Y	 ; Get object row
	ASL A
	ASL A
	ASL A
	ASL A		; Multiply by 16 (make pixel position)
	CMP <Temp_Var6
	BNE PRG005_BB21	 ; If object not equal to "look ahead" low component, jump to PRG005_BB21 (skip to next object)

	; Object should be spawned...

	DEX		 ; X-- (undo INX above)

	STX <Temp_Var2		 ; Backup object index -> Temp_Var2
	STA <Temp_Var1		 ; Backup pixel X position -> Temp_Var1

	; SB: Fixing bug here, using object ID like it should
	LDA Level_Objects-2,Y
	
	; SB: NEW: Extended bank objects
	CMP #OBJ_EXTBANK_BEGIN
	BGE PRG005_BB5F		; If this is an extended bank object, jump to PRG005_BB5F
	
	; FIXME, needs work!
	;CMP #OBJ_CFIRE_BULLETBILL
	;BLT OSPV_NotCannonFire	 ; If object ID < OBJ_CFIRE_BULLETBILL, jump to OSPV_NotCannonFire

	; Object ID >= OBJ_CFIRE_BULLETBILL...

	;SBC #OBJ_CFIRE_BULLETBILL	 ; Zero base it
	;ADD #$01	 ; +1 (because zero means "empty/unused" in Cannon Fire)

	;JSR CannonFire_Init	 ; Initialize the Cannon Fire
	
	;RTS

;OSPV_NotCannonFire:

	CMP #OBJ_CHEEPCHEEPBEGIN
	BLT PRG005_BB5F	

	SBC #(OBJ_CHEEPCHEEPBEGIN-1)
	STA Level_Event	 ; Store into Level_Event

	RTS		 ; Return

PRG005_BB5F:
	LDX #$04	 ; X = 4
PRG005_BB61:
	LDA Objects_State,X	
	BEQ PRG005_BB6C	 ; If this object is "dead/empty", jump to PRG005_BB6C
	DEX		 ; X--
	BPL PRG005_BB61	 ; While X >= 0, loop!
	JMP PRG005_BB9A	 ; Jump to PRG005_BB9A (RTS)

PRG005_BB6C:

	; Set object Y
	LDA <Temp_Var1
	STA <Objects_Y,X
	LDA <Temp_Var7	
	STA <Objects_YHi,X

	; Object X Hi is never used in a vertical level
	LDA #$00
	STA <Objects_XHi,X

	DEY		 ; Y-- (different way of getting at the column...)

	; Turn column into X pixel coordinate
	LDA Level_Objects,Y	 ; Get object column
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	STA <Objects_X,X

	DEY		 ; Y-- (now we're at the ID field)

	; Store object ID
	LDA Level_Objects,Y
	STA Level_ObjectID,X

	LDY <Temp_Var2		 ; Y = Temp_Var2 (object index)

	; Mark object as spawned
	LDA Level_ObjectsSpawned,Y
	ORA #$80
	STA Level_ObjectsSpawned,Y

	TYA		 ; Y -> 'A' (object index)

	STA Objects_SpawnIdx,X	 ; Store parent index

	INC Objects_State,X	 ; Set object state to 1

PRG005_BB9A:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelEvent_Do
;
; Performs a "level event" based on the value of Level_Event
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelEvent_Do:
	LDA Level_Event	
	BEQ PRG005_BBBF	 ; If no level event, jump to PRG005_BBBF (RTS)
	JSR DynJump	 ; Dynamic jump based on Level_Event... 
	
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!! 

	.word LevelEvent_DoNothing	; 0 - Do nothing (not used!)
	.word LevelEvent_CheepCheep	; 1 - Cheep Cheep attack
	.word LevelEvent_SpikeCheep	; 2 - Spike Cheeps float by
	.word LevelEvent_LakituFlee	; 3 - Clears Lakitu_Active which causes an active Lakitu to flee / be removed
	.word LevelEvent_Parabeetles	; 4 - Green and red parabeetles flyby!
	.word LevelEvent_BulletBill	; 5 - Random bullet bill firings
	.word LevelEvent_WoodPlatforms	; 6 - Random wooden platforms 
	.word LevelEvent_TreasureBox	; 7 - Get a treasure box
	.word LevelEvent_Cancel		; 8 - Does nothing but clear Level_Event

LevelEvent_LakituFlee:

	; Clears Lakitu_Active

	LDA #$00
	STA Lakitu_Active

LevelEvent_Cancel:
	LDA #$00
	STA Level_Event

PRG005_BBBF:
	RTS		 ; Return


WoodenPlatform_XVel:
	.byte -$04, -$08, -$06, -$08

LevelEvent_WoodPlatforms:
	LDA Level_NoStopCnt
	AND #$3f
	BNE PRG005_BBBF	 ; Only do anything every 127 ticks

	LDA #OBJ_ALBATOSS
	JSR Level_CountNotDeadObjs
	CPY #$04
	BCS PRG005_BC41	 ; If there's already at least 3 wooden platforms, jump to PRG005_BC41 (RTS)

	JSR Level_SpawnObj	 ; Spawn new object (Note: If no slots free, does not return)

	; ?? ObjectID 0?
	LDA #$00
	STA Level_ObjectID,X

	LDA RandomN,X
PRG005_BBDF:
	AND #$7f
	ADD #$40
	ADD Level_VertScroll
	AND #$e0	; Locks to 32 pixel grid
	ORA #$08
	STA <Temp_Var1	 ; Temp_Var1 = 64 + (Random 0 to 127), locked to 32 pixel grid with 15 offset
	PHP		 ; Save process status

	; Now comes a lengthy check to make sure that no wooden 
	; platform appears where another already is (vertically)
	LDY #$04
PRG005_BBF1:
	LDA Objects_State,Y
	BEQ PRG005_BC11	 ; If this object slot is "dead/empty", jump to PRG005_BC11

	LDA Level_ObjectID,Y
	CMP #OBJ_ALBATOSS
	BNE PRG005_BC11	 ; If this object slot is a OBJ_WOODENPLATFORM, jump to PRG005_BC11

	; This check specifically prevents two platforms from appearing in the same place
	LDA Objects_Y,Y
	CMP <Temp_Var1	
	BNE PRG005_BC11	 ; If this object slot's Y position does not match what we generated, jump to PRG005_BC11

	; Random + $30
	LDA RandomN,X
	ADD #$30
	STA RandomN,X

	PLP		 ; Restore process status
	JMP PRG005_BBDF	 ; Jump to PRG005_BBDF

PRG005_BC11:
	DEY		 ; Y--
	BPL PRG005_BBF1	 ; While Y >= 0, loop!

	; Y coordinate checks out, assign!
	LDA <Temp_Var1
	STA <Objects_Y,X
	PLP		 ; Restore process status
	LDA <Vert_Scroll_Hi
	ADC #$00
	STA <Objects_YHi,X

	; Set X coordinate
	LDA <Horz_Scroll
	ADD #$ff
	STA <Objects_X,X
	LDA <Horz_Scroll_Hi
	ADC #$00
	STA <Objects_XHi,X

	; Set X velocity
	LDA RandomN,X
	AND #$03
	TAY		 ; Y = random 0 to 3
	LDA WoodenPlatform_XVel,Y
	STA <Objects_XVel,X
	
	;LDA RandomN+1,X
	;AND #$07
	;NEG
	;STA <Objects_YVel,X

	; Force palette 1
	LDA #SPR_PAL1
	STA Objects_SprAttr,X

	; Set wooden platform ID at last
	LDA #OBJ_ALBATOSS
	STA Level_ObjectID,X

PRG005_BC41:
	RTS		 ; Return


LevelEvent_DECOMMISSIONED:
	RTS		 ; Return


LevelEvent_TreasureBox:

	; Used as delay until collected box kicks back to map
	LDY LevelEvent_Cnt
	BEQ PRG005_BCB6	 ; If LevelEvent_Cnt = 0, jump to PRG005_BCB6

	DEC LevelEvent_Cnt	; LevelEvent_Cnt--
	BNE PRG005_BCB5	 	; If LevelEvent_Cnt <> 0, jump to PRG005_BCB5 (RTS)

	; Exit to map
	INC Level_ExitToMap
	LDA #$00
	STA Map_ReturnStatus

PRG005_BCB5:
	RTS		 ; Return

PRG005_BCB6:

	; The following loop limits the appearance of the treasure box
	; to only when there's no objects...
	LDY #$07	 ; Y = 7

PRG005_BCB8:
	LDA SpecialObj_ID,Y
	BNE PRG005_BCF4	 ; If special object slot <> 0 (dead/empty), jump to PRG005_BCF4 (RTS)

	CPY #$05
	BGE PRG005_BCCD	 ; If Y >= 5, jump to PRG005_BCCD

	LDA Level_ObjectID,Y
	CMP #OBJ_GIANTBLOCKCTL	 
	BEQ PRG005_BCCD	 ; If object ID = OBJ_GIANTBLOCKCTL (the Giant World block controller), jump to PRG005_BCCD

	LDA Objects_State,Y	
	BNE PRG005_BCF4	 ; If this object slot is not "dead/empty", jump to PRG005_BCF4

PRG005_BCCD:
	DEY		 ; Y--
	BPL PRG005_BCB8	 ; While Y >= 0, loop!

	; Set treasure box state to Init
	LDA #OBJSTATE_INIT
	STA Objects_State

	; Set treasure box ID
	LDA #OBJ_TREASUREBOX
	STA Level_ObjectID

	; Treasure box always appears at Y coordinate $0170
	LDA #$01
	STA <Objects_YHi
	LDA #$70
	STA <Objects_Y

	; Treasure box attempts to appear roughly at left quarter of screen
	LDA #$30
	LDY <Player_X
	BMI PRG005_BCEA
	LDA #$c0
PRG005_BCEA:
	ADC <Horz_Scroll
	STA <Objects_X
	LDA <Horz_Scroll_Hi
	ADC #$00
	STA <Objects_XHi

PRG005_BCF4:
	RTS		 ; Return


	; Random X Offsets employed by the jumping 
	; Cheep Cheeps; may negate sign!
CheepCheep_RandomXs:
	.byte $10, $18, $20, $28

	; Random X Velocities employed by the jumping 
	; Cheep Cheeps; may negate sign!
CheepCheep_RandomXVels:
	.byte $18, $1A, $1C, $1E

LevelEvent_CheepCheep:	
	LDA Level_NoStopCnt
	AND #$3f	 ; Cap 0 - 31
	BNE PRG005_BD53	 ; If not zero, jump to PRG005_BD53 (RTS)

	LDA #OBJ_JUMPINGCHEEPCHEEP
	JSR Level_CountNotDeadObjs
	CPY #$03
	BGE PRG005_BD53	 ; If there are already at least 3 Jumping Cheep Cheeps, jump to PRG005_BD53 (RT)S

	JSR Level_SpawnObj	 ; Spawn new object (Note: If no slots free, does not return)

	; Set the Cheep Cheep's object ID
	LDA #OBJ_JUMPINGCHEEPCHEEP
	STA Level_ObjectID,X

	; Set Cheep Cheep's Y at bottom of screen
	LDA Level_VertScroll
	ADD #$c0
	STA <Objects_Y,X

	LDA <Vert_Scroll_Hi
	ADC #$00
	STA <Objects_YHi,X

	LDA RandomN,X	 ; Get random number

	PHP		 ; Save process status
	PHP		 ; Save process status

	AND #$03	 ; Cap 0 - 3
	TAY		 ; -> 'Y'
	LDA CheepCheep_RandomXs,Y	 ; Get one of the random X offset
	PLP		 ; Restore process status
	BPL PRG005_BD33	 ; If random number was positive, jump to PRG005_BD33

	EOR #$ff	 ; Otherwise, negate (sort of)

PRG005_BD33:
	ADD <Horz_Scroll 	; Horz_Scroll + X offset
	STA <Objects_X,X	; Store as object's X

	; Apply carry as needed
	LDA <Horz_Scroll_Hi
	ADC #$00
	STA <Objects_XHi,X

	LDA RandomN+2,X	 ; Get another random number
	AND #$03	 ; Cap 0 - 3
	TAY		 ; -> 'Y'
	LDA CheepCheep_RandomXVels,Y	 ; Get one of the random X velocities
	PLP		 ; Restore process status
	BPL PRG005_BD4D	 ; If original random number was positive, jump to PRG005_BD4D

	JSR Negate	 ; Otherwise, negate it!

PRG005_BD4D:
	STA <Objects_XVel,X	 ; Set X velocity

	LDA #-$48
	STA <Objects_YVel,X	 ; Set Y velocity = -$48

PRG005_BD53:
	RTS		 ; Return

	; The Spike Cheeps appear on the left or right side of the screen (respective)
	; And thus travel to the right or the left (respective again)
SpikeCheepX:	.byte 0, 255
SpikeCheepXVel:	.byte 8, -16

LevelEvent_SpikeCheep:

	INC LevelEvent_Cnt	 ; LevelEvent_Cnt++

	LDA LevelEvent_Cnt
	CMP #$aa
	BNE PRG005_BDB0	 ; If LevelEvent_Cnt <> $AA, jump to PRG005_BDB0 (RTS)

	LDA #$00
	STA LevelEvent_Cnt	 ; Reset LevelEvent_Cnt

	LDX #$02	 ; X = 2 (only spawning Spike Cheeps in slots 0 - 2)
	JSR Level_SpawnObjSetMax	 ; Spawn new object (Note: If no slots free, does not return)

	LDA Level_Tileset
	CMP #10
	BNE LE_NotAirship

	; On Airships (really the ghost ship of W3) spawn Fish Bones
	LDA #OBJ_FISHBONE
	BNE LE_SpawnID	; Jump (technically always) to LE_SpawnID

LE_NotAirship:
	; Set Spike Cheep's object ID
	LDA #OBJ_GREENCHEEP
	
LE_SpawnID:
	STA Level_ObjectID,X

	LDA RandomN,X	 ; Get a random number
	AND #$01	 ; Random 0 or 1
	TAY		 ; -> 'Y'

	; Set Spike Cheep's X
	LDA <Horz_Scroll
	ADD SpikeCheepX,Y	; Start on left or right of screen
	STA <Objects_X,X
	LDA <Horz_Scroll_Hi
	ADC #$00
	STA <Objects_XHi,X

	LDA SpikeCheepXVel,Y	 ; Get matching X velocity

	LDY Level_AScrlConfig
	BEQ PRG005_BD91	 ; If auto scroll is not in effect , jump to PRG005_BD91

	ADD Level_AScrlHVel	 ; Otherwise, apply auto scroll's horizontal delta to Spike Cheep's X velocity

PRG005_BD91:
	STA <Objects_XVel,X	 ; Set X velocity

	; Set Spike Cheep's Y
	LDA RandomN,X	 ; Get random number
	AND #$f0	 ; Keep aligned to 16 pixels
	ADC #$20	 ; + 32
	AND #$7f	 ; Cap 0 - $7F
	ADC Level_VertScroll
	STA <Objects_Y,X	
	LDA Level_VertScrollH
	ADC #$00
	STA <Objects_YHi,X

	LDA #$01
	STA Objects_Var1,X	; var 1 = 1
	STA Objects_InWater,X	; Object is in water

PRG005_BDB0:
	RTS		 ; Return

ParaBeetle_X:		.byte 0, 255
ParaBeetle_XVel:	.byte 8, -8

LevelEvent_Parabeetles:
	LDA Level_NoStopCnt
	AND #$3f	 
	BNE PRG005_BDFF	 ; Only do anything once every 64 ticks

	LDA #OBJ_PARABEETLE
	JSR Level_CountNotDeadObjs
	CPY #$04
	BGE PRG005_BDFF	 ; If there's already at least 4 parabeetles, jump to PRG005_BDFF (RTS)

	JSR Level_SpawnObj	 ; Spawn new object (Note: If no slots free, does not return)

	; Set parabeetle's object ID
	LDA #OBJ_PARABEETLE
	STA Level_ObjectID,X

	JSR EventObj_RandomHeight

	; Set appropriate starting X velocity
	LDA ParaBeetle_XVel,Y
	LDY RandomN+1,X
	BPL PRG005_BDEA
	ASL A		; Roughly 50/50 chance that this parabeetle will be twice as fast!
PRG005_BDEA:
	STA <Objects_XVel,X

PRG005_BDFF:
	RTS		 ; Return

EventObj_RandomHeight:
	LDA RandomN,X
	AND #$01
	TAY		 ; Y = random 0 or 1

	; Set appropriate starting X position
	LDA <Horz_Scroll
	ADD ParaBeetle_X,Y
	STA <Objects_X,X
	LDA <Horz_Scroll_Hi
	ADC #$00
	STA <Objects_XHi,X

	; Set Y position (screen height + 16 + (Random 0 - 127))
	LDA RandomN,X
	AND #$7f	
	ADD #$10	
	ADC Level_VertScroll
	STA <Objects_Y,X	
	LDA <Vert_Scroll_Hi	
	ADC #$00
	STA <Objects_YHi,X
	
	RTS


BillLEPB_XVel:	.byte $18, -$18
BillLEPB_Flip:	.byte SPR_HFLIP, $00
BillLEPB_Var4:	.byte $01, $00

	; Bullet bill hack -- almost like Parabeetles, but different parameters

LevelEvent_BulletBill:
	LDA Level_NoStopCnt
	AND #$7f
	BNE PRG005_BDFF	 ; Only do anything once every 64 ticks

	JSR Level_SpawnObj	 ; Spawn new object (Note: If no slots free, does not return)

	; Set Bullet Bill's object ID
	LDA #OBJ_BULLETBILL
	STA Level_ObjectID,X

	JSR EventObj_RandomHeight

	; Bullet bill
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Set bullet bill's object ID
	LDA #OBJ_BULLETBILL
	STA Level_ObjectID,X

	; X velocity is different
	LDA BillLEPB_XVel,Y
	STA <Objects_XVel,X

	; Bill faces correctly
	LDA BillLEPB_Flip,Y
	STA Objects_FlipBits,X

	; Set Bill's direction flag
	LDA BillLEPB_Var4,Y
	STA <Objects_Var4,X

	LDA #SPR_PAL3
	STA Objects_SprAttr,X

	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_SpawnObj	-- slots 0 - 4
; Level_SpawnObjSetMax	-- slots 0 - input X register
;
; This function "spawns" a new object (finds an empty object slot 
; from slots 0 - 4 (or custom) and preps it for normal operation.)
; Does not set up X, Y, ID, etc -- this is the responsibility of
; the caller to do so.
; NOTE!! If no slot is free, this function does NOT RETURN TO
; THE CALLER!! So no additional logic checking is necessary.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_SpawnObj:
	LDX #$04	 ; X = 4

Level_SpawnObjSetMax:
	LDA Objects_State,X	 ; Check the state of this object slot

	BEQ PRG005_BE26	 ; If this object slot is "dead/empty", jump to PRG005_BE26

	DEX		 ; X--
	BPL Level_SpawnObjSetMax	 ; While X >= 0, loop!

	; When no slots are open, does not return to caller!
	PLA		 
	PLA		 ; Do not return to caller!!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_CountNotDeadObjs
;
; This function counts the number of objects that are not in the
; "dead/empty" state in object slots 0 - 4
; It also sets X = SlotIndexBackup
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_CountNotDeadObjs:
	STA <Temp_Var1	 ; Store object ID we're hunting for -> Temp_Var1

	LDY #$00	 ; Y = 0 (count how many of this object already exist)
	LDX #$04	 ; X = 4

PRG005_BE13:
	LDA Objects_State,X
	BEQ PRG005_BE20	 ; If this object slot is "dead", jump to PRG005_BE20

	LDA Level_ObjectID,X
	CMP <Temp_Var1	
	BNE PRG005_BE20	 ; If this object slot does not have the same ID as what was input, jump to PRG005_BE20

	INY		 ; Otherwise, increment count

PRG005_BE20:
	DEX		 ; X--
	BPL PRG005_BE13	 ; While X >= 0, loop!

	LDX <SlotIndexBackup	 ; X = SlotIndexBackup
	RTS		 ; Return


PRG005_BE26:
	JSR Level_PrepareNewObject	 ; Prepare new object!

	LDA #OBJSTATE_NORMAL
	STA Objects_State,X	 ; Objects_State[X] = OBJSTATE_NORMAL (item alive, default state)

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_DoChangeReset
;
; Whenever a new "scene" of a level is entered into, the initial
; screen needs to be set up (clears old objects out, spawns new
; ones in!)  This activates only when Level_ChangeReset = 0!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_DoChangeReset: 
	LDA Level_ChangeReset
	BEQ PRG005_BE35	 ; If Level_ChangeReset not set, jump to PRG005_BE35

	RTS		 ; Return

PRG005_BE35:
	LDY #$09	 	; Y = 9

PRG005_BE37:
	STA SpecialObj_ID,Y	; Set special object ID to 0

	CPY #$08	 
	BGE PRG005_BE41	 	; If Y >= 8, jump to PRG005_BE41

	STA CannonFire_ID,Y

PRG005_BE41:
	CPY #$05
	BGE PRG005_BE4B	 ; If Y >= 5, jump to PRG005_BE4B

	; Clear the scores
	STA Scores_Value,Y
	STA Scores_Counter,Y

PRG005_BE4B:
	CPY #$03
	BEQ PRG005_BE64	 	; If Y = 3, jump to PRG005_BE64
	BGE PRG005_BE67	 	; If Y > 3, jump to PRG005_BE67

	STA Bubble_Cnt,Y	; Clear any water bubbles
	STA Splash_Counter,Y	; Clear any water splashes
	STA BrickBust_En,Y	; Clear any brick busting effects

	CPY #$02
	BGE PRG005_BE64	 	; If Y >= 2, jump to PRG005_BE64

	STA Buffer_Occupied,Y 	; Clear the buffer occupation flags
	STA PlayerProj_ID,Y 	; Clear Player projectiles

PRG005_BE64:
	STA CoinPUp_State,Y	; Clear power-up coin state

PRG005_BE67:
	DEY		 ; Y--
	BPL PRG005_BE37	 ; While Y >= 0, loop

	; Clear a bunch of stuff!
	STA Player_DebugNoHitFlag	
	STA EndCard_Flag
	STA RotatingColor_Cnt
	STA Player_TwisterSpin
	STA Level_Vibration
	STA Vert_Scroll_Off
	STA Player_VibeDisable
	STA Level_Event	
	STA LevelEvent_Cnt
	STA Splash_DisTimer
	STA Level_ScrollDiffH
	STA Level_ScrollDiffV
	STA Level_ActSwAction

	; Clear Level_ObjectsSpawned (nothing spawned)
	LDY #$2f	 ; Y = $2F
PRG005_BE90:
	STA Level_ObjectsSpawned,Y
	DEY		 ; Y--
	BPL PRG005_BE90	 ; While Y >= 0, loop!

	STY Level_ChangeReset
	STA Player_PartDetEn
	STA Level_ObjIdxStartByScreen
	STA Player_InWater
	STA Player_UphillFlag
	STA AScrlURDiag_WrapState_Copy
	STA AScrlURDiag_WrapState
	STA Cine_ToadKing
	STA Level_AScrlVVel
	STA <Temp_Var1

	TAX		 ; X = 0

	TAY
	INY		 ; Y = 1

PRG005_BEB6:
	CPX #$10	 
	BEQ PRG005_BEFC	 ; If X = $10, jump to PRG005_BEFC
 
	LDA Level_Objects,Y
	CMP #$ff	 
	BEQ PRG005_BEE5	 ; If terminator, jump to PRG005_BEE5

	LDA Level_7Vertical
	PHP		 	; Save process status
	LDA Level_Objects+1,Y	; Get object column
	PLP		 	; Restore process status

	BEQ PRG005_BECE	 	; If level is NOT vertical, jump to PRG005_BECE

	LDA Level_Objects+2,Y	; Get object row instead for vertical

PRG005_BECE:
	LSR A
	LSR A
	LSR A
	LSR A		 ; Get appropriate screen offset
	STA <Temp_Var2	 ; -> Temp_Var2

	CPX <Temp_Var2	
	BNE PRG005_BEE5	 ; If X <> screen offset, jump to PRG005_BEE5

	INC <Temp_Var1	 ; Temp_Var1++

	LDA <Temp_Var1	
	STA Level_ObjIdxStartByScreen+1,X ; Calculated first object index for next screen

	INY
	INY 
	INY		 ; Y += 3 (next object)
	JMP PRG005_BEB6	 ; Jump to PRG005_BEB6

PRG005_BEE5:
	LDA <Temp_Var1	 

	CPX #$0f	 
	BEQ PRG005_BEEE	 ; If X = $F, jump to PRG005_BEEE

	STA Level_ObjIdxStartByScreen+1,X ; Calculated first object index for next screen

PRG005_BEEE:
	CMP Level_ObjIdxStartByScreen,X	 
	BNE PRG005_BEF8	 ; If Level_ObjIdxStartByScreen[X] <> 0, jump to PRG005_BEF8

	LDA #$ff	 
	STA Level_ObjIdxStartByScreen,X	 ; Level_ObjIdxStartByScreen[X] = $FF (means no objects this screen)

PRG005_BEF8:
	INX		 ; X++
	JMP PRG005_BEB6	 ; Jump to PRG005_BEB6

	; Clear all object states
PRG005_BEFC:
	LDX #$07	 ; X = 7
PRG005_BEFE:
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X	 ; Clear object state
	DEX		 ; X--
	BPL PRG005_BEFE	 ; While X >= 0, loop!

	; RIGHT HERE DUDES	
	JSR_THUNKC 30, Level_JunctionYoshi

	LDA #$4f	 
	STA PatTable_BankSel+5	 ; Set sixth pattern table to $4F

	LDA Level_TilesetIdx
	CMP #$0a	 
	BNE PRG005_BF1C	 ; If Level_TilesetIdx <> 10 (Giant World), jump to PRG005_BF1C

	; Setup object slot 4 for OBJ_GIANTBLOCKCTL
	LDA #OBJSTATE_INIT
	STA Objects_State+4
	LDA #OBJ_GIANTBLOCKCTL
	STA Level_ObjectID+4

PRG005_BF1C:
	LDA Level_7Vertical	 
	BNE PRG005_BF70	 ; If level is vertical, jump to PRG005_BF70

	LDA <Horz_Scroll
	PHA		 ; Save Horz_Scroll

	LDA LOSBS_LookAhead	 ; $10
	SUB LOSBS_LookAhead+1	 ; $10 - $E0 = $30

	; Adds $130 to Horz_Scroll/Hi (basically one screen over to the right of the start)

	ADD <Horz_Scroll ; Horz_Scroll += $30

	AND #$f0	 ; Align to grid

	STA <Temp_Var14	 ; -> Temp_Var14

	LDA <Horz_Scroll_Hi
	PHA		 ; Save Horz_Scroll_Hi

	ADC LOSBS_LookAheadHi	 ; Add 1 with carry (LOSBS_LookAheadHi = 1)
	STA <Temp_Var15	 ; -> Temp_Var15

	LDA #$01
	STA <Scroll_LastDir	 ; Scroll_LastDir = 1 (screen last moved left)

	; Fake leftward scroll by 16
	LDA <Horz_Scroll
	SUB #16
	STA <Horz_Scroll	; Horz_Scroll -= $10

	BCS PRG005_BF49	 	; If carry set, jump to PRG005_BF49
	DEC <Horz_Scroll_Hi	; Apply carry

	; This loop spawns all objects which should be visible at the initial
	; screen of the level by pretending to scroll a whole screen's worth

PRG005_BF49:
	LDA <Horz_Scroll
	ADC #$10
	AND #$f0
	STA <Horz_Scroll ; Horz_Scroll += $10, aligned to grid

	BCC PRG005_BF55	 ; If no carry, jump to PRG005_BF55
	INC <Horz_Scroll_Hi	 ; Apply carry
PRG005_BF55:

	; Ensures all objects that should appear on the initial screen, will appear
	JSR Level_ObjectsSpawnByScroll
	JSR Level_ObjectsSpawnByScroll

	LDA <Temp_Var15
	CMP <Horz_Scroll_Hi
	BNE PRG005_BF49	 ; If we haven't reached the high target yet, loop

	LDA <Temp_Var14	
	CMP <Horz_Scroll
	BNE PRG005_BF49	 ; If we haven't reached the low target yet, loop

	PLA
	STA <Horz_Scroll_Hi	 ; Restore Horz_Scroll_Hi

	PLA
	STA <Horz_Scroll	 ; Restore Horz_Scroll

	; Do not return to caller!!
	PLA
	PLA

	RTS		 ; Return

PRG005_BF70:

	; SB: Spawn all Alt Level Mods and Touch Warps immediately and permanently
	JSR LevReset_VSpawnSpecs

	; This loop spawns all objects which should be visible at the initial
	; screen of the level by pretending to scroll a whole screen's worth

	LDA Level_VertScroll
	PHA		 ; Save Level_VertScroll

	ADD LOSBSV_LookAhead+1
	AND #$f0
	STA <Temp_Var14	 ; Temp_Var14 = Level_VertScroll + [LOSBSV_LookAhead+1], aligned to nearest row

	LDA Level_VertScrollH
	PHA		 ; Save Level_VertScrollH
	
	ADD LOSBSV_LookAheadHi+1
	STA <Temp_Var15	 ; Temp_Var15 = Level_VertScrollH + [LOSBSV_LookAheadHi+1]

	LDA #$00
	STA <Scroll_LastDir	 ; Scroll_LastDir = 0 (screen last moved up)

	; Fake upward scroll by one row
	LDA Level_VertScroll
	SUB #16
	STA Level_VertScroll	 ; Level_VertScroll -= 16

	BCS PRG005_BF98		 ; If carry set, jump to PRG005_BF98
	DEC Level_VertScrollH	 ; Apply carry
PRG005_BF98:

	LDA Level_VertScroll
	ADC #16
	AND #$f0
	STA Level_VertScroll	 ; Level_VertScroll += 16, aligned to row
	BCC PRG005_BFA7	 ; If carry clear, jump to PRG005_BFA7
	INC Level_VertScrollH	 ; Apply carry
PRG005_BFA7:

	; Ensures all objects that should appear on the initial screen, will appear
	JSR Level_ObjectsSpawnByScrollV
	JSR Level_ObjectsSpawnByScrollV

	LDA <Temp_Var15
	CMP Level_VertScrollH
	BNE PRG005_BF98	 ; If we haven't reached the high target yet, loop

	LDA <Temp_Var14
	CMP Level_VertScroll
	BNE PRG005_BF98	 ; If we haven't reached the low target yet, loop

	PLA
	STA Level_VertScrollH	 ; Restore Level_VertScrollH

	PLA
	STA Level_VertScroll	 ; Restore Level_VertScroll

	; Do not return to caller!!
	PLA
	PLA

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevReset_VSpawnSpecs
;
; If vertical level, this will spawn all Alt Level Mod objects.
; The vertical level paradigm does not support the concept of
; objects that use their Y coordinate as a parameter very well.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevReset_VSpawnSpecs:

	LDX #$00	; X = 0
	LDY #$01	; Y = 1 (Skip the strange useless byte)

LevReset_VSpawnSpecs_Loop:

	; Next byte is ID of object (or $FF to terminate the list)
	LDA Level_Objects,Y

	CMP #$ff	 
	BEQ LevReset_VSpawnSpecs_Quit	 	; If terminator hit, jump to LevReset_VSpawnSpecs_Quit (RTS)

	; Need to increment Y so it lines up 
	INY

	CMP #OBJ_ACTIONSWITCH
	BEQ LevReset_VSpawnSpecs_ActSw
	
	CMP #OBJ_ALTLEVELMOD
	BEQ LevReset_VSpawnSpecs_IsOne

	CMP #OBJ_TOUCHWARP
	BNE LevReset_VSpawnSpecs_NotOne

LevReset_VSpawnSpecs_IsOne:

	; Backup 'X' and 'Y'
	TXA
	PHA
	TYA
	PHA

	; Needed for spawn -> index into 'X'
	STX <Temp_Var2

	; Calculate X coordinate -> Temp_Var1
	; X Hi not needed in vertical world
	LDA Level_Objects,Y
	ASL A
	ASL A
	ASL A
	ASL A	; Multiply by 16
	STA <Temp_Var1	; -> Temp_Var1

	; Zero out the would-be X Hi
	LDA #0
	STA <Temp_Var7

	; Spawn an alternate level mod!
	JSR ObjPrioSpecObj_Init ; Initialization code for OBJ_ALTLEVELMOD/OBJ_TOUCHWARP

	; Restore 'Y' and 'X'
	PLA
	TAY
	PLA
	TAX

LevReset_VSpawnSpecs_MarkSpawn:

	; Mark object as already spawned
	LDA Level_ObjectsSpawned,X
	ORA #$80	 
	STA Level_ObjectsSpawned,X

LevReset_VSpawnSpecs_NotOne:

	; Y += 2 (skip passed rest of object)
	INY
	INY

	; X++ (Next object)
	INX

	JMP LevReset_VSpawnSpecs_Loop		; Loop!

LevReset_VSpawnSpecs_Quit:
	RTS		 ; Return


LevReset_VSpawnSpecs_ActSw:

	; Action Switch set!
	LDA Level_Objects+1,Y	 ; Get object row
	STA Level_ActSwEvent	; -> Level_ActSwEvent

	JMP LevReset_VSpawnSpecs_MarkSpawn

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ObjPrioSpecObj_Init
;
; Appropriately creates one of my new priority Special Objects
; that support a special "X Hi" and will bump out other special
; objects if they must to get a slot!
;
; Note there's risk of software freeze if too many of these are
; attempted to be created, so be sensible in your level building!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; This table is based on OBJ_ALTLEVELMOD and so must
	; follow the same order!

ObjPrioSpecObj_MatchIDs:	.byte OBJ_ALTLEVELMOD, OBJ_TOUCHWARP, OBJ_FENCE_CTL
ObjPrioSpecObj_MatchEnd
ObjPrioSpecObj_SObjIDs:	.byte SOBJ_ALTLEVELMOD, SOBJ_TOUCHWARP, SOBJ_FENCECTL

ObjPrioSpecObj_Init:

	; SB: Priority Special Object creation
	; If we find an empty special object slot, great.
	; If we don't, we'll FORCE into one!!

	LDA Level_Objects+1,Y	; Get object row
	STA <Temp_Var3	; -> Temp_Var3

	; Match the object ID to its cooresponding special object ID
	LDA Level_Objects-1,Y	; Get object ID
	LDY #(ObjPrioSpecObj_MatchEnd - ObjPrioSpecObj_MatchIDs - 1)
ObjPrioSpecObj_SearchLoop:
	CMP ObjPrioSpecObj_MatchIDs,Y
	BEQ ObjPrioSpecObj_Matched

	DEY		; Y--
	BPL ObjPrioSpecObj_SearchLoop	; While Y >= 0, loop!

ObjPrioSpecObj_Matched:	
	LDA ObjPrioSpecObj_SObjIDs,Y	; Get Special Object ID
	STA <Temp_Var4	; -> Temp_Var4

	LDY #$07	 ; Y = 7
PrioSpecObj_SearchEmpty:
	LDA SpecialObj_ID,Y
	BEQ PrioSpecObj_SearchEmpty_Found	 ; If special object slot = 0 (dead/empty), jump to PrioSpecObj_SearchEmpty_Found

	DEY		 ; Y--
	BPL PrioSpecObj_SearchEmpty	 ; While Y >= 0, loop!

PrioSpecObj_SearchEmpty_None:
	; No empty slots?  We'll just have to force our way in!
	; To be fair, pick a random number from 0-7
	LDA RandomN
	AND #$07
	TAY

	; SB: Obviously if you're being silly and put too many priority special objects together,
	; this will cause the software to freeze.  Don't do that, be sensible, okay??
PrioSpecObj_SearchEmpty_Chk:
	; But it'd be dumb to step on another Priority Special Object, right?
	
	LDA SpecialObj_ID,Y
	LDX #(ObjPrioSpecObj_MatchEnd - ObjPrioSpecObj_MatchIDs - 1)
PrioSpecObj_SearchEmpty_IDLoop:
	CMP ObjPrioSpecObj_SObjIDs,X
	BNE PrioSpecObj_SearchEmpty_Found
	
	DEX		; X--
	BPL PrioSpecObj_SearchEmpty_IDLoop	; While X >= 0, loop!

	; Darn, we stepped on a different priority special object!  Okay, try again...
	JSR Randomize
	JMP PrioSpecObj_SearchEmpty_None

PrioSpecObj_SearchEmpty_Found:
	; We have an empty slot in 'Y' ...

	; Set the appropriate Special Object ID...
	LDA <Temp_Var4
	STA SpecialObj_ID,Y

	; Store object spawn index into Var1 (so we can un-mark ourselves as spawned later; we WANT this to retrigger!)
	LDA <Temp_Var2
	STA SpecialObj_Var1,Y

	; Store the object X -> X Lo
	LDA <Temp_Var1
	STA SpecialObj_XLo,Y

	; Special objects generally do not have "X Hi", but we really need it this time,
	; so we're going to borrow Var3 as a forced X Hi
	LDA <Temp_Var7
	STA SpecialObj_Var3,Y

	LDA <Temp_Var4
	CMP #SOBJ_FENCECTL
	BNE PrioSpecObj_NoRealY

	; Fence controller needs a real YLo/Hi!
	; Upper 4 bits shifted right -> CannonFire_YHi (high Y)
	LDA <Temp_Var3	 ; Get object row
	AND #$f0	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA SpecialObj_YHi,Y

	; Upper 4 bits shifted left -> CannonFire_Y (low Y)
	LDA <Temp_Var3	 ; Get object row
	AND #$0f	
	ASL A		
	ASL A		
	ASL A		
	ASL A		
	STA SpecialObj_YLo,Y

	JMP PrioSpecObj_YSet

PrioSpecObj_NoRealY:
	; Store the object row (used as a parameter) -> Y Lo
	LDA <Temp_Var3
	STA SpecialObj_YLo,Y

PrioSpecObj_YSet:
	LDA #$00
	STA SpecialObj_XVel,Y
	STA SpecialObj_YVel,Y
	STA SpecialObj_Var2,Y
	STA SpecialObj_Data,Y

	LDX <Temp_Var2	 ; Restore object index

	RTS

ClimbingKoopa_InitVel:	.byte -$08, $08


ObjInit_ClimbingKoopa:
	LDY <Scroll_LastDir
	
	LDA Level_ObjectID,X
	PHA
	AND #1
	BEQ ClimbingKoopa_InitGreen
	
	; Red climbing Koopa goes up/down
	
	; If level is vertical, use Y = Scroll_LastDir, otherwise assume climbing down to start always
	LDA Level_7Vertical
	BNE ClimbingKoopa_InitRedV
	
	; Ignore in non-vertical level
	LDY #0
	
ClimbingKoopa_InitRedV:
	
	; Red Koopa's velocities make sense in reverse
	TYA
	EOR #1
	TAY
	
	LDA ClimbingKoopa_InitVel,Y
	STA <Objects_YVel,X
	JMP ClimbingKoopa_InitCommon
	
ClimbingKoopa_InitGreen:
	; Green climbing Koopa goes left/right

	; If level is NOT vertical, use Y = Scroll_LastDir, otherwise assume climbing down to start always
	LDA Level_7Vertical
	BEQ ClimbingKoopa_InitGreenV
	
	; Ignore in vertical level
	LDY #0
	
ClimbingKoopa_InitGreenV:

	LDA ClimbingKoopa_InitVel,Y
	STA <Objects_XVel,X
	
ClimbingKoopa_InitCommon:

	; Store direction -> Var4
	TYA
	STA Objects_Var4,X
	
	PLA	; Restore ID
	SUB #OBJ_CLIMBINGKOOPA_G
	CMP #2
	BLT ClimbingKoopa_NotBehind

	; This climbing Koopa should be BEHIND the fence...
	LDA Objects_SprAttr,X
	ORA #SPR_BEHINDBG
	STA Objects_SprAttr,X

	; Mark as behind the scenes...
	INC Objects_IsBehind,X

ClimbingKoopa_NotBehind:
	RTS

ObjNorm_ClimbingKoopa:
	JSR ClimbingKoopa_Draw
	LDA <Player_HaltGame
	BNE ClimbingKoopa_Halt	 ; If gameplay is halted, jump to ClimbingKoopa_Halt
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE ClimbingKoopa_Halt	; If object is not in normal state, jump to ClimbingKoopa_Halt

	JSR Object_ApplyXVel
	JSR Object_ApplyYVel
	JSR Object_HandleBumpUnderneath
	JSR Object_DeleteOffScreen_N2
	
	LDA <Counter_1
	AND #$08
	ASL A
	ASL A
	ASL A
	STA Objects_FlipBits,X
	
	JSR Object_GetAttrAndMoveTiles
	
	LDA Level_Tile
	SUB #TILE2_FENCE_UL
	CMP #(TILE2_FENCE_LR - TILE2_FENCE_UL + 1)
	BLT ClimbingKoopa_Halt	; If this is a fence tile, jump to VineClimb_FortOverride
	
	; Climbing Koopa is no longer on a fence tile; reverse direction!
	LDA Objects_Var4,X
	EOR #1
	STA Objects_Var4,X
	TAY
	
	LDA Level_ObjectID,X
	AND #1
	BEQ ClimbingKoopa_SetXVel	; If this is a green Climbing Koopa, set X velocity
	
	; Offset to Y velocity instead
	TXA
	ADD #(Objects_YVel - Objects_XVel)
	TAX
	
ClimbingKoopa_SetXVel:
	LDA ClimbingKoopa_InitVel,Y
	STA <Objects_XVel,X
	
	LDX <SlotIndexBackup
	
ClimbingKoopa_Halt:
	RTS

ClimbingKoopa_Palette: .byte SPR_PAL2, SPR_PAL1

ClimbingKoopa_Draw:
	; Set proper sprite, forward or backward climber
	LDA Level_ObjectID,X
	SUB #OBJ_CLIMBINGKOOPA_G
	LSR A
	STA Objects_Frame,X
	
	JSR Object_DetermineHorzVis
	JSR Object_DetermineVertVis
	JSR Object_CalcSpriteXY_NoHi
	JSR Object_Draw16x32Sprite

	LDA Objects_Frame,X
	BNE ClimbingKoopa_NoShell	; If this is NOT the "front" climber, jump to ClimbingKoopa_NoShell
	
	; Front climber needs a shell on top

	; Reset vis variables
	LDA Objects_SprVVis,X
	STA <Temp_Var5		; Temp_Var5 = Objects_SprVVis
	LDA Objects_SprHVis,X
	STA <Temp_Var8		; Temp_Var8 = Objects_SprVVis
	
	; Advance 2 sprites
	TYA
	ADD #8
	TAY

	LDA Objects_FlipBits,X
	BPL ClimbingKoopa_NotVFlip
	
	; If vertically flipped, shell is at top not bottom...
	
	; Move shell up 16 pixels
	LDA <Temp_Var1
	SUB #16
	STA <Temp_Var1

ClimbingKoopa_NotVFlip:
	; Set proper palette
	LDX <SlotIndexBackup
	LDA <Temp_Var4	; We expect that the palette portion is currently SPR_PAL3, %xxxxxx11
	AND #~%00000011		; Clear palette setting
	STA <Temp_Var4
	LDA Level_ObjectID,X
	AND #1
	TAX
	LDA ClimbingKoopa_Palette,X
	ORA <Temp_Var4
	STA <Temp_Var4
	
	; Select patterns for shell
	LDX #(CK_Shell-ObjectGroup04_PatternSets)
		
	; Draw shell!
	JSR Object_Draw16x16Sprite
	LDX <SlotIndexBackup

ClimbingKoopa_NoShell:
	RTS
