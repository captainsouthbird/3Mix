; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg003.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup02 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $02 (i.e. objects starting at ID $48) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup02_InitJumpTable:
	.word ObjInit_DarknessCtl		; Object $48 - OBJ_DARKNESSCTL
	.word ObjInit_FireSnake		; Object $49 - OBJ_ICESNAKE
	.word ObjInit_BoomBoomQBall	; Object $4A - OBJ_BOOMBOOMQBALL
	.word ObjInit_BoomBoom		; Object $4B - OBJ_BOOMBOOMJUMP
	.word ObjInit_BoomBoom		; Object $4C - OBJ_BOOMBOOMFLY
	.word ObjInit_DoNothing		; Object $4D
	.word ObjInit_Birdo		; Object $4E - OBJ_BOSSBIRDO
	.word ObjInit_DoNothing		; Object $4F
	.word ObjInit_BobOmbExplode	; Object $50 - OBJ_BOBOMBEXPLODE
	.word ObjInit_DoNothing		; Object $51 - OBJ_BOOLOOP
	.word ObjInit_TreasureBox	; Object $52 - OBJ_TREASUREBOX
	.word ObjInit_PodobooCeiling	; Object $53 - OBJ_PODOBOOCEILING
	.word ObjInit_DonutLift		; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjInit_BobOmb		; Object $55 - OBJ_BOBOMB
	.word ObjInit_PiranhaSidewaysL	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjInit_PiranhaSidewaysR	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjInit_FireChomp		; Object $58 - OBJ_FIRECHOMP
	.word ObjInit_FireSnake		; Object $59 - OBJ_FIRESNAKE
	.word ObjInit_Thwomp		; Object $5A - OBJ_THWOMP
	.word ObjInit_ThwompLRSlide	; Object $5B - OBJ_THWOMPLEFTSLIDE
	.word ObjInit_ThwompLRSlide	; Object $5C - OBJ_THWOMPRIGHTSLIDE
	.word ObjInit_ThwompUDSlide	; Object $5D - OBJ_THWOMPUPDOWN
	.word ObjInit_ThwompUDSlide	; Object $5E - OBJ_THWOMPDIAGONALUL
	.word ObjInit_ThwompUDSlide	; Object $5F - OBJ_THWOMPDIAGONALDL
	.word ObjInit_DoNothing		; Object $60 - OBJ_ICEBLOCK 
	.word ObjInit_BlooperWithKids	; Object $61 - OBJ_BLOOPERWITHKIDS
	.word ObjInit_Blooper		; Object $62 - OBJ_BLOOPER
	.word ObjInit_DoNothing	; Object $63
	.word ObjInit_CheepCheepHopper	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjInit_WaterCurrent	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjInit_WaterCurrent	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjInit_LavaLotus		; Object $67 - OBJ_LAVALOTUS
	.word ObjInit_Twirling		; Object $68 - OBJ_TWIRLINGBUZZY
	.word ObjInit_Twirling		; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjInit_BlooperWithKids	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.word ObjInit_PileDriver	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup02_NormalJumpTable:
	.word ObjNorm_DarknessCtl		; Object $48 - OBJ_DARKNESSCTL
	.word ObjNorm_FireSnake		; Object $49 - OBJ_ICESNAKE
	.word ObjNorm_BoomBoomQBall	; Object $4A - OBJ_BOOMBOOMQBALL
	.word ObjNorm_BoomBoom		; Object $4B - OBJ_BOOMBOOMJUMP
	.word ObjNorm_BoomBoom		; Object $4C - OBJ_BOOMBOOMFLY
	.word ObjNorm_DoNothing		; Object $4D
	.word ObjNorm_Birdo		; Object $4E - OBJ_BOSSBIRDO
	.word ObjNorm_DoNothing	; Object $4F
	.word ObjNorm_BobOmb		; Object $50 - OBJ_BOBOMBEXPLODE
	.word ObjNorm_BooLoop		; Object $51 - OBJ_BOOLOOP
	.word ObjNorm_TreasureBox	; Object $52 - OBJ_TREASUREBOX
	.word ObjNorm_PodobooCeiling	; Object $53 - OBJ_PODOBOOCEILING
	.word ObjNorm_DonutLift		; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjNorm_BobOmb		; Object $55 - OBJ_BOBOMB
	.word ObjNorm_PiranhaSideways	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjNorm_PiranhaSideways	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjNorm_FireChomp		; Object $58 - OBJ_FIRECHOMP
	.word ObjNorm_FireSnake		; Object $59 - OBJ_FIRESNAKE
	.word ObjNorm_Thwomp		; Object $5A - OBJ_THWOMP
	.word ObjNorm_ThwompLRSlide	; Object $5B - OBJ_THWOMPLEFTSLIDE
	.word ObjNorm_ThwompLRSlide	; Object $5C - OBJ_THWOMPRIGHTSLIDE
	.word ObjNorm_ThwompVertical	; Object $5D - OBJ_THWOMPUPDOWN
	.word ObjNorm_ThwompVertical	; Object $5E - OBJ_THWOMPDIAGONALUL
	.word ObjNorm_ThwompVertical	; Object $5F - OBJ_THWOMPDIAGONALDL
	.word ObjNorm_IceBlock		; Object $60 - OBJ_ICEBLOCK
	.word ObjNorm_Blooper		; Object $61 - OBJ_BLOOPERWITHKIDS
	.word ObjNorm_Blooper		; Object $62 - OBJ_BLOOPER
	.word ObjNorm_DoNothing	; Object $63
	.word ObjNorm_CheepCheepHopper	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjNorm_WaterCurrent	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjNorm_WaterCurrent	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjNorm_LavaLotus		; Object $67 - OBJ_LAVALOTUS
	.word ObjNorm_TwirlingShell	; Object $68 - OBJ_TWIRLINGBUZZY
	.word ObjNorm_TwirlingShell	; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjNorm_Blooper		; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.word ObjNorm_PileDriver	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup02_CollideJumpTable:
	.word ObjHit_DoNothing	; Object $48 - OBJ_DARKNESSCTL
	.word ObjHit_DoNothing	; Object $49 - OBJ_ICESNAKE
	.word ObjHit_DoNothing	; Object $4A - OBJ_BOOMBOOMQBALL
	.word ObjHit_DoNothing	; Object $4B - OBJ_BOOMBOOMJUMP
	.word ObjHit_DoNothing	; Object $4C - OBJ_BOOMBOOMFLY
	.word ObjHit_DoNothing	; Object $4D
	.word ObjHit_DoNothing	; Object $4E - OBJ_BOSSBIRDO
	.word ObjHit_DoNothing	; Object $4F
	.word ObjHit_DoNothing	; Object $50 - OBJ_BOBOMBEXPLODE
	.word ObjHit_DoNothing	; Object $51 - OBJ_BOOLOOP
	.word ObjHit_DoNothing	; Object $52 - OBJ_TREASUREBOX
	.word ObjHit_DoNothing	; Object $53 - OBJ_PODOBOOCEILING
	.word ObjHit_DoNothing	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjHit_DoNothing	; Object $55 - OBJ_BOBOMB
	.word ObjHit_DoNothing	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjHit_DoNothing	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjHit_DoNothing	; Object $58 - OBJ_FIRECHOMP
	.word ObjHit_DoNothing	; Object $59 - OBJ_FIRESNAKE
	.word $0000		; Object $5A - OBJ_THWOMP
	.word $0000		; Object $5B - OBJ_THWOMPLEFTSLIDE
	.word $0000		; Object $5C - OBJ_THWOMPRIGHTSLIDE
	.word $0000		; Object $5D - OBJ_THWOMPUPDOWN
	.word $0000		; Object $5E - OBJ_THWOMPDIAGONALUL
	.word $0000		; Object $5F - OBJ_THWOMPDIAGONALDL
	.word ObjHit_DoNothing	; Object $60 - OBJ_ICEBLOCK
	.word ObjHit_DoNothing	; Object $61 - OBJ_BLOOPERWITHKIDS
	.word ObjHit_DoNothing	; Object $62 - OBJ_BLOOPER
	.word ObjHit_DoNothing	; Object $63
	.word ObjHit_DoNothing	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjHit_DoNothing	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjHit_DoNothing	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjHit_DoNothing	; Object $67 - OBJ_LAVALOTUS
	.word OCSPECIAL_KILLCHANGETO | OBJ_BUZZYBEATLE	; Object $68 - OBJ_TWIRLINGBUZZY
	.word OCSPECIAL_KILLCHANGETO | OBJ_SPINY	; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjHit_DoNothing	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.word ObjHit_DoNothing	; Object $6B - OBJ_PILEDRIVER

	
	; Object group $02 (i.e. objects starting at ID $48) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup02_Attributes:
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $48 - OBJ_DARKNESSCTL
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $49 - OBJ_ICESNAKE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $4C - OBJ_BOOMBOOMFLY
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $4D
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $4E - OBJ_BOSSBIRDO
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4F
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $51 - OBJ_BOOLOOP
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $52 - OBJ_TREASUREBOX
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $53 - OBJ_PODOBOOCEILING
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $55 - OBJ_BOBOMB
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $58 - OBJ_FIRECHOMP
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $59 - OBJ_FIRESNAKE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $5A - OBJ_THWOMP
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $5B - OBJ_THWOMPLEFTSLIDE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $5C - OBJ_THWOMPRIGHTSLIDE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $5D - OBJ_THWOMPUPDOWN
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $5E - OBJ_THWOMPDIAGONALUL
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $5F - OBJ_THWOMPDIAGONALDL
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $60 - OBJ_ICEBLOCK
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $62 - OBJ_BLOOPER
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $63
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $67 - OBJ_LAVALOTUS
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $6B - OBJ_PILEDRIVER

	; Object group $02 (i.e. objects starting at ID $48) second set attribute bits

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup02_Attributes2:
	.byte OA2_TDOGRP1	; Object $48 - OBJ_DARKNESSCTL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $49 - OBJ_ICESNAKE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP2	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP2	; Object $4C - OBJ_BOOMBOOMFLY
	.byte OA2_TDOGRP0	; Object $4D
	.byte OA2_TDOGRP2	; Object $4E - OBJ_BOSSBIRDO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $4F
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $51 - OBJ_BOOLOOP
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $52 - OBJ_TREASUREBOX
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $53 - OBJ_PODOBOOCEILING
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $55 - OBJ_BOBOMB
	.byte OA2_TDOGRP0	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA2_TDOGRP0	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $58 - OBJ_FIRECHOMP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $59 - OBJ_FIRESNAKE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $5A - OBJ_THWOMP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $5B - OBJ_THWOMPLEFTSLIDE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $5C - OBJ_THWOMPRIGHTSLIDE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $5D - OBJ_THWOMPUPDOWN
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $5E - OBJ_THWOMPDIAGONALUL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $5F - OBJ_THWOMPDIAGONALDL
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $60 - OBJ_ICEBLOCK
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $62 - OBJ_BLOOPER
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $63
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA2_TDOGRP0	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA2_TDOGRP0	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA2_TDOGRP0	; Object $67 - OBJ_LAVALOTUS
	.byte OA2_TDOGRP1	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA2_TDOGRP1	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup02_Attributes3:
	.byte OA3_HALT_DONOTHING | OA3_TAILATKIMMUNE 	; Object $48 - OBJ_DARKNESSCTL
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE	; Object $49 - OBJ_ICESNAKE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4C - OBJ_BOOMBOOMFLY
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $4D
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $4E - OBJ_BOSSBIRDO
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $4F
	.byte OA3_HALT_NORMALONLY 	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $51 - OBJ_BOOLOOP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $52 - OBJ_TREASUREBOX
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $53 - OBJ_PODOBOOCEILING
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA3_HALT_NORMALONLY 	; Object $55 - OBJ_BOBOMB
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA3_HALT_NORMALONLY 	; Object $58 - OBJ_FIRECHOMP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $59 - OBJ_FIRESNAKE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $5A - OBJ_THWOMP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $5B - OBJ_THWOMPLEFTSLIDE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $5C - OBJ_THWOMPRIGHTSLIDE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $5D - OBJ_THWOMPUPDOWN
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $5E - OBJ_THWOMPDIAGONALUL
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $5F - OBJ_THWOMPDIAGONALDL
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $60 - OBJ_ICEBLOCK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $62 - OBJ_BLOOPER
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $63
	.byte OA3_HALT_NORMALONLY 	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $67 - OBJ_LAVALOTUS
	.byte OA3_HALT_NORMALONLY 	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte OA3_HALT_NORMALONLY 	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup02_PatTableSel:
	.byte OPTS_NOCHANGE	; Object $48 - OBJ_DARKNESSCTL
	.byte OPTS_SETPT5 | $0E	; Object $49 - OBJ_ICESNAKE
	.byte OPTS_SETPT5 | $13	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte OPTS_SETPT6 | $33	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte OPTS_SETPT6 | $33	; Object $4C - OBJ_BOOMBOOMFLY
	.byte OPTS_NOCHANGE	; Object $4D
	.byte OPTS_NOCHANGE	; Object $4E - OBJ_BOSSBIRDO (SB: Done manually in ObjInit_Birdo)
	.byte OPTS_SETPT5 | $0A	; Object $4F
	.byte OPTS_SETPT5 | $36	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OPTS_SETPT5 | $12	; Object $51 - OBJ_BOOLOOP
	.byte OPTS_SETPT5 | $05	; Object $52 - OBJ_TREASUREBOX
	.byte OPTS_SETPT5 | $12	; Object $53 - OBJ_PODOBOOCEILING
	.byte OPTS_NOCHANGE	; Object $54 - OBJ_DONUTLIFTSHAKEFALL (SB: Done manually in ObjNorm_DonutLift)
	.byte OPTS_SETPT5 | $0B	; Object $55 - OBJ_BOBOMB
	.byte OPTS_SETPT5 | $5A	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OPTS_SETPT5 | $5A	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OPTS_SETPT5 | $0E	; Object $58 - OBJ_FIRECHOMP
	.byte OPTS_SETPT5 | $0E	; Object $59 - OBJ_FIRESNAKE
	.byte OPTS_NOCHANGE	; Object $5A - OBJ_THWOMP (SB: Done manually in ObjNorm_Thwomp)
	.byte OPTS_SETPT5 | $12	; Object $5B - OBJ_THWOMPLEFTSLIDE
	.byte OPTS_SETPT5 | $12	; Object $5C - OBJ_THWOMPRIGHTSLIDE
	.byte OPTS_SETPT5 | $12	; Object $5D - OBJ_THWOMPUPDOWN
	.byte OPTS_SETPT5 | $12	; Object $5E - OBJ_THWOMPDIAGONALUL
	.byte OPTS_SETPT5 | $12	; Object $5F - OBJ_THWOMPDIAGONALDL
	.byte OPTS_SETPT6 | $4F	; Object $60 - OBJ_ICEBLOCK
	.byte OPTS_SETPT5 | $1A	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OPTS_SETPT5 | $1A	; Object $62 - OBJ_BLOOPER
	.byte OPTS_SETPT5 | $1A	; Object $63
	.byte OPTS_SETPT6 | $4F	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OPTS_NOCHANGE	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OPTS_NOCHANGE	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OPTS_SETPT6 | $1B	; Object $67 - OBJ_LAVALOTUS
	.byte OPTS_SETPT5 | $0B	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OPTS_SETPT5 | $0B	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OPTS_SETPT5 | $1A	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte OPTS_SETPT6 | $4F	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) "Kill Action"
	; Determines what action is taken when object is in "Killed" state (6)
	; See Object_DoKillAction for the jump table
	; NOTE: Any action type other than zero always sets the frame to 2 (unless object is not general purpose, i.e. index >= 5)

	.org ObjectGroup_Attributes4	; <-- help enforce this table *here*
ObjectGroup02_Attributes4:
	.byte OA4_KA_JUSTDRAW16X16	; Object $48 - OBJ_DARKNESSCTL
	.byte OA4_KA_NORMALSTATE	; Object $49 - OBJ_ICESNAKE
	.byte OA4_KA_STANDARD	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte OA4_KA_NORMALANDKILLED	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte OA4_KA_NORMALANDKILLED	; Object $4C - OBJ_BOOMBOOMFLY
	.byte OA4_KA_STANDARD	; Object $4D
	.byte OA4_KA_NORMALANDKILLED	; Object $4E - OBJ_BOSSBIRDO
	.byte OA4_KA_NORMALANDKILLED	; Object $4F
	.byte OA4_KA_JUSTDRAW16X16	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OA4_KA_STANDARD	; Object $51 - OBJ_BOOLOOP
	.byte OA4_KA_STANDARD	; Object $52 - OBJ_TREASUREBOX
	.byte OA4_KA_JUSTDRAWMIRROR | OA4_POOFFROZEN	; Object $53 - OBJ_PODOBOOCEILING
	.byte OA4_KA_STANDARD	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA4_KA_JUSTDRAW16X16	; Object $55 - OBJ_BOBOMB
	.byte OA4_KA_POOFDEATH | OA4_FROZENCANTKICK	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA4_KA_POOFDEATH | OA4_FROZENCANTKICK	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA4_KA_NORMALSTATE	; Object $58 - OBJ_FIRECHOMP
	.byte OA4_KA_NORMALSTATE	; Object $59 - OBJ_FIRESNAKE
	.byte OA4_KA_NORMALANDKILLED	; Object $5A - OBJ_THWOMP
	.byte OA4_KA_NORMALANDKILLED	; Object $5B - OBJ_THWOMPLEFTSLIDE
	.byte OA4_KA_NORMALANDKILLED	; Object $5C - OBJ_THWOMPRIGHTSLIDE
	.byte OA4_KA_NORMALANDKILLED	; Object $5D - OBJ_THWOMPUPDOWN
	.byte OA4_KA_NORMALANDKILLED	; Object $5E - OBJ_THWOMPDIAGONALUL
	.byte OA4_KA_NORMALANDKILLED	; Object $5F - OBJ_THWOMPDIAGONALDL
	.byte OA4_KA_NORMALSTATE	; Object $60 - OBJ_ICEBLOCK
	.byte OA4_KA_NORMALSTATE	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OA4_KA_JUSTDRAWMIRROR	; Object $62 - OBJ_BLOOPER
	.byte OA4_KA_NORMALANDKILLED	; Object $63
	.byte OA4_KA_JUSTDRAW16X16	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA4_KA_STANDARD	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA4_KA_STANDARD	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA4_KA_NORMALANDKILLED	; Object $67 - OBJ_LAVALOTUS
	.byte OA4_KA_JUSTDRAWMIRROR	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA4_KA_JUSTDRAWMIRROR	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA4_KA_NORMALSTATE	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte OA4_KA_NORMALSTATE	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) pattern index starts
	; These are used for all states except "normal"

OG2_POff .func (\1 - ObjectGroup02_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup02_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG2_POff(ObjP48), OG2_POff(ObjP49), OG2_POff(ObjP4A), OG2_POff(ObjP4B)
	.byte OG2_POff(ObjP4C), OG2_POff(ObjP4D), OG2_POff(ObjP4E), OG2_POff(ObjP4F)
	.byte OG2_POff(ObjP50), OG2_POff(ObjP51), OG2_POff(ObjP52), OG2_POff(ObjP53)
	.byte OG2_POff(ObjP54), OG2_POff(ObjP55), OG2_POff(ObjP56), OG2_POff(ObjP57)
	.byte OG2_POff(ObjP58), OG2_POff(ObjP59), OG2_POff(ObjP5A), OG2_POff(ObjP5B)
	.byte OG2_POff(ObjP5C), OG2_POff(ObjP5D), OG2_POff(ObjP5E), OG2_POff(ObjP5F)
	.byte OG2_POff(ObjP60), OG2_POff(ObjP61), OG2_POff(ObjP62), OG2_POff(ObjP63)
	.byte OG2_POff(ObjP64), OG2_POff(ObjP65), OG2_POff(ObjP66), OG2_POff(ObjP67)
	.byte OG2_POff(ObjP68), OG2_POff(ObjP69), OG2_POff(ObjP6A), OG2_POff(ObjP6B)


	; Object group $02 (i.e. objects starting at ID $48) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup02_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup02_PatternSets:
	; (End restricted alignment space)

ObjP4E: .byte $A1, $A3, $A5, $A7, $A9, $AB	; Birdo head
	.byte $B1, $B3, $B5, $B7		; Birdo feet
ObjP4D:
ObjP4F:
ObjP65:
ObjP66:
	.byte $91, $93, $9D, $9F, $9D, $9F
ObjP52:
	.byte $AB, $AD, $85, $85, $87, $87, $9D, $9F, $81, $81, $83, $83, $8B, $8B, $A9, $A9, $FF, $FF, $FF, $FF, $95, $97, $99, $9B
ObjP53:
	.byte $8D, $8D
ObjP6B:
	.byte $75, $75
ObjP68:
	.byte $95, $97, $91, $93, $A1, $A1
ObjP69:
	.byte $81, $83, $85, $87, $89, $89
ObjP54:
	.byte $91, $93, $91, $93
ObjP55:
	.byte $B1, $B3, $B5, $B7, $A7, $B9, $A7, $B9
ObjP50:
	.byte $9D, $BF, $BB, $BD, $BB, $BD, $BB, $BD
ObjP4A:
	.byte $BD, $BF
ObjP48:
	.byte $93, $95, $93, $97, $93, $97
ObjP4B:
ObjP4C:
	.byte $C1, $C1, $CF, $CD, $C1, $C1, $C5, $C7, $C1, $C1, $CF, $CD, $C1, $C1, $C5, $C7, $C1, $C1, $CF, $CD, $C1, $C1, $C5, $C7, $D3, $D3, $ED, $ED, $D9, $D9, $DD, $DD, $71, $71, $E7, $E9, $71, $71, $E9, $E7, $C1, $C1, $C7, $C7, $C1, $C1, $C5, $C5, $81, $81, $85, $87, $81, $81, $8D, $8F, $89, $89, $91, $93, $81, $81, $87, $85, $81, $81, $8F, $8D, $89, $89, $93, $91, $71, $71, $AD, $99, $71, $71, $9D, $9F, $A1, $A1, $A5, $A5, $A7, $A7, $AB, $AB
ObjP56:
ObjP57:
	.byte $81, $83, $87, $89
ObjP67:
	.byte $C1, $C5, $C3, $C7, $C9, $CD, $CB, $CF, $D1, $D5, $D3, $E7
ObjP58:
	.byte $AF, $AF, $99, $9B, $95, $97
ObjP49:
ObjP59:
	.byte $A1, $A3, $A5, $A7, $A5, $A7
ObjP51:	.byte $95, $97, $B9, $BF
ObjP60:
ObjP61:
ObjP62:
ObjP6A:
	.byte $B1, $B1, $B3, $B3, $B1, $B1
ObjP63:
	.byte $81, $83, $8D, $A1, $81, $83, $87, $89, $81, $83, $87, $89
ObjP64:
	.byte $E7, $E9, $E7, $EF, $E7, $EF
ObjP5A:
ObjP5B:
ObjP5C:
ObjP5D:
ObjP5E:
ObjP5F:
	.byte $B1, $B3, $BB, $BD, $B1, $B3, $BB, $BD, $B1, $B3, $BB, $BD


ObjNorm_IceBlock:

	; This may seem confusing, but an Ice Block is in held state when grabbed,
	; shelled state when kicked, and just comes here to get busted...

	LDA #$03	 ; A = 3
	JMP PRG003_A4DD	 ; Jump to PRG003_A4DD

ToadItem_PalPerItem:
	.byte $30	; 0: INVALID
	.byte $16	; 1: Mushroom
	.byte $2A	; 2: Fire flower
	.byte $2A	; 3: Leaf
	.byte $2A	; 4: Penguin
	.byte $17	; 5: Rabbit
	.byte $2A	; 6: Hammer
	.byte $36	; 7: Star
	.byte $27	; 8: Key
	.byte $30	; 9: ---
	.byte $07	; A: Star Coin
	
ObjInit_TreasureBox:
	LDA Level_TreasureItem	 
	STA <Objects_Var5,X	; Var5 = what item we're gonna get
	TAY		 ; -> 'Y'

	LDA ToadItem_PalPerItem,Y
	STA Palette_Buffer+$1A
	LDA #$30
	STA Palette_Buffer+$19
	LDA #$0f
	STA Palette_Buffer+$1B

	; Update the palette!
	LDA #$06
	STA Graphics_Queue

	; Timer = $1F (ticks until appearance)
	LDA #$1f
	STA Objects_Timer,X

	RTS		 ; Return

TBoxItem_MirrorFlags:
	.byte $00, $81, $82, $03, $80, $81, $82, $83, $00, $81, $02, $03, $00, $01

ObjNorm_TreasureBox:
	LDA Objects_Timer,X
	BEQ PRG003_A2DB	 ; If timer has expired, jump to PRG003_A2DB

	CMP #$18
	BNE PRG003_A2DA	; If timer <> $18, jump to PRG003_A2DA (RTS)

	; Treasure box appear sound 
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1

	JSR TreasureBox_Poof	 ; "Poof" and it appears!

PRG003_A2DA:
	RTS		 ; Return

PRG003_A2DB:
	LDA <Objects_Var4,X
	BNE PRG003_A300	 ; If Var4 is non-zero (box is now the rising power up), jump to PRG003_A300

	JSR Object_DoMoveBounceConveyor	 ; Treasure box will bounce when it falls or even get carried by conveyors

	JSR Object_HitTest	 ; Check if Player has touched the box yet
	BCC PRG003_A2F8	 	; If Player has not yet touched box, jump to PRG003_A2F8

	; Powerup rising sound
	LDA #SND_LEVELRISE
	STA Sound_QLevel1

	; Stop the clock
	STA Level_TimerEn

	; Var4++ (box is now a rising power up)
	INC <Objects_Var4,X

	; Item Y velocity
	LDA #-$30
	STA <Objects_YVel,X

	JSR TreasureBox_Poof	 ; Do another poof on opening

PRG003_A2F8:
	LDA #$00
	STA Objects_Frame,X
	JMP Object_ShakeAndDraw	 ; Just draw treasure box and don't come back

PRG003_A300:
	LDA Objects_Timer2,X
	BEQ PRG003_A30E	 ; If timer 2 is expired, jump to PRG003_A30E

	CMP #$01
	BEQ PRG003_A321	 ; If timer 2 has one tick left, jump to PRG003_A321

	; Otherwise...
	AND #%00001100
	BNE PRG003_A33A	 ; 12 ticks on, 12 ticks off; jump to PRG003_A33A

	RTS		 ; Return

PRG003_A30E:

	; Timer 2 expired
	JSR Object_CalcSpriteXY_NoHi
	LDA <Objects_SpriteY,X
	CMP #-16
	BLT TBoxItem_NotTooHigh

	LDA #0
	STA <Objects_YVel,X
	
	LDA <Vert_Scroll
	ADD #8
	STA <Objects_Y,X
	LDA <Vert_Scroll_Hi
	ADC #0
	STA <Objects_YHi,X

TBoxItem_NotTooHigh:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	INC <Objects_YVel,X
	BMI PRG003_A33A	 ; If Y velocity is still negative, jump to PRG003_A33A

	; Item has slowed to apex...

	; Set timer 2 to $70
	LDA #$70
	STA Objects_Timer2,X

	; "You got it" sound
	LDA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

	BNE PRG003_A33A	 ; Jump (technically always) to PRG003_A33A

PRG003_A321:

	; Timer 2 has one tick left

	; Give Player the treasure item
	LDA Level_TreasureItem
	CMP #10
	BEQ TreasureBox_NoGive	; We don't give a star coin
	
	SUB #1
	JSR Player_GetItem

TreasureBox_NoGive:
	LDX <SlotIndexBackup		 ; X = object slot index

	; ?? This is the "full power" ringing noise, and really can't be heard this way
	;LDA Sound_QPlayer
	;ORA #SND_PLAYERPOWER
	;STA Sound_QPlayer

	JSR Object_SetDeadEmpty	 ; Destroy the treasure box object

	; Countdown until exit
	;LDA #$60
	;STA LevelEvent_Cnt

	;RTS		 ; Return
			
TBox_StillVictone:
	LDA SndCur_Music1
	BNE TBox_StillVictone
	
	JMP ExitLevel_InvalidateCP

PRG003_A33A:

	; Timer 2 has time yet... or Y velocity is still negative...

	LDA Level_TreasureItem
	TAY
	STA Objects_Frame,X	 ; Item -> Frame

	LDA #SPR_PAL2
	CPY #10
	BNE TreasureBox_Attr2

	; Set sprite attribute
	LDA #SPR_PAL3

TreasureBox_Attr2:
	STA Objects_SprAttr,X

	LDA TBoxItem_MirrorFlags,Y
	BPL PRG003_A34E	 ; If bit 7 not set, jump to PRG003_A34E

	JMP Object_ShakeAndDrawMirrored	 ; Draw treasure box item mirrored

PRG003_A34E:
	JMP Object_ShakeAndDraw	 ; Draw treasure box item without mirroring


TreasureBox_Poof:
	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot or don't come back here!

	; The "poof" from when it appears	 
	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y

	; Set the poof where the box will be
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	; Set the "poof" counter
	LDA #$1f
	STA SpecialObj_Data,Y

	RTS		 ; Return

ObjInit_PodobooCeiling:

	; Store original Y/Hi into Var5/Var4
	LDA <Objects_Y,X
	STA <Objects_Var5,X
	LDA <Objects_YHi,X
	STA <Objects_Var4,X

	RTS		 ; Return

ObjNorm_PodobooCeiling:
	LDA Objects_Timer,X
	BEQ PRG003_A387	 ; If timer expired, jump to PRG003_A387

	STA Objects_SprHVis,X	 ; Set horizontal off-scren bits (a stupid way of preventing drawing?)

	LSR A
	BNE PRG003_A386	 ; If timer > 1, jump to PRG003_A386 (RTS)

	; Propel downwards
	LDA #$58
	STA <Objects_YVel,X

PRG003_A386:
	RTS		 ; Return

PRG003_A387:
	LDA <Player_HaltGame
	BNE PRG003_A3D5	 ; If gameplay halted, jump to PRG003_A3D5

	JSR Player_HitEnemy	 ; Handle Player collision with Podoboo

	; Flip vertically based on velocity
	LDA <Objects_YVel,X
	EOR #SPR_VFLIP
	AND #SPR_VFLIP
	STA Objects_FlipBits,X

	LDA <Counter_1
	AND #$03
	BNE PRG003_A3AA	 ; Proceed 1:4 ticks, otherwise jump to PRG003_A3AA

	; Frame loop 0-2
	INC Objects_Frame,X
	LDY Objects_Frame,X
	CPY #$03
	BNE PRG003_A3AA

	STA Objects_Frame,X	; Zero the frame

PRG003_A3AA:
	LDA <Objects_YVel,X
	BPL PRG003_A3C2	 ; If Podoboo is moving downward, jump to PRG003_A3C2

	LDA <Objects_Y,X
	CMP <Objects_Var5,X

	LDA <Objects_YHi,X
	SBC <Objects_Var4,X
	BCS PRG003_A3C2	 ; If Podoboo has not returned to origin, jump to PRG003_A3C2

	; Podoboo went back to where he came from; reload timer with random value $40-$7F
	LDA RandomN,X
	AND #$3f
	ORA #$40
	STA Objects_Timer,X

PRG003_A3C2:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	BPL PRG003_A3CD	 ; If Podoboo is moving downward, jump to PRG003_A3CD

	CMP #-$6F
	BLT PRG003_A3D2	 ; If Podoboo is not moving upward faster than -$6F, jump to PRG003_A3D2

PRG003_A3CD:
	SUB #$02		; Accelerate Podoboo
	STA <Objects_YVel,X	; Update Y velocity

PRG003_A3D2:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

PRG003_A3D5:
	JMP Object_ShakeAndDrawMirrored	 ; Draw Podoboo and don't come back!

ObjInit_PileDriver: 
	RTS		 ; Return


PileDriver_TowardsPlayerXVel:	.byte $10, -$10

	; Runs compare against object's state to see if it's state 2 (Normal)
Object_CheckIfNormalState:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	RTS		 ; Return


ObjNorm_PileDriver
	JSR Object_CheckIfNormalState
	BEQ PRG003_A3E9	 ; If in normal state, jump to PRG003_A3E9

	JMP BrickBust_MicroGoomba	 ; Bust out the Micro Goomba

PRG003_A3E9:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Player_HaltGame
	BEQ PRG003_A3F3	 ; If gameplay halted, jump to PRG003_A3F3

	JMP PRG003_A47A	 ; Jump to PRG003_A47A

PRG003_A3F3:
	LDA <Objects_Var5,X
	BEQ PRG003_A40F	 ; If Var5 = 0, jump to PRG003_A40F

	DEC <Objects_Var5,X	 ; Var5--

	BNE PRG003_A424	 ; If Var5 <> 0, jump to PRG003_A424

	; Piledriver jumps!
	LDA #-$60
	STA <Objects_YVel,X

	; Timer set to $70
	LDA #$70
	STA Objects_Timer,X

	JSR Level_ObjCalcXDiffs

	; Jump towards Player
	LDA PileDriver_TowardsPlayerXVel,Y
	STA <Objects_XVel,X

	JMP PRG003_A424	 ; Jump to PRG003_A424

PRG003_A40F:
	LDA Objects_Timer,X
	BNE PRG003_A424		; If timer not expired, jump to PRG003_A424

	JSR Level_ObjCalcXDiffs

	LDA <Temp_Var16
	ADD #$30
	CMP #$60
	BGE PRG003_A424	 ; If Player is not close enough, jump to PRG003_A424

	; Var5 = $28
	LDA #$28
	STA <Objects_Var5,X

PRG003_A424:
	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	BMI PRG003_A434	 ; If Piledriver is moving upward, jump to PRG003_A434

	CMP #$70
	BGE PRG003_A446	 ; If Piledriver is falling at or faster $70, jump to PRG003_A446
	BLT PRG003_A437	 ; Otherwise, jump to PRG003_A437

PRG003_A434:
	JSR Negate	 ; Negate the velocity value (absolute value)

PRG003_A437:
	LSR A
	LSR A		; Divide current velocity by 4
 
	; I'm not sure what this check is for?  The Y velocity will never be
	; negative because of the PRG003_A434 Negate, so maybe this is in error?
	LDY <Objects_YVel,X
	BPL PRG003_A43F	 ; If Piledriver is moving upward, jump to PRG003_A43F

	; Probably unreachable?
	LSR A
	LSR A

PRG003_A43F:
	ADD #$01		; +1 to divided Y velocity
	ADC <Objects_YVel,X
	STA <Objects_YVel,X	; Update Y velocity

PRG003_A446:
	JSR Object_WorldDetectN1	 ; Detect world

	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped underneath

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG003_A456	 ; If Piledriver hit ceiling, jump to PRG003_A456

	; Bounce off ceiling
	LDA #$01
	STA <Objects_YVel,X

PRG003_A456:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_A471	 ; If Piledriver hits ground, jump to PRG003_A471

	LDA <Objects_YVel,X
	CMP #$20
	BLT PRG003_A46A	 ; If Piledriver is not moving at least $20, jump to PRG003_A46A

	; Wa-bam! Landing sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

PRG003_A46A:
	JSR Object_HitGround	 ; Align Piledriver to ground

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG003_A471:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG003_A47A	 ; If Piledriver has hit a wall, jump to PRG003_A47A

	JSR Object_AboutFace	 ; Turn around

PRG003_A47A:
	JSR Object_ShakeAndDrawMirrored	 ; Draw the Piledriver

	; Add little Microgoomba sticking out the bottom
	LDA Sprite_RAM+$00,Y
	SUB #$01
	STA Sprite_RAM+$00,Y
	LDA Sprite_RAM+$04,Y
	SBC #$01
	STA Sprite_RAM+$04,Y

	JSR Object_AnySprOffscreen
	BNE PRG003_A4DA	 ; If any of Piledriver's sprites are off-screen, jump to PRG003_A4DA

	LDA <Objects_YVel,X
	ASL A		; Sets carry if negative

	LDA #$02	 ; A = 2
	BCS PRG003_A4A1	 ; If Piledriver is moving upward, jump to PRG003_A4A1

	LDA <Objects_Var5,X
	BEQ PRG003_A4DA	 ; If Var5 = 0, jump to PRG003_A4DA

	LSR A
	LSR A
	LSR A	; A = Var5 / 8

PRG003_A4A1:
	TAX		 ; -> 'X'

	; Set Y offset
	LDA Sprite_RAM+$00,Y
	SUB Piledriver_YOff,X
	STA Sprite_RAM+$00,Y
	LDA Sprite_RAM+$04,Y
	SUB Piledriver_YOff,X
	STA Sprite_RAM+$04,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$08,Y

	; NOTE: This sprite is not visible... I suspect this may originally
	; not have been the microgoomba, but a regular goomba, hence the
	; timed toggled horizontal flip to do his "walking" animation...
	;;;;;;;;;;;;;;;;;;

	LDA <Objects_SpriteX,X
	ADD #$04
	STA Sprite_RAM+$0B,Y

	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	LSR A

	LDA #SPR_PAL3	 ; palette selected 3
	BCC PRG003_A4D2	 ; 16 ticks on, 16 ticks off; jump to PRG003_A4D2

	LDA #(SPR_HFLIP | SPR_PAL3)	 ; horizontal flip, palette select 3

PRG003_A4D2:
	STA Sprite_RAM+$0A,Y	 ; Set attribute

	; Pattern $FF (not visible)
	LDA #$ff
	STA Sprite_RAM+$09,Y

	;;;;;;;;;;;;;;;;;;

PRG003_A4DA:
	RTS		 ; Return


BrickBust_MicroGoomba:
	LDA #$04	 ; A = 4 (the Microgoomba that falls out of a Piledriver)

PRG003_A4DD:
	STA <Temp_Var16	 ; Input value -> Temp_Var16

	; Crumbling brick sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR Object_SetDeadEmpty	; Destroy the Ice Block

	; Break apart into the four brick bust pieces
PRG003_A4EA:
	JSR BustBlock_Segment 	; Generate Ice block segment

	DEC <Temp_Var16		; Temp_Var16--
	BPL PRG003_A4EA		; While Temp_Var16 >= 0, loop!

	RTS		 ; Return

Piledriver_YOff:	.byte $01, $00, $02, $04, $05, $02

	; "Bust block" is an ice block that smashed into wall or a Microgoomba brick getting busted
	; First four are the brick bits, the last is the microgoomba
BustBlock_YOffByInput:	.byte -$04, -$04, $04, $04, $00
BustBlock_YHiOffByInput:	.byte  $FF,  $FF, $00, $00, $00
PRG003_A502:	.byte $00, $08, $00, $08, $04
BustBlock_YVelByInput:	.byte $C0, $C0, $D0, $D0, $D0
BustBlock_XVelByInput:	.byte $F8, $08, $F8, $08, $00 

	; Generates a segment of the busted brick (or microgoomba in the case of the Piledriver)
BustBlock_Segment:
	LDY #$07	 ; Y = 7 (wider expanse of special object slots)

	JSR SpecialObj_FindEmptyAbortY	 ; Find an empty special object slot or don't come back here...

	; Temp_Var1 = Ice Block's Y
	LDA <Objects_Y,X
	STA <Temp_Var1

	; Temp_Var3 = Ice Block's Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var3

	; Temp_Var2 = Ice Block's X
	LDA <Objects_X,X
	STA <Temp_Var2

	; X = Temp_Var16 (input value for Ice Block)
	LDX <Temp_Var16

	; Add Y offset by input
	LDA <Temp_Var1
	ADD BustBlock_YOffByInput,X
	STA SpecialObj_YLo,Y
	LDA <Temp_Var3
	ADC BustBlock_YHiOffByInput,X
	STA SpecialObj_YHi,Y

	; X Lo = Temp_Var2
	LDA <Temp_Var2
	STA SpecialObj_XLo,Y

	; Set Ice Block Y Velocity by input
	LDA BustBlock_YVelByInput,X
	STA SpecialObj_YVel,Y

	; Set Ice Block X Velocity by input
	LDA BustBlock_XVelByInput,X
	STA SpecialObj_XVel,Y

	LDA #SOBJ_BRICKDEBRIS	 ; Busting brick, input value 4 only
 
	CPX #$04	 ; X = 4
	BNE PRG003_A54E	 ; If input value <> 4, jump to PRG003_A54E

	LDA #SOBJ_MICROGOOMBA	 ; Otherwise, micro Goomba

PRG003_A54E:
	STA SpecialObj_ID,Y	 ; Set appropriate ID

	LDA #$ff
	STA SpecialObj_Data,Y
	STA SpecialObj_Timer,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X
	CMP #OBJ_ICEBLOCK
	BEQ PRG003_A567	 ; If this is an Ice Block, jump to PRG003_A567

	LDA #$00
	STA SpecialObj_Timer,Y

PRG003_A567:
	RTS		 ; Return

Twirler_InitXVel:	.byte $08, -$08

ObjInit_Twirling:
	JSR Level_ObjCalcXDiffs

	; Set twirler X velocity towards Player
	LDA Twirler_InitXVel,Y
	STA <Objects_XVel,X

	; Set vertically flipped
	LDA #SPR_VFLIP
	STA Objects_FlipBits,X

	DEC <Objects_Y,X	 ; Start one pixel higher

	LDY <Objects_Y,X
	INY	
	BNE PRG003_A580
	DEC <Objects_YHi,X	 ; Apply carry
PRG003_A580:

	RTS		 ; Return


ObjNorm_TwirlingShell:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JSR TwirlShell_Draw	 	; Draw the twirling shell enemy

	LDA <Player_HaltGame
	BNE PRG003_A5EF	 ; If gameplay halted, jump to PRG003_A5EF

	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped from underneath

	LDA Level_ObjectID,X
	CMP #OBJ_BUZZYBEATLE
	BNE PRG003_A59A	 ; If object has not become a Buzzle Beatle, jump to PRG003_A59A

	JMP Object_SetShellState ; Set shell state and don't come back!

PRG003_A59A:
	LDY #$00	 ; Y = 0

	LDA <Counter_1
	AND #$08
	BEQ PRG003_A5A3	 ; 8 ticks on, 8 ticks off; jump to PRG003_A5A3

	INY		 ; Y = 1

PRG003_A5A3:
	TYA
	STA Objects_Frame,X	 ; Toggle frame 0/1

	JSR Object_ApplyXVel	 ; Apply X velocity

	; Maintain Y Velocity = -$01 (sticks to ceiling)
	LDA #-$01
	STA <Objects_YVel,X

	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$08
	BNE PRG003_A5CA	 ; If still detecting ceiling, jump to PRG003_A5CA

	; No more ceiling!

	INC Objects_Var7,X	 ; Var7++

	LDA Objects_Var7,X
	CMP #$02
	BGE PRG003_A5DB	 	; If Var7 >= 2, jump to PRG003_A5DB

	JSR Object_AboutFace	; Turn around
	JSR Object_ApplyXVel	; Apply X velocity
	JMP PRG003_A5CF		; Jump to PRG003_A5CF

PRG003_A5CA:
	; Var7 = 0
	LDA #$00
	STA Objects_Var7,X

PRG003_A5CF:
	JSR Level_ObjCalcXDiffs	

	LDA <Temp_Var16
	ADD #$30
	CMP #$60
	BGE PRG003_A5EF	 ; If Player is not close enough, jump to PRG003_A5EF

PRG003_A5DB:

	; Go into "kicked" state!
	LDA #OBJSTATE_KICKED
	STA Objects_State,X

	LDA ObjGroupRel_Idx
	ASL A		; 2 byte index for ObjectGroup02_CollideJumpTable
	TAY		; Y = offset into ObjectGroup_CollideJumpTable

	LDA ObjectGroup02_CollideJumpTable,Y
	STA Level_ObjectID,X	 ; Change into the appropriate target object

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG003_A5EF:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG003_A5F8	 ; If object has not hit a wall, jump to PRG003_A5F8

	JSR Object_AboutFace	 ; Otherwise, turn around...

PRG003_A5F8:
	RTS		 ; Return

TwirlShell_Draw:
	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

	LDA Objects_Frame,X
	CMP #$02
	BLT PRG003_A613	 ; If frame < 2, jump to PRG003_A613

	; Clear horizontal flip on frame 2+
	LDA Objects_FlipBits,X
	AND #~SPR_HFLIP
	STA Objects_FlipBits,X

PRG003_A613:
	JMP Object_ShakeAndDraw	 ; Draw shelled enemy and don't come back!

ObjInit_DonutLift: 
	RTS		 ; Return

ObjNorm_DonutLift:
	; Hack: "PatTableSel" cannot support a bank value over 127, so must do so manually

	LDA PatTable_BankSel+4
	CMP #134
	BEQ PRG003_A62D	; If SMB2 sprites are active, jump to PRG003_A62D
	CMP #31
	BEQ PRG003_A62D	; If fence enemy sprites are active, jump to PRG003_A62D

	JSR Object_SetPaletteFromAttr	 ; Set palette

	LDY #$5a	 ; Y = $5A (Patterns for donut lift, vertical only)

	LDA Level_7Vertical
	BNE PRG003_A62A	 ; If this level is vertical, jump to PRG003_A62A

	LDA Level_TilesetIdx
	CMP #$0E
	BEQ DonutLift_12
	CMP #$01
	BNE PRG003_A62D	 ; If tileset is not Mini-Fortress style, jump to PRG003_A62D

DonutLift_12:
	LDY #$12	 ; Y = $12 (Patterns for donut lift, Mini-Fortress only)

PRG003_A62A:

	; Mini-Fortress or vertical orientation only...

	STY PatTable_BankSel+4

PRG003_A62D:
	JSR Object_AnySprOffscreen
	BNE PRG003_A64E	 ; If object falls off-screen at all, jump to PRG003_A64E (destroys it)

	JSR Object_ShakeAndDraw		; Draw donut lift

	LDA <Player_HaltGame
	BNE PRG003_A651	 ; If gameplay is halted, jump to PRG003_A651 (RTS)

	LDA Objects_Var7,X
	BNE PRG003_A66A	 ; If Var7 is non-zero, jump to PRG003_A66A

	JSR Object_HitTest	 ; Do Player to object collision test

	LDA Objects_PlayerHitStat,X
	BNE PRG003_A652	 ; If Player is not touching object, jump to PRG003_A652

	LDA Level_ChgTileEvent
	BNE PRG003_A651	 ; If a tile change event is active, jump to PRG003_A651

	JSR DonutLift_ChangeBlock	; Do block change

PRG003_A64E:
	JSR Object_SetDeadEmpty	 ; Mark as dead/empty

PRG003_A651:
	RTS		 ; Return

PRG003_A652:
	DEC <Objects_Var5,X	 ; Var5--
	BNE PRG003_A65A	 	; If Var5 > 0, jump to PRG003_A65A

	INC Objects_Var7,X	 ; Var7++

	RTS		 ; Return

PRG003_A65A:
	LDA <Counter_1
	AND #$07
	STA Objects_Timer4,X	 ; Timer4 = 0 to 7

	LDA Objects_PlayerHitStat,X
	BEQ PRG003_A669	 ; If Player has not touched donut lift, jump to PRG003_A669 (RTS)

	JSR PRG003_A67C

PRG003_A669:
	RTS		 ; Return

PRG003_A66A:
	JSR Object_Move

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_A677	 ; If donut lift hasn't hit something solid, jump to PRG003_A677

	; Set timer to $1F (poof death timer)
	LDA #$1f
	STA Objects_Timer,X

	LDA #OBJSTATE_POOFDEATH
	STA Objects_State,X
	
	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

PRG003_A677:
	JSR Object_HitTest	 ; Do Player to object collision detection
	BCC PRG003_A691	 ; If no collision, jump to PRG003_A691 (RTS)

PRG003_A67C:
	LDA <Player_YVel
	BMI PRG003_A691	 ; If Player is moving upward, jump to PRG003_A691 (RTS)

	; Otherwise, lock Player at 31 pixels above donut lift
	LDA <Objects_Y,X
	SUB #31
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	; Player is not in air
	LDA #$00
	STA <Player_InAir

PRG003_A691:
	RTS		 ; Return

DonutLift_ChangeBlock:
	; Queue tile change event
	LDA #CHNGTILE_DELETEDONUT
	STA Level_ChgTileEvent

	; Block change to occur at Y+1
	LDA <Objects_Y,X
	ADD #$01
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	ADC #$00
	STA Level_BlockChgYHi

	LDA <Objects_XHi,X
	STA Level_BlockChgXHi
	LDA <Objects_X,X
	STA Level_BlockChgXLo

	RTS		 ; Return

	; Bob-omb's starting X velocity depending on where Player is
BobOmb_StartXVel:	.byte $08, -$08

	; Bob-omb's starting X velocity depending on where Player is
BobOmbExp_StartXVel:	.byte $10, -$10

ObjInit_BobOmb:
	JSR Level_ObjCalcXDiffs

	; Start Bob-omb moving towards Player
	LDA BobOmb_StartXVel,Y
	STA <Objects_XVel,X

	RTS		 ; Return

ObjInit_BobOmbExplode:
	JSR Level_ObjCalcXDiffs

	; Start Bob-omb moving towards Player
	LDA BobOmbExp_StartXVel,Y
	STA <Objects_XVel,X

	INC Objects_Var7,X	 ; Var7 = 1 for exploding Bob-omb!

	RTS		 ; Return

ObjNorm_BobOmb:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Objects_Var5,X
	CMP #$02
	BEQ PRG003_A6DD	 ; If Var5 = 2 (Exploding), jump to PRG003_A6DD

	JSR Object_ShakeAndDraw	 ; Normally draw Bob-omb (Except when exploding)

	LDA <Player_HaltGame
	BNE PRG003_A6E8	 ; If gameplay halted, jump to PRG003_A6E8 (RTS)

	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

PRG003_A6DD:
	LDA <Objects_Var5,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BobOmb_WalkAround		; 0: Unsquashed Bob-omb minding his own business
	.word BobOmb_FlashToExplode	; 1: Squashed Bob-omb who then flashes and explodes
	.word BobOmb_DoExplosion	; 2: Do the explosion, kill things, etc.

PRG003_A6E8:
	RTS		 ; Return

BobOmb_WalkAround:
	JSR Object_Move	 ; Do standard movements

	LDA Objects_Var7,X
	BEQ PRG003_A6FF	 ; If Var7 = 0 (Bob-omb not ready to explode), jump to PRG003_A6FF

	; Bob-omb has been squashed and ready to blow!

	LDA Objects_Timer3,X
	ORA <Objects_Var5,X
	BNE PRG003_A6FF	 ; If timer 3 not expired or Var5 <> 0 (initial internal state), jump to PRG003_A6FF

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Set timer to $60
	LDA #$60
	STA Objects_Timer,X

PRG003_A6FF:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_A730	 ; If Bob-omb's not on the ground, jump to PRG003_A730

	LDA #-$20
	STA <Objects_YVel,X

	LDY #$00	 ; Y = 0

	LDA <Counter_1
	AND #$08
	BEQ PRG003_A712	 ; 8 ticks on, 8 ticks off; jump to PRG003_A712

	INY		 ; Y = 1

PRG003_A712:
	; Little walking frame
	TYA
	STA Objects_Frame,X

	JSR Object_HitGround	 ; Align to floor

	LDA Objects_Var7,X
	BEQ PRG003_A730	 ; If Var7 = 0 (not ready to explode), jump to PRG003_A730

	INC Objects_Var3,X	 ; Var3++
	LDA Objects_Var3,X
	AND #$3f	 
	BNE PRG003_A730	 ; Every 1:64 ticks proceed, otherwise jump to PRG003_A730

	JSR Level_ObjCalcXDiffs

	; March toward Player
	LDA BobOmbExp_StartXVel,Y
	STA <Objects_XVel,X

PRG003_A730:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG003_A739	 ; If Bob-omb has not hit wall, jump to PRG003_A739

	JSR Object_AboutFace	 ; Otherwise, turn around

PRG003_A739:
	JSR Object_HandleBumpUnderneath
	BCC PRG003_A75E	 ; If Bob-omb wasn't hit from underneath, jump to PRG003_A75E

	LDA Objects_PlayerHitStat,X
	BEQ PRG003_A75E	 ; If Player didn't touch Bob-omb, jump to PRG003_A75E (RTS)

	LDA Player_Kuribo
	BEQ PRG003_A74B	 ; If Player is not in Kuribo's shoe, jump to PRG003_A74B

	JMP BobOmb_Kill	 ; Jump to BobOmb_Kill

PRG003_A74B:
	INC <Objects_Var5,X

	LDA #$ff
	STA Objects_Timer,X

	LDA #$08
	STA Objects_Timer2,X

	; Little bounce for the Player
	LDA #-$30
	STA <Player_YVel

	JMP PRG003_A7FE	 ; Just do Bob-omb death

PRG003_A75E:
	RTS		 ; Return

PRG003_A75F:
	.byte $10, $20, $30, $40, $FC, $F8, $F4, $F0

BobOmb_FlashToExplode:
	; Toggles between frames 2 and 3, but these are indiscernable,
	; both look like the "eyes closed, footless" Bob-omb...
	; Maybe was supposed to animate crank or something?
	LDY #$02	; Y = 2

	LDA <Counter_1
	AND #$08
	BEQ PRG003_A770	 ; 8 ticks on, 8 ticks off; jump to PRG003_A770

	INY		 ; Y = 3

PRG003_A770:
	TYA
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BNE PRG003_A798	 ; If timer not expired, jump to PRG003_A798

	; Timer expired...

BobOmb_Explode:
	; Var3 = 0
	LDA #$00
	STA Objects_Var3,X

	; Set internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	; Reset timer to $28 (length of explosion)
	LDA #$28
	STA Objects_Timer,X

	; Ba-boom
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Since Bob-omb is exploding, he no longer needs to enforce his pattern bank
	INC Objects_DisPatChng,X

SetRotatingColor:
	LDA #$10
	STA RotatingColor_Cnt

	RTS		 ; Return


PRG003_A798:

	; Bob-omb's timer hasn't gone out yet...

	CMP #$40
	BGE PRG003_A79F	 ; If timer >= $40, jump to PRG003_A79F
 
	STA Objects_ColorCycle,X	 ; Otherwise, start flashing

PRG003_A79F:
	JSR Object_Move	 ; Do standard movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_A7CC	 ; If Bob-omb has not hit floor, jump to PRG003_A7CC

	; This whole block works to get the X velocity arithmetically divided by 2
	LDA <Objects_XVel,X
	PHP		 ; Save CPU state
	; Get absolute value of X velocity
	BPL PRG003_A7B0
	JSR Negate
PRG003_A7B0:
	LSR A		 ; Divide by 2
	PLP		 ; Restore CPU state
	BPL PRG003_A7B7	 ; If the X velocity was positive, jump to PRG003_A7B7
	JSR Negate	 ; Otherwise, make this negative again
PRG003_A7B7:
	STA <Objects_XVel,X	 ; X velocity now divided by 2

	LDA <Objects_YVel,X
	PHA		 ; Save Y velocity

	JSR Object_HitGround	 ; Align to floor

	PLA		 ; Restore Y velocity
	BMI PRG003_A7CC	 ; If it's negative, jump to PRG003_A7CC

	; Bob-omb was falling downward...
	LSR A		; Divide by 2
	JSR Negate	 ; Negate it (bounce back up)
	CMP #$fc
	BGE PRG003_A7CC	 ; If the velocity was small enough, then just stop

	STA <Objects_YVel,X	 ; Otherwise, bounce away

PRG003_A7CC:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG003_A7DC	 ; If Bob-omb did not hit a wall, jump to PRG003_A7DC

	; Otherwise bounce off
	LDA <Objects_XVel,X
	JSR Negate
	STA <Objects_XVel,X

	; ... and sort of arithmetically divide by 2
	ASL A
	ROR <Objects_XVel,X

PRG003_A7DC:
	JSR Object_HitTest
	BCC PRG003_A7F0	 ; If Player and Bob-omb didn't collide, jump to PRG003_A7F0 (RTS)

	LDA Objects_Timer2,X
	BNE PRG003_A7F0	 ; If timer2 has not expired, jump to PRG003_A7F0 (RTS)

	LDA Player_Kuribo
	BNE BobOmb_Kill	 ; If Player is in Kuribo's shoe, kill Bob-omb, jump to BobOmb_Kill

	; Otherwise, set Bob-omb's state to 4 (Held, doesn't really make sense)
	LDA #OBJSTATE_HELD
	STA Objects_State,X

PRG003_A7F0:
	RTS		 ; Return

BobOmb_Kill:
	; Player bounces
	LDA #-$30
	STA <Player_YVel

	; Set Bob-omb state to Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; A little bounce from the Bob-omb
	LDA #-$10
	STA <Objects_YVel,X

PRG003_A7FE:
	LDA Kill_Tally
	INC Kill_Tally
	JSR Score_Get100PlusPts	 ; Get score according to Kill Tally

	; "Kick" noise
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	RTS		 ; Return

	; X and Y offsets for the exploding Bob-omb stars
BombStars_XOff:	.byte -$04, $04, $08, $04, -$04, -$08, $00, $08, $08, $00, -$08, -$08
BombStars_YOff:	.byte -$08, -$08, $00, $08, $08, $00, $08, $04, -$04, -$08, -$04, $04

BobOmb_DoExplosion:
	LDA <Player_HaltGame
	BNE PRG003_A82E	 ; If gameplay is halted, jump to PRG003_A82E

	INC <Objects_Var4,X	 ; Otherwise, Var4++

PRG003_A82E:
	LDA Objects_Timer,X
	BNE PRG003_A836	 ; If timer has not expired, jump to PRG003_A836

	JMP Object_SetDeadEmpty	 ; Otherwise, mark Bob-omb as Dead/Empty and don't come back!

PRG003_A836:
	JSR Bobomb_BustBlocks
	JSR Object_CalcSpriteXY_NoHi

	; Temp_Var16 = 5
	LDA #$05
	STA <Temp_Var16

PRG003_A83D:
	; Temp_Var1 = Bob-omb's sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1	

	; Temp_Var2 = Bob-omb's sprite X + 4
	LDA <Objects_SpriteX,X
	ADD #$04
	STA <Temp_Var2

	LDA <Objects_Var4,X
	LSR A		 ; Var4 / 2
	PHA		 ; Save value

	; Temp_Var3 = 0 to 3, depending on Var4 / 2
	AND #$03
	STA <Temp_Var3

	LDX <Temp_Var16	 ; X = Temp_Var16

	PLA		 ; Restore Var4 / 2

	AND #$04	 ; Mask 0-3
	BEQ PRG003_A85C	 ; If result is zero, jump to PRG003_A85C

	; Otherwise, X += 6
	TXA
	ADD #$06
	TAX

PRG003_A85C:
	LDA <Temp_Var1
	ADD BombStars_YOff,X
	STA <Temp_Var1

	LDA <Temp_Var2
	ADD BombStars_XOff,X
	STA <Temp_Var2

	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG003_A85C	 ; While Temp_Var3 >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

	JSR Sprite_NoCarryIfVisible
	BCS PRG003_A89D	 ; If this star is not visible, jump to PRG003_A89D

	LDA <Temp_Var16
	ASL A
	ASL A		; A = Temp_Var16 * 4 (one sprite per star)
	ADC Object_SprRAM,X	 ; Add the base Sprite_RAM offset
	TAY		 ; -> 'Y'

	; Star Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Star X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; Star pattern
	LDA #$73
	STA Sprite_RAM+$01,Y

	LDA <Counter_1
	LSR A	
	LSR A	
	ADD <SlotIndexBackup
	AND #$03	 ; Palette select 0 to 3
	STA Sprite_RAM+$02,Y	 ; Set attributes

	JSR PRG003_BD1E	 ; Uses part of the "Tail" hurt code, checks if Player has been hit by explosion

PRG003_A89D:
	DEC <Temp_Var16	 ; Temp_Var16--
	BPL PRG003_A83D	 ; While Temp_Var16 >= 0, loop!

	JSR Object_AnySprOffscreen
	BNE PRG003_A8D2	 ; If any part of the exploding Bob-omb has fallen off-screen, jump to PRG003_A8D2

	JSR BobOmb_CalcULOffXY	; (large bounding box for explosion)

	; Temp_Var13 = 0
	LDA #$00
	STA <Temp_Var13

	INC Obj2Obj_FlagNoHitChk	; We WANT the explosion to hit OAT_HITNOTKILL objects (specifically Mouser)
	JSR PRG000_DC09	 ; Object-to-object collision test sans visibility check and bounding box calculation
	DEC Obj2Obj_FlagNoHitChk	; Clear the flag
	BCC PRG003_A8D2	 ; If there hasn't been a collision, jump to PRG003_A8D2 (RTS)

	; There was a collision; was it Mouser?
	LDA Level_ObjectID,Y
	CMP #OBJ_BOSS_MOUSER
	BEQ BobombExp_MouserAlwaysOK	; If this was Mouser, jump to BobombExp_MouserAlwaysOK
	
	LDA Object_AttrFlags,Y
	AND #OAT_HITNOTKILL
	BNE PRG003_A8D2	 ; If this is an OAT_HITNOTKILL object, deny the hit, jump to PRG003_A8D2

BobombExp_MouserAlwaysOK:
	; SB: "Color rotation" invincibility hack
	LDA Objects_ColorCycle,Y
	BNE PRG003_A8D2

	; "Kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; SB: Check for HP
	LDA Objects_HitCount,Y
	BEQ BomOmb_ObjectNoHP

	; Deduct hit!
	SUB #1
	STA Objects_HitCount,Y

	; Flash invincibility instead
	LDA #60
	STA Objects_ColorCycle,Y
	BNE PRG003_A8D2

BomOmb_ObjectNoHP:
	; Set object to state Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,Y

	; Killed object bounces up a bit
	LDA #-$30
	STA Objects_YVel,Y

	; Halt horizontal movement
	LDA #$00
	STA Objects_XVel,Y

	; SB: Hack for Mouser
	LDA Level_ObjectID,Y
	CMP #OBJ_BOSS_MOUSER
	BNE BobOmb_KillNotMouser

	; Get 1000 points for Mouser!
	LDA #4
	BNE BobOmb_KillMouser	; Jump (technically always) to BobOmb_KillMouser

BobOmb_KillNotMouser:
	; Var3 works as a kill counter for things killed by the explosion
	LDA Objects_Var3,X
	INC Objects_Var3,X

BobOmb_KillMouser:
	JSR Score_Get100PlusPtsY	 ; Get score for that

PRG003_A8D2:
	RTS		 ; Return

	; Calculates an upper left X/Y offset
BobOmb_CalcULOffXY:
	; Temp_Var3 = Bob-omb's Sprite X - 24
	LDA <Objects_SpriteX,X	 
	SUB #24
	STA <Temp_Var3

	; Temp_Var7 = Bob-omb's Sprite Y - 24
	LDA <Objects_SpriteY,X
	SUB #24
	STA <Temp_Var7

	; Temp_Var4 and Temp_Var8 = $40
	LDA #$40
	STA <Temp_Var4
	STA <Temp_Var8

	RTS		 ; Return

	
Bobomb_BustBlocks:

	; SB: NEW: Bobomb busts blocks while exploding!
	; Needed to put it in bank 30 though...

	JMP_THUNKC 30, Bobomb_BustBlocks30


ObjNorm_BoomBoomQBall:
	LDY Objects_Timer,X	; Y = timer
	BEQ PRG003_A8FF	 	; If timer expired, jump to PRG003_A8FF

	; This timer is active after time has been converted to score,
	; in that momentary pause after that before exiting

	STY Player_VibeDisable	; Cause Player to be vibrationally disabled
	DEY		 ; Y--
	BNE PRG003_A8FE	 ; If timer > 1, jump to PRG003_A8FE (RTS)

	; Exit to map!
	JSR ExitLevel_InvalidateCP

PRG003_A8FE:
	RTS		 ; Return

PRG003_A8FF:
	LDA <Objects_Var5,X
	BEQ PRG003_A911	 ; If Var5 = 0, jump to PRG003_A911

	STA Player_VibeDisable	 ; Clear Player vibrationally disabled flag

	JSR DoTimeBonus	 ; Convert remaining time into score
	BNE PRG003_A910	 ; If not done converting, jump to PRG003_A910 (RTS)

	; Set timer to $40
	LDA #$40
	STA Objects_Timer,X

PRG003_A910:
	RTS		 ; Return

PRG003_A911:
	LDA <Player_HaltGame
	BNE PRG003_A92D	 ; If gameplay is halted, jump to PRG003_A92D

	LDA <Objects_YVel,X
	BMI PRG003_A92D	 ; If ball moving upwards, jump to PRG003_A92D

	JSR Object_HitTest
	BCC PRG003_A92D	 ; If Player is not touching it, jump to PRG003_A92D

	; A living Player has grabbed it!

	INC <Objects_Var5,X	 ; Var5++

	; Do the color cycle effect
	LDA #$1e
	STA RotatingColor_Cnt

	; SB: Stop the clock
	LDA Level_TimerEn
	ORA #$01
	STA Level_TimerEn

	; SB: Alternate exit!
	INC Map_WasAltExit

	; Victory fanfare
	LDA Sound_QMusic1
	ORA #MUS1_COURSECLEAR
	STA Sound_QMusic1

PRG003_A92D:
	JSR Object_ShakeAndDraw	 ; Draw it

Object_DoMoveBounceConveyor:
	JSR Object_Move	 ; Do standard movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ ObjInit_BoomBoomQBall ; If ball hasn't hit ground, jump to ObjInit_BoomBoomQBall (RTS)


	JSR Object_HandleConveyorCarry	 ; Carry ball along conveyor

	LDA <Objects_YVel,X
	PHA		 ; Save Y velocity

	JSR Object_HitGround	 ; Align to floor

	PLA		 ; Restore Y velocity
	LSR A
	LSR A		 ; Current Y velocity / 4

	JSR Negate	 ; Bounce at a quarter of impact

	CMP #$fe	 
	BCS ObjInit_BoomBoomQBall	; If the bounce is really small, jump to ObjInit_BoomBoomQBall (RTS)

	STA <Objects_YVel,X	 ; Update Y velocity for a bounce

ObjInit_BoomBoomQBall:
	RTS		 ; Return


ObjInit_BoomBoom:

	; Set Var4 to Boom Boom's Y Hi -- this will select which value goes into Map_DoFortressFX
	; So if Boom Boom's Y Hi is 1, then Map_DoFortressFX = 1, etc.
	; The actual assignment to Map_DoFortressFX is done with the (?) ball after Boom Boom is defeated
	LDA <Objects_YHi,X
	STA <Objects_Var4,X

	; Boom Boom will always appear at Y Hi = 1 (since this was used as a parameter)
	LDA #$01
	STA <Objects_YHi,X
	STA Objects_IsGiant,X	 ; Boom Boom is considered a "giant" enemy

	; Boom Boom requires 37 fire balls before going down 
	LDA #37
	STA Objects_HitCount,X

	; Boom Boom starts on frame 7
	LDA #$07
	STA Objects_Frame,X

	RTS		 ; Return

BoomBoom_TowardsPlayerXVel:	.byte $10, -$10

BoomBoom_FinalAttackXVel:
	.byte $20, -$20, $18, -$18	; First two values are for any world besides World 1, last two are World 1 only

BoomBoom_GetupFrames:
	.byte $0A, $06, $07, $07, $07, $07, $06, $0A, $10, $14
	.byte $15, $15, $15, $15, $14, $10

ObjNorm_BoomBoom:

	; Boom Boom's graphics
	LDA #$4d
	STA PatTable_BankSel+4

	LDA Level_TilesetIdx
	CMP #11
	BNE PRG003_AA25	 ; If Level_TilesetIdx <> 11 (ice level), jump to PRG003_AA25

	STA Objects_Var2,X	 ; Var2 = 11

PRG003_AA25:
	LDA Objects_HitCount,X
	CMP #$20
	BNE PRG003_AA3B	 ; If HitCount <> $20, jump to PRG003_AA3B

	DEC Objects_HitCount,X	 ; HitCount--

	; Var5 = 5
	LDA #$05
	STA <Objects_Var5,X

	; Timer = $50
	LDA #$50
	STA Objects_Timer,X

	JMP BoomBoom_Draw	 ; Draw Boom Boom and don't come back

PRG003_AA3B:
	JSR BoomBoom_Draw	 ; Draw Boom Boom
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	JSR Object_CheckIfNormalState
	BEQ PRG003_AA5D	 ; If Boom Boom is in normal state, jump to PRG003_AA5D

	; Not normal state... any state not normal is considered Boom Boom has
	; been killed, and as such will cause him to turn into the "(?)" ball.

	LDA <Objects_Var5,X
	BEQ PRG003_AA5D	 ; If Var5 = 0, jump to PRG003_AA5D

	; Set state Normal (for the end ball)
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDA #$70
	STA <Objects_Y,X
	STA <Objects_X,X

	LDA #$01
	STA <Objects_YHi,X

	LSR A		 ; A = 0
	JMP PRG003_AE95	 ; Jump to PRG003_AE95

BoomBoom_Halted:
	RTS

PRG003_AA5D:
	LDA <Player_HaltGame
	BNE BoomBoom_Halted	; If gameplay halted, jump to BoomBoom_Halted (RTS)

	LDA <Objects_Var5,X
	CMP #$05
	BEQ PRG003_AAD9	 ; If Var5 (internal state) = 5, jump to PRG003_AAD9

	; Var5 (Internal state) < 5...

	LDY Objects_Timer2,X
	BEQ PRG003_AA92	 ; If timer 2 expired, jump to PRG003_AA92
	DEY		 ; Y--
	BNE PRG003_AA72	 ; If Y > 0, jump to PRG003_AA72

	JSR BoomBoom_ResetVar6	 ; Sets Var6 to $2F

PRG003_AA72:
	LDY #$08	 ; Y = 8

	; Boom Boom's squashed wiggle frames

	LDA <Counter_1
	AND #$04
	BEQ PRG003_AA7B	 ; On for 4 ticks, off 4 ticks; jump to PRG003_AA7B every other

	INY		 ; Y = 9

PRG003_AA7B:
	LDA Level_ObjectID,X
	CMP #OBJ_BOOMBOOMFLY
	BNE PRG003_AA8D	 ; If this is not a flying Boom Boom, jump to PRG003_AA8D

	LDA <Objects_Var5,X
	CMP #$03
	BNE PRG003_AA8D	 ; If Var5 (Internal State) <> 3, jump to PRG003_AA8D

	; Add 10 to 'Y' (Boom Boom's wings appear)
	TYA
	ADD #$0a
	TAY

PRG003_AA8D:

	; Set frame
	TYA
	STA Objects_Frame,X

	RTS		 ; Return

PRG003_AA92:
	LDA Objects_Var6,X
	BEQ PRG003_AAD3	 ; If Var6 = 0, jump to PRG003_AAD3

	DEC Objects_Var6,X
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = Var6 / 8

	; Set frames while Boom Boom is "getting up"
	LDA BoomBoom_GetupFrames,Y
	STA Objects_Frame,X

	LDA Objects_Var6,X
	CMP #$10
	BNE PRG003_AABC	 ; If Var6 <> $10, jump to PRG003_AABC

	; Boom Boom hops a bit when he gets up
	LDA #-$2D
	STA <Objects_YVel,X

	LDA Objects_Var2,X
	BNE PRG003_AABC	 ; If Var2 <> 0, jump to PRG003_AABC

	JSR Level_ObjCalcXDiffs

	; Set X Velocity towards Player
	LDA BoomBoom_TowardsPlayerXVel,Y
	STA <Objects_XVel,X

PRG003_AABC:
	LDA <Counter_1
	LSR A
	BCC PRG003_AACD	 ; Every other tick, jump to PRG003_AACD

	LDA <Objects_XVel,X
	BEQ PRG003_AACD	 ; If Boom Boom is not moving horizontally, jump to PRG003_AACD
	BPL PRG003_AACB	 ; If moving to the right, jump to PRG003_AACB

	; Moving to the left...

	; Double increment because it hits the decrement, basically a single increment
	INC <Objects_XVel,X	; Moving left, slow down
	INC <Objects_XVel,X

PRG003_AACB:
	DEC <Objects_XVel,X	; Moving right, slow down

PRG003_AACD:
	JSR BoomBoom_HitTest	; Test for collisions between Player and Boom Boom
	JMP PRG003_AB8E	 	; Jump to PRG003_AB8E

PRG003_AAD3:
	JSR BoomBoom_HitTest	; Test for collisions between Player and Boom Boom

	INC Objects_Var3,X	 ; Var3++

PRG003_AAD9:
	LDA <Objects_Var5,X	; Var5 is internal state for Boom Boom
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BoomBoom_Init		; 0: Initial state, wait for Player
	.word BoomBoom_Unused		; 1: Lost state?  Never used, just goes to state 2
	.word BoomBoom_PrimaryAttack	; 2: Boom Boom's run around with fists flailing
	.word BoomBoom_SeconaryAttack	; 3: Boom Boom jumps about or flies, depending
	.word BoomBoom_FinalAttack	; 4: Second hit
	.word BoomBoom_Death		; 5: Kaboom Death
	.word BoomBoom_TimeOut		; 6: SB NEW: Boom Boom just takes care of level end

BoomBoom_Init:

	; Boom Boom awaits in his crouch frame
	LDA #$07
	STA Objects_Frame,X
	STA Objects_SprHVis,X	 ; ??

	JSR Boss_WaitAndLock
	BCC PRG003_AB1E		; If boss not positioned yet, jump to PRG003_AB1E (RTS)

	; Var5 = 2
	STA <Objects_Var5,X


BoomBoom_ResetVar6:

	; Var6 = $2F
	LDA #$2f
	STA Objects_Var6,X

PRG003_AB1E:
	RTS		 ; Return

Boss_WaitAndLock:
	LDA <Horz_Scroll
	CMP #$07
	BGE Boss_WaitAndLock_End	 ; If the horizontal scroll is any greater than 7, jump to Boss_WaitAndLock_End (RTS) (Waits for screen to come around to boss)

	; Lock horizontal scroll to zero point
	LDA #$00
	STA <Horz_Scroll

	; Halt Player horizontally
	LDY #$00
	STY <Player_XVel

	LDA <Player_InAir
	BNE Boss_WaitAndLock_End	; If Player is not on ground, jump to Boss_WaitAndLock_End (RTS)

	STA Level_PSwitchCnt	 ; Cancel any active P-Switch

	; Play boss music
	LDA #MUS2B_BOSS
	STA Sound_QMusic2

	; Lock horizontal scrolling
	INC LevelJctBQ_Flag

	; Lock vertical scrolling
	LDA #$02
	STA Level_FreeVertScroll

	; Set carry for success
	SEC
	RTS

Boss_WaitAndLock_End:

	; Clear carry for not yet ready
	CLC
	RTS


BoomBoom_Unused:
	INC <Objects_Var5,X	 ; Just jumps to state 2
	RTS		 ; Return

BoomBoom_XVelLimit:	.byte $10, -$10	; Boom Boom primary attack limits
BoomBoom_XVelFastLimit:	.byte $30, -$30	; Boom Boom final attack limits
BoomBoom_XVelAccel:	.byte $01, -$01	; Boom Boom primary attack acceleration
BoomBoom_XVelFastAccel:	.byte $02, -$02	; Boom Boom final attack acceleration

BoomBoom_PrimaryAttack:
	LDA Objects_Var2,X
	BEQ PRG003_AB52	 ; If Var2 = 0, jump to PRG003_AB52

	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP BoomBoom_XVelLimit,Y
	BEQ PRG003_AB42	 ; If Boom Boom is at his X velocity limit, jump to PRG003_AB42

	; Boom Boom X velocity not at his limit...

	ADD BoomBoom_XVelAccel,Y	; Accelerate
	STA <Objects_XVel,X		; Update X velocity

	; While Boom Boom is accelerating...

	INC Objects_Var3,X	 ; Var3++

PRG003_AB42:
	INC Objects_Var1,X	 ; Var1++

	LDA Objects_Var1,X
	BNE PRG003_AB4F	 ; If Var1 has not overflowed, jump to PRG003_AB4F

	; When Var1 overflows, Boom Boom goes back into his shell

	; Var6 = $3F
	LDA #$3f
	STA Objects_Var6,X

PRG003_AB4F:
	JMP PRG003_AB78	 ; Jump to PRG003_AB78

PRG003_AB52:
	INC Objects_Var1,X	 ; Var1++

	LDA Objects_Var1,X
	BNE PRG003_AB6C	 ; If Var1 has not overflowed, jump to PRG003_AB6C

	; Var6 = $3F
	LDA #$3f
	STA Objects_Var6,X

	JSR Level_ObjCalcXDiffs

	; Boom Boom slides a bit when he jumps back in his shell
	LDA BoomBoom_XVelSlide,Y
	STA <Objects_XVel,X

	JMP PRG003_AA92	 ; Jump to PRG003_AA92

BoomBoom_XVelSlide:	.byte $20, -$20

PRG003_AB6C:
	AND #$3f
	BNE PRG003_AB78	 ; 1:64 counts on Var1 proceed, otherwise jump to PRG003_AB78

	; Shift Boom Boom's horizontal direction towards Player
	JSR Level_ObjCalcXDiffs
	LDA BoomBoom_TowardsPlayerXVel,Y
	STA <Objects_XVel,X

PRG003_AB78:
	LDA Objects_Var3,X
	AND #$03
	BNE PRG003_AB8E	 ; Proceed 1:4 Var3 counts, otherwise jump to PRG003_AB8E

	INC Objects_Frame,X	 ; Boom Boom's frame++

	; Loop frames 0-6
	LDA Objects_Frame,X
	CMP #$06
	BLT PRG003_AB8E	 ; If Boom Boom frame < 6, jump to PRG003_AB8E

	LDA #$00
	STA Objects_Frame,X

PRG003_AB8E:
	JSR Object_Move	 ; Boom Boom does standard movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_AB9A	 ; If Boom Boom did not hit the ground, jump to PRG003_AB9A

	JSR Object_HitGround	 ; Align to floor

PRG003_AB9A:
	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG003_ABC3	 ; If Boom Boom has not hit ceiling, jump to PRG003_ABC3

	; Boom Boom Y Vel = 1, i.e. hit off ceiling
	LDA #$01
	STA <Objects_YVel,X

	; Set tile detection coordinates

	LDA <Objects_X,X
	ADD #$08
	STA ObjTile_DetXLo

	LDA <Objects_XHi,X
	STA ObjTile_DetXHi

	LDA <Objects_Y,X
	ADC #$0c
	STA ObjTile_DetYLo

	LDA #$01
	STA ObjTile_DetYHi

	LDA Object_TileFeet2
	JSR Object_BumpBlocks	 ; Boom Boom can hit blocks! (???)

PRG003_ABC3:
	LDA <Objects_DetStat,X	
	AND #$03
	BNE PRG003_ABDB	 ; If Boom Boom has hit a wall, jump to PRG003_ABDB

	; Boom Boom has not hit a wall...

PRG003_ABC9:
	LDA <Objects_XVel,X
	BPL PRG003_ABD5	 ; If Boom Boom is not moving left, jump to PRG003_ABD5

	; Boom Boom is moving leftward...

	LDA <Objects_SpriteX,X
	CMP #$08
	BGE PRG003_ABDE	 ; If Boom Boom's Sprite X >= 8, jump to PRG003_ABDE (RTS)
	BLT PRG003_ABDB	 ; Otherwise, jump to PRG003_ABDB

PRG003_ABD5:

	; Boom Boom is moving rightward...

	LDA <Objects_SpriteX,X
	CMP #224
	BLT PRG003_ABDE	 ; If Boom Boom's Sprite X < 224, jump to PRG003_ABDE (RTS)

PRG003_ABDB:
	JSR Object_AboutFace	 ; Boom Boom turns around

PRG003_ABDE:
	RTS		 ; Return


BoomBoom_SeconaryAttack:
	LDA Level_ObjectID,X
	CMP #OBJ_BOOMBOOMFLY
	BNE PRG003_ABE9	 ; If this is not the flying Boom Boom, jump to PRG003_ABE9

	JMP PRG003_AC70	 ; Jump to PRG003_AC70

PRG003_ABE9:

	; Non-flying Boom Boom

	LDA Objects_Var7,X
	BEQ PRG003_AC1A	 ; If Var7 = 0, jump to PRG003_AC1A

	LDA <Counter_1
	AND #$03
	BNE PRG003_AC00	 ; Every 1:4 ticks, proceed, otherwise jump to PRG003_AC00

	LDA <Objects_XVel,X
	BEQ PRG003_AC00	 ; If Boom Boom is not moving horizontally, jump to PRG003_AC00
	BPL PRG003_ABFE	 ; If Boom Boom is moving to the right, jump to PRG003_ABFE

	; Moving to the left...

	; Double increment because it hits the decrement, basically a single increment
	INC <Objects_XVel,X	; Moving left, slow down
	INC <Objects_XVel,X

PRG003_ABFE:
	DEC <Objects_XVel,X	; Moving right, slow down

PRG003_AC00:

	; Jump tensing frame
	LDA #$0B
	STA Objects_Frame,X

	DEC Objects_Var7,X	 ; Var7--

	BNE PRG003_AC11	 ; If Var7 <> 0, jump to PRG003_AC11

	; Boom Boom's jump!
	LDA #-$60
	STA <Objects_YVel,X

	JSR BoomBoom_SetXVelTowardsPlayer	 ; Jump towards Player

PRG003_AC11:
	LDA Objects_Var2,X
	BEQ PRG003_AC19	 ; If Var2 = 0, jump to PRG003_AC19 (RTS)

	JSR Object_ApplyXVel	 ; Apply X Velocity

PRG003_AC19:
	RTS		 ; Return

PRG003_AC1A:
	LDA <Objects_DetStat,X
	AND #$04
	BNE PRG003_AC23	 ; If Boom Boom hit floor, jump to PRG003_AC23

	JSR Object_ApplyXVel	 ; Otherwise, apply X velocity while jumping

PRG003_AC23:
	JSR PRG003_AB78		; Boom Boom flails arms while jumping

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_AC69	 ; If Boom Boom has NOT hit floor, jump to PRG003_AC69 (RTS)

	; Boom Boom hit floor...
	
	LDA Objects_Var2,X
	BEQ PRG003_AC47	 ; If Var2 = 0, jump to PRG003_AC47

	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP BoomBoom_XVelLimit,Y
	BEQ PRG003_AC44	 ; If Boom Boom is at his X velocity limit, jump to PRG003_AC44

	ADD BoomBoom_XVelAccel,Y	; Boom Boom accelerates towards Player
	STA <Objects_XVel,X	 ; Update X Velocity

	INC Objects_Var3,X	 ; Var3++

PRG003_AC44:
	JMP PRG003_AC4D	 	; Jump to PRG003_AC4D

PRG003_AC47:
	LDA <Counter_1
	AND #$3f
	BEQ BoomBoom_SetXVelTowardsPlayer	 ; Every 64 ticks, move towards Player

PRG003_AC4D:
	LDA <Counter_1
	ADD #$1f	; Offsets counter
	ASL A	
	BNE PRG003_AC69	 ; If offset counter has NOT overflowed, jump to PRG003_AC69 (RTS)

	LDA #$18	 ; A = $18

	STA Objects_Var7,X	 ; Set Var7 (ticks tensed until jump)

	RTS		 ; Return

BoomBoom_SetXVelTowardsPlayer:
	JSR Level_ObjCalcXDiffs	 

	LDA BoomBoom_TowardsPlayerXVel,Y
	STA <Objects_XVel,X

PRG003_AC69: 
	RTS		 ; Return

BoomBoom_FlyXVelLimit:	.byte $20, -$20
BoomBoom_FlyAccel:	.byte $01, -$01
BoomBoom_FlyYVelAccel:	.byte $10, -$10

PRG003_AC70:

	; Flying Boom Boom

	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP BoomBoom_FlyXVelLimit,Y
	BEQ PRG003_AC80	 ; If flying Boom Boom is at his X velocity limit, jump to PRG003_AC80

	; Flying Boom Boom accelerates
	ADD BoomBoom_FlyAccel,Y
	STA <Objects_XVel,X

PRG003_AC80:
	JSR PRG003_ABC9	 ; Handle Boom Boom hitting against walls

	LDA Objects_Var13,X	; current flight state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BoomBoom_FlightToPlan	; 0: Plan a flight towards the Player
	.word BoomBoom_ExecuteFlight	; 1: Execute flight

BoomBoom_FlightToPlan:
	JSR Object_ApplyXVel	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDY #$00	 ; Y = 0

	LDA <Objects_Y,X
	CMP #16
	BLT PRG003_AC9C	 ; If Boom Boom's Y < 16, jump to PRG003_AC9C

	INY		 ; Y = 1

PRG003_AC9C:
	LDA <Objects_YVel,X
	CMP BoomBoom_FlyYVelAccel,Y
	BEQ PRG003_ACA9	 ; If Boom Boom is flying at his vertical velocity limit, jump to PRG003_ACA9

	; Otherwise, accelerate flight
	ADD BoomBoom_FlyAccel,Y
	STA <Objects_YVel,X

PRG003_ACA9:
	LDA <Objects_Y,X
	CMP #32
	BGE PRG003_ACC2	 ; If Boom Boom's Y >= 32, jump to PRG003_ACC2

	INC Objects_Var14,X

	LDA Objects_Var14,X
	BNE PRG003_ACC2	 ; If Objects_Var14 <> 0, jump to PRG003_ACC2

	JSR BoomBoom_PlanFlight	 ; Plan a flight towards the Player

	INC Objects_Var13,X	 ; Next flight state

	; timer = $18
	LDA #$18
	STA Objects_Timer,X

PRG003_ACC2:
	LDA #$03	 ; A = 3
	BNE PRG003_ACF0	 ; Jump (technically always) to PRG003_ACF0

BoomBoom_ExecuteFlight:
	LDA Objects_Timer,X
	BEQ PRG003_ACD1	; If timer expired, jump to PRG003_ACD1

	; Set Boom Boom to frame $0C (first frame of flight animation)
	LDA #$0c
	STA Objects_Frame,X

	RTS		 ; Return

PRG003_ACD1:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_Y,X
	CMP #80
	BLT PRG003_ACEE	 ; If Boom Boom's Y < 80, jump to PRG003_ACEE

	; Return to initial flight state
	LDA #$00
	STA Objects_Var13,X

	LDA RandomN,X
	AND #$03
	BNE PRG003_ACEE	 ; Only 1:4 chance we'll proceed, otherwise jump to PRG003_ACEE

	; Set Var6 = $3F
	LDA #$3f
	STA Objects_Var6,X

PRG003_ACEE:
	LDA #$01

PRG003_ACF0:
	AND <Counter_1
	BNE PRG003_AD03	 ; Every other tick, jump to PRG003_AD03 (RTS)

	INC Objects_Frame,X	 ; Frame++

	; Boom Boom's flight animation, frames $0C to $12
	LDA Objects_Frame,X
	CMP #$12
	BLT PRG003_AD03	 ; If Boom Boom's frame < $12, jump to PRG003_AD03

	; Set Boom Boom's frame to $0C
	LDA #$0c
	STA Objects_Frame,X

PRG003_AD03:
	RTS		 ; Return


BoomBoom_FinalAttack:
	INC Objects_Var3,X	 ; Var3++

	JSR PRG003_AB78		 ; Reuse some of Boom Boom's primary attack code

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_AD3E	 ; If Boom Boom hasn't hit the floor, jump to PRG003_AD3E

	LDA Objects_Var2,X
	BEQ PRG003_AD29	 ; If Var2 = 0, jump to PRG003_AD29

	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP BoomBoom_XVelFastLimit,Y
	BEQ PRG003_AD28	 ; If Boom Boom is at his X velocity limit, jump to PRG003_AD28

	ADD BoomBoom_XVelFastAccel,Y	; Boom Boom accelerates towards Player
	STA <Objects_XVel,X	 ; Update X Velocity

	INC Objects_Var3,X	 ; Var3++

PRG003_AD28:
	RTS		 ; Return

PRG003_AD29:
	LDA <Counter_1
	AND #$1f
	BNE PRG003_AD3E	 ; 1:32 ticks proceed, otherwise jump to PRG003_AD3E

	JSR Level_ObjCalcXDiffs

	; Set Boom Boom's X velocity towards Player as appropriate for direction and world
	LDA BoomBoom_FinalAttackXVel,Y
	STA <Objects_XVel,X

PRG003_AD3E:
	RTS		 ; Return

BoomBoom_PlanFlight:
	LDA #$20 
	JSR BoomBoom_CalcFlightPath	 ; Calculate a flight plan towards the Player

	; Set velocities in accordance with flight plan
	LDA <Temp_Var1
	STA <Objects_YVel,X
	LDA <Temp_Var2
	STA <Objects_XVel,X

	RTS		 ; Return

	; Boom Boom's left arm patterns
BoomBoom_PatternLeft:
	.byte $C9, $D1, $C3, $C3, $CB, $C9, $D5, $DB, $DF, $EB, $C3, $C3, $83, $8B, $71, $83
	.byte $8B, $71, $95, $9B, $A3, $A9

	; Boom Boom's right arm patterns
BoomBoom_PatternRight:
	.byte $C3, $CB, $C9, $C9, $D1, $C3, $D5, $DB, $EB, $DF, $C3, $C3, $83, $8B, $71, $83
	.byte $8B, $71, $95, $9B, $A3, $A9

	; Boom Boom's left arm Y offset
BoomBoom_SprYOffArmLeft:
	.byte $08, $10, $10, $10, $10, $08, $10, $10, $10, $10, $10, $10, $08, $10, $10, $08
	.byte $10, $10, $10, $10, $10, $10

	; Boom Boom's right arm Y offset
BoomBoom_SprYOffArmRight:
	.byte $10, $10, $08, $08, $10, $10, $10, $10, $10, $10, $10, $10, $08, $10, $10, $08
	.byte $10, $10, $10, $10, $10, $10

	.byte $00, $02, $08, $0E, $10, $0E, $08, $02, $04, $03, $00, $03, $04, $07, $08, $07

PRG003_ADB5:
	RTS

BoomBoom_Draw:

	; Copy horizontal visibility -> Temp_VarNP0
	LDA Objects_SprHVis,X
	STA Temp_VarNP0

	LDA <Objects_Y,X
	PHA		 ; Save Boom Boom's Y

	LDA Objects_Var7,X
	BEQ PRG003_ADC8	 ; If Var7 = 0, jump to PRG003_ADC8

	; Draw +2 pixels down
	INC <Objects_Y,X
	INC <Objects_Y,X

PRG003_ADC8:
	LDA <Objects_X,X
	PHA		 ; Save Boom Boom's X

	ADD #$08	 
	STA <Objects_X,X ; Object's X += 8

	LDA <Objects_XHi,X
	PHA		 ; Save Boom Boom's X Hi
	ADC #$00		; Apply carry
	STA <Objects_XHi,X	; Update X Hi

	ASL Objects_SprHVis,X

	JSR Object_DrawTallAndHFlip	 ; Draw large, mirrored sprite

	; Restore X Hi
	PLA
	STA <Objects_XHi,X

	; Restore X
	PLA
	STA <Objects_X,X

	; Restore Y
	PLA
	STA <Objects_Y,X

	; Beginning of arm drawing logic

	JSR Object_CalcSpriteXY_NoHi
	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	LDA Objects_SprVVis,X
	BNE PRG003_ADB5	 ; If any sprite is vertically off-screen, jump to PRG003_ADB5 (RTS)

	; Temp_Var1 = Sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; X = frame
	LDA Objects_Frame,X
	TAX

	LDA Temp_VarNP0
	BMI PRG003_AE07	 ; If this sprite is off-screen, jump to PRG003_AE07

	; Add offset to sprite Y
	LDA <Temp_Var1
	ADD BoomBoom_SprYOffArmLeft,X
	STA Sprite_RAM+$10,Y

PRG003_AE07:
	LDA Temp_VarNP0
	AND #$10
	BNE PRG003_AE17	 ; If the other side sprite is off-screen, jump to PRG003_AE17

	; Add offset to sprite Y
	LDA <Temp_Var1
	ADD BoomBoom_SprYOffArmRight,X
	STA Sprite_RAM+$14,Y

PRG003_AE17:
	LDA BoomBoom_PatternLeft,X
	STA Sprite_RAM+$11,Y

	LDA BoomBoom_PatternRight,X
	STA Sprite_RAM+$15,Y

	; Copies attributes across
	LDA Sprite_RAM+$02,Y
	STA Sprite_RAM+$12,Y

	; Horizontal flag
	ORA #SPR_HFLIP
	STA Sprite_RAM+$16,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	; Temp_Var2 = Sprite X
	LDA <Objects_SpriteX,X
	STA <Temp_Var2	

	; Set Sprite Xs
	STA Sprite_RAM+$13,Y
	ADD #24
	STA Sprite_RAM+$17,Y

	RTS		 ; Return

BoomBoom_HitTest:
	LDA <Objects_Var5,X
	CMP #5
	BGE PRG003_AE87

	JSR Object_HandleBumpUnderneath	 ; Hm, Boom Boom handles getting bumped underneath?

	LDA Objects_PlayerHitStat,X
	BEQ PRG003_AE87	 ; If Player is not hitting Boom Boom at all, jump to PRG003_AE87 (RTS)

	LDA Objects_Frame,X
	CMP #$07
	BNE PRG003_AE50	 ; If Boom Boom's frame <> 7 (Spiky Shell), jump to PRG003_AE50

	JMP Player_HurtIfNotDieOffBehind	 ; Hurt Player and don't come back!

PRG003_AE50: 
	LDA <Player_YVel
	BMI PRG003_AE87	 ; If Player is moving upward, jump to PRG003_AE87 (RTS)

	; Play squish sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	; Get 1000, 2000, or 4000 points
	LDA <Objects_Var5,X
	ADD #$07
	JSR Score_PopUp

	; Player Y Vel = -$30 (bounce off)
	LDA #-$30
	STA <Player_YVel

	LDA <Objects_Var5,X
	INC <Objects_Var5,X	; Var5++ (Next internal state)
	CMP #$04	 
	BEQ PRG003_AE82	 ; If next up is internal state 4 (Death), jump to PRG003_AE82

	; Halt Boom Boom's movement
	LDA #$00
	STA <Objects_YVel,X
	STA <Objects_XVel,X

	; Clear Var7 and Var3
	STA Objects_Var7,X
	STA Objects_Var3,X

	; Timer2 = $30 (ticks till he gets back up)
	LDA #$30
	STA Objects_Timer2,X

	RTS		 ; Return

PRG003_AE82:

	; Object's timer = $80
	LDA #$80
	STA Objects_Timer,X

PRG003_AE87:
	RTS		 ; Return

BoomBoom_Death:
	LDA #0
	STA <Objects_XVel,X
	JSR PRG003_AB8E
	
	LDA #$08 
	STA Objects_SprHVis,X
	STA Objects_Frame,X	; Set Boom Boom's frame = 8

	LDA Objects_Timer,X
	BNE PRG003_AEE3	 ; If timer not expired, jump to PRG003_AEE3

PRG003_AE95:
	STA Objects_FlipBits,X	; Update flip bits

	 ; Halt the level timer
	LDA #$01
	STA Level_TimerEn

	LDA #MUS1_BOSSVICTORY
	STA Sound_QMusic1

	INC <Objects_Var5,X	; Var5++ (Next internal state)

	; Ba-bam! sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	JSR Explode_Stars	; Explode into stars!
	
	LDA #$FF
	STA <Objects_Y,X

PRG003_AEE3:
	STA Objects_ColorCycle,X	; Timer -> color cycle

	RTS		 ; Return
	
BoomBoom_TimeOut:
	LDA #$08 
	STA Objects_SprHVis,X
	STA Objects_Frame,X	; Set Boom Boom's frame = 8

	JSR DoTimeBonus	 ; Convert remaining time into score
	BNE BoomBoom_StillTimering	 ; If not done converting, jump to PRG003_A910 (RTS)

	LDA Objects_Timer,X
	BNE BoomBoom_StillTimering
	
	LDA #$40
	STA Objects_Timer,X
	
BoomBoom_StillTimering:
	LDA Objects_Timer,X
	CMP #1
	BEQ BoomBoom_ExitLevel

	RTS

BoomBoom_ExitLevel:
	JMP ExitLevel_InvalidateCP
	

Star_Vel:
	.byte -$20, -$17, $00, $17, $20, $17, $00, -$17
Star_VelEnd

Explode_Stars:
	LDY #(Star_VelEnd - Star_Vel - 1)

PRG003_AEF1:
	; Explosion star
	LDA #SOBJ_EXPLOSIONSTAR
	STA SpecialObj_ID,Y

	; Star X +4
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Star Y +16
	LDA <Objects_Y,X
	ADD #16
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA SpecialObj_YHi,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data,X

	; Set Y velocity
	LDA Star_Vel,Y
	STA SpecialObj_YVel,Y

	; X is rotated around by offset
	TYA
	ADD #$02
	AND #$07
	TAX

	; Set X velocity
	LDA Star_Vel,X
	STA SpecialObj_XVel,Y

	; SpecialObj_Timer = $3F
	LDA #$3F
	STA SpecialObj_Timer,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	DEY		 ; Y--
	BPL PRG003_AEF1	; While Y >= 0, loop!

	RTS		 ; Return

ObjInit_PiranhaSidewaysR:
	; Right-way piranha +16 X (basically start outside of pipe instead of inside)
	LDA #16
	ADD <Objects_X,X
	STA <Objects_X,X

ObjInit_PiranhaSidewaysL:

	; Start X + 1 over
	LDA <Objects_X,X
	ADD #$01
	STA <Objects_Var5,X

	; Start Y + 7 over
	LDA <Objects_Y,X
	ADD #$07
	STA <Objects_Y,X

	RTS		 ; Return


ObjNorm_PiranhaSideways:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JSR SidePiranha_Draw	 ; Draw piranha
	JSR Player_HitEnemy	 ; Player to piranha collision

	LDA <Player_HaltGame
	BNE PRG003_AF9C	 ; If gameplay halted, jump to PRG003_AF9C

	; Var3 is the animation timer; toggles frame 0 and 1 every 8 ticks
	INC Objects_Var3,X	; Var3++
	LDA Objects_Var3,X
	LDY #$00	 ; Y = 0
	AND #$08	 
	BEQ PRG003_AF60	 ; 8 ticks on, 8 ticks off; jump to PRG003_AF60
	INY		 ; Y = 1
PRG003_AF60:
	TYA		 
	STA Objects_Frame,X	 ; Update frame

	; Perform the state action of Var4 (0-3)
	LDA <Objects_Var4,X
	AND #$03
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word SidePiranha_HideInPipe	; Piranha hides in pipe until timer expires
	.word SidePiranha_Emerge	; Piranha emerges from pipe
	.word SidePiranha_Chomp		; Piranha sits there and chomps for a bit
	.word SidePiranha_Receed	; Piranha goes back into pipe

SidePiranha_Emerge:
	LDA <Objects_Var5,X
	SUB #25
	CMP <Objects_X,X
	BGE PRG003_AF95	 ; If (Var5 - 25) >= Piranha's X, jump to PRG003_AF95

	LDA #-$10	; Leftward moving piranha
	BNE PRG003_AF8B	 ; Jump (technically always) to PRG003_AF8B

SidePiranha_Receed:
	LDA <Objects_X,X
	ADD #$01
	CMP <Objects_Var5,X
	BGE PRG003_AF95	 ; If piranha's X >= Var5, jump to PRG003_AF95

	LDA #$10	; Rightward moving piranha

PRG003_AF8B:
	STA <Objects_XVel,X	 ; Update X velocity

	JMP Object_ApplyXVel	 ; Apply X velocity and don't come back!

SidePiranha_Chomp:
	LDA Objects_Timer,X
	BNE PRG003_AFA4	 ; If timer not expired, jump to PRG003_AFA4 (RTS)

PRG003_AF95:
	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	; Reset timer to $38
	LDA #$38
	STA Objects_Timer,X

PRG003_AF9C:
	RTS		 ; Return

SidePiranha_HideInPipe:
	LDA Objects_Timer,X
	BNE PRG003_AFA4	 ; If timer not expired, jump to PRG003_AFA4 (RTS)

	BEQ PRG003_AF95	 ; Otherwise, jump to PRG003_AF95

PRG003_AFA4:
	RTS		 ; Return

SidePiranha_EndSprXOff:
	.byte 16, 0

SidePiranha_Draw:
	LDA #$20	 ; A = $20 (leftward piranha attributes)

	LDY Level_ObjectID,X
	CPY #OBJ_PIRANHASIDEWAYSLEFT
	BEQ PRG003_AFB2	 ; If this is a leftward piranha, jump to PRG003_AFB2

	LDA #$60	 ; A = $60 (rightward piranha attributes)

PRG003_AFB2:
	STA Objects_FlipBits,X	 ; Set piranha attributes

	LDA <Objects_X,X
	PHA		 ; Save piranha's X

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG003_AFC9	 ; If piranha is not horizontally flipped, jump to PRG003_AFC9

	ASL Objects_SprHVis,X

	; Piranha's X += 8 (Piranha is 24 pixels wide, of which there's no routine for exactly)
	LDA <Objects_X,X
	ADD #$08
	STA <Objects_X,X

PRG003_AFC9:
	JSR Object_ShakeAndDraw	 ; Draw most of piranha

	PLA		 ; Restore 'X'
	STA <Objects_X,X	 ; -> 'X'

	JSR Object_CalcSpriteXY_NoHi

	LDY #$00	 ; Y = 0

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG003_AFDC	 ; If piranha is NOT horizontally flipped, jump to PRG003_AFDC

	INY		 ; Y = 1

PRG003_AFDC:
	LDA <Objects_SpriteX,X	 ; Get piranha's sprite X
	ADD SidePiranha_EndSprXOff,Y
	STA <Temp_Var2		 ; Temp_Var2 = Sprite X for piranha's remaining bit

	; SB: They never implemented horizontal check for this, interestingly
	LDA Objects_SprHVis,X
	AND HPiranha_MaskBits,Y
	BNE PRG003_AFFA			; If third sprite is not visible, jump to PRG003_AFFA

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Set sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$13,Y

	; Temp_Var1 = vertical visibility
	LDA Objects_SprVVis,X
	STA <Temp_Var1

	LDA <Objects_SpriteY,X
	LSR <Temp_Var1
	BCS PRG003_AFFA	 ; If piranha's last bit isn't vertically visible, jump to PRG003_AFFA

	STA Sprite_RAM+$10,Y	 ; Otherwise, set the Y

PRG003_AFFA:
	LDA Sprite_RAM+$02,Y	; Get attribute value from earlier piranha segment
	AND #~$03		; Clear palette select
	ORA #SPR_PAL2		; Set palette select 2
	STA Sprite_RAM+$12,Y	; -> Sprite's attribute

	; Use pattern $85
	LDA #$85
	STA Sprite_RAM+$11,Y

	RTS		 ; Return

HPiranha_MaskBits:	.byte %00100000, %10000000

LavaLotus_RightEdgePatTop:	.byte $C1, $C9, $D1
LavaLotus_RightEdgePatBottom:	.byte $C3, $CB, $D3

ObjNorm_LavaLotus:
	JSR Object_CheckIfNormalState
	BNE PRG003_B05F	 ; If not in normal state, jump to PRG003_B05F

	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Player_HaltGame
	BNE PRG003_B05F		; If gameplay is halted, jump to PRG003_B05F

	JSR Player_HitEnemy	 ; Player to Lava Lotus collision

	LDA Objects_SprHVis,X
	AND #%11100000
	CMP #%11100000
	BNE PRG003_B030	 ; If the Lava Lotus does not have three horizontally off-screen sprites, jump to PRG003_B030

	; Var5 = $FF
	LDA #$ff
	STA <Objects_Var5,X

	; Var4 = $05
	LDA #$05
	STA <Objects_Var4,X

PRG003_B030:
	DEC <Objects_Var5,X	 ; Var5--

	LDA <Objects_Var5,X
	CMP #$50
	BLT PRG003_B056	 ; If Var5 < $50, jump to PRG003_B056

	LDY #$00	 ; Y = 0

	AND #%00001100
	BEQ PRG003_B03F	 ; Periodically jump to PRG003_B03F
 
	INY		 ; Y = 1

PRG003_B03F:
	TYA		 
	STA Objects_Frame,X	 ; Set frame 0/1

	LDA Level_NoStopCnt
	AND #$1f
	BNE PRG003_B053	 ; 1:32 ticks proceed, otherwise, jump to PRG003_B053

	LDA <Objects_Var4,X
	BEQ PRG003_B053	 ; If Var4 = 0, jump to PRG003_B053

	DEC <Objects_Var4,X	 ; Var4--

	JSR LavaLotus_SpitFire	 ; Spit a fireball

PRG003_B053:
	JMP PRG003_B05F	; Jump to PRG003_B05F

PRG003_B056:

	; Var4 = 5
	LDA #$05
	STA <Objects_Var4,X

	; Frame = 2 (open lotus)
	LDA #$02
	STA Objects_Frame,X

PRG003_B05F:
	; Clear flip bits
	LDA #$00
	STA Objects_FlipBits,X

	; Draw most of lotus
	JSR Object_Draw16x32Sprite

	LDA Objects_SprHVis,X
	AND #%00100000
	BNE PRG003_B0B1	 ; If edge sprite of lotus is off-screen, jump to PRG003_B0B1 (RTS)

	; Need to draw one more sprite for lotus...

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Right edge sprite, so +16
	LDA <Objects_SpriteX,X
	ADD #16
	STA Sprite_RAM+$13,Y
	STA Sprite_RAM+$17,Y

	; Vertical off-screen bits -> Temp_Var1
	LDA Objects_SprVVis,X
	STA <Temp_Var1

	LDA <Objects_SpriteY,X
	LSR <Temp_Var1	
	BCS PRG003_B08A	 ; If this sprite is vertically off-screen, jump to PRG003_B08A

	STA Sprite_RAM+$10,Y	 ; Store this sprite's Y

PRG003_B08A:
	LSR <Temp_Var1
	BCS PRG003_B094	 ; If this sprite is vertically off-screen, jump to PRG003_B08A

	ADD #16
	STA Sprite_RAM+$14,Y	 ; Store this sprite's Y

PRG003_B094:
	LDA Sprite_RAM+$02,Y	 ; Get sprite attributes from left edge
	ORA #SPR_HFLIP
	STA Sprite_RAM+$12,Y	 ; Horizontally flipped compared to left edge
	STA Sprite_RAM+$16,Y	 ; Horizontally flipped compared to left edge

	LDA Objects_Frame,X
	TAX
	LDA LavaLotus_RightEdgePatTop,X	
	STA Sprite_RAM+$11,Y	 ; Set top pattern

	LDA LavaLotus_RightEdgePatBottom,X
	STA Sprite_RAM+$15,Y	 ; Set bottom pattern

	LDX <SlotIndexBackup		 ; X = object slot index

PRG003_B0B1:
	RTS		 ; Return

LavaLotusFire_XOff:	.byte $03, $0D, $06, $0B, $08
LavaLotusFire_XVel:	.byte $FB, $05, $FD, $03, $00
LavaLotusFire_YVel:	.byte $F5, $F5, $F0, $F0, $EE

LavaLotus_SpitFire:
	JSR Object_AnySprOffscreen
	BNE PRG003_B0D0	 ; If any part of Lava Lotus is off-screen, jump to PRG003_B0D0 (RTS)

	LDY #$07	 ; Y = 7

	; This loop really could be replaced by 
	;JSR SpecialObj_FindEmptyAbortY

PRG003_B0C8:
	LDA SpecialObj_ID,Y
	BEQ PRG003_B0D1	 ; If this special object slot is free, jump to PRG003_B0D1

	DEY		 ; Y--
	BPL PRG003_B0C8	; If Y >= 0, loop!

PRG003_B0D0:
	RTS		 ; Return

PRG003_B0D1:

	; Lava Lotus fireball
	LDA #SOBJ_LAVALOTUSFIRE
	STA SpecialObj_ID,Y

	LDA #$c0
	STA SpecialObj_Var2,Y

	; Fireball at Y + 7
	LDA <Objects_Y,X
	ADD #$07
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA SpecialObj_YHi,Y

	; Temp_Var1 = Var4 (which fireball we're on)
	LDA <Objects_Var4,X
	STA <Temp_Var1

	; Fireball X
	LDA <Objects_X,X
	CLC	
	LDX <Temp_Var1		 ; X = Temp_Var1 (Var4)
	ADC LavaLotusFire_XOff,X
	STA SpecialObj_XLo,Y

	; Fireball Y velocity
	LDA LavaLotusFire_YVel,X
	STA SpecialObj_YVel,Y

	; Fireball X velocity
	LDA LavaLotusFire_XVel,X
	STA SpecialObj_XVel,Y

	; Fireball data = 1
	LDA #$01
	STA SpecialObj_Data,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	; Store parent's object index into SpecialObj_Var1
	TXA
	STA SpecialObj_Var1,Y

	RTS		 ; Return

ObjInit_LavaLotus:

	; Var5 = $FF
	LDA #$ff
	STA <Objects_Var5,X

	; Var4 = 5
	LDA #$05
	STA <Objects_Var4,X

	; Mark object as in water
	INC Objects_InWater,X

ObjInit_WaterCurrent:
	RTS		 ; Return

CurrentUpward_YAccel:	.byte -$03, -$03, -$02, -$01, $00, $00, $00, $00, $00
CurrentDownward_YAccel:	.byte  $03,  $02,  $01,  $00, $00, $00, $00, $00, $00

ObjNorm_WaterCurrent:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	JSR Object_AnySprOffscreen
	ORA <Player_HaltGame
	BNE PRG003_B197	 ; If object falls off-screen or gameplay is halted, jump to PRG003_B197

	JSR Level_ObjCalcXDiffs

	LDA <Temp_Var16
	ADD #$08
	CMP #$20
	BGE PRG003_B18C	 ; If Player is not close enough, jump to PRG003_B18C

	JSR Level_ObjCalcYDiffs

	LDA Level_ObjectID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BEQ PRG003_B157	 ; If this is a downward current, jump to PRG003_B157

	; For upward current...

	; Negate Temp_Var16
	LDA <Temp_Var16	
	JSR Negate	
	STA <Temp_Var16	
	DEY		 ; Y-- (change direction)

PRG003_B157:
	CPY #$00
	BNE PRG003_B18C	 ; If Player is on wrong side of current object, jump to PRG003_B18C

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = index relative of Player's Y offset

	LDA Level_ObjectID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BNE PRG003_B177	 ; If this is not a downard current, jump to PRG003_B177

	; Downward current...

	LDA <Player_YVel
	CMP #$3b
	BGS PRG003_B18C	 ; If Player's Y velocity >= $3B, jump to PRG003_B18C

	ADD CurrentDownward_YAccel,Y	 ; Push Player downward

	JMP PRG003_B186	 ; Jump to PRG003_B186

PRG003_B177:
	LDA Player_HitCeiling
	BNE PRG003_B18C	 ; If Player just hit off ceiling, jump to PRG003_B18C

	LDA <Player_YVel
	CMP #-$3C
	BMI PRG003_B18C	 ; If Player's Y velocity is already moving faster than -$3C, jump to PRG003_B18C

	ADD CurrentUpward_YAccel,Y	 ; Push Player upward

PRG003_B186:
	STA <Player_YVel	; Update Player's Y velocity

	; Flag Player as mid-air
	LDA #$01
	STA <Player_InAir

PRG003_B18C:
	INC <Objects_Var5,X	 ; Var5++

	LDA <Objects_Var5,X
	AND #$0f
	BNE PRG003_B197	 ; 1:16 ticks proceed, otherwise jump to PRG003_B197

	JSR Current_GenerateBubble	; Generate a bubble

PRG003_B197:
	RTS		 ; Return

Current_GenerateBubble:
	LDY #$05
	JSR SpecialObj_FindEmptyAbortY	; Find a free special object in one of the first two slots or don't come back!

	; SpecialObj_Timer = $28
	LDA #$28
	STA SpecialObj_Timer,Y

	; A bubble
	LDA #SOBJ_BUBBLE
	STA SpecialObj_ID,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data,Y

	STY <Temp_Var1	 ; Special object index -> Temp_Var1

	; Apply a bit of randomness to the bubble's X
	TYA
	ADC RandomN,Y
	AND #$17
	ADD <Objects_X,X
	LDY <Temp_Var1		 ; Y = special object index
	STA SpecialObj_XLo,Y	 ; Store slightly random adjusted X -> Bubble X

	LDA Level_ObjectID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BEQ PRG003_B1D7	 ; If this is a downard current, jump to PRG003_B1D7

	; Bubble appears at Y - 8
	LDA <Objects_Y,X
	SBC #$08
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	; Bubble's Y velocity = -$80
	LDA #-$80
	STA SpecialObj_YVel,Y

	RTS		 ; Return

PRG003_B1D7:
	; Bubble appears at Y + 3
	LDA <Objects_Y,X
	ADC #$03
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X	; Bug? They don't apply the carry (ADC) here!
	STA SpecialObj_YHi,Y

	; Bubble's Y velocity = $7F
	LDA #$7f
	STA SpecialObj_YVel,Y

	RTS		 ; Return




CheepCheepHopper_InitXVel:	.byte $0C, -$0C

ObjInit_CheepCheepHopper:
	JSR Level_ObjCalcXDiffs

	; Set hopper's initial X velocity
	LDA CheepCheepHopper_InitXVel,Y
	STA <Objects_XVel,X


ObjNorm_CheepCheepHopper:
	JSR Object_DeleteOffScreen	; Delete object if it falls too far off-screen
	JSR Object_SetHFlipByXVel 	; Set horizontal flip by travel direction
	JSR Object_ShakeAndDraw	 	; Draw Cheep Chep

	LDA <Player_HaltGame
	BNE PRG003_B47A	 ; If gameplay is halted, jump to PRG003_B47A

	JSR Object_Move	 	; Do standard movements
	JSR Player_HitEnemy	 ; Player to Cheep Cheep collision

	LDA Objects_InWater,X
	BEQ PRG003_B471	 	; If Cheep Cheep is NOT in water, jump to PRG003_B471

	JSR Level_ObjCalcXDiffs	

	LDY #-$30	 ; Y = -$30

	LDA <Temp_Var16
	ADD #$40
	CMP #$80
	BGE PRG003_B46F	 ; If Cheep Cheep is not close enough to Player, jump to PRG003_B46F

	LDY #-$60	 ; Otherwise, Y = -$60
PRG003_B46F:
	STY <Objects_YVel,X	 ; Update Y velocity

PRG003_B471:

	; Toggle frame 0/1
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

PRG003_B47A:
	RTS		 ; Return


ObjInit_Blooper:
	RTS		 ; Return

ObjInit_BlooperWithKids:

	; Var7 = 4 (kids left)
	LDA #$04
	STA Objects_Var7,X

	JSR Object_InitTailBuffer	 ; Initialize tail buffer (if no buffer available, will be destroyed and won't come back)

	RTS		 ; Return

Blooper_YVelAccel:	
	.byte $02, -$02

Blooper_YVelLimit:
	.byte $24, -$24

PRG003_B763:
	.byte $00, $10, $00, $01, $FF

Blooper_FlipTowardsPlayer:
	.byte SPR_HFLIP, $00

ObjNorm_Blooper:
	LDA Level_ObjectID,X
	CMP #OBJ_BLOOPER
	BNE PRG003_B781	 ; If this is not a straight Blooper, jump to PRG003_B781

	; Just a regular Blooper...

	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Player_HaltGame
	BEQ PRG003_B77B	 ; If gameplay is not halted, jump to PRG003_B77B

	JMP Object_ShakeAndDrawMirrored	 ; Otherwise, draw Blooper and don't come back!

PRG003_B77B:
	JSR Player_HitEnemy	 ; Do Player to Blooper hit detection!
	JMP PRG003_B78B	 ; Jump to PRG003_B78B

PRG003_B781:
	JSR TailEnemy_DoStandard	 ; A Blooper with kids... gotta do Tail updates!

	LDA <Player_HaltGame
	BEQ PRG003_B78B	 ; If gameplay is not halted, jump to PRG003_B78B

	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_B78B:
	LDA Objects_Timer,X
	BEQ PRG003_B7A2	 ; If timer = 0, jump to PRG003_B7A2

	STA Objects_ColorCycle,X	; Cycle colors

	CMP #$01
	BNE PRG003_B79F	 ; If timer <> 1, jump to PRG003_B79F

	; Var7 = 0
	LDA #$00
	STA Objects_Var7,X

	JSR Blooper_LaunchKids	 ; Blooper launches off his four spawn

PRG003_B79F:
	JMP PRG003_B85C	 ; Jump to PRG003_B85C

PRG003_B7A2:
	LDA <Objects_Var5,X
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA <Objects_YVel,X
	ADD Blooper_YVelAccel,Y
	STA <Objects_YVel,X

	CMP Blooper_YVelLimit,Y
	BNE PRG003_B7B6	 ; If Blooper is not at his velocity limit, jump to PRG003_B7B6

	INC <Objects_Var5,X	 ; Otherwise, Var5++

PRG003_B7B6:
	LDA <Objects_YVel,X

	LDY Objects_FlipBits,X
	BEQ PRG003_B7C0	 ; If Blooper is not flipped, jump to PRG003_B7C0

	JSR Negate	 ; Otherwise, negate Y velocity

PRG003_B7C0:
	LDY <Objects_YVel,X
	BMI PRG003_B7DD	 ; If Bloope is moving upward, jump to PRG003_B7DD

	TXA
	LSR A
	BCC PRG003_B7D2	 ; If Blooper is an "even" slot, jump to PRG003_B7D2

	LDY #$00	 ; Y = 0

	LDA <Player_FlipBits
	BNE PRG003_B7CF	 ; If Blooper is flipped, jump to PRG003_B7CF

	INY		 ; Y = 1

PRG003_B7CF:
	JMP PRG003_B7D5	 ; Jump to PRG003_B7D5

PRG003_B7D2:
	JSR Level_ObjCalcXDiffs

PRG003_B7D5
	; Blooper faces Player
	LDA Blooper_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	LDA #$00	 ; A = 0

PRG003_B7DD:
	STA <Objects_XVel,X	 ; Update X Velocity

	JSR Object_WorldDetectN1	 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$03
	BNE PRG003_B7EB	 ; If Blooper hit a wall, jump to PRG003_B7EB

	JSR Object_ApplyXVel	 ; Otherwise, apply X Velocity

PRG003_B7EB:
	LDA <Objects_YVel,X
	PHA		 ; Save Y velocity

	CMP #$08
	BLS PRG003_B814	 ; If Y velocity < $08, jump to PRG003_B814

	LDA <Player_Y	
	PHA		 ; Save Player's Y

	SBC #23
	STA <Player_Y	 ; Subtract 23 from Player's Y

	LDA <Player_YHi
	PHA		 ; Save Player Y Hi
	SBC #$00	 ; Apply carry
	STA <Player_YHi	

	JSR Level_ObjCalcYDiffs

	; Restore Player Y/Hi
	PLA
	STA <Player_YHi
	PLA
	STA <Player_Y

	DEY		 ; Y--
	BEQ PRG003_B810	 ; If Y = 0, jump to PRG003_B810

	PLA		 ; Restore Y velocity

	LDA #$08
	PHA		 ; Save 8 instead

PRG003_B810:
	; Set velocity to $08
	LDA #$08
	STA <Objects_YVel,X

PRG003_B814:
	LDA <Objects_DetStat,X
	AND #$0c
	BNE PRG003_B826	 ; If Blooper hit floor or ceiling, jump to PRG003_B826

	LDA <Objects_YVel,X
	BPL PRG003_B823	 ; If Blooper is not moving upward, jump to PRG003_B823

	LDA Objects_InWater,X
	BEQ PRG003_B826	 ; If Blooper is not in water, jump to PRG003_B826

PRG003_B823:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity

PRG003_B826:
	PLA		 ; Restore Y Velocity
	STA <Objects_YVel,X	 ; Update Y Veocity

	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA #$01	; A = 1

	LDY <Objects_YVel,X
	BPL PRG003_B833	 ; If Blooper is not moving upward, jump to PRG003_B833

	LSR A		; A = 0

PRG003_B833:
	STA Objects_Frame,X	 ; Set frame based on movement

	LDA Level_ObjectID,X
	CMP #OBJ_BLOOPER
	BEQ PRG003_B85F	 ; If this is a normal Blooper, jump to PRG003_B85F

	CMP #OBJ_BLOOPERCHILDSHOOT
	BNE PRG003_B85C	 ; If this is NOT a Blooper that launches children, jump to PRG003_B85C

	INC Objects_Var2,X	; Var2++

	LDA Objects_Var2,X
	AND #$3f
	BNE PRG003_B85C	 ; If Var2 hasn't hit 64 ticks yet, jump to PRG003_B85C

	LDA Objects_Var7,X
	CMP #$04
	BNE PRG003_B859	 ; If Var7 <> 4, jump to PRG003_B859

	; After all this, set timer to $40
	LDA #$40
	STA Objects_Timer,X

	BNE PRG003_B85C	 ; Jump (technically always) to PRG003_B85C

PRG003_B859:
	INC Objects_Var7,X	 ; Var7++

PRG003_B85C:
	JMP Tail_DrawAndHurtPlayer	 ; Jump to Tail_DrawAndHurtPlayer

PRG003_B85F:
	JMP Object_ShakeAndDrawMirrored	 ; Draw Blooper and don't come back!

BlooperKid_YVel:	.byte $F8, $08, $08, $F8
BlooperKid_XVel:	.byte $08, $08, $F8, $F8
BlooperKid_Data:	.byte $00, $00, $01, $01
BlooperKid_UNKD:	.byte $00, $01, $01, $00

Blooper_LaunchKids:

	; Temp_Var1 = 3
	LDA #$03
	STA <Temp_Var1

PRG003_B876:
	JSR SpecialObj_FindEmptyAbort

	; Blooper child
	LDA #SOBJ_BLOOPERKID
	STA SpecialObj_ID,Y

	; Blooper child X
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Blooper child Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y

	; Blooper child Y Hi
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	LDX <Temp_Var1	 ; X = Temp_Var1

	LDA BlooperKid_YVel,X
	STA SpecialObj_YVel,Y

	LDA BlooperKid_XVel,X
	STA SpecialObj_XVel,Y

	LDA BlooperKid_Data,X
	STA SpecialObj_Data,Y

	LDA BlooperKid_UNKD,X
	STA SpecialObj_Var1,Y

	LDA #$ff
	STA SpecialObj_Timer,Y

	LDX <SlotIndexBackup	 ; X = object slot index
	DEC <Temp_Var1		 ; Temp_Var1--
	BPL PRG003_B876	 ; While Temp_Var1 >= 0, loop 

	RTS		 ; Return

Object_SetHFlipByXVel:
	; Clear horizontal flip
	LDA Objects_FlipBits,X	 
	AND #~SPR_HFLIP

	LDY <Objects_XVel,X
	BEQ PRG003_B8C6		; If not moving horizontally, jump to PRG003_B8C6
	BMI PRG003_B8C3		; If moving leftward, jump to PRG003_B8C3

	; Moving to the right
	ORA #SPR_HFLIP	 ; Set horizontal flip

PRG003_B8C3:
	STA Objects_FlipBits,X	 ; Update flip bits

PRG003_B8C6:
	RTS		 ; Return

	; Temp_Var2 is an X input
	; I don't really understand this function, but it determines horizontal
	; visibility by Sprite X somehow. Carry set if not visible.
Sprite_NoCarryIfVisible:
	LDA Objects_SprVVis,X	 
	BNE PRG003_B8E7	 ; If any of the sprites are vertically off-screen, jump to PRG003_B8E7

	LDA <Objects_SpriteY,X
	CMP #208
	BGE PRG003_B8E7	 ; If sprite Y >= 208, jump to PRG003_B8E7

	LDY #$40	 ; Y = $40

	LDA <Objects_SpriteX,X
	BMI PRG003_B8DA	 ; If sprite X >= $80, jump to PRG003_B8DA

	LDY #$C0	 ; Y = $C0

PRG003_B8DA:
	CPY <Temp_Var2	 ; Compare $40 or $C0 to input X value

	EOR Objects_SprHVis,X

	BMI PRG003_B8E5	 ; If there are inappropriate horizontally off-screen sprites (??) jump to PRG003_B8E5

	BLT PRG003_B8E7	 ; If input X value < 'Y', jump to PRG003_B8E7 (carry clear, but will set carry)
	BGE PRG003_B8E9	 ; If input X value >= 'Y', jump to PRG003_B8E9 (carry set, but will be clear)

PRG003_B8E5:
	BLT PRG003_B8E9	 ; If input X value < 'Y', jump to PRG003_B8E9 (carry clear)

PRG003_B8E7:
	SEC		 ; Set carry
	RTS		 ; Return

PRG003_B8E9:
	CLC		 ; Clear carry
	RTS		 ; Return

ObjInit_FireSnake:
	JSR Object_InitTailBuffer	 ; Initialize tail buffer (if no buffer available, will be destroyed and won't come back)

	; Set X velocity = 0
	LDA #$00
	STA <Objects_XVel,X

	BEQ PRG003_B96E	 ; Jump (technically always) to PRG003_B96E

ObjInit_FireChomp:
	JSR Object_InitTailBuffer	 ; Initialize tail buffer (if no buffer available, will be destroyed and won't come back)

	; Var5 = random value 
	LDA RandomN,X
	STA <Objects_Var5,X

PRG003_B96E:
	; Var7 = 4
	LDA #$04
	STA Objects_Var7,X

	RTS		 ; Return

	; Initializes the buffer which holds "tail" X and Y coordinates
Object_InitTailBuffer:
	LDY #$01	 ; Y = 1
PRG003_B976:
	LDA Buffer_Occupied,Y
	BEQ PRG003_B983	 ; If this buffer slot is empty, jump to PRG003_B983

	DEY		 ; Y--
	BPL PRG003_B976	 ; While Y >= 0, loop!

	; Giving up...

	; Do NOT return to caller
	PLA
	PLA
	JMP Object_SetDeadAndNotSpawned	; Fire Chomp can't be created...

PRG003_B983:
	; Mark buffer slot as occupied
	LDA #$01
	STA Buffer_Occupied,Y

	JSR Object_CalcSpriteXY_NoHi

	; Sprite Y -> Temp_Var1
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; Sprite X -> Temp_Var2
	LDA <Objects_SpriteX,X
	STA <Temp_Var2

	TYA		
	STA Objects_Var6,X	 ; Store Buffer_Occupied slot index -> Var6

	LSR A
	ROR A
	LSR A
	LSR A	; A = $00 or $20

	; Copy sprite X and Y into buffer space
	TAX		 ; -> 'X'
	LDY #$1f	 ; Y = $1F
PRG003_B99E:
	LDA <Temp_Var1
	STA Object_BufferY,X
	LDA <Temp_Var2
	STA Object_BufferX,X

	INX		 ; X++

	DEY		 ; Y--
	BPL PRG003_B99E	 ; While Y >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

	RTS		 ; Return


ObjNorm_FireChomp:
	JSR TailEnemy_DoStandard	 ; Do standard tailed enemy states

	LDA <Player_HaltGame
	BEQ PRG003_B9D4	 ; If gameplay is not halted, jump to PRG003_B9D4

	JMP PRG003_BD92	 ; Jump (indirectly) to PRG003_BB17 (draws enemy) and don't come back!

PRG003_B9D4:

	; Set frame 0
	LDA #$00
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BEQ PRG003_BA08	 ; If timer expired, jump to PRG003_BA08

	CMP #$10
	BNE PRG003_B9F2	 ; If timer <> $10, jump to PRG003_B9F2

	DEC Objects_Var7,X	 ; Var7--
	BNE PRG003_B9EF	 ; If Var7 <> 0, jump to PRG003_B9EF

	; Strips bit 0 off of X velocity?
	LSR <Objects_XVel,X
	ASL <Objects_XVel,X

	; Var4 = $FF
	LDA #$ff
	STA <Objects_Var4,X

PRG003_B9EF:
	JSR FireChomp_SpitFire	 ; Spit fire towards Player

PRG003_B9F2:

	; Gaping mouth
	INC Objects_Frame,X

	LDA Objects_Timer,X
	SUB #$08
	CMP #$10
	BGE PRG003_BA02	 ; If timer >= $18, jump to PRG003_BA02

	INC Objects_Frame,X	 ; Mouth open all the way

PRG003_BA02:
	JSR TailEnemy_MoveTailWithScroll	 ; Update tail with scroll
	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_BA08:
	JSR FireChomp_MoveAndExplodeDeath	 ; Move and explode when out of fire balls!

Enemy_DeleteIfOffAndDrawTail:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JMP Tail_DrawAndHurtPlayer	 ; Jump to Tail_DrawAndHurtPlayer

FireChomp_XVelLimit:	.byte $0A, -$0A, $10, -$10
FireChomp_XVelAccel:	.byte $01, -$01, $01, -$01

FireChomp_FlipTowardsPlayer:	.byte SPR_HFLIP, $00

FireChomp_YVelLimit:	.byte $12, -$12
FireChomp_YVelAccel:	.byte $01, -$01

FireChomp_MoveAndExplodeDeath:
	LDA <Objects_Var4,X	 
	BEQ PRG003_BA38	 ; If Var4 = 0, jump to PRG003_BA38

	DEC <Objects_Var4,X	 ; Var4--

	CMP #$40
	BGE PRG003_BA4C	 ; If Var4 >= $40, jump to PRG003_BA4C

	STA Objects_ColorCycle,X	 ; Cycle colors

	CMP #$01
	BNE PRG003_BA4C	 ; If Var4 <> 1, jump to PRG003_BA4C

	; Turn into a Bob-omb (for the explosion!)
	LDA #OBJ_BOBOMB
	STA Level_ObjectID,X

	JMP BobOmb_Explode	 ; Jump to BobOmb_Explode (do Bob-omb's explosion routine)

PRG003_BA38:

	; Var4 = 0...

	INC Objects_Var2,X	 ; Var2++

	LDA Objects_Var2,X
	AND #$7f
	BNE PRG003_BA4C	 ; 128 ticks on, 128 ticks off; jump to PRG003_BA4C

	LDA Objects_Var7,X
	BEQ PRG003_BA4C	 ; If Var7 = 0, jump to PRG003_BA4C

	; Timer = $20
	LDA #$20
	STA Objects_Timer,X

PRG003_BA4C:
	JSR Level_ObjCalcXDiffs

	; Face Player
	LDA FireChomp_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	LDA Objects_Var7,X
	BNE PRG003_BA5C	 ; If Var7 <> 0, jump to PRG003_BA5C

	; Y += 2
	INY
	INY

PRG003_BA5C:
	INC Objects_Var3,X	 ; Var3++

	LDA Objects_Var3,X
	LSR A
	BCC PRG003_BA72	 ; Every other tick, jump to PRG003_BA72

	LDA <Objects_XVel,X
	CMP FireChomp_XVelLimit,Y
	BEQ PRG003_BA72	 ; If Fire Chomp's X velocity is at limit, jump to PRG003_BA72

	; Otherwise, accelerate!
	ADD FireChomp_XVelAccel,Y
	STA <Objects_XVel,X

PRG003_BA72:
	JSR Object_ApplyXVel	 ; Apply X velocity

	LDA <Player_Y
	PHA		 ; Save Player's Y

	ADD #$00	; Add ... zero?
	STA <Player_Y	; Update Player's Y (pointless!)

	LDA <Player_YHi
	PHA		 ; Save Player's Y Hi

	ADC #$00	 ; Apply carry
	STA <Player_YHi	 ; Update Player's Y Hi

	JSR Level_ObjCalcYDiffs

	PLA		 
	STA <Player_YHi	; Restore Player's Y Hi

	PLA
	STA <Player_Y	; Restore Player's Y

	LDA Objects_Var3,X
	LSR A
	BCC PRG003_BAA0	 ; Every other count of Var3, jump to PRG003_BAA0

	LDA <Objects_YVel,X
	CMP FireChomp_YVelLimit,Y
	BEQ PRG003_BAA0	 ; If Fire Chomp's Y velocity is at limit, jump to PRG003_BAA0

	; Otherwise, accelerate!
	ADD FireChomp_YVelAccel,Y
	STA <Objects_YVel,X

PRG003_BAA0:
	JMP Object_ApplyYVel_NoLimit	 ; Apply Y velocity and don't come back!

	; Moves all tail segments based on screen scroll change
TailEnemy_MoveTailWithScroll:

	; Essentially shift Var6 left 5 places, so A = $00 or $20 (buffer offset)
	LDA Objects_Var6,X
	LSR A
	ROR A
	LSR A
	LSR A

	ADD #31		; +31
	TAY		; -> 'Y'

	LDX #$1f	 ; X = $1F (all buffer entries)
PRG003_BAB0:
	; Update X by scroll
	LDA Object_BufferX,Y 
	SUB Level_ScrollDiffH
	STA Object_BufferX,Y

	; Update Y by scroll
	LDA Object_BufferY,Y
	SUB Level_ScrollDiffV
	STA Object_BufferY,Y

	DEY		 ; Y-- (previous buffer)
	DEX		 ; X-- (decrement counter)
	BPL PRG003_BAB0	; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

FireChompTail_Patterns:
	.byte $65, $67, $65, $67

FireChompTail_Attributes:
	.byte SPR_PAL1, SPR_PAL1, SPR_HFLIP | SPR_VFLIP | SPR_PAL1, SPR_HFLIP | SPR_VFLIP | SPR_PAL1


	; For objects which have "tails", like the Fire Snake, Blooper w/ kids, etc.
Tail_DrawAndHurtPlayer:
	JSR Object_DetermineHorzVis	 ; Determine is object is horizontally visible

	; Essentially shift Var6 left 5 places, so A = $00 or $20 (buffer offset)
	LDA Objects_Var6,X
	LSR A
	ROR A
	LSR A
	LSR A

	PHA	; Save offset
	TAY	; -> 'Y'

	; Set buffer X
	LDA <Objects_X,X
	SUB <Horz_Scroll
	ADD Level_ScrollDiffH
	STA Object_BufferX,Y

	; Set buffer Y
	LDA <Objects_Y,X
	SUB Level_VertScroll
	ADD Level_ScrollDiffV
	STA Object_BufferY,Y

	PLA		 ; Restore offset
	ADD #$1e	 ; Add $1E (other end of the buffer)

	TAY		 ; -> 'Y'

	LDX #$1e	 ; X = $1E (going to work backward)
PRG003_BAFF:
	; Subtract and push down the line X
	LDA Object_BufferX,Y 
	SUB Level_ScrollDiffH
	STA Object_BufferX+1,Y

	; Subtract and push down the line Y
	LDA Object_BufferY,Y
	SUB Level_ScrollDiffV
	STA Object_BufferY+1,Y

	DEY		 ; Y-- (previous buffer byte)
	DEX		 ; X-- (previous buffer count)
	BPL PRG003_BAFF	 ; While X >= 0, loop!

PRG003_BB17:
	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X
	CMP #OBJ_BLOOPERCHILDSHOOT
	BEQ PRG003_BB24	 ; If this is a Blooper who launches off kids, jump to PRG003_BB24

	CMP #OBJ_BLOOPERWITHKIDS
	BNE PRG003_BB2A	 ; If this is not a Blooper w/ kids, jump to PRG003_BB2A

PRG003_BB24:
	JSR Object_ShakeAndDrawMirrored	 ; Draw object
	JMP PRG003_BB36	 ; Jump to PRG003_BB36

PRG003_BB2A:
	CMP #OBJ_FIRECHOMP
	BNE PRG003_BB33	 ; If this is not a Fire Chomp, jump to PRG003_BB33

	; For a Fire Chomp....

	LDA Objects_Frame,X
	BEQ PRG003_BB24	 ; If frame = 0, jump to PRG003_BB24

PRG003_BB33:
	JSR Object_ShakeAndDraw	 ; Draw object, not mirrored

PRG003_BB36:
	LDA Object_SprRAM,X
	ADD #$08
	STA <Temp_Var5		 ; Temp_Var5 = Sprite_RAM offset two bytes over

	; Essentially shift Var6 left 5 places, so A = $00 or $20 (buffer offset)
	LDA Objects_Var6,X
	LSR A
	ROR A
	LSR A
	LSR A

	ADD #$07
	STA <Temp_Var4		 ; Temp_Var4 = offset 7 bytes into the X/Y buffer

	LDA Objects_Var7,X
	BNE PRG003_BB52	 ; If Var7 <> 0, jump to PRG003_BB52

	JMP PRG003_BBF5	 ; Jump to PRG003_BBF5

PRG003_BB52:
	STA <Temp_Var16		 ; Var7 -> Temp_Var16 (Tail length)


	; TAIL DRAW / HURT LOGIC
	; The following 

PRG003_BB54:
	LDY <Temp_Var4		 ; Y = offset into X/Y Buffer

	; Temp_Var1 = Buffer Y @ Temp_Var4
	LDA Object_BufferY,Y
	STA <Temp_Var1	

	; Temp_Var2 = Buffer X @ Temp_Var4 + 4
	LDA Object_BufferX,Y
	ADD #$04
	STA <Temp_Var2

	JSR Sprite_NoCarryIfVisible
	BCS PRG003_BBE0	 ; If carry set, sprite is not visible, jump to PRG003_BBE0

	LDY <Temp_Var5		 ; Y = Temp_Var5 (Sprite_RAM offset)

	; Store Y and X into sprite RAM
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	LDA Level_ObjectID,X
	CMP #OBJ_BLOOPERWITHKIDS
	BGE PRG003_BBBE	 ; Basically if a Blooper jump to PRG003_BBBE

	; Fire Snake, Fire Chomp, or freed Chain Chomp

	CMP #OBJ_FIRECHOMP
	BNE PRG003_BB9B	 ; If not a Fire Chomp, jump to PRG003_BB9B

	; Fire Chomp only

	LDA <Temp_Var16
	ASL A
	ADC Level_NoStopCnt
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3

	LDA FireChompTail_Patterns,X
	STA Sprite_RAM+$01,Y

	LDA FireChompTail_Attributes,X
	STA Sprite_RAM+$02,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	JMP PRG003_BBDD	 ; Jump to PRG003_BBDD

PRG003_BB9B:

	; Fire snake

	; Sets the carry
	LDA Level_NoStopCnt
	LSR A
	LSR A

	; Something removed here
	NOP
	NOP

	LDA #$8b	 ; A = $8B
	BCC PRG003_BBAC	 ; 4 ticks on, 4 ticks off; jump to PRG003_BBAC

	LDA #$89	 ; A = $89

PRG003_BBAC:
	STA Sprite_RAM+$01,Y	 ; Store pattern $89 or $8B

	JMP PRG003_BBD2	 ; Jump to PRG003_BBD2



PRG003_BBBE:
	LDA <Temp_Var16
	ASL A	
	ADC Level_NoStopCnt

	LDX #$b5	 ; X = $B5

	AND #$08
	BNE PRG003_BBCC	 ; 8 ticks on, 8 ticks off; jump to PRG003_BBCC

	LDX #$b7	 ; X = $B7

PRG003_BBCC:
	TXA		 ; Pattern -> 'X'
	STA Sprite_RAM+$01,Y	 ; Set pattern

	LDX <SlotIndexBackup	 ; X = object slot index
PRG003_BBD2:
	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Copies attribute from one sprite to the other
	LDA Sprite_RAM+$02,Y
	LDY <Temp_Var5
	STA Sprite_RAM+$02,Y

PRG003_BBDD:
	JSR Tail_CheckHurtPlayer	; Have the tail hurt the Player by touching it

PRG003_BBE0:
	LDA <Temp_Var4
	ADD #$08
	STA <Temp_Var4

	LDA <Temp_Var5
	ADD #$04
	STA <Temp_Var5

	DEC <Temp_Var16		 ; Temp_Var16-- (one less tail segment)

	BEQ PRG003_BBF5	 ; If out of segments, jump to PRG003_BBF5
	JMP PRG003_BB54	 ; Otherwise, loop!

PRG003_BBF5:
	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Magiblot_ShootFire:
	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot or don't come back!

	LDA #SND_LEVELPOOF
	STA Sound_QLevel1
	
	BNE Magiblot_ShootfireCont

FireChomp_SpitFire:
	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot or don't come back!
 
Magiblot_ShootfireCont:
	; Fire Chomp's fireball
	LDA #SOBJ_FIRECHOMPFIRE
	STA SpecialObj_ID,Y

	; Calculate a flight path towards Player
	LDA #$14
	JSR BoomBoom_CalcFlightPath

	; Send fireball along flight path
	LDA <Temp_Var1
	STA SpecialObj_YVel,Y
	LDA <Temp_Var2
	STA SpecialObj_XVel,Y

	; Set coordinates as offset from Fire Chomp
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	RTS		 ; Return

Bleck_CalcProjPath:
	LDA #$0f

	; Calculates flying Boom Boom's path so he flies towards Player
BoomBoom_CalcFlightPath:
	STA <Temp_Var2	; Store input value -> Temp_Var2

	; Backup 'X' and 'Y'
	TXA
	PHA
	TYA
	PHA

	JSR Level_ObjCalcYDiffs
	STY <Temp_Var3		 ; Store Y difference indicator -> Temp_Var3

	; Get absolute value of Y difference
	LDA <Temp_Var16
	BPL PRG003_BCAA
	JSR Negate
PRG003_BCAA:
	STA <Temp_Var13		 ; -> Temp_Var13
 
	JSR Level_ObjCalcXDiffs
	STY <Temp_Var4		 ; Store X difference indicator -> Temp_Var4

	; Get absolute value of X difference
	LDA <Temp_Var16
	BPL PRG003_BCB8
	JSR Negate
PRG003_BCB8:
	STA <Temp_Var14		 ; -> Temp_Var14

	LDY #$00	 ; Y = 0
	LDA <Temp_Var14	
	CMP <Temp_Var13	
	BGE PRG003_BCCB	 ; If Y difference >= X difference, jump to PRG003_BCCB

	INY		 ; Y = 1

	; Swap differences (so greater difference will be in Temp_Var14)
	PHA
	LDA <Temp_Var13
	STA <Temp_Var14
	PLA
	STA <Temp_Var13

PRG003_BCCB:
	LDA #$00
	STA <Temp_Var12	; Clear Temp_Var12
	STA <Temp_Var1	; Clear Temp_Var1

	LDX <Temp_Var2		 ; X = Temp_Var2 (original input value)

PRG003_BCD3:
	LDA <Temp_Var12
	ADD <Temp_Var13		; A = Temp_Var12 + Temp_Var13 (the lesser difference)
	CMP <Temp_Var14		
	BLT PRG003_BCE0	 	; If (Temp_Var12 + Temp_Var13) < Temp_Var14 (the greater difference), jump to PRG003_BCE0

	; If (Temp_Var12 + Temp_Var13) >= Temp_Var14

	SBC <Temp_Var14		 ; Subtract total from Temp_Var14
	INC <Temp_Var1		 ; Temp_Var1++

PRG003_BCE0:
	STA <Temp_Var12		 ; Update Temp_Var12 with the previous total
	DEX		 	; X--
	BNE PRG003_BCD3		; While X >= 0, loop!

	TYA		 ; A = 0 or 1
	BEQ PRG003_BCF2	 ; If zero (don't need to swap), jump to PRG003_BCF2

	; Swap Temp_Var1 and Temp_Var2
	LDA <Temp_Var1
	PHA	
	LDA <Temp_Var2
	STA <Temp_Var1
	PLA	
	STA <Temp_Var2

PRG003_BCF2:
	LDA <Temp_Var1		 ; A = Temp_Var1

	LDY <Temp_Var3		 ; Y = Temp_Var3 (Y difference indicator)
	BEQ PRG003_BCFD	 	; If Player was lower than object, jump to PRG003_BCFD

	; Otherwise, negate Temp_Var1
	JSR Negate
	STA <Temp_Var1

PRG003_BCFD:
	LDA <Temp_Var2		 ; A = Temp_Var2

	LDY <Temp_Var4		 ; Y = Temp_Var4 (X difference indicator)
	BEQ PRG003_BD08	 	; If Player was lower than object, jump to PRG003_BD08

	; Otherwise, negate Temp_Var2
	JSR Negate
	STA <Temp_Var2

PRG003_BD08:

	; Restore 'Y' and 'X'
	PLA
	TAY
	PLA
	TAX 

	RTS		 ; Return

Tail_PlayerYOff:	.byte $12, $04	; Offset to Player Sprite Y for small/ducking, or not
Tail_PlayerYLimit:	.byte $0E, $18	; Limit value

	; For enemies with tails (e.g. Fire Snake, Fire Chomp, Blooper with Kids),
	; checks if the Player has touched any part of their tail and should be hurt.
Tail_CheckHurtPlayer:
	LDA <Temp_Var16
	ADD <Counter_1
	LSR A
	BCC PRG003_BD60	 ; Every other tick, jump to PRG003_BD60 (RTS)

	LDA Objects_Var1,X
	BNE PRG003_BD60	 ; If Var1 <> 0, jump to PRG003_BD60 (RTS)

PRG003_BD1E:
	LDY #$00	 ; Y = 0

	LDA <Player_Suit
	BEQ PRG003_BD2A	 ; If Player is small, jump to PRG003_BD2A

	LDA Player_IsDucking
	BNE PRG003_BD2A	 ; If Player is ducking, jump to PRG003_BD2A

	INY		 ; Y = 1

PRG003_BD2A:
	LDA <Temp_Var1
	CMP #$c3
	BGE PRG003_BD60	 ; If Temp_Var1 >= $C3, jump to PRG003_BD60 (RTS)

	ADD #$08
	SUB <Player_SpriteY
	SUB Tail_PlayerYOff,Y
	CMP Tail_PlayerYLimit,Y
	BGE PRG003_BD60	 ; If Player is not in good Y range, jump to PRG003_BD60 (RTS)

	LDA <Temp_Var2
	ADD #$04
	SUB <Player_SpriteX
	SBC #$00
	CMP #$10
	BGE PRG003_BD60	 ; If Player is not in good X range, jump to PRG003_BD60 (RTS)

	LDA Player_StarInv
	BNE PRG003_BD60	 ; If Player is invincible by Starman, jump to PRG003_BD60 (RTS)

Player_HurtIfNotDieOffBehind:
	ORA Player_IsDying  	; If Player is dying...
	ORA Player_OffScreen	; ... off-screen ...
	ORA Player_Behind_En	; ... or behind the scenes ...
	BNE PRG003_BD60	 	; ... jump to PRG003_BD60 (RTS)

	JSR Player_GetHurt	; Otherwise, hurt Player!

PRG003_BD60:
	RTS		 ; Return

FireSnake_XVelTowardsPlayer:	.byte $08, -$08

FireSnake_FrameForTick:	.byte $00, $01, $00, $01

FireSnake_JumpYVel:	.byte -$18, -$24

FireSnake_RandomTimer3Vals:	.byte $50, $70, $00, $70, $50, $00, $00, $00

ObjNorm_FireSnake:
	LDA Objects_FrozenTimer,X
	BEQ FireSnake_OK

	; Cancel frozen state
	LDA #0
	STA Objects_FrozenTimer,X

	JSR Enemy_Kill

FireSnake_OK:
	; Set flip bit for this tick
	LDA <Objects_XVel,X
	LSR A
	AND #SPR_HFLIP
	
	LDY Objects_ReverseGrav,X
	BEQ FireSnake_NotGravFlipped
	
	ORA #SPR_VFLIP
	
FireSnake_NotGravFlipped:
	STA Objects_FlipBits,X

	LDA Level_NoStopCnt
	LSR A
	AND #$03
	TAY		 ; Y = 0 to 3

	; Set frame for this tick
	LDA FireSnake_FrameForTick,Y
	STA Objects_Frame,X

	JSR Object_WorldDetect4	 ; Detect against the world

	JSR TailEnemy_DoStandard	 ; Do standard tailed enemy states

	LDA <Player_HaltGame
	BEQ PRG003_BD95	 ; If gameplay is NOT halted, jump to PRG003_BD95

PRG003_BD92:
	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_BD95:
	LDA Objects_Timer,X
	BNE PRG003_BDE6	 ; If timer not expired, jump to PRG003_BDE6

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	BMI PRG003_BDA8	 ; If Fire Snake is moving upward, jump to PRG003_BDA8

	CMP #$18
	BGE PRG003_BDAA	 ; If Fire Snake is moving at $18 downward, jump to PRG003_BDAA

PRG003_BDA8:
	INC <Objects_YVel,X	 ; Fire Snake's light gravity

PRG003_BDAA:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_BDE6	 ; If Fire Snake has not touched ground, jump to PRG003_BDE6

	LDA Objects_Timer3,X
	BNE PRG003_BDE6	; If timer 3 is not expired, jump to PRG003_BDE6

	; timer = $15
	LDA #$15
	STA Objects_Timer,X

	JSR Object_HitGround	 ; Align Fire Snake to ground

	LDA RandomN,X
	AND #$01
	TAY		 ; Y = 0 or 1, random

	; Fire Snake's random hop
	LDA FireSnake_JumpYVel,Y
	STA <Objects_YVel,X

	JSR Level_ObjCalcYDiffs

	CPY #$00
	BNE PRG003_BDDB	; If Player is lower than Fire Snake, jump to PRG003_BDDB

	LDA RandomN,X
	AND #$07
	TAY		 ; Y = 0 to 7, random

	; Random timer 3 reload value
	LDA FireSnake_RandomTimer3Vals,Y
	STA Objects_Timer3,X

PRG003_BDDB:
	JSR Level_ObjCalcXDiffs

	; Set X velocity towards Player
	LDA FireSnake_XVelTowardsPlayer,Y
	STA <Objects_XVel,X

	JMP PRG003_BDE6	 ; Jump to PRG003_BDE6 (... right down below)

PRG003_BDE6:
	JMP Enemy_DeleteIfOffAndDrawTail	 ; Delete if off-screen, draw tail, and don't come back!

PRG003_BDE9:
	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

TailEnemy_DoStandard:
	LDA Objects_Var1,X
	BEQ TailEnemy_InitOrHalt	 ; If Var1 = 0, jump to TailEnemy_InitOrHalt

	LDY <Player_HaltGame
	BEQ PRG003_BDFA	 ; If gameplay is not halted, jump to PRG003_BDFA

	; Do not return to caller!
	PLA
	PLA

	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_BDFA:
	; Jump based on Var1
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word TailEnemy_InitOrHalt		; 0: Action to take initially or when gameplay is halted
	.word TailEnemy_DrawAndWaitTimer2	; 1: Draws object and waits for timer 2 to expire; WILL NOT RETURN TO CALLER!
	.word TailEnemy_DoDeath			; 2: Does "wiggle death" and draws tail; WILL NOT RETURN TO CALLER!

TailEnemy_InitOrHalt:
	JSR Object_CheckIfNormalState
	BEQ PRG003_BE1D	 ; If in normal state, jump to PRG003_BE1D

	; Not in normal state...

	; Var1 = 1 (next internal state)
	LDA #$01
	STA Objects_Var1,X

	LSR A
	STA <Objects_XVel,X	; Stop horizontal velocity
	STA <Objects_VarBSS+1,X

	; Color cycle!
	LDA #$10
	STA Objects_ColorCycle,X

	; Timer2 = 8
	LDA #$08
	STA Objects_Timer2,X

	RTS		 ; Return

PRG003_BE1D:
	LDA Level_ObjectID,X
	CMP #OBJ_FIRESNAKE
	BNE PRG003_BE27	 ; If this is NOT a Fire Snake, jump to PRG003_BE27

	JMP Object_HandleBumpUnderneath	 ; Otherwise just handle getting bumped underneath and don't come back!

PRG003_BE27:
	JMP Player_HitEnemy	 ; Handle full enemy-to-Player collision and don't come back!

TailEnemy_DrawAndWaitTimer2:
	LDA Objects_Timer2,X	 
	BNE PRG003_BE37	 ; If timer2 is not expired, jump to PRG003_BE37

	INC Objects_Var1,X	 ; Var1++ (next internal state)

	; Timer2 = $FF
	LDA #$ff
	STA Objects_Timer2,X

PRG003_BE37:
	; Do NOT return to caller!
	PLA
	PLA

	JMP Enemy_DeleteIfOffAndDrawTail	; Delete if off-screen, draw tail, and don't come back!

PRG003_BE3A:
	RTS		 ; Return

TailEnemy_DoDeath:
	LDA Objects_Timer2,X
	BNE PRG003_BE52	 ; If timer 2 is not expired, jump to PRG003_BE52

	; Timer 2 expired...

	STA Objects_Var1,X	 ; Var1 = 0 (Return to initial internal state)

	; Removes bit 7 (vertical flip)
	ASL Objects_FlipBits,X
	LSR Objects_FlipBits,X

	; Little hop upward
	LDA #-$10
	STA <Objects_YVel,X

	JMP PRG003_BE37	; Draw tail, Do NOT return to caller, and don't come back!


PRG003_BE52:

	; Sets vertical flip bit 7
	ASL Objects_FlipBits,X
	SEC
	ROR Objects_FlipBits,X

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	BMI PRG003_BE67	 ; If enemy moving upward, jump to PRG003_BE67

	CMP #$18
	BGE PRG003_BE6B	 ; If enemy moving downward >= $18, jump to PRG003_BE6B

PRG003_BE67:
	; Apply gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG003_BE6B:
	LDY #$08	 ; Y = $08

	LDA Level_NoStopCnt
	AND #$08
	BEQ PRG003_BE76	 ; 8 ticks on, 8 ticks off; jump to PRG003_BE76

	LDY #-$08	 ; Y = -$08

PRG003_BE76:
	STY <Objects_XVel,X	 ; Set X velocity as $08 or -$08

	JMP PRG003_BE37	; Draw tail, Do NOT return to caller, and don't come back!


	; 32 Y/X pairs to move in a circle
BooLoop_Offsets:
	.byte 80, 0, 79, 3, 79, 7, 79, 11, 78, 15, 77, 19, 76, 23, 75, 26
	.byte 73, 30, 72, 34, 70, 37, 68, 41, 66, 44, 64, 47, 61, 50, 59, 53
	.byte 56, 56, 53, 59, 50, 61, 47, 64, 44, 66, 41, 68, 37, 70, 34, 72 
	.byte 30, 73, 26, 75, 23, 76, 19, 77, 15, 78, 11, 79, 7, 79, 3, 79

	; Provides an effective modulus for sprite distribution
			;     0  1  2  3  4  
;BooLoop_IndexMod:	.byte 1, 2, 3, 4, 0, 1, 2, 3

ObjNorm_BooLoop:

	LDA <Player_HaltGame
	BNE BooLoop_NoInc	 ; If gameplay halted, jump to PRG003_A3D5

	LDA Level_NoStopCnt
	AND #$03
	BNE BooLoop_NoInc

	; Var += 2
	INC Objects_Var4,X
	INC Objects_Var4,X

BooLoop_NoInc:
	LDA Objects_Var4,X
	STA Objects_Var1,X

	LDA #6
	STA Objects_Var2,X

BooLoop_AllBoos:
	LDA Objects_Var1,X
	JSR BooLoop_DoABoo

	; PROBLEM: Each SMB3 object is only allocated six 8x16 sprites
	; This is only enough for 3 Boos; but we need 7 Boos!
	; To get 4 more, we're going to steal from the other main objects
	; on the off-chance they won't require their last 2 sprites.
	; It's not a great system but prudent object placement should
	; make it work out okay...

	; Loop count 6,5,4 we can use our own allocated sprites
	; By this point of course we've already drawn the Boo 
	; at the index, so for index 6 and 5 only we simply add
	; 8 to Object_SprRAM to get the next two sprites...
	LDA Objects_Var2,X
	BEQ BooLoop_DrawLoop		; If on index zero, there's nothing really to do, jump to BooLoop_DrawLoop
	CMP #5
	BLT BooLoop_UseOtherSprs	; If loop index is 1 to 4, jump to BooLoop_UseOtherSprs

	; Two sprites over
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	BNE BooLoop_DrawLoop	; Jump (technically always) to BooLoop_DrawLoop

BooLoop_UseOtherSprs:

	; If we get here, we're on the last 4 Boos, which will require
	; taking some additional sprites from other objects...

	; 'A' will be 4, 3, 2, 1 which we can use to calculate the
	; index of one of the "other" objects that we'll be taking
	; sprites from...
	;ADD <SlotIndexBackup		; Add Boo Loop index to the 1 thru 4 value
	;TAY				; -> 'Y'

	; Now get the "next" object slot (BooLoop_IndexMod provides a psuedo MOD 5)
	;LDA BooLoop_IndexMod-1,Y	; -1 because we're up by 1

	; Use the standard formula to find out what this object's Sprite_RAM offset would be
	;ADD Counter_7to0 	; Add current value of Counter_7to0
	;TAY	
	;LDA SprRamOffsets,Y
	;ADD #16			; Four sprites in; we want the last two sprites
	;STA Object_SprRAM,X	; Store Boo Loop's Sprite_RAM offset
	
	SUB #1	; -1 because we're up by 1
	JSR Object_StealAdjSprite
	TYA
	ADD #(4 * 4)		; Four sprites in; we want the last two sprites
	STA Object_SprRAM,X	; Store Boo Loop's Sprite_RAM offset
	

BooLoop_DrawLoop:

	LDA Objects_Var1,X
	ADD #32
	STA Objects_Var1,X

	DEC Objects_Var2,X
	BPL BooLoop_AllBoos


	JMP Object_DeleteOffScreen_N2	; Jump to Object_DeleteOffScreen and don't come back




BooLoop_DoABoo:
	STA <Temp_Var1	; Save input

	; Backup X/Y
	LDA <Objects_Y,X
	PHA
	LDA <Objects_YHi,X
	PHA
	LDA <Objects_X,X
	PHA
	LDA <Objects_XHi,X
	PHA

	LDA <Temp_Var1	 ; Restore input

	JSR BooLoop_GetOffsetXY

	; Offset X
	LDA Objects_X,X
	ADD <Temp_Var3
	STA Objects_X,X
	LDA Objects_XHi,X
	ADC <Temp_Var4
	STA Objects_XHi,X

	; Offset Y
	LDA Objects_Y,X
	ADD <Temp_Var1
	STA Objects_Y,X
	LDA Objects_YHi,X
	ADC <Temp_Var2
	STA Objects_YHi,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of the RotoDisc
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of the RotoDisc
	JSR BooLoop_CollideAndCycle	 ; Draw Boo Loop 

	; Restore X/Y
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	RTS

BooLoop_CollideAndCycle:
	JSR Object_CalcSpriteXY_NoHi	; Calculate the sprite
	JSR Player_HitEnemy	 	; Player to Rotodisc collision detection

PRG003_BFAE:

	; Toggle between frame 0 and 1
	; Alternate by Boo index
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	LSR A
	EOR Objects_Var2,X	; Alternate each Boo
	AND #$01
	STA Objects_Frame,X

	JSR Level_ObjCalcXDiffs
	LDA BooLoop_FlipBitsFacePlayer,Y
	STA Objects_FlipBits,X

	JMP Object_ShakeAndDraw	 ; Draw Rotodisc and don't come back!

BooLoop_FlipBitsFacePlayer:	.byte SPR_HFLIP, $00

	; Reverses the index (XOR) which will reverse
	; the lookup on quadrants 1 and 3
BooLoop_QuadReversals:	.byte $00, $3E, $00, $3E

	; Reverses Y on quadrants 1 and 2
BooLoop_VReversals:	.byte $FF, $00, $00, $FF

	; Reverses X on quadrants 2 and 3
BooLoop_HReversals:	.byte $00, $00, $FF, $FF


	; Alternate call for thunking
BooLoop_GetOffsetXY_TV1:
	LDA <Temp_Var1

BooLoop_GetOffsetXY:

	; Save input
	PHA

	; Circle quadrants
	;   .---.
	;  /3 | 0\
	; |___|___|
	; |   |   |
	;  \2_|_1/

	; Upper 4 bits of Var4 input determine which quadrant of circle we're on
	ASL A
	ROL A
	ROL A
	AND #$03
	TAY		; -> 'Y'

	; Get H reversal (X Hi offset)
	LDA BooLoop_HReversals,Y
	STA <Temp_Var4	; -> Temp_Var4

	; Get V reversal (Y Hi offset)
	LDA BooLoop_VReversals,Y
	STA <Temp_Var2	; -> Temp_Var6

	; Restore input
	PLA

	; Calculate offset into BooLoop_Offsets
	AND #$3E			; Cap 0-62 (even)
	EOR BooLoop_QuadReversals,Y	; Reverse index if needed
	TAY				; -> 'Y'

	; Get Y offset
	LDA BooLoop_Offsets,Y
	EOR <Temp_Var2	; (Sort of) negate if needed
	STA <Temp_Var1	; -> Temp_Var1


	; Get X offset
	LDA BooLoop_Offsets+1,Y
	EOR <Temp_Var4	; (Sort of) negate if needed
	STA <Temp_Var3	; -> Temp_Var2

	RTS

ObjInit_Thwomp:

	; Var4 = origin Y
	LDA <Objects_Y,X
	STA <Objects_Var4,X

Thwomp_Center:
	; center the X
	LDA <Objects_X,X
	ADD #$04
	STA <Objects_X,X

PRG003_A676:
	RTS		 ; Return


ObjNorm_Thwomp:

	LDA PatTable_BankSel+4
	CMP #31
	BEQ Thwomp_FenceAltPattern	; If fence enemy sprites are active, jump to Podoboo_FenceAltPattern
	
	; pattern bank 18 normally
	LDY #18
	STY PatTable_BankSel+4

Thwomp_FenceAltPattern:
	
	; SB: FIXME: I don't remember why I put this in. Was Thwomp in something that shifted?
	; It's broken in any case, really messes up Thwomp's return...
	; If needed, restore, but make a 16-bit restoration position or something
	
	; If Thwomp is in a shifting maze, fix his Y
	;JSR ObjAScrlDeltaAdj3

	;LDA <Objects_Var4,X
	;ADD Level_ScrollDiffV	 ; Level_ScrollDiffV is 0 or -1 right now
	;STA <Objects_Var4,X
	
	
	JSR Thwomp_Draw	 ; Draw Thwomp; if not in normal state, we don't come back!

	LDA <Player_HaltGame
	BNE PRG003_A676	 ; If gameplay halted, jump to PRG003_A676 (RTS)

	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JSR Player_HitEnemy	 	; Do Player to Thwomp collision

	LDA <Objects_Var5,X	 ; Var5 is internal state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Thwomp_WaitForPlayer
	.word Thwomp_FallToGround
	.word Thwomp_ReturnToOrigin

Thwomp_WaitForPlayer
	JSR Object_AnySprOffscreen
	BNE PRG003_A6A6	 ; If any sprite is off-screen, jump to PRG003_A6A6 (RTS)

	JSR Level_ObjCalcXDiffs

	LDA <Temp_Var16
	ADD #$24
	CMP #$50
	BGE PRG003_A6A6	 ; If Player is too far away, jump to PRG003_A6A6 (RTS)

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Stop Thwomp's vertical movement
	LDA #$00
	STA <Objects_YVel,X

PRG003_A6A6:
	RTS		 ; Return

Thwomp_FallToGround:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity
 
	LDA <Objects_YVel,X
	CMP #$70
	BGE PRG003_A6B4	 ; If Thwomp is falling >= $70, jump to PRG003_A6B4

	; Thwomp fall Y Vel += 4
	ADC #$04
	STA <Objects_YVel,X

PRG003_A6B4:
	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_A6D4	 ; If Thwomp did not hit ground, jump to PRG003_A6D4 (RTS)

	JSR Object_HitGround	 ; Align to floor

	; Shake floor!
	LDA #$18
	STA Level_Vibration

	; Ba-bam! sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Set timer to $40
	LDA #$40
	STA Objects_Timer,X

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

PRG003_A6D4:
	RTS		 ; Return

Thwomp_ReturnToOrigin:
	LDA Objects_Timer,X 
	BNE PRG003_A6EC	 ; If timer is not expired, jump to PRG003_A6EC (RTS)

	; FIXME: This is a really lazy check Nintendo implemented ... I can see it being problematic ...
	LDA <Objects_Y,X
	CMP <Objects_Var4,X
	BNE PRG003_A6E5	 ; If Thwomp has not returned to his origin Y, jump to PRG003_A6E5

	; Var5 = 0 (return to original internal state)
	LDA #$00
	STA <Objects_Var5,X

	RTS		 ; Return

PRG003_A6E5:
	; Set Thwomp Y velocity to -$10
	LDA #-$10
	STA <Objects_YVel,X

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

PRG003_A6EC:
	RTS		 ; Return


Thwomp_Draw:

	; Clear any flip
	LDA #$00 
	STA Objects_FlipBits,X

	JSR Object_Draw16x32Sprite	 ; Draw left 2/3 of Thwomp

	LDA Objects_SprHVis,X
	AND #$20
	BNE PRG003_A737	 ; If sprite is not visible, jump to PRG003_A737

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; The right sprites appear +16 away from Thwomp's left
	LDA <Objects_SpriteX,X
	ADD #16
	STA Sprite_RAM+$13,Y
	STA Sprite_RAM+$17,Y

	; Temp_Var1 = vertical visibility bits
	LDA Objects_SprVVis,X
	STA <Temp_Var1	

	LDA <Objects_SpriteY,X

	LSR <Temp_Var1
	BCS PRG003_A718	 ; If sprite is vertically off-screen, jump to PRG003_A718

	STA Sprite_RAM+$10,Y	 ; Set upper Sprite Y

PRG003_A718:
	LSR <Temp_Var1
	BCS PRG003_A722	 ; If sprite is vertically off-screen, jump to PRG003_A722

	ADD #16
	STA Sprite_RAM+$14,Y	 ; Set lower Sprite Y

PRG003_A722:

	; Right sprite horizontally flipped
	LDA Sprite_RAM+$02,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$12,Y
	STA Sprite_RAM+$16,Y

	; Upper sprite pattern
	LDA #$b1
	STA Sprite_RAM+$11,Y

	; Lower sprite pattern
	LDA #$bb
	STA Sprite_RAM+$15,Y

PRG003_A737:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG003_A740	 ; If Thwomp's state is Normal, jump to PRG003_A740 (RTS)

	; If Thwomp is in normal state, don't return to caller!
	PLA
	PLA

PRG003_A740:
	RTS		 ; Return

ObjInit_ThwompLRSlide:
	JSR Thwomp_Center	 ; Center the X of the Thwomp

	; Var4 = origin X
	STA <Objects_Var4,X

	RTS		 ; Return

ObjNorm_ThwompLRSlide:
	JSR Thwomp_Draw	 ; Draw Thwomp

	LDA <Player_HaltGame
	BNE PRG003_A78B	 ; If gameplay is halted, jump to PRG003_A78B (RTS)

	JSR Object_DeleteOffScreen_N2	 ; Delete if falls off-screen
	JSR Player_HitEnemy	 ; Do Player to Thwomp collision detection

	LDA <Objects_Var5,X	 ; Var5 is internal state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word ThwompLR_WaitForPlayer
	.word ThwompLR_Slide
	.word ThwompLR_Return


ThwompLR_WaitForPlayer:
	JSR Object_AnySprOffscreen
	BNE PRG003_A78B	 ; If any sprite is off-screen, jump to PRG003_A78B (RTS)

	JSR Level_ObjCalcXDiffs	

	LDA <Temp_Var16
	ADD #$70
	CMP #$e8
	BGE PRG003_A78B	 ; If Player is too far from Thwomp, jump to PRG003_A78B (RTS)

	LDA Level_ObjectID,X
	SUB #OBJ_THWOMPLEFTSLIDE
	STA <Temp_Var1		 ; Temp_Var1 = 0 if left sliding Thwomp, or 1 if right sliding Thwomp

	CPY <Temp_Var1	
	BEQ PRG003_A78B	 ; If Player is not on correct side of Thwomp, jump to PRG003_A78B (RTS)

	; Set Var7 for slide direction
	TYA
	STA Objects_Var7,X

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Stop Thwomp's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	; Set timer to $3B
	LDA #$3b
	STA Objects_Timer,X

PRG003_A78B:
	RTS		 ; Return

ThwompLR_XVelAccel:	.byte  $02, -$02
ThwompLR_XVelLimit:	.byte  $20, -$20
ThwompLR_ReturnXVel:	.byte -$08,  $08
	

ThwompLR_Slide:
	LDA Objects_Timer,X
	BNE PRG003_A79E	 ; If timer not expired, jump to PRG003_A79E

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Timer set to $40
	LDA #$40
	STA Objects_Timer,X

PRG003_A79E:
	JSR Object_ApplyXVel	 ; Apply X Velocity

	LDY Objects_Var7,X	 ; Y = Var7 (slide direction)

	LDA <Objects_XVel,X
	CMP ThwompLR_XVelLimit,Y
	BEQ PRG003_A7B1	 	; If Thwomp's X velocity is at its limit, jump to PRG003_A7B1

	; Accelerate!
	ADD ThwompLR_XVelAccel,Y
	STA <Objects_XVel,X

PRG003_A7B1:
	RTS		 ; Return


ThwompLR_Return:
	LDA Objects_Timer,X	 
	BNE PRG003_A7CD	 ; If timer is not expired, jump to PRG003_A7CD (RTS)

	LDA <Objects_X,X
	CMP <Objects_Var4,X
	BNE PRG003_A7C2	 ; If Thwomp is not back to his origin X, jump to PRG003_A7C2

	; Var5 = 0 (return to original internal state)
	LDA #$00
	STA <Objects_Var5,X

	RTS		 ; Return

PRG003_A7C2:
	LDY Objects_Var7,X	 ; Y = Var7 (slide direction)

	; Set Thwomp's return X velocity
	LDA ThwompLR_ReturnXVel,Y
	STA <Objects_XVel,X

	JSR Object_ApplyXVel	 ; Apply X Velocity

PRG003_A7CD:
	RTS		 ; Return

	; Values for OBJ_THWOMPUPDOWN, OBJ_THWOMPDIAGONALUL, OBJ_THWOMPDIAGONALDL, respectively
SlideThwomp_InitXVel:	.byte $00, $10, $10
SlideThwomp_InitYVel:	.byte $10, $10, $F0

ObjInit_ThwompUDSlide:
	LDA Level_ObjectID,X
	SUB #OBJ_THWOMPUPDOWN
	TAY		 ; Y = relative Thwomp index

	; Set initial X velocity
	LDA SlideThwomp_InitXVel,Y
	STA <Objects_XVel,X

	; Set initial Y velocity
	LDA SlideThwomp_InitYVel,Y
	STA <Objects_YVel,X

	JMP Thwomp_Center	 ; Center this Thwomp and don't come back!


ObjNorm_ThwompVertical:
	JSR Thwomp_Draw		; Draw Thwomp
	 
	LDA <Player_HaltGame
	BNE PRG003_A831	 ; If gameplay is halted, jump to PRG003_A831 (RTS)

	JSR Object_DeleteOffScreen_N2	 ; Delete if Thwomp falls off-screen
	JSR Player_HitEnemy	 ; Do Player to Thwomp collision

	LDA <Objects_Var5,X	 ; Var5 is internal state
	AND #$03	 	; Limit 0-3

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word ThwompVert_Reverse
	.word ThwompVert_Slide
	.word ThwompVert_Reverse
	.word ThwompVert_Slide

ThwompVert_Reverse:
	LDA Objects_Timer,X
	BNE PRG003_A81E	 ; If timer not expired, jump to PRG003_A81E (RTS)

	; Thwomp turns around...

	; Negate X velocity
	LDA <Objects_XVel,X
	JSR Negate
	STA <Objects_XVel,X

	; Negate Y velocity
	LDA <Objects_YVel,X
	JSR Negate
	STA <Objects_YVel,X

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Set timer to $80
	LDA #$80
	STA Objects_Timer,X

PRG003_A81E:
	RTS		 ; Return

ThwompVert_Slide:
	LDA Objects_Timer,X
	BNE PRG003_A82B	 ; If timer not expired, jump to PRG003_A82B

	INC <Objects_Var5,X	 ; Var5++

	; Set timer to $3C
	LDA #$3c
	STA Objects_Timer,X

PRG003_A82B:
	JSR Object_ApplyXVel	 	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	; Apply Y velocity

PRG003_A831:
	RTS		 ; Return


	; Birdo starts out pink, turns red, then green (mimicking the abilities of those types from SMB2)
Birdo_HitColors:	.byte $2A, $16, $25

ObjInit_Birdo:
	; Hack: "PatTableSel" cannot support a bank value over 127, so must do so manually
	LDA #134
	STA PatTable_BankSel+4

	; Birdo initial hit color
	LDA Birdo_HitColors+2
	STA Palette_Buffer+$1F

	; And put white here
	LDA #$20
	STA Palette_Buffer+$1E

	; State: Wait for Player, and set hit level to 2
	LDA #((2 << 4) | 7)
	STA Objects_Var4,X
	
	LDA Player_RescuePrincess
	BEQ Birdo_InitNormal

	; Ending 2 only
	LDA #(2 << 4)
	STA Objects_Var4,X

Birdo_InitNormal:
	; More relaxed looking
	INC Objects_Var2,X

	; Birdo HP
	LDA #($10 * 3 - 1)
	STA Objects_HitCount,X

	RTS

ObjNorm_Birdo:
	LDA Player_RescuePrincess
	BEQ Birdo_NotEnding

	; Ending 2 only...
	JSR Object_DeleteOffScreen

Birdo_NotEnding:
	; Birdo pattern; walk from start to left up to 3.5 tiles and back again
	; Run for random ticks
	; When ticks expire, stop, then randomly jump, pause, or spit egg
	; And around again...

	; Var1: Head frame (0 - normal, 1 - spit, 2 - hit)
	; Var2: Body frame (0/1)
	; Var3: Walk remaining; bit 7 set, left, otherwise right
	; Var4: Lower 4 bits, state
	;	0: Init walk (invert bit, set Var3)
	;	1: Walking (random interrupt to state 2-4)
	;	2: Jump
	;	3: Pause
	;	4: Spit Egg
	; Var4: Upper 4 bits, hit level (init 2, then 1, then 0)
	; Var5: State-specific var
	; Var6: Timeout until next ShyGuy drop (last hit level only)
	LDA <Player_HaltGame
	BEQ Birdo_NotHalted 

	JMP Birdo_Draw

Birdo_NotHalted:
	; If Birdo's in state 6 (Dying), jump to Birdo_Die
	LDA Objects_Var7,X
	AND #$0F
	CMP #6
	BEQ Birdo_Die

	; If Birdo's not in dying state but the game engine is declaring him dying
	; we must begin that state...
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE Birdo_NotDying	; If not dying, jump to Birdo_NotDying

	LDA Objects_ColorCycle,X
	BNE Birdo_Invincible	; If Birdo is color cycling, invincible; jump to Birdo_Invincible

	; But Birdo also goes into "Dying" state if hit by egg/etc., so
	; we have to hack that a bit
	LDA Objects_Var4,X
	AND #$F0		; Mask out the hit level
	BEQ Birdo_IsKilled	; If Birdo is at zero hit level, jump to Birdo_IsKilled

	; Birdo still has hit level left!

	; Deduct 16 hit points, if possible
	LDA Objects_HitCount,X
	CMP #16
	BGE Birdo_Deduct16

	; This Birdo is as good as dead!
	JMP Birdo_IsKilled

Birdo_Deduct16:
	; Deduct 16 hits from the object impact and resume!
	SUB #16
	STA Objects_HitCount,X

Birdo_Invincible:
	; Return to normal state
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Cancel the implied velocities
	LDA #0
	STA Objects_XVel,X
	STA Objects_YVel,X

	BEQ Birdo_NotDying	; Jump (technically always) to Birdo_NotDying

Birdo_IsKilled:
	; Reset Var5
	LDA #0
	STA Objects_Var5,X

	; Pain face all the way down...
	LDA #2
	STA Objects_Var1,X

	 ; Halt the level timer
	LDA #$01
	STA Level_TimerEn

	; Force state 6 (Dying)
	LDA #6
	STA Objects_Var7,X

Birdo_Die:
	JMP Birdo_Dying 	; If Birdo is dying, jump to Birdo_Dying

Birdo_NotDying:
	; If on last hit level, see if it's time for a Shy Guy drop
	LDA Objects_Var4,X
	AND #$F0	; Upper 4 bits are hit level
	BNE Birdo_NoDrop

	JSR Birdo_CheckForShyGuy
	BEQ Birdo_NoDrop	; If Shy Guy still exists, jump to Birdo_NoDrop

	; Shy Guy is gone...

	; If Var6 hasn't expired, no drop
;	LDA Objects_Var6,X
;	BNE Birdo_DecVar6

	; Var6 expired...

	; Prepare new object (if possible!)
	JSR PrepareNewObjectOrAbort

	LDA #SPR_PAL2
	STA Objects_SprAttr,X

	; Green Shy Guy!
	LDA #OBJ_SHYGUY_GREEN
	STA Level_ObjectID,X

	; Fall to Player
	LDA <Horz_Scroll
	ADD #$FF
	STA Objects_X,X
	LDA <Horz_Scroll_Hi
	ADC #0
	STA Objects_XHi,X

	LDA <Vert_Scroll
	ADD #40
	STA Objects_Y,X
	LDA #0
	ADC #0
	STA Objects_YHi,X

	LDA #-$20
	STA Objects_YVel,X

	; Boing!
	LDA #SND_PLAYERJUMPSM
	STA Sound_QPlayer

	LDX <SlotIndexBackup		 ; X = object slot index

	; Reset Var6
	;LDA #64
	;STA Objects_Var6,X

;Birdo_DecVar6:
;	DEC Objects_Var6,X

Birdo_NoDrop:
	JSR Level_ObjCalcXDiffs

	; Face Player
	LDA FireChomp_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	JSR Object_Move	 ; Do standard movements

	LDA <Objects_DetStat,X
	AND #$08
	BEQ Birdo_NoCeilHit	 ; If Birdo did not hit ceiling, jump to Birdo_NoCeilHit

	; Bounce off ceiling
	LDA #$01
	STA <Objects_YVel,X

Birdo_NoCeilHit:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ Birdo_NoGndHit	 ; If Birdo did not hit ground, jump to Birdo_NoGndHit

	JSR Object_HitGround	 ; Align Birdo to ground

Birdo_NoGndHit:

	; Check if Birdo has gone to a different hit level
	LDA Objects_Var4,X
	AND #$F0	; Upper 4 bits are hit level
	STA <Temp_Var1	; -> Temp_Var1

	LDA Objects_HitCount,X
	AND #$F0
	CMP <Temp_Var1	; Compare upper 4 bits of hit count to hit level
	BEQ Birdo_NoChangeHit	; If Birdo has not changed to a new hit level, jump to Birdo_NoChangeHit

	; Birdo changed hit level!  Update hit level and go to state 5!
	LDA #5
	STA <Temp_Var1
	JSR Birdo_ChangeState

	; Change upper frame to 2
	LDA #2
	STA Objects_Var1,X

Birdo_NoChangeHit:
	JSR Birdo_Draw

	LDA Objects_ColorCycle,X
	BEQ Birdo_NotInvincible

	JSR Birdo_NoDetect

Birdo_NotInvincible:
	LDA Objects_Var4,X
	AND #$0F	; Lower 4 bits are state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Birdo_InitWalk	; 0
	.word Birdo_Walking	; 1
	.word Birdo_Jump	; 2
	.word Birdo_Pause	; 3
	.word Birdo_SpitEgg	; 4
	.word Birdo_Hit		; 5
	.word Birdo_Dying	; 6
	.word Birdo_Wait4Player	; 7

Birdo_Draw:
	JSR Object_ShakeAndCalcSprite

	; Store frame into Temp_Var14 (top) and Temp_Var15 (bottom)
	LDX <SlotIndexBackup		 ; X = object slot index

	; Upper body sprite frame
	LDA Objects_Var1,X
	ASL A
	STA <Temp_Var14

	; Lower body sprite frame
	LDA Objects_Var2,X
	ADD #3		; Base frame for lower body
	ASL A
	STA <Temp_Var15

	LDA Objects_FlipBits,X
	AND #SPR_VFLIP
	BEQ Birdo_DrawNotVFlipped

	; If vertically flipped, swap Temp_Var14/15
	LDA <Temp_Var14
	PHA

	LDA <Temp_Var15
	STA <Temp_Var14

	PLA
	STA <Temp_Var15

Birdo_DrawNotVFlipped:

	LDX <Temp_Var14
	JSR Object_Draw16x16Sprite

	LSR <Temp_Var5	 ; Next visibility bit

	; Next two sprites
	TYA
	ADD #8
	TAY

	LDA <Temp_Var1
	ADD #16
	STA <Temp_Var1

	LDX <Temp_Var15
	JSR Object_Draw16x16Sprite

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS


Birdo_Wait4Player:
	JSR Boss_WaitAndLock
	BCC Birdo_NoDetect		; If boss not positioned yet, jump to Birdo_NoDetect

	; Initialize walking and go!  (Implicitly, state becomes zero here)
	LDA Objects_Var4,X
	AND #$F0	; Mask out hit level
	STA Objects_Var4,X

Birdo_NoDetect:

	; Deliberately breaks object detection
	LDA #$FF
	STA Objects_SpriteX,X
	STA Objects_SpriteY,X

	RTS

Birdo_WalkXVel: .byte $0C, -$0C

Birdo_InitWalk:
	; Init walk

	; 3.5 tiles = 56 pixels of walking
	; Speed will be at $0C (0.75 pixels/frame)
	; Frames needed to cover distance: 56 / 0.75 = ~75

	LDA Objects_Var3,X
	AND #$80	; Only keep bit 7
	EOR #$80	; Invert it (reverse walk direction)
	ORA #75		; Set tick count
	STA Objects_Var3,X

Birdo_ResetWalk:
	AND #$80	; Get bit 7
	ROL A
	ROL A		; Move to bit 0
	TAY
	LDA Birdo_WalkXVel,Y
	STA Objects_XVel,X

	; Change to walk state
	LDA Objects_Var4,X
	AND #$F0	; Mask out hit level
	ORA #1		; State = 1 (walk)
	STA Objects_Var4,X

	; Drop into walking...

Birdo_Walking:

	DEC Objects_Var3,X
	LDA Objects_Var3,X

	; Examine just the tick part of this value (bit 7 is direction)
	AND #$7F
	BEQ Birdo_InitWalk	; If Birdo has completed this walk cycle, jump to Birdo_InitWalk

	; Otherwise, just update body frame
	LSR A
	LSR A
	AND #$01
	STA Objects_Var2,X

	; Randomly decide to do something else or not
	LDA RandomN
	CMP #240
	BGE Birdo_DoSomethingElse

	; Just walking...
	RTS

	; Valid destination states: 2 = Jump, 3 = Pause, 4 = Spit Egg
Birdo_DestStates:	.byte 2, 3, 4, 4	; Extra chance on the egg spitting

Birdo_DoSomethingElse:

	AND #$03
	TAY
	LDA Birdo_DestStates,Y	; Random state 2 to 4
	STA <Temp_Var1

Birdo_ChangeState:
	LDA Objects_Var4,X
	AND #$F0		; Mask out hit level
	ORA <Temp_Var1		; Store new state
	STA Objects_Var4,X	; Go for it, Birdo

	; Clear state-specific var
	LDA #0
	STA Objects_Var5,X

	; Birdo stops moving
	LDA #0
	STA Objects_XVel,X

	RTS

Birdo_Jump:

	LDA Objects_Var5,X	; Var5 = 0 means not actually jumped yet
	BNE Birdo_AlreadyHopped

	; Mark as having jumped
	INC Objects_Var5,X

	; Jump!
	LDA #-$28
	STA Objects_YVel,X

	RTS

Birdo_AlreadyHopped:

	LDA <Objects_DetStat,X
	AND #$04
	BEQ Birdo_JumpNotLanded	; If Birdo hasn't landed yet, jump to Birdo_JumpNotLanded (RTS)

Birdo_FinishedState:
	; Return to state 1
	LDA #1
	STA Objects_Var5,X

	; Need to reset walk speed
	LDA Objects_Var3,X
	JMP Birdo_ResetWalk

Birdo_JumpNotLanded:
	RTS

Birdo_Pause:
	LDA Objects_Var5,X
	BNE Birdo_PauseCont	; If Birdo already initialized pause, jump to Birdo_PauseCont

	; Initialize pause
	LDA RandomN
	AND #$1F	; Additional value
	ADD #16		; Base value
	STA Objects_Var5,X

Birdo_PauseCont:

	DEC Objects_Var5,X	; Decrement pause value
	BEQ Birdo_FinishedState	; If zero, jump to Birdo_FinishedState
	RTS

Birdo_SpitEgg:
	LDA Objects_Var5,X
	BNE Birdo_SpitCont	; If Birdo already initialized egg spit, jump to Birdo_SpitCont

	; Set upper frame to spit-ready
	LDA #1
	STA Objects_Var1,X

	; Set timer
	LDA #$18
	STA Objects_Var5,X

Birdo_SpitCont:

	DEC Objects_Var5,X	; Decrement ticker

	LDA Objects_Var5,X
	BEQ Birdo_SpitStop	; If zero, jump to Birdo_SpitStop

	CMP #$08
	BNE Birdo_SpitDone	; If not trigger tick for spit, jump to Birdo_SpitDone (RTS)

	; Play spit sound
	LDA #SND_LEVELUNK
	STA Sound_QLevel1

	; Spit egg
	JSR Birdo_SpawnEgg

Birdo_SpitDone:
	RTS

Birdo_SpitStop:
	; Set upper frame to closed mouth
	LDA #0
	STA Objects_Var1,X

	BEQ Birdo_FinishedState 	; Jump (technically always) to Birdo_FinishedState

Birdo_Hit:
	LDA Objects_Var5,X
	BNE Birdo_SpitCont	; If Birdo hit ticker already initialized, jump to Birdo_HitCont

	; Change Birdo's color as appropriate and resume walking
	LDA Objects_HitCount,X
	AND #$F0	; Get next hit level
	TAY		; -> 'Y'
	ORA #5		; Stay in state 5 for now
	STA Objects_Var4,X

	; 'Y' is scaled up by 4 bits, need to tone it down
	TYA
	LSR A
	LSR A
	LSR A
	LSR A
	TAY

	; Get next Birdo palette color
	LDA Birdo_HitColors,Y
	STA Palette_Buffer+$1F

	; Hit effect ticker = 32
	LDA #32
	STA Objects_Var5,X
	STA Objects_ColorCycle,X

Birdo_HitCont:
	DEC Objects_Var5,X	; Decrement hit ticker
	BNE Birdo_HitNotDone	; If not done yet, jump to Birdo_HitNotDone

	LDA Objects_Var4,X
	AND #$F0	; Retain hit level
	ORA #1		; Back to walking state
	STA Objects_Var4,X

Birdo_HitNotDone:
	RTS

Birdo_Dying:
	LDA Objects_Var5,X
	BNE Birdo_DeadTimeout	; If Var5 > 0, jump to Birdo_DeadTimeout

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ Birdo_EndLevel	; If Birdo's state is "Normal" here, that means we're doing the victory / bonus countdown

	; Birdo is falling...
	JSR Birdo_Draw

	; While Birdo is dying, we're going to stop him from just falling off
	; because we want to play some victory music and convert time -> bonus
	LDA Objects_YHi,X
	BEQ Birdo_StillDying	; If not Y Hi = 1 yet, jump to Birdo_StillDying (RTS)

	LDA Objects_Y,X
	AND #$F0
	CMP #$C0
	BNE Birdo_StillDying	; If Birdo's not real low yet, jump to Birdo_StillDying (RTS)

	; Whoop!  Birdo is low, let's change
	LDA Player_RescuePrincess
	BPL Birdo_NoEndingDie

	JMP Object_Delete

Birdo_NoEndingDie:
	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BNE Birdo_NotDDComet

	JMP_THUNKC 30, Level_EndComet

Birdo_NotDDComet:

	LDA World_Num
	CMP #9
	BEQ Birdo_NoWZeroVictory	; No victory song on World Zero

	; Victory fanfare
	LDA Sound_QMusic1
	ORA #MUS1_BOSSVICTORY
	STA Sound_QMusic1

Birdo_NoWZeroVictory:
	; Go into normal state for bonus countdown
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

Birdo_StillDying:
	RTS

Birdo_EndLevel:
	JSR DoTimeBonus	 ; Convert remaining time into score
	BNE Birdo_StillTimering	 ; If not done converting, jump to PRG003_A910 (RTS)

	; Set timer to $40
	LDA #$40
	STA Objects_Var5,X

Birdo_StillTimering:
	RTS

Birdo_DeadTimeout:
	DEC Objects_Var5,X
	BNE Birdo_StillTimering

	LDA World_Num
	CMP #9
	BNE Birdo_NotWZeroExit

	; Clear Arena Door 0
	LDA #0
	STA <Temp_Var1
	JSR_THUNKA 41, ArenaCtl_ExitBoss
	JMP Object_Delete

Birdo_NotWZeroExit:

	; Exit to map!
	JMP ExitLevel_InvalidateCP

BirdoEgg_XVel:	.byte -$18, $18

BirdoEgg_Type:	.byte $01, $01	; 0: Always fireball
		.byte $00, $01	; 1: Sometimes egg, sometimes fireball
		.byte $00, $00	; 2: Always egg

Birdo_SpawnEgg:
	LDY #$04	 ; Y = 4
PRG003_B34A:
	LDA Objects_State,Y
	BEQ PRG003_B353	 ; If this object slot is dead/empty, jump to PRG003_B353

	DEY		 ; Y--
	BPL PRG003_B34A	 ; While Y >= 0, loop!

	RTS		 ; Return

PRG003_B353:
	TYA		 
	TAX		 ; X = open object slot index

	JSR Level_PrepareNewObject

	LDX <SlotIndexBackup		 ; X = object slot index

	; Set to normal state
	LDA #OBJSTATE_NORMAL
	STA Objects_State,Y

	LDA #SPR_PAL1
	STA Objects_SprAttr,Y

	; Birdo egg!
	LDA #OBJ_BIRDOEGG
	STA Level_ObjectID,Y

	; May have chance for fireball at other hit levels
	; 2 = Always egg, 1 = 50/50, 2 = Always fireball
	LDA Objects_Var4,X
	AND #$F0	; 2, 1, 0
	LSR A
	LSR A
	LSR A		; Hit level * 2
	STA <Temp_Var1	; -> Temp_Var1

	LDA RandomN
	AND #$01	; 50/50 chance of something different
	ORA <Temp_Var1
	TAX
	LDA BirdoEgg_Type,X
	STA Objects_Frame,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	LDA <Objects_Y,X
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	STA Objects_YHi,Y

	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	LDA Objects_FlipBits,X

	; X = 0
	LDX #$00

	AND #SPR_HFLIP
	BEQ PRG003_B37D	 ; If Birdo is not flipped, jump to PRG003_B37D

	INX	; X = 1

PRG003_B37D:

	LDA BirdoEgg_XVel,X
	STA Objects_XVel,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return


Birdo_CheckForShyGuy:
	LDY #$04	 ; Y = 4
Birdo_CheckForShyGuy_Loop:
	LDA Objects_State,Y
	BEQ Birdo_CheckEmpty	 ; If this object slot is dead/empty, jump to Birdo_CheckEmpty

	; Not dead/empty...
	LDA Level_ObjectID,Y
	CMP #OBJ_SHYGUY_GREEN
	BNE Birdo_CheckEmpty	; If this object is not a green Shy Guy, jump to Birdo_CheckEmpty

	; Found green Shy Guy, no drop (Check with BEQ since CMP matched)
	RTS

Birdo_CheckEmpty:
	DEY		 ; Y--
	BPL Birdo_CheckForShyGuy_Loop	; While Y >= 0, loop!

	; If you get here, the Green Shy Guy is gone!  (Check with BNE since Y < 0)
	RTS		 ; Return


ExitLevel_InvalidateCP:
	; Invalidate the checkpoint for this Player
	JSR_THUNKC 30, Object_InvalidateCP

	; Timer done, exit!
	LDA #0
	STA Map_ReturnStatus

	INC Level_ExitToMap
	RTS


ObjInit_DarknessCtl:

	LDY #4
DC_CheckDarkness_Loop:
	CPY <SlotIndexBackup
	BEQ DC_NotDarkCtl	; Don't nix yourself

	LDA Objects_State,Y
	BEQ DC_NotDarkCtl	; If object is not alive, jump to BooCDL_NotDarkCtl

	LDA Level_ObjectID,Y
	CMP #OBJ_DARKNESSCTL
	BNE DC_NotDarkCtl	; If this is not the darkness controller, jump to BooCDL_NotDarkCtl
	
	; Darkness controller found!  Don't need two!
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X
	RTS

DC_NotDarkCtl:
	DEY
	BPL DC_CheckDarkness_Loop

	; Marks that we don't have a previous switch
	LDA #$FF
	STA Objects_Var1,X

	RTS
	

ObjNorm_DarknessCtl:

	; NOTE:
	;LDA Level_ActSwYHi
	;STA Objects_Var1,X
	;LDA Level_ActSwY
	;STA Objects_Var2,X
	;LDA Level_ActSwXHi
	;STA Objects_Var3,X
	;LDA Level_ActSwX
	;STA Objects_Var6,X

	; Jump by state
	LDA <Objects_Var4,X
	JSR DynJump
	
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word DarknessCtl_Darken		; 0: Darken room
	.word DarknessCtl_Brighten		; 1: Brighten room
	.word DarknessCtl_ResetSwitch	; 2: Reset switch (waits until Level_ChgTileEvent is clear)

Darkness_FullBlack:	.byte $0F, $0F, $00, $0F

DarknessCtl_Darken:

	; Pal_Data holds ORIGNAL palette
	; Palette_Buffer holds CURRENT palette
	
	LDA <Counter_1
	AND #$07
	BNE DarknessCtl_DarkWait

	; We'll keep the first non-BG color at $00 for minimal visibility
	
	LDA #31		; All 32 colors
	STA <Temp_Var1
DarknessCtl_DarkeningLoop:
	LDA <Temp_Var1
	BEQ DarknessCtl_NotStatBar	; Color 0 is acceptable to modify; jump to DarknessCtl_NotStatBar
	
	; Otherwise...
	AND #$0F	; Status bar and Player palette are same check
	CMP #4
	BLT DarknessCtl_SkipStatBar	; If this is a status bar OR Player sprite color, jump to DarknessCtl_NotStatBar
	
DarknessCtl_NotStatBar:
	LDA <Temp_Var1
	TAY		; -> 'Y'

	; This will select the "full darkness" color (gray for one color to keep 
	; things from becoming completely invisible)
	AND #$03
	TAX

	LDA Palette_Buffer,Y
	SUB #$10
	BPL DarknessCtl_ColorOK
	
	; If color has become "negative", set it to the "full darkness" color
	LDA Darkness_FullBlack,X
	
DarknessCtl_ColorOK:
	STA Palette_Buffer,Y

DarknessCtl_SkipStatBar:
	DEC <Temp_Var1		; Temp_Var1++
	BPL DarknessCtl_DarkeningLoop	; While Temp_Var1 > 0, loop!
	
	; Completed darkening
	LDA #0

	LDX <SlotIndexBackup

DarknessCtl_DarkWait:
	RTS
	
DarknessCtl_Brighten:

	LDA #31		; All 32 colors
	STA <Temp_Var1
DarknessCtl_B_BrighteningLoop:
	LDA <Temp_Var1
	BEQ DarknessCtl_B_NotStatBar	; Color 0 is acceptable to modify; jump to DarknessCtl_B_NotStatBar
	
	
	; Otherwise...
	AND #$0F	; Status bar and Player palette are same check
	CMP #4
	BLT DarknessCtl_B_SkipStatBar	; If this is a status bar color, jump to DarknessCtl_B_NotStatBar
	
DarknessCtl_B_NotStatBar:
	LDA <Temp_Var1
	TAY		; -> 'Y'

	LDA Palette_Buffer,Y
	ADD #$10
	CMP Pal_Data,Y
	BLT DarknessCtl_B_ColorOK

	; We're at the color!
	LDA Pal_Data,Y
	
DarknessCtl_B_ColorOK:
	STA Palette_Buffer,Y

DarknessCtl_B_SkipStatBar:
	DEC <Temp_Var1		; Temp_Var1++
	BPL DarknessCtl_B_BrighteningLoop	; While Temp_Var1 > 0, loop!

	
	LDA Objects_Timer,X
	BNE DarknessCtl_StillBright

	DEC <Objects_Var5,X		; Var5--
	BMI DarknessCtl_Done	; If we're not doing any more rounds, jump to DarknessCtl_Done
	
	; Another round!
	DEC Objects_Timer,X		; Timer = $FF
	LDA #0		; So we don't miss a beep
	BEQ DarknessCtl_StillBright		; Jump (technically always) to DarknessCtl_StillBright

DarknessCtl_Done:

	; Attempt to reset switch
	INC <Objects_Var4,X

DarknessCtl_StillBright:
	LDY Objects_Var5,X
	BEQ DarknessCtl_LastRound

	; Not the last round, assume slow mask
	LDX #0
	BEQ StillBright_SlowMask	; Jump (technically always) to StillBright_SlowMask

DarknessCtl_LastRound:
	LDX #0
	CMP #$80
	BGE StillBright_SlowMask

	; Fast mask when almost done
	INX

StillBright_SlowMask:
	AND Darkness_BeepMask,X
	BNE StillBright_NoBeep

	; Beep!
	LDA #SND_LEVELBLIP
	STA Sound_QLevel1

StillBright_NoBeep:
	LDX <SlotIndexBackup
	RTS

Darkness_BeepMask:	.byte $1F, $0F

DarknessCtl_ResetSwitch:

	LDA Level_ChgTileEvent
	BNE Darkness_CantResetYet	; If tile change is not free, jump to Darkness_CantResetYet

	; Reset back to state 0
	LDA #0
	STA <Objects_Var4,X
	
	LDA Objects_Var1,X
	STA Level_BlockChgYHi
	LDA Objects_Var2,X
	STA Level_BlockChgYLo
	LDA Objects_Var3,X
	STA Level_BlockChgXHi
	LDA Objects_Var6,X
	STA Level_BlockChgXLo
	
	LDA #CHNGTILE_ACTSWAPPEAR
	STA Level_ChgTileEvent

	; Marks that we don't have a previous switch
	LDA #$FF
	STA Objects_Var1,X
	
Darkness_CantResetYet:
	RTS


; FIXME: Would like to make this global...
ObjAScrlDeltaAdj3:
	LDA Level_AScrlSelect
	CMP #4
	BNE OADA3_NotInShiftingMaze
	
	LDY #$00	 ; Y = 0

	LDA Level_ScrollDiffV	 ; Level_ScrollDiffV is 0 or -1 right now
	CMP #$ff
	BNE ObjAScrlDeltaAdj3_YNotNeg
	DEY		 ; Y = -1 

ObjAScrlDeltaAdj3_YNotNeg:
	ADD <Objects_Y,X
	STA <Objects_Y,X
	TYA		
	ADC <Objects_YHi,X
	STA <Objects_YHi,X

OADA3_NotInShiftingMaze:
	RTS		 ; Return

