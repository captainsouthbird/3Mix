; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg001.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------

	; CAUTION!! ObjectGroup00 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $00 (i.e. objects starting at ID $00) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup00_InitJumpTable:
	.word ObjInit_DoNothing	; Object $00
	.word ObjInit_DoNothing	; Object $01 - OBJ_PIPERAISE1
	.word ObjInit_DoNothing	; Object $02 - OBJ_PIPERAISE2
	.word ObjInit_DoNothing	; Object $03 - OBJ_PIPERAISE3
	.word ObjInit_DoNothing	; Object $04 - OBJ_PIPERAISE4
	.word ObjInit_Bowser	; Object $05 - OBJ_BOSS_BOWSER2
	.word ObjInit_BounceDU	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjInit_DoNothing	; Object $07 - OBJ_PARADRYBONES
	.word ObjInit_PDoor	; Object $08 - OBJ_PSWITCHDOOR
	.word ObjInit_Bowser	; Object $09 - OBJ_BOSS_BOWSERFINAL
	.word ObjInit_Eerie	; Object $0A - OBJ_EERIE
	.word ObjInit_PUpMush	; Object $0B - OBJ_POWERUP_1UP
	.word ObjInit_StarOrSuit; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjInit_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjInit_Topmaniac	; Object $0E - OBJ_TOPMANIC
	.word ObjInit_RGravEnmy	; Object $0F - OBJ_RGREENTROOPA - OBJ_RGREENTROOPA
	.word ObjInit_RGravEnmy	; Object $10 - OBJ_RREDTROOPA - OBJ_RREDTROOPA
	.word ObjInit_RGravEnmy	; Object $11 - OBJ_RPARATROOPAGREENHOP - OBJ_RPARATROOPAGREENHOP
	.word ObjInit_RGravEnmy	; Object $12 - OBJ_RFLYINGREDPARATROOPA - OBJ_RFLYINGREDPARATROOPA
	.word ObjInit_RGravEnmy	; Object $13 - OBJ_RBUZZYBEATLE - OBJ_RBUZZYBEATLE
	.word ObjInit_RGravEnmy	; Object $14 - OBJ_RSPINY - OBJ_RSPINY
	.word ObjInit_RGravEnmy	; Object $15 - OBJ_RGOOMBA - OBJ_RGOOMBA
	.word ObjInit_Topman	; Object $16 - OBJ_TOPMAN
	.word ObjInit_SpinyCheep; Object $17 - OBJ_SPINYCHEEP
	.word ObjInit_Bowser	; Object $18 - OBJ_BOSS_BOWSER
	.word ObjInit_FireFlower; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjInit_CheckpointF	; Object $1A - OBJ_CHECKPOINT_FORCE
	.word ObjInit_BounceLR	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjInit_GreenPiranhaX	; Object $1C - OBJ_GREENPIRANHA_FIRE_X
	.word ObjInit_DoNothing	; Object $1D - OBJ_GREENSHELL
	.word ObjInit_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjInit_Vine	; Object $1F - OBJ_GROWINGVINE
	.word ObjInit_CoinSnake	; Object $20 - OBJ_COINSNAKE
	.word ObjInit_LaunchStar	; Object $21 - OBJ_LAUNCHSTAR
	.word ObjInit_ChangeMusic	; Object $22 - OBJ_MUSICSET
	.word ObjInit_Checkpoint	; Object $23 - OBJ_CHECKPOINT


	; Object group $00 (i.e. objects starting at ID $00) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup00_NormalJumpTable:
	.word ObjNorm_DoNothing	; Object $00
	.word ObjNorm_PipeRaise	; Object $01 - OBJ_PIPERAISE1
	.word ObjNorm_PipeRaise	; Object $02 - OBJ_PIPERAISE2
	.word ObjNorm_PipeRaise	; Object $03 - OBJ_PIPERAISE3
	.word ObjNorm_PipeRaise	; Object $04 - OBJ_PIPERAISE4
	.word ObjNorm_Bowser	; Object $05 - OBJ_BOSS_BOWSER2
	.word ObjNorm_BounceDU	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjNorm_ParaDryBones	; Object $07 - OBJ_PARADRYBONES
	.word ObjNorm_PDoor	; Object $08 - OBJ_PSWITCHDOOR
	.word ObjNorm_BowserFinal	; Object $09 - OBJ_BOSS_BOWSERFINAL
	.word ObjNorm_Eerie	; Object $0A - OBJ_EERIE
	.word ObjNorm_PUp1UpMush; Object $0B - OBJ_POWERUP_1UP
	.word ObjNorm_StarOrSuit; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjNorm_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjNorm_Topmaniac	; Object $0E - OBJ_TOPMANIC
	.word ObjNorm_DoNothing	; Object $0F - OBJ_RGREENTROOPA - OBJ_RGREENTROOPA
	.word ObjNorm_DoNothing	; Object $10 - OBJ_RREDTROOPA - OBJ_RREDTROOPA
	.word ObjNorm_DoNothing	; Object $11 - OBJ_RPARATROOPAGREENHOP - OBJ_RPARATROOPAGREENHOP
	.word ObjNorm_DoNothing	; Object $12 - OBJ_RFLYINGREDPARATROOPA - OBJ_RFLYINGREDPARATROOPA
	.word ObjNorm_DoNothing	; Object $13 - OBJ_RBUZZYBEATLE - OBJ_RBUZZYBEATLE
	.word ObjNorm_DoNothing	; Object $14 - OBJ_RSPINY - OBJ_RSPINY
	.word ObjNorm_DoNothing	; Object $15 - OBJ_RGOOMBA - OBJ_RGOOMBA
	.word ObjNorm_Topman	; Object $16 - OBJ_TOPMAN
	.word ObjNorm_SpinyCheep; Object $17 - OBJ_SPINYCHEEP
	.word ObjNorm_Bowser	; Object $18 - OBJ_BOSS_BOWSER
	.word ObjNorm_FireFlower; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjNorm_DoNothing	; Object $1A - OBJ_CHECKPOINT_FORCE
	.word ObjNorm_BounceLR	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjNorm_DoNothing	; Object $1C - OBJ_GREENPIRANHA_FIRE_X
	.word ObjNorm_GreenShell	; Object $1D - OBJ_GREENSHELL
	.word ObjNorm_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjNorm_Vine	; Object $1F - OBJ_GROWINGVINE
	.word ObjNorm_CoinSnake	; Object $20 - OBJ_COINSNAKE
	.word ObjNorm_LaunchStar	; Object $21 - OBJ_LAUNCHSTAR
	.word ObjNorm_DoNothing	; Object $22 - OBJ_MUSICSET
	.word ObjNorm_Checkpoint	; Object $23 - OBJ_CHECKPOINT


	; Object group $00 (i.e. objects starting at ID $00) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup00_CollideJumpTable:
	.word ObjHit_DoNothing	; Object $00
	.word ObjHit_DoNothing	; Object $01 - OBJ_PIPERAISE1
	.word ObjHit_DoNothing	; Object $02 - OBJ_PIPERAISE2
	.word ObjHit_DoNothing	; Object $03 - OBJ_PIPERAISE3
	.word ObjHit_DoNothing	; Object $04 - OBJ_PIPERAISE4
	.word OCSPECIAL_HIGHSCORE; Object $05 - OBJ_BOSS_BOWSER2
	.word ObjHit_DoNothing	; Object $06 - OBJ_BOUNCEDOWNUP
	.word OCSPECIAL_KILLCHANGETO | OBJ_DRYBONES	; Object $07 - OBJ_PARADRYBONES
	.word ObjHit_DoNothing	; Object $08 - OBJ_PSWITCHDOOR
	.word OCSPECIAL_HIGHSCORE	; Object $09 - OBJ_BOSS_BOWSERFINAL
	.word ObjHit_DoNothing	; Object $0A - OBJ_EERIE
	.word ObjHit_PUp1UpMush	; Object $0B - OBJ_POWERUP_1UP
	.word ObjHit_StarOrSuit	; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjHit_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjHit_DoNothing	; Object $0E - OBJ_TOPMANIC
	.word ObjHit_DoNothing	; Object $0F - OBJ_RGREENTROOPA - OBJ_RGREENTROOPA
	.word ObjHit_DoNothing	; Object $10 - OBJ_RREDTROOPA - OBJ_RREDTROOPA
	.word ObjHit_DoNothing	; Object $11 - OBJ_RPARATROOPAGREENHOP - OBJ_RPARATROOPAGREENHOP
	.word ObjHit_DoNothing	; Object $12 - OBJ_RFLYINGREDPARATROOPA - OBJ_RFLYINGREDPARATROOPA
	.word ObjHit_DoNothing	; Object $13 - OBJ_RBUZZYBEATLE - OBJ_RBUZZYBEATLE
	.word ObjHit_DoNothing	; Object $14 - OBJ_RSPINY - OBJ_RSPINY
	.word ObjHit_DoNothing	; Object $15 - OBJ_RGOOMBA - OBJ_RGOOMBA
	.word ObjHit_DoNothing	; Object $16 - OBJ_TOPMAN
	.word ObjHit_DoNothing	; Object $17 - OBJ_SPINYCHEEP
	.word OCSPECIAL_HIGHSCORE; Object $18 - OBJ_BOSS_BOWSER
	.word ObjHit_FireFlower	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjHit_DoNothing	; Object $1A - OBJ_CHECKPOINT_FORCE
	.word ObjHit_BoundLR	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjHit_DoNothing	; Object $1C - OBJ_GREENPIRANHA_FIRE_X
	.word ObjHit_DoNothing	; Object $1D - OBJ_GREENSHELL
	.word ObjHit_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjHit_DoNothing	; Object $1F - OBJ_GROWINGVINE
	.word ObjHit_DoNothing	; Object $20 - OBJ_COINSNAKE
	.word ObjHit_LaunchStar	; Object $21 - OBJ_LAUNCHSTAR
	.word ObjHit_DoNothing	; Object $22 - OBJ_MUSICSET
	.word ObjHit_Checkpoint	; Object $23 - OBJ_CHECKPOINT

	
	; Object group $00 (i.e. objects starting at ID $00) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup00_Attributes:
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $00
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $01 - OBJ_PIPERAISE1
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $02 - OBJ_PIPERAISE2
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $03 - OBJ_PIPERAISE3
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $04 - OBJ_PIPERAISE4
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH32	; Object $05 - OBJ_BOSS_BOWSER2
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $07 - OBJ_PARADRYBONES
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $08 - OBJ_PSWITCHDOOR
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH32	; Object $09 - OBJ_BOSS_BOWSERFINAL
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0A - OBJ_EERIE
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0B - OBJ_POWERUP_1UP
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $0E - OBJ_TOPMANIC
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $0F - OBJ_RGREENTROOPA
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $10 - OBJ_RREDTROOPA
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $11 - OBJ_RPARATROOPAGREENHOP
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $12 - OBJ_RFLYINGREDPARATROOPA
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $13 - OBJ_RBUZZYBEATLE
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $14 - OBJ_RSPINY
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $15 - OBJ_RGOOMBA
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $16 - OBJ_TOPMAN
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $17 - OBJ_SPINYCHEEP
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH32	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1A - OBJ_CHECKPOINT_FORCE
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $1C - OBJ_GREENPIRANHA_FIRE_X
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1D - OBJ_GREENSHELL
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1F - OBJ_GROWINGVINE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $20 - OBJ_COINSNAKE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $21 - OBJ_LAUNCHSTAR
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $22 - OBJ_MUSICSET
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $23 - OBJ_CHECKPOINT


	; Object group $00 (i.e. objects starting at ID $00) second set attribute bits

	; Attribute bits for objects:
	;	Bits 0: If set, object is NOT a "shelled" enemy
	;	Bits 1: Subtly modifies Player detection response; see comments in PRG000_D205
	;	Bits 2: If set, object doesn't respond if stomped (indifferent, not same as attr 3, bit 5 which leads to hurting player)
	;	Bits 3: Object uses 16-bit X value (otherwise, Object_XHi will be zeroed)
	;	Bits 4-7: Pick root tile detection group offset (from Object_TileDetectOffsets)

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup00_Attributes2:
	.byte OA2_TDOGRP0	; Object $00
	.byte OA2_TDOGRP0	; Object $01 - OBJ_PIPERAISE1
	.byte OA2_TDOGRP0	; Object $02 - OBJ_PIPERAISE2
	.byte OA2_TDOGRP0	; Object $03 - OBJ_PIPERAISE3
	.byte OA2_TDOGRP0	; Object $04 - OBJ_PIPERAISE4
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP12	; Object $05 - OBJ_BOSS_BOWSER2
	.byte OA2_TDOGRP1	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA2_TDOGRP1	; Object $07 - OBJ_PARADRYBONES
	.byte OA2_TDOGRP0	; Object $08 - OBJ_PSWITCHDOOR
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP12	; Object $09 - OBJ_BOSS_BOWSERFINAL
	.byte OA2_TDOGRP1	; Object $0A - OBJ_EERIE
	.byte OA2_TDOGRP1	; Object $0B - OBJ_POWERUP_1UP
	.byte OA2_TDOGRP1	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA2_TDOGRP1	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP10	; Object $0E - OBJ_TOPMANIC
	.byte OA2_TDOGRP0	; Object $0F - OBJ_RGREENTROOPA
	.byte OA2_TDOGRP0	; Object $10 - OBJ_RREDTROOPA
	.byte OA2_TDOGRP0	; Object $11 - OBJ_RPARATROOPAGREENHOP
	.byte OA2_TDOGRP0	; Object $12 - OBJ_RFLYINGREDPARATROOPA
	.byte OA2_TDOGRP0	; Object $13 - OBJ_RBUZZYBEATLE
	.byte OA2_TDOGRP0	; Object $14 - OBJ_RSPINY
	.byte OA2_TDOGRP0	; Object $15 - OBJ_RGOOMBA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $16 - OBJ_TOPMAN
	.byte OA2_TDOGRP1	; Object $17 - OBJ_SPINYCHEEP
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP12	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA2_TDOGRP1	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA2_TDOGRP1	; Object $1A - OBJ_CHECKPOINT_FORCE
	.byte OA2_TDOGRP1	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $1C - OBJ_GREENPIRANHA_FIRE_X
	.byte OA2_TDOGRP0	; Object $1D - OBJ_GREENSHELL
	.byte OA2_TDOGRP1	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA2_TDOGRP1	; Object $1F - OBJ_GROWINGVINE
	.byte OA2_TDOGRP0	; Object $20 - OBJ_COINSNAKE
	.byte OA2_TDOGRP0	; Object $21 - OBJ_LAUNCHSTAR
	.byte OA2_TDOGRP1	; Object $22 - OBJ_MUSICSET
	.byte OA2_TDOGRP1	; Object $23 - OBJ_CHECKPOINT


	; Object group $00 (i.e. objects starting at ID $00) third set attribute bits

	; Attribute bits for objects:
	;	Bits 0-3: Determines what to do when gameplay halted (see Object_DoHaltedAction, most common is 5 / 0101)
	;	Bit 4: If set, enemy goes to "squashed" (state 7) after being stomped, otherwise it goes to "shelled" (state 3); in the case of being stomped by Kuribo's shoe or the Rabbit statue, squashed enemies still get sqashed, and otherwise they get "killed" (6)
	;	Bit 5: Object is NOT stompable (e.g. a spikey enemy, HURTS PLAYER, not same as attr 2 bit 2 which is just indifferent)
	;	Bit 6: The CollideJumpTable entry MAY contain the "special" entry; see CollideJumpTable; also "dies" into "shell" (state 3) (i.e. object "bumps" into shell when hit from beneath)
	;	Bit 7: If set, object cannot be tail attacked

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup00_Attributes3:
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $00
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $01 - OBJ_PIPERAISE1
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $02 - OBJ_PIPERAISE2
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE 	; Object $03 - OBJ_PIPERAISE3
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE 	; Object $04 - OBJ_PIPERAISE4
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $05 - OBJ_BOSS_BOWSER2
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA3_HALT_NORMALONLY | OA3_DIESHELLED | OA3_TAILATKIMMUNE	; Object $07 - OBJ_PARADRYBONES
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $08 - OBJ_PSWITCHDOOR
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $09 - OBJ_BOSS_BOWSERFINAL
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $0A - OBJ_EERIE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0B - OBJ_POWERUP_1UP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0E - OBJ_TOPMANIC
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $0F - OBJ_RGREENTROOPA
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $10 - OBJ_RREDTROOPA
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $11 - OBJ_RPARATROOPAGREENHOP
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $12 - OBJ_RFLYINGREDPARATROOPA
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $13 - OBJ_RBUZZYBEATLE
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $14 - OBJ_RSPINY
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $15 - OBJ_RGOOMBA
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE 	; Object $16 - OBJ_TOPMAN
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $17 - OBJ_SPINYCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA3_HALT_JUSTDRAW 	; Object $1A - OBJ_CHECKPOINT_FORCE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $1C - OBJ_GREENPIRANHA_FIRE_X
	.byte OA3_HALT_DONOTHING 	; Object $1D - OBJ_GREENSHELL
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $1F - OBJ_GROWINGVINE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE 	; Object $20 - OBJ_COINSNAKE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $21 - OBJ_LAUNCHSTAR
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $22 - OBJ_MUSICSET
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $23 - OBJ_CHECKPOINT


	; Object group $00 (i.e. objects starting at ID $00) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup00_PatTableSel:
	.byte OPTS_NOCHANGE	; Object $00
	.byte OPTS_NOCHANGE	; Object $01 - OBJ_PIPERAISE1
	.byte OPTS_NOCHANGE	; Object $02 - OBJ_PIPERAISE2
	.byte OPTS_NOCHANGE	; Object $03 - OBJ_PIPERAISE3
	.byte OPTS_NOCHANGE	; Object $04 - OBJ_PIPERAISE4
	.byte OPTS_SETPT5 | $3A	; Object $05 - OBJ_BOSS_BOWSER2
	.byte OPTS_NOCHANGE	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OPTS_SETPT6 | $13	; Object $07 - OBJ_PARADRYBONES
	.byte OPTS_SETPT6 | $13	; Object $08 - OBJ_PSWITCHDOOR
	.byte OPTS_SETPT5 | $3A	; Object $09 - OBJ_BOSS_BOWSERFINAL
	.byte OPTS_SETPT5 | $12	; Object $0A - OBJ_EERIE
	.byte OPTS_NOCHANGE	; Object $0B - OBJ_POWERUP_1UP
	.byte OPTS_NOCHANGE	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OPTS_NOCHANGE	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OPTS_SETPT5 | 76	; Object $0E - OBJ_TOPMANIC
	.byte OPTS_NOCHANGE	; Object $0F - OBJ_RGREENTROOPA
	.byte OPTS_NOCHANGE	; Object $10 - OBJ_RREDTROOPA
	.byte OPTS_NOCHANGE	; Object $11 - OBJ_RPARATROOPAGREENHOP
	.byte OPTS_NOCHANGE	; Object $12 - OBJ_RFLYINGREDPARATROOPA
	.byte OPTS_NOCHANGE	; Object $13 - OBJ_RBUZZYBEATLE
	.byte OPTS_NOCHANGE	; Object $14 - OBJ_RSPINY
	.byte OPTS_NOCHANGE	; Object $15 - OBJ_RGOOMBA
	.byte OPTS_NOCHANGE	; Object $16 - OBJ_TOPMAN
	.byte OPTS_SETPT5 | $1A	; Object $17 - OBJ_SPINYCHEEP
	.byte OPTS_SETPT5 | $3A	; Object $18 - OBJ_BOSS_BOWSER
	.byte OPTS_NOCHANGE	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OPTS_NOCHANGE	; Object $1A - OBJ_CHECKPOINT_FORCE
	.byte OPTS_NOCHANGE	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OPTS_SETPT6 | $4F	; Object $1C - OBJ_GREENPIRANHA_FIRE_X
	.byte OPTS_NOCHANGE	; Object $1D - OBJ_GREENSHELL
	.byte OPTS_NOCHANGE	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OPTS_SETPT6 | $4F	; Object $1F - OBJ_GROWINGVINE
	.byte OPTS_NOCHANGE	; Object $20 - OBJ_COINSNAKE
	.byte OPTS_NOCHANGE	; Object $21 - OBJ_LAUNCHSTAR
	.byte OPTS_NOCHANGE	; Object $22 - OBJ_MUSICSET
	.byte OPTS_NOCHANGE	; Object $23 - OBJ_CHECKPOINT


	; Object group $00 (i.e. objects starting at ID $00) "Kill Action"

	.org ObjectGroup_Attributes4	; <-- help enforce this table *here*
ObjectGroup00_Attributes4:
	.byte OA4_KA_STANDARD	; Object $00
	.byte OA4_KA_STANDARD	; Object $01 - OBJ_PIPERAISE1
	.byte OA4_KA_STANDARD	; Object $02 - OBJ_PIPERAISE2
	.byte OA4_KA_STANDARD	; Object $03 - OBJ_PIPERAISE3
	.byte OA4_KA_STANDARD	; Object $04 - OBJ_PIPERAISE4
	.byte OA4_KA_NORMALSTATE	; Object $05 - OBJ_BOSS_BOWSER2
	.byte OA4_KA_STANDARD	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA4_KA_NORMALANDKILLED	; Object $07 - OBJ_PARADRYBONES
	.byte OA4_KA_STANDARD	; Object $08 - OBJ_PSWITCHDOOR
	.byte OA4_KA_NORMALSTATE	; Object $09 - OBJ_BOSS_BOWSERFINAL
	.byte OA4_KA_JUSTDRAW16X16	; Object $0A - OBJ_EERIE
	.byte OA4_KA_JUSTDRAWMIRROR	; Object $0B - OBJ_POWERUP_1UP
	.byte OA4_KA_JUSTDRAWMIRROR	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA4_KA_JUSTDRAWMIRROR	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA4_KA_NORMALSTATE	; Object $0E - OBJ_TOPMANIC
	.byte OA4_KA_STANDARD	; Object $0F - OBJ_RGREENTROOPA
	.byte OA4_KA_STANDARD	; Object $10 - OBJ_RREDTROOPA
	.byte OA4_KA_STANDARD	; Object $11 - OBJ_RPARATROOPAGREENHOP
	.byte OA4_KA_STANDARD	; Object $12 - OBJ_RFLYINGREDPARATROOPA
	.byte OA4_KA_STANDARD	; Object $13 - OBJ_RBUZZYBEATLE
	.byte OA4_KA_STANDARD	; Object $14 - OBJ_RSPINY
	.byte OA4_KA_STANDARD	; Object $15 - OBJ_RGOOMBA
	.byte OA4_KA_POOFDEATH	; Object $16 - OBJ_TOPMAN
	.byte OA4_KA_JUSTDRAW16X16	; Object $17 - OBJ_SPINYCHEEP
	.byte OA4_KA_NORMALSTATE	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA4_KA_JUSTDRAWMIRROR	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA4_KA_STANDARD	; Object $1A - OBJ_CHECKPOINT_FORCE
	.byte OA4_KA_STANDARD	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA4_KA_POOFDEATH	; Object $1C - OBJ_GREENPIRANHA_FIRE_X
	.byte OA4_KA_JUSTDRAWMIRROR	; Object $1D - OBJ_GREENSHELL
	.byte OA4_KA_STANDARD	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA4_KA_STANDARD	; Object $1F - OBJ_GROWINGVINE
	.byte OA4_KA_STANDARD	; Object $20 - OBJ_COINSNAKE
	.byte OA4_KA_STANDARD	; Object $21 - OBJ_LAUNCHSTAR
	.byte OA4_KA_STANDARD	; Object $22 - OBJ_MUSICSET
	.byte OA4_KA_STANDARD	; Object $23 - OBJ_CHECKPOINT


	; Object group $00 (i.e. objects starting at ID $00) pattern index starts
	; These are used for all states except "normal"

OG0_POff .func (\1 - ObjectGroup00_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup00_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG0_POff(ObjP00), OG0_POff(ObjP01), OG0_POff(ObjP02), OG0_POff(ObjP03)
	.byte OG0_POff(ObjP04), OG0_POff(ObjP05), OG0_POff(ObjP06), OG0_POff(ObjP07)
	.byte OG0_POff(ObjP08), OG0_POff(ObjP09), OG0_POff(ObjP0A), OG0_POff(ObjP0B)
	.byte OG0_POff(ObjP0C), OG0_POff(ObjP0D), OG0_POff(ObjP0E), OG0_POff(ObjP0F)
	.byte OG0_POff(ObjP10), OG0_POff(ObjP11), OG0_POff(ObjP12), OG0_POff(ObjP13)
	.byte OG0_POff(ObjP14), OG0_POff(ObjP15), OG0_POff(ObjP16), OG0_POff(ObjP17)
	.byte OG0_POff(ObjP18), OG0_POff(ObjP19), OG0_POff(ObjP1A), OG0_POff(ObjP1B)
	.byte OG0_POff(ObjP1C), OG0_POff(ObjP1D), OG0_POff(ObjP1E), OG0_POff(ObjP1F)
	.byte OG0_POff(ObjP20), OG0_POff(ObjP21), OG0_POff(ObjP22), OG0_POff(ObjP23)

	; Object group $00 (i.e. objects starting at ID $00) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup00_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup00_PatternSets:

	; (End restricted alignment space)
ObjP00:
ObjP01:
ObjP02:
ObjP03:
ObjP04:
ObjP05:
ObjP09:
ObjP0F:
ObjP10:
ObjP11:
ObjP12:
ObjP13:
ObjP14:
ObjP15:
ObjP17:
ObjP18:
	.byte $AD, $AF, $B9, $BB, $B9, $BB	
ObjP1D:
	.byte $BD, $BD	; 0
	.byte $BD, $BD	; 1
	.byte $BD, $BD	; 2 killed
	.byte $BD, $BD	; 3 shell state
	.byte $BD, $BD	; 4 spin
	.byte $B7, $B9	; 5 spin
	.byte $B9, $BB	; 6 spin
ObjP06:	
ObjP1B:
ObjP0A:	.byte $99, $9B, $9D, $9F
ObjP0C:	.byte $55, $55, $7D, $7D, $69, $69, $5F, $5F
ObjP0B:	
ObjP0D:	.byte $51, $51
ObjP19:	.byte $53, $53
ObjP1A:	.byte $59, $5B
ObjP1C:	.byte $75, $77
ObjP1E:	.byte $5D, $5D
ObjP1F:	.byte $E1, $E1, $E5, $E5	; SB: SMW+ style "piranha topper" vine growth
ObjP20:	.byte $49, $4F, $49, $4F	; SB: Formerly $49, $4F, $4D, $4F
ObjP21:	
	.byte $91, $93, $95, $97
	.byte $A1, $A3, $A5, $A7
	.byte $B1, $B3, $B5, $B7
ObjP22:	.byte $53, $53
ObjP23:	.byte $55, $55
ObjP08:	.byte $FB, $F7, $F5, $F3, $BB, $B9, $B9, $BB, $BF, $BD
ObjP07:
	.byte $C1, $C3, $C5, $C7, $C9, $CB, $CD, $CF, $D1, $D3, $D5, $F9, $DD, $DF
ObjP0E:
	.byte $81, $83, $85, $87
	.byte $91, $93, $95, $97
	.byte $A1, $A3, $A5, $A7
	.byte $B1, $B3, $B5, $B7
	.byte $B9, $BB, $BD, $BF

ObjP16:
	.byte $99, $9B, $9D, $9F, $99, $9B, $8D, $8F


SpinyCheep_XVel:
	.byte 8, -8

ObjInit_SpinyCheep:
	INC Objects_InWater,X	 ; Set object as in-water

	; Pick the correct X Velocity to chase Player
	JSR Level_ObjCalcXDiffs
	LDA SpinyCheep_XVel,Y
	STA <Objects_XVel,X

	; Var10 = Object's X
	LDA <Objects_X,X
	SUB #$30
	STA Objects_Var10,X

	; Var11 = Object's X + 96
	ADD #96
	STA Objects_Var11,X

	RTS		 ; Return

	; Y velocity acceleration and limits based on direction
SpinyCheep_YVelAccel:	.byte $01, -$01
SpinyCheep_YVelMax:	.byte $08, -$08

ObjNorm_SpinyCheep:
	LDA <Player_HaltGame
	BNE PRG001_A277	 ; If gameplay is halted, jump to PRG001_A277

	INC <Objects_Var5,X	 ; Not sure what this is used for?

	LDA <Counter_1	
	AND #$07	
	BNE PRG001_A23F	 ; Only proceed every 8 ticks, otherwise, jump to PRG001_A23F

	LDA <Objects_Var4,X	 ; Get Var 4 (selects direction)
	AND #$01
	TAY		 ; Y = 0 or 1

	; Spike Cheep's Y velocity
	LDA <Objects_YVel,X
	ADD SpinyCheep_YVelAccel,Y
	STA <Objects_YVel,X

	CMP SpinyCheep_YVelMax,Y
	BNE PRG001_A23F	 	; If Spiny cheep hasn't hit velocity limit, jump to PRG001_A23F

	INC <Objects_Var4,X	 ; Effectively, change direction

PRG001_A23F:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_X,X
	CMP Objects_Var10,X
	BEQ PRG001_A25A	 	; If Spiny Cheep is back at his origin, jump to PRG001_A25A

	CMP Objects_Var11,X
	BEQ PRG001_A25A	 	; If Spiny Cheep is at his origin + 96, jump to PRG001_A25A

	JSR Object_WorldDetect4	 

	LDA <Objects_DetStat,X	
	AND #$03	 
	BEQ PRG001_A263	 ; If spiny cheep hasn't hit a wall on either side, jump to PRG001_A263

PRG001_A25A:
	; Flip Spiny cheep around!
	JSR Object_AboutFace
	JSR Object_ApplyXVel
	JSR Object_ApplyXVel

PRG001_A263:
	JSR Player_HitEnemy	 ; Player hits enemy
	JSR Object_DeleteOffScreen_N4	 ; Delete object if it falls off-screen

	; Swim frame based on counter and index (just to keep it interesting)
	TXA
	ASL A
	ASL A
	ADC Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

PRG001_A277:
	JMP Object_ShakeAndDraw	 ; Draw object and don't return


	RTS		 ; Return



ObjInit_BounceDU: 
	LDA Player_ReverseGrav
	BEQ ObjInit_BounceDU_NoRev

	STA Objects_ReverseGrav,X

	; SB: If reverse gravity and downward direction, need to push Player away 
	; a little bit or else he gets stuck for some reason
	LDA Player_BounceDir
	BEQ ObjInit_BounceDU_NoRev


ObjInit_BounceDU_NoRev:
	LDA Player_BounceDir
	STA Objects_Var2,X	 ; Store Player's bounce into var 2
	BEQ PRG001_A4BF	 ; If bounce direction is down, jump to PRG001_A4BF

	LDA Player_BounceObj
	BNE PRG001_A4C6	 ; If this is actually an object that bounced, jump to PRG001_A4C6

	LDA #$20	 
	STA <Player_YVel ; PRG001_A4C6 = $20 (bounce down)

PRG001_A4BF:
	STX <Player_InAir ; Mark Player as mid-air

	LDA #$00
	STA Player_Flip	 ; Cancel invincibility somersault

PRG001_A4C6:
	LDA Player_Bounce
	STA Objects_Var1,X	; Store Player_Bounce -> var1

	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 ; Shift right 4
	STA Objects_Frame,X	 ; Store into Objects_Frame 
 
	LDA #$00
	STA Player_Bounce	 ; Clear Player_Bounce
	STA Player_BounceObj	 ; Clear Player_BounceObj
	STA Objects_FlipBits,X	 ; Force left/right flag to zero
	STA Objects_SprVVis,X	 ; Clear flags 2
	STA Objects_SprHVis,X	 ; Clear flags 1

	LDA #10
	STA Level_BlkBump_Pos-6,X ; Block bump position = 10

	JMP BounceBlock_Update	 ; Jump to BounceBlock_Update

	; Power-up which may emerge from different types of bounce blocks
Bouncer_PUp:	.byte $00, $00, OBJ_POWERUP_FIREFLOWER, OBJ_POWERUP_SUPERLEAF, OBJ_POWERUP_STARMAN
		.byte OBJ_POWERUP_MUSHROOM, OBJ_GROWINGVINE, OBJ_POWERUP_1UP
Bouncer_PUp_SS:	
		.byte OBJ_POWERUP_STARMAN, OBJ_POWERUP_STARMAN, OBJ_POWERUP_STARMAN	; SB: New: Super suits
Bouncer_PUp_SS_End

Bounce_TileReplacements:	
	.byte CHNGTILE_TOGNOTEBLOCK
	.byte CHNGTILE_COINHEAVEN
	.byte CHNGTILE_TOMETALPLATE
	.byte CHNGTILE_TOBRICK
	.byte CHNGTILE_TONOTEBLOCK
	.byte CHNGTILE_TOBOUNCEWOOD
	.byte CHNGTILE_TOBRICKCOIN
	.byte CHNGTILE_PIPEJCT

	; Power-up X or Y velocity upon emerging from the bounce block
Bouncer_PUpVel:	.byte $00, -$40, -$40, -$30, -$20, -$10, $00, $10, $20, $30, $40
		.byte -$20, -$20, -$20	; SB: New: Super suits


ObjNorm_BounceDU:
	LDY Level_BlkBump_Pos-6,X
	BNE PRG001_A56F	 ; If the block bump position > 0, jump to PRG001_A56F

	; Block bump complete
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X	; Set state to dead/empty

	LDA Objects_Var1,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Var1 >> 4 -> 'Y'

	LDA Bounce_TileReplacements,Y
	CMP #$07	 
	BNE PRG001_A527	 ; If value <> 7, jump to PRG001_A527

	LDY Level_PSwitchCnt
	BEQ PRG001_A527	 ; If P-Switch not active, jump to PRG001_A527

	LDA #CHNGTILE_FROZENCOIN	 ; Otherwise, A = CHNGTILE_FROZENCOIN (same as "frozen coin" thawing, replace coin)

PRG001_A527:
	STA <Temp_Var12  ; -> Temp_Var12

	; Temp_Var15 = bumper X Hi
	LDA <Objects_XHi,X
	STA <Temp_Var15	 

	; Temp_Var16 = bumper X
	LDA <Objects_X,X
	STA <Temp_Var16	 

	; Temp_Var13 = bumper Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Temp_Var14 = bumper Y, grid aligned
	LDA <Objects_Y,X
	AND #$f0	
	STA <Temp_Var14	

	JSR BlockBump_Init

	LDA Objects_Var2,X
	BNE PRG001_A56E	 ; If Var 2 <> 0, jump to PRG001_A56E (RTS)

	LDA #-$38
	STA <Player_YVel	 ; Set Player bounce
	STA Player_mGoomba	 

	LDA Objects_Timer2,X
	BEQ PRG001_A56E	 ; If timer 2 expired, jump to PRG001_A56E (RTS)

	LDA #-$70
	STA <Player_YVel	; Larger Player bounce

	LDA Objects_Var1,X
	AND #$f0
	CMP #$10
	BNE PRG001_A56E	 ; If var 1 upper 4 bits <> $10, jump to PRG001_A56E (RTS)

	LDA Player_InWater
	BNE PRG001_A56E	 ; If Player is in water, jump to PRG001_A56E (RTS)

OHLS_SendAway:
	; Flag to go to coin heaven
	LDA #$80
	STA Level_CoinHeav

	; Bounce into coin heaven sound
	LDA Sound_QLevel1
	ORA #SND_LEVELVINE
	STA Sound_QLevel1

PRG001_A56E:
	RTS		 ; Return


PRG001_A56F:
	LDA Level_BlkBump_Pos-6,X
	CMP #10
	BNE PRG001_A5D5	 ; If Block bump position <> 10, jump to PRG001_A5D5

	; Block bump position is 10...

	LDA Objects_Var1,X
	AND #$0f
	TAY		 ; Y = 0 to 15, based on var 1

	LDA Bouncer_PUp,Y
	BEQ PRG001_A5BB	 ; If value is zero (no power up), jump to PRG001_A5BB

	STA <Temp_Var1	 ; Store value -> Temp_Var1

	LDY #$05	 ; Y = 5 (power-up always in slot 5)

	; Set the ID
	LDA <Temp_Var1
	STA Level_ObjectID,Y

	LDA Objects_Var1,X
	AND #$0f
	CMP #(Bouncer_PUp_SS - Bouncer_PUp)
	BLT Bouncer_Not_SuperSuit	; If not a super suit, jump to Bouncer_Not_SuperSuit
	CMP #(Bouncer_PUp_SS_End - Bouncer_PUp)
	BGE Bouncer_Not_SuperSuit	; If not a super suit, jump to Bouncer_Not_SuperSuit

	; Super suit!  Just set frame!
	SUB #(Bouncer_PUp_SS - Bouncer_PUp - 1)
	STA Objects_Frame,X

Bouncer_Not_SuperSuit:

	; Set X
	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; State 1 (Initialize)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

	; Set Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var1

	LDA #$08	 ; A = 8

	STY <Temp_Var2		 ; Backup 'Y' -> Temp_Var2

	LDY Objects_Var2,X
	BEQ PRG001_A5AA	 ; If var2 = 0, jump to PRG001_A5AA

	DEC <Temp_Var1	 ; Temp_Var1-- (Y Hi)
	LDA #-1		 ; A = -1

PRG001_A5AA:
	LDY <Temp_Var2	 ; Restore 'Y'

	ADD <Objects_Y,X ; Apply Y offset
	STA Objects_Y,Y	 ; -> Object's Y
 
	BCC PRG001_A5B6	 ; If no carry, jump to PRG001_A5B6

	INC <Temp_Var1	 ; Apply carry

PRG001_A5B6:
	; Set Y Hi
	LDA <Temp_Var1
	STA Objects_YHi,Y

PRG001_A5BB:
	; Backup Y Hi -> Temp_Var13 
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Backup Y -> Temp_Var14
	LDA <Objects_Y,X
	STA <Temp_Var14

	; Backup X Hi -> Temp_Var15
	LDA <Objects_XHi,X
	STA <Temp_Var15

	; Backup X -> Temp_Var16
	LDA <Objects_X,X
	STA <Temp_Var16

	LDA Objects_Var2,X
	BEQ PRG001_A5D5	 ; If Var2 = 0, jump to PRG001_A5D5

	; Erase the tile behind the bump
	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars

PRG001_A5D5:
	JSR Object_ApplyYVel	 ; Apply Y velocity
	JSR BounceBlock_Update

	LDY Level_BlkBump_Pos-6,X	; Y = block bump pos

	LDA Bouncer_PUpVel,Y

	LDY Objects_Var2,X	 ; Y = var2
	BEQ PRG001_A5EE	 ; If Var2 = 0, jump to PRG001_A5EE

	JSR Negate	 ; Negate retrieved Y Velocity

	STA <Objects_YVel,X	; Set Y Velocity 

	JMP PRG001_A5FD	 ; Jump to PRG001_A5FD

PRG001_A5EE:
	STA <Objects_YVel,X	 ; Set Y Velocity 
	STA <Player_YVel	 ; ... of Player too

	LDA <Pad_Input
	AND #PAD_A
	BEQ PRG001_A5FD	 ; If Player is not pressing A, jump to PRG001_A5FD

	; Otherwise, Timer 2 = 11
	LDA #$0b
	STA Objects_Timer2,X

PRG001_A5FD:
	DEC Level_BlkBump_Pos-6,X	; Block bump pos--
	RTS		 ; Return

	; The following block bounces are referenced by PRG008's LATR_BlockResult
	; Type 7 is for the UNUSED breakable pipeworks tile!

	; Palette select for a bounce block
BounceBlock_Pal:
	.byte SPR_PAL1	; 0 (possibly unused / Note Block)
	.byte SPR_PAL2	; 1 (coin heaven Note Block)
	.byte SPR_PAL3	; 2 ("Metal plate" post-? block hit)
	.byte SPR_PAL3	; 3 (used for empty brick)
	.byte SPR_PAL1	; 4 (typical Note Block)
	.byte SPR_PAL3	; 5 (wood)
	.byte SPR_PAL3	; 6 (used for brick with coins)
	.byte SPR_PAL1	; 7 (UNUSED, would be for desert's breakable pipeworks tile!)

	; Offset into Sprite_RAM based on which block bounce slot
BounceBlock_SprOff:
	.byte $08, $10

	; Tile for block bounce sprite (if same, mirrors)
BounceBlock_Tile:
	.byte $79, $7B	; 0 (possibly unused / Note Block)
	.byte $79, $7B	; 1 (coin heaven Note Block)
	.byte $77, $77	; 2 ("Metal plate" post-? block hit)
	.byte $75, $75	; 3 (used for empty brick)
	.byte $79, $7B	; 4 (typical Note Block)
	.byte $77, $77	; 5 (wood)	; SB: "Metal plate" because I needed patterns!
	.byte $75, $75	; 6 (used for brick with coins)
	.byte $7B, $7B	; 7 (UNUSED, would be for desert's breakable pipeworks tile!)

BounceBlock_Update:
	LDA Objects_Var1,X	; Player_Bounce
	LSR A
	LSR A
	LSR A
	LSR A		; Get kind of block that is getting bounced
	TAY		; -> Y

	; Temp_Var1 stores palette of object
	LDA BounceBlock_Pal,Y	
	STA <Temp_Var1

	; Y *= 2
	TYA
	ASL A
	TAY

	; Temp_Var2/3 store the tiles that make up the sprites of the bounce block
	LDA BounceBlock_Tile,Y
	STA <Temp_Var2		
	LDA BounceBlock_Tile+1,Y
	STA <Temp_Var3		

	LDA #$00	 ; A = 0 (do not flip second sprite)

	LDY <Temp_Var2
	CPY <Temp_Var3
	BNE PRG001_A63F	 ; If tiles are NOT the same, jump to PRG001_A63F

	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (flip second sprite)

PRG001_A63F:
	STA <Temp_Var4	 ; Store the selected sprite attribute

	LDA #$05
	ADD Counter_7to0
	TAY		 ; Y = 5 + (0 to 7)

	LDA SprRamOffsets,Y
	PHA		 ; Save this value

	; Block bouncers always appear in object slot 6 or 7, so this makes it relative to 0 or 1
	TXA		 
	SUB #$06	 
	TAY		 ; Y = 0 or 1
 
	PLA		 ; Restore the value

	ADD BounceBlock_SprOff,Y
	TAY		 ; Y is now offset into Sprite_RAM

	; Screen-relative X position for sprite position
	LDA <Objects_X,X
	SUB Horz_Scroll	
	STA <Objects_SpriteX,X

	; Store two pieces of bounce block sprite X
	STA Sprite_RAM+3,Y
	ADD #$08	 
	STA Sprite_RAM+7,Y

	; Screen-relative Y position for sprite position
	LDA <Objects_Y,X
	SUB Level_VertScroll
	SUB #$01
	STA <Objects_SpriteY,X

	; Store two pieces of bounce block sprite Y
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y

	; Build the other parts of sprites
	LDA <Temp_Var2
	STA Sprite_RAM+1,Y

	LDA <Temp_Var3
	STA Sprite_RAM+5,Y

	LDA <Temp_Var1
	STA Sprite_RAM+2,Y

	ORA <Temp_Var4
	STA Sprite_RAM+6,Y

	RTS		 ; Return


Eerie_XVel:	.byte $10, -$10
Eerie_FlipBitsStart:	.byte SPR_HFLIP, $00

ObjInit_Eerie:

	JSR Level_ObjCalcXDiffs

	; Pick the correct X Velocity to chase Player
	LDA Eerie_XVel,Y
	STA <Objects_XVel,X

	; Eerie faces Player
	LDA Eerie_FlipBitsStart,Y
	STA Objects_FlipBits,X

	RTS		 ; Return


ObjNorm_Eerie:
	LDA <Player_HaltGame
	BNE Eerie_JustDraw	 ; If gameplay is halted, jump to PRG001_A277

	; Toggle frames based on counter and index (just to keep it interesting)
	TXA
	ASL A
	ASL A
	ADC Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR Object_ApplyXVel

	JSR Player_HitEnemy	 ; Player hits enemy
	JSR Object_DeleteOffScreen_N4	 ; Delete object if it falls off-screen

Eerie_JustDraw:
	JMP Object_ShakeAndDraw


ObjNorm_PUp1UpMush:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_A78E	 	; If mushroom has not hit ground, jump to PRG001_A78E

	LDA <Objects_XVel,X
	BNE PRG001_A78E	 	; If mushroom is moving horizontally, jump to PRG001_A78E

	JSR PowerUp_BounceXVel	 ; Bounce off wall

PRG001_A78E:
	JSR Object_InteractWithWorld	 	; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen 		; Delete object if it falls off screen
	JMP PowerUp_DoHitTest	 		; Do hit test and don't come back!


ObjHit_PUp1UpMush:

	; "1-UP"
	LDA #$0d	
	JSR Score_PopUp	

	; Set to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	RTS		 ; Return

Star_Palettes:
	.byte SPR_PAL0, SPR_PAL3, SPR_PAL2, SPR_PAL2

ObjInit_StarOrSuit:
	; Set gravity by Player
	LDA Player_ReverseGrav
	STA Objects_ReverseGrav,X

	JSR Mushroom_SetFall	 ; Figure the way that the star should fall

	LDA #$10	
	STA Objects_Timer2,X	 ; Object's timer 2 = 16

	; This will make mushroom drop downward if it was "knocked out" downward
	LDY #$10	
	LDA Player_BounceDir
	BEQ PRG001_A7BF	 
	LDY #0		; SB: Old value was -$38; not really needed since star will bounce anyway

	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X	 ; Set object's timer to $3d

PRG001_A7BF:
	STY <Objects_YVel,X	 ; Set object's Y velocity
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?

	; SB: Star Man uses this routine stock, other super suits will do something different...

	JSR PowerUp_BounceXVel	 ; Bounce off wall

	; 1 = Rabbit
	; 2 = Penguin
	; 3 = Boomerang
	LDA PUp_StarManFlash
	AND #$7F
	BEQ PUp_IsStar		; If this really is a Star Man, jump to PUp_IsStar
	
	; Other suits...
	LDY #0	; Y = 0
	
	CMP #1
	BEQ PUp_IsRabbit	; If this is Rabbit, jump to PUp_IsRabbit
	
	CMP #2
	BNE PUp_IsBoomerang	; If this is not Penguin, jump to PUp_IsBoomerang

	; Penguin suit moves SLOWLY...
	LDA <Objects_XVel,X
	ASR
	ASR
	ASR
	TAY
	BNE PUp_IsRabbit
	
PUp_IsBoomerang:
	; .. ?


PUp_IsRabbit:
	STY <Objects_XVel,X

PUp_IsStar:
	LDA PUp_StarManFlash
	AND #$03	 
	STA Objects_Frame,X
	TAY

	; Set a start palette
	LDA Star_Palettes,Y
	STA Objects_SprAttr,X

	RTS		 ; Return


ObjNorm_StarOrSuit:
	LDA <Objects_Var5,X
	BEQ SOS_Normal			; Var5 being non-zero is a special cinematic star for World 7

	; Cinematic star!
	JSR Object_ShakeAndDrawMirrored
	
	LDA #-$14
	STA <Objects_XVel,X
	LDA #$20
	STA <Objects_YVel,X
	
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel
	
	DEC <Objects_Var5,X			; Var5--
	BNE SOS_Cine_StillGoing		; If Var5 > 0, jump to SOS_Cine_StillGoing
	
	JMP Object_Delete
	
SOS_Cine_StillGoing:
	RTS

SOS_Normal:
	LDA PUp_StarManFlash
	BPL PRG001_A7E0	 ; If flashing is not active, jump to PRG001_A7E0

	; Store counter into cycler
	LDA <Counter_1	
	STA Objects_ColorCycle,X

PRG001_A7E0:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world

	LDA <Objects_DetStat,X
	TAY		 ; Detection status -> 'Y'

	AND #$04
	BEQ ONSOS_NotPenguin	 ; If star hasn't touched the ground, jump to PRG001_A7F1

	LDA Objects_Frame,X
	BNE PRG001_A7F1			; If not a Star Man, jump to PRG001_A7F1 (only Star Man will bounce around)

	LDA #-$40	; Ground bounce
	STA <Objects_YVel,X	; Star bounce off ground!

PRG001_A7F1:
	CMP #2
	BNE ONSOS_NotPenguin

	; Penguin only: Periodically hop when on-ground
	LDA <Counter_1
	AND #$3F
	BNE ONSOS_NotPenguin
	
	LDA #-$10
	STA <Objects_YVel,X

ONSOS_NotPenguin:
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!

	; Different "frames" of the "Starman" power up include the super
	; suits; Rabbit, Penguin, and Hammer, in order
PUp_StarOrSuitFrames:	.byte $00, $05, $04, $06	; Star, Rabbit, Penguin, Hammer

ObjHit_StarOrSuit:
	LDA Objects_Frame,X
	BNE PRG001_A818	 ; If frame <> 0, jump to PRG001_A818

	LDA Level_PSwitchCnt
	BNE PRG001_A810	 ; If P-Switch is active, jump to PRG001_A810

	; Otherwise, play invincibility theme!
	LDA Sound_QMusic2
	ORA #MUS2A_INVINCIBILITY
	STA Sound_QMusic2

	; SB: I like the "power up" sound with the Starman!
	LDA #SND_LEVELPOWER
	STA Sound_QLevel1

PRG001_A810:

	; Player_StarInv = $FF
	LDA #$FF
	STA Player_StarInv

	; Now that we use Kill_Tally for hit count with Star Man, reset it!
	LDA #0
	STA Kill_Tally

	JMP PUp_GeneralCollect	 ; Jump to PUp_GeneralCollect

PRG001_A818:

	; This is one of the Super Suits (Rabbit, Penguin, Hammer), not a Starman

	TAY		 ; Frame -> 'Y' (index)

	LDA PUp_StarOrSuitFrames,Y	 ; Get what kind of super suit this is
	CMP <Player_Suit
	BEQ PRG001_A834	 ; If this is already the suit that the Player is wearing, jump to PRG001_A834

	TAY		 ; Suit -> 'Y'
	INY		 ; Y++ (valid Player_QueueSuit value)
	STY Player_QueueSuit	 ; Queue changing to this suit!

	; SB: New effect: Store previous power up
	LDA <Player_Suit
	STA <Player_OldSuit

PRG001_A825:
	; New Power up Effect
	LDA #$30
	STA Player_Grow

	; Play suit power-up sound
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1

	; Technically this is just needed to keep you from "flying" with
	; the carrot, but I'll just lazily blank it for all
	LDA #0
	STA Player_FlyTime

	BNE PRG001_A837	 ; Jump (technically always) to PRG001_A837

PRG001_A834:
	JSR PowerUp_PlaySound	 ; Play Power Up sound

PRG001_A837:
	JMP PUp_GeneralCollect	 ; Jump to PUp_GeneralCollect


ObjInit_PUpMush:
 
	; Set gravity by Player
	LDA Player_ReverseGrav
	STA Objects_ReverseGrav,X

	JSR Mushroom_SetFall	 ; Figure the way that the mushroom should fall

	LDA #$10	
	STA Objects_Timer2,X	 ; Object's timer 2 = 16

	; SB: This is probably used by the Big ? block which CAN spawn mushroom/flower/star for some reason
	LDA PUp_StarManFlash
	BEQ PRG001_A852	 ; If flashing is NOT active, jump to PRG001_A852

	JSR Mushroom_SetXVel	 ; Set's X velocity appropriately by Player's 

	LDY #-$38
	JSR Mushroom_SetUpVel	 ; Set vertical velocity and mid air flag
	JMP PRG001_A859		; Jump to PRG001_A859

PRG001_A852:

	; This will make mushroom drop downward if it was "knocked out" downward
	LDY #$10	
	LDA Player_BounceDir
	BEQ Mushroom_SetUpVel

PRG001_A859:
	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X

	RTS		 ; Return


Mushroom_SetUpVel:
	STY <Objects_YVel,X	 ; Set object's Y velocity
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?
	RTS		 ; Return


Mushroom_SetXVel:
	LDY #$10	 ; Y = $10

	LDA <Player_X
	AND #$10	 ; determine if Player is on even/odd tile
	BNE PRG001_A86E	 ; Jump to PRG001_A86E if odd
	LDY #-$10	 ; Otherwise, Y = -$10
PRG001_A86E:
	STY <Objects_XVel,X	 ; Set X velocity appropriately
	RTS		 ; Return


ObjNorm_PUpMush:

	; Display vertically flipped if reverse gravity
	LDA Objects_ReverseGrav,X
	ROR A
	ROR A	; Convert 1 -> $80 (SPR_VFLIP)
	STA Objects_FlipBits,X

	JSR PowerUp_DoRaise	 ; Do power up raising out of box

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_A881	 ; If mushroom has NOT hit the ground, jump to PRG001_A881

	LDA <Objects_XVel,X
	BNE PRG001_A881	 ; If mushroom hasn't hit a wall, jump to PRG001_A881

	JSR PowerUp_BounceXVel	 ; Otherwise, bounce off wall!

PRG001_A881:
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

PowerUp_DoHitTest:
	; Cannot collect power up while it's "raising"
	LDA Objects_Timer2,X
	BNE PRG001_A892	 ; If the timer is still active, jump to PRG001_A892 (RTS)

	JSR Object_HitTestRespond	 ; Otherwise, perform hit testing

PRG001_A892:
	RTS		 ; Return

ObjHit_PUpMush:

	; Temp_Var = 1
	LDA #$01
	STA <Temp_Var1

PRG001_A897:
	JSR PowerUp_PlaySound	 ; Play Power Up sound

	LDA <Player_Suit
	BNE PUp_GeneralCollect	; If Player is not small, jump to PUp_GeneralCollect

	; Queue change to Super
	LDA #$02
	STA Player_QueueSuit

	LDA Player_Kuribo
	BEQ PRG001_A8AB	 ; If Player is NOT in a Kuribo's shoe, jump to PRG001_A8AB

	JMP PRG001_A825	 ; Jump to PRG001_A825

PRG001_A8AB:

	; Do "growing" animation
	LDA #$2f
	STA Player_Grow
	
	; The checkpoint also uses this entry so we don't want for it to be destroyed!
	LDA Level_ObjectID,X
	CMP #OBJ_CHECKPOINT
	BEQ PRG001_A892		; If we're actually a checkpoint, jump to PRG001_A892 (RTS)

PUp_GeneralCollect:
	; Get 1000 pts
	LDA #$09
	JSR Score_PopUp

	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X	 ; Set power-up to dead/empty

	RTS		 ; Return

PowerUp_PlaySound:
	; Play the standard "Power Up" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1
	RTS		 ; Return

PRG001_A940_fix:
	JMP PRG001_A940

PRG001_A93D_fix:
	JMP PRG001_A93D

PowerUp_DoRaise:
	LDA Objects_Timer,X
	BEQ PRG001_A940_fix	 ; If timer expired, jump to PRG001_A940 (will NOT return here if game is halted)

	CMP #$2d
	BNE PRG001_A8D5	 ; If object timer <> $2D, jump to PRG001_A8D5

	; Play powerup rising sound
	LDA Sound_QLevel1
	ORA #SND_LEVELRISE
	STA Sound_QLevel1

PRG001_A8D5:
	BGE PRG001_A93D_fix	 ; If timer is >= $2D, jump to PRG001_A93D

	; ObjSplash_DisTimer = 8
	LDA #$08
	STA ObjSplash_DisTimer,X

	DEC Objects_Var1,X	 ; Objects_Var1--
	BPL PRG001_A8F7	 ; If Objects_Var1 >= 0, jump to PRG001_A8F7

	; When var 1 falls below 0, reset to 2
	LDA #$02
	STA Objects_Var1,X

	LDA <Player_HaltGame
	BNE PRG001_A8F7	 ; If game is halted, jump to PRG001_A8F7


	; Game not halted...

	LDA Objects_ReverseGrav,X
	BEQ DoRaise_NoRev

	; Move powerup down 1 pixel
	LDA <Objects_Y,X
	ADD #$01
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	ADC #$00
	STA <Objects_YHi,X
	
	JMP PRG001_A8F7

DoRaise_MaskYOff:	.byte 15, -1	; For not-reversed-gravity, or reversed gravity

DoRaise_NoRev:
	; Move powerup up 1 pixel
	LDA <Objects_Y,X
	SUB #$01
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X

PRG001_A8F7:
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite

	LDA Level_PipeMove
	BNE PRG001_A937	 ; If Player in pipe, jump to PRG001_A937 (no masking sprite)

	LDY #$00	 ; Y = 0

	JSR Object_AnySprOffscreen
	BNE PRG001_A937	 ; If any sprite is off-screen, jump to PRG001_A937 (no masking sprite)

	; This puts on the masking sprite over the raising powerup

	STY <Temp_Var1	; Backup 'Y'

	LDY Objects_ReverseGrav,X	; Y = 0 or 1

	LDA <Objects_Y,X
	AND #$f0	 	; Align object Y to tile
	ADD DoRaise_MaskYOff,Y	; Apply appropriate offset
	SUB Level_VertScroll	; Calc relative to vertical scroll

	LDY <Temp_Var1	; Restore 'Y'

	; Set for both sprite halves Y
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y

	; Masking tile
	LDA #$77
	STA Sprite_RAM+1,Y
	STA Sprite_RAM+5,Y

	; Set sprite priority
	LDA #%00100000
	STA Sprite_RAM+2,Y
	STA Sprite_RAM+6,Y

	; Set sprite X's side by side
	LDA Objects_SpriteX,X
	STA Sprite_RAM+3,Y
	ADD #$08
	STA Sprite_RAM+7,Y

PRG001_A937:
	JSR PowerUp_DoHitTest	 ; Hit test power up when it has emerged from the box
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

PRG001_A93D:

	; Do NOT return to caller!
	PLA
	PLA

	RTS		 ; Return

PRG001_A940:
	LDA <Player_HaltGame
	BEQ PRG001_A949	 ; If game is NOT halted by Player, jump to PRG001_A949

	; Draw mushroom if game halted
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite

	; Do NOT return to caller!! (JSR could've been a JMP?)
	PLA
	PLA

PRG001_A949:
	RTS		 ; Return

	; Determines which way a mushroom should fall based on Player's position
Mushroom_SetFall:
	LDY #$00	 ; Y = 0 (mushroom falls to the left)

	LDA <Objects_X,X
	SUB <Horz_Scroll	; Make X relative to screen
	CMP <Player_SpriteX	
	BLT PRG001_A956	 	; If object X is less than Player's X, jump to PRG001_A956

	INY		 	; Otherwise, Y = 1 (mushroom falls to the right)

PRG001_A956:
	STY Player_MushFall	; Set direction of mushroom fall
	RTS		 ; Return

PowerUp_BounceXVel:
	LDY #$10	 ; Y = $10

	LDA Player_MushFall	
	BNE PRG001_A963	 ; If falling to right, jump to PRG001_A963
	LDY #-$10	 ; Otherwise, Y = -$10
PRG001_A963:
	STY <Objects_XVel,X	 ; Set X velocity appropriately


	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_InteractWithWorld
;
; Calls Object_Move and handles the object responding to hitting
; the floor/ceiling, or bump blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $A966
Object_InteractWithWorld:
	JSR Object_Move	; Move and collide with world

	LDA <Objects_DetStat,X

	TAY		 ; Object detection status -> 'Y'
	AND #$04	 
	BEQ PRG001_A973	 ; If object did NOT hit floor, jump to PRG001_A973

	JSR Object_HitGround ; Object hit ground, align

PRG001_A973:
	TYA		 ; Object detection status -> 'A'
	AND #$08
	BEQ PRG001_A97C	 ; If object did NOT hit ceiling, jump to PRG001_A97C

	LDA #$04
	STA <Objects_YVel,X ; Object hit ceiling, use rebound velocity

PRG001_A97C:
	LDA Object_TileFeet2
	CMP #TILEA_BLOCKBUMP_CLEAR
	BNE PRG001_A993	 ; If object did not hit the TILEA_BLOCKBUMP_CLEAR tile, jump to PRG001_A993

	; Hit the blockbump tile... (i.e. this kills an enemy who was unlucky enough to be on a bumped block)

	LDA #-$30
	STA <Objects_YVel,X	 ; Object Y velocity = -$30

	LDA <Objects_X,X
	ASL A	
	ASL A	
	ASL A	
	ASL A			; Shift X left 4 (sort of makes it a 4.4FP)
	EOR <Objects_XVel,X	; Flip against the "whole" part of the X velocity
	AND #$80	 	
	BNE PRG001_A9B1	 	; If object is on the left half of the tile with a right going velocity or vice versa, jump to PRG001_A9B1

PRG001_A993:

	; Object didn't hit the bump tile 

	TYA		 ; Object detection status -> 'A'
	AND #$03
	BEQ PRG001_A9B7	 ; If object did NOT hit a wall, jump to PRG001_A9B7 (RTS)

	CPX #$05
	BNE PRG001_A9B1	 ; If object slot is NOT 5, jump to PRG001_A9B1

	; Object slot 5 only...

	LSR A		 ; Shifts detection bits right 1
 
	LDA <Objects_X,X
	AND #$0f	 ; Tile-relative X

	LDY #$03	 ; Y = 3

	BCS PRG001_A9A7	 ; If object hit wall on the right, jump to PRG001_A9A7

	LDY #$03	 ; Otherwise, Y = 3 (oops?)

PRG001_A9A7:
	STY <Temp_Var1	 ; Temp_Var1 = 3 (because the above does nothing, heh)
	ADD <Temp_Var1	 ; Temp_Var1 = 6
	CMP #$08	 
	BGE PRG001_A9B1	 ; If Temp_Var1 >= 8 (never gonna happen), jump to PRG001_A9B1

	RTS		 ; Return

PRG001_A9B1:

	; Combined, this just reverses the X velocity
	JSR Object_AboutFace
	JSR Object_FlipFace

PRG001_A9B7:
	RTS		 ; Return

ObjInit_FireFlower:
	; Set gravity by Player
	LDA Player_ReverseGrav
	STA Objects_ReverseGrav,X

	LDA #$10
	STA Objects_Timer2,X	 ; Fire flower's timer 2 = $10

	; SB: This is probably used by the Big ? block which CAN spawn mushroom/flower/star for some reason
	LDA PUp_StarManFlash
	BEQ PRG001_A9C8	 ; If flashing is NOT active, jump to PRG001_A852

	; Strangely, the Big ? flower will "move over"; probably a partially developed idea??
	; Or they just accidentally leftover stuff from mushroom
	JSR Mushroom_SetXVel
	JMP PRG001_A9CF	 ; Jump to PRG001_A9CF

PRG001_A9C8:

	; This will make flower drop downward if it was "knocked out" downward
	LDY #$10
	LDA Player_BounceDir
	BEQ PRG001_A9D5	

PRG001_A9CF:
	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X
	RTS		 ; Return

PRG001_A9D5:
	; Knock flower downward
	STY <Objects_YVel,X	; Y Vel = $10
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?
	RTS		 ; Return

ObjNorm_FireFlower:
	; Display vertically flipped if reverse gravity
	LDA Objects_ReverseGrav,X
	ROR A
	ROR A	; Convert 1 -> $80 (SPR_VFLIP)
	STA Objects_FlipBits,X

	LDA PUp_StarManFlash
	BPL PRG001_A9E4	 ; If there's no star man flash going on, jump to PRG001_A9E4

	; Otherwise, color cycle (?)
	LDA <Counter_1
	STA Objects_ColorCycle,X

PRG001_A9E4:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

	LDA <Objects_YVel,X
	BNE PRG001_A9F6	 ; If Y Velocity <> 0, jump to PRG001_A9F6

	STA <Objects_XVel,X	 ; Otherwise, halt horizontal movement too

PRG001_A9F6:
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!


ObjHit_FireFlower:
	; SB: Always charge to fire power (modern rule)

	LDA <Player_Suit
	CMP #$02
	BEQ PRG001_AA13	 ; If Player is already Fire, jump to PRG001_AA13

	; New Power up Effect
	LDA #$30
	STA Player_Grow

	; And ultimately comes out fire!
	LDA #$03
	STA Player_QueueSuit

	; SB: New effect: Store previous power up
	LDA <Player_Suit
	STA <Player_OldSuit

PRG001_AA13:
	JSR PowerUp_PlaySound	 ; Play Power Up sound

	; Set flower to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X
	STA Player_Statue	 ; Also kill statue mode if you're in it!

	JMP PUp_GeneralCollect	 ; Jump to PUp_GeneralCollect


ObjInit_BounceLR:
	LDA Player_BounceDir
	STA Objects_Var2,X	 ; Store Player's bounce into var 2

	LDY #-$10	 ; Y = -$10 (bounce left)

	CMP #$02	 
	BEQ PRG001_AA57	 ; If bouncing to the left, jump to PRG001_AA57

	LDY #$10	 ; Otherwise, Y = $10 (bounce right)

PRG001_AA57:
	STY <Player_XVel 	; Store appropriate X velocity

	LDA Player_Bounce
	STA Objects_Var1,X	; Store Player_Bounce -> var1

	LDA #$00
	STA Objects_SprVVis,X	 ; Clear flags 2
	STA Objects_SprHVis,X	 ; Clear flags 1
	STA Player_Bounce	 ; Clear Player_Bounce
	STA Objects_FlipBits,X	 ; Force left/right flag to zero

	LDA #10
	STA Level_BlkBump_Pos-6,X ; Block bump position = 10

	JSR BounceBlock_Update	 ; Do block bounce update

	RTS		 ; Return


ObjNorm_BounceLR:
	LDY Level_BlkBump_Pos-6,X
	BNE PRG001_AAB1	 ; If block bump pos <> 0, jump to PRG001_AAB1

	; Block bump pos = 0...

	; Set to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	LDA Objects_Var1,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = var >> 4

	LDA Bounce_TileReplacements,Y
	STA <Temp_Var12

	; Temp_Var15 = Bouncer X Hi
	LDA <Objects_XHi,X
	STA <Temp_Var15

	; Temp_Var16 = Bouncer X
	LDA <Objects_X,X
	STA <Temp_Var16

	; Temp_Var13 = Bouncer Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Temp_Var14 = Bouncer Y
	LDA <Objects_Y,X
	STA <Temp_Var14

	JSR BlockBump_Init

	LDY #10		 ; Y = 10

	LDA <Objects_XVel,X
	BPL PRG001_AAA8	 ; If bouncer is moving to the right, jump to PRG001_AAA8

	LDY #-10	 ; Y = -10

PRG001_AAA8:
	TYA		 ; A = 10 or -10

	; SpriteX += 10 or -10
	ADD <Objects_SpriteX,X
	STA <Objects_SpriteX,X

	JMP Object_HitTestRespond	 ; Do hit test and don't come back


PRG001_AAB1:

	; Block bump pos <> 0...

	LDA Level_BlkBump_Pos-6,X
	CMP #$05
	BNE PRG001_AAC5	 ; If block bump pos <> 5, jump to PRG001_AAC5

	; Block bump pos = 5...

	; LRBounce_X = Sprite X
	LDA <Objects_SpriteX,X
	STA LRBounce_X

	; LRBounce_Y = Sprite Y
	LDA <Objects_SpriteY,X
	STA LRBounce_Y

	JMP PRG001_AAFE	 ; Jump to PRG001_AAFE

PRG001_AAC5:
	CMP #$0a
	BNE PRG001_AAFE	 ; If block bump pos <> 10, jump to PRG001_AAFE

	; Block bump pos = 10...

	LDA Objects_Var1,X
	AND #$0f
	TAY		 ; Y = lower 4 bits of Var1

	LDA Bouncer_PUp,Y ; Get power-up for this block
	BEQ PRG001_AAFE	 ; If no Power Up for this block, jump to PRG001_AAFE

	STA <Temp_Var1	 ; Power Up type -> Temp_Var1

	LDY #$05	 ; Y = 5 (power-up always in slot 5)

	LDA Objects_State,Y	; ? Maybe they were going to check first?

	; Set the ID
	LDA <Temp_Var1
	STA Level_ObjectID,Y

	; Set X
	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; Set Y
	LDA <Objects_Y,X
	SUB #$01
	STA Objects_Y,Y

	; Set Y Hi
	LDA <Objects_YHi,X
	SBC #$00
	STA Objects_YHi,Y

	; State 1 (Initialize)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

PRG001_AAFE:
	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR BounceBlock_Update	 ; Do block bounce update

	LDY Level_BlkBump_Pos-6,X ; Y = block bump pos

	LDA Bouncer_PUpVel,Y	 ; Get velocity

	LDY Objects_Var2,X
	CPY #$02
	BEQ PRG001_AB14	 ; If var2 = 2, jump to PRG001_AB14

	JSR Negate	 ; Otherwise, negate the velocity

PRG001_AB14:
	STA <Objects_XVel,X	 ; Set appropriate X velocity

	DEC Level_BlkBump_Pos-6,X ; Block bump pos--

	RTS		 ; Return


ObjHit_BoundLR:
	LDY #$10	 ; Y = $10

	LDA <Player_X
	CMP <Objects_X,X
	BGS PRG001_AB24	 ; If Player_X > Objects_X, jump to PRG001_AB24

	LDY #-$10	 ; Y = -$10

PRG001_AB24:
	STY <Player_XVel ; Set Player's X velocity as appropriate

	LDY #15		 ; Y = 15 (Player will be aligned to right side of bouncer)

	LDA <Player_X
	PHA		 ; Save Player_X

	AND #$0f	 ; Lower 4 bits only
	CMP #$08
	BGS PRG001_AB33	 ; If Player is to the right of the bouncer, jump to PRG001_AB33

	LDY #$00	 ; Y = 0 (Player will be aligned to left side of bouncer)

PRG001_AB33:
	STY <Temp_Var1	 ; Temp_Var1 = $00 or $0F
	PLA		 ; Restore Player_X


	AND #$f0	 ; Keep only upper 4 bits of Player's position
	ORA <Temp_Var1	 ; Apply the alignment
	STA <Player_X	 ; -> Player_X

	RTS		 ; Return




	; Values used by the leaf based on bounce direction
Leaf_YVels:	.byte $04, $E0, $E0, $E0
Leaf_TimerVals:	.byte $08, $FF, $FF, $FF

ObjInit_SuperLeaf:
	; Set gravity by Player
	LDA Player_ReverseGrav
	STA Objects_ReverseGrav,X

	LDA #$00
	STA <Objects_XVel,X	 ; Halt X velocity
	STA Objects_Var2,X	 ; Var2 = 0

	LDA #$0c	; A = $C (top spawn offset)

	LDY Player_BounceDir
	BEQ PRG001_ABA9	 ; If Player bounce down, jump to PRG001_ABA9

	LDA #-$0d	; A = -$D (bottom spawn offset)

	DEC <Objects_YHi,X	

PRG001_ABA9:
	ADD <Objects_Y,X
	STA <Objects_Y,X	 ; Set object Y

	BCC PRG001_ABB2	 	; If there's no carry, jump to PRG001_ABB2

	INC <Objects_YHi,X	 ; Otherwise, apply carry

PRG001_ABB2:
	; Set appropriate timer value (used to figure how far up the leaf needs to go)
	LDA Leaf_TimerVals,Y
	STA Objects_Timer,X

	; Set Y velocity
	LDA Leaf_YVels,Y
	STA <Objects_YVel,X

	; Timer2 = $10
	LDA #$10
	STA Objects_Timer2,X

	LDA PUp_StarManFlash
	BEQ PRG001_ABCC	; If leaf did not come from big ? block, jump to PRG001_ABCC

	; Otherwise, be green!!  (What IS this about anyway?)
	LDA #$02
	STA Objects_SprAttr,X

PRG001_ABCC:
	RTS		 ; Return

Leaf_XVelByOsc:	.byte $02, -$02
Leaf_XVelLimit:	.byte $20, -$20

PRG001_ABD1:
	.byte $0A, -$0A, $08

ObjNorm_SuperLeaf:
	LDA Objects_Timer,X
	BEQ PRG001_ABEC	 ; If timer expired, jump to PRG001_ABEC

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity
	INC <Objects_YVel,X	 ; YVel ++

	LDA <Objects_YVel,X
	CMP #$00
	BEQ PRG001_ABE7	 ; If Super Leaf Y Vel = 0, jump to PRG001_ABE7

	JMP PRG001_AC15	 ; Jump to PRG001_AC15

PRG001_ABE7:

	; Reset timer
	LDA #$00
	STA Objects_Timer,X

PRG001_ABEC:
	LDA Objects_Var2,X
	AND #$01
	TAY		 ; Y = 0 or 1 (which oscillation direction)

	; Add appropriate X velocity for oscillation direction
	LDA <Objects_XVel,X
	ADD Leaf_XVelByOsc,Y
	STA <Objects_XVel,X

	CMP Leaf_XVelLimit,Y
	BNE PRG001_AC02	 ; If leaf has not hit X Vel limit, jump to PRG001_AC02

	INC Objects_Var2,X	 ; Switch oscillation direction

PRG001_AC02:
	LDA <Objects_XVel,X
	BPL PRG001_AC07	 ; If leaf is moving to the right, jump to PRG001_AC07

	INY		 ; Otherwise, Y++ (makes Y = 2)

PRG001_AC07:
	LDA PRG001_ABD1,Y
	ADD #$06	 	; Value +6
	STA <Objects_YVel,X	; -> Y Velocity

	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity

PRG001_AC15:
	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (horizontal flip)

	LDY <Objects_XVel,X
	BEQ PRG001_AC22	 ; If leaf X Vel = 0, jump to PRG001_AC22 (don't change flip at midpoint)
	BPL PRG001_AC1F	 ; If leaf X Vel > 0, jump to PRG001_AC1F

	LDA #$00	 ; A = 0 (not horizontally flipped)

PRG001_AC1F:
	STA Objects_FlipBits,X	 ; Set flip

	; Display vertically flipped if reverse gravity
	LDA Objects_ReverseGrav,X
	ROR A
	ROR A	; Convert 1 -> $80 (SPR_VFLIP)
	STA Objects_FlipBits,X


PRG001_AC22:
	JSR Object_ShakeAndDrawMirrored	; Draw object and "shake awake" 
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!



ObjHit_SuperLeaf:

	; SB: Always charge to Raccoon Mario (modern rule)

	LDA <Player_Suit
	CMP #$03
	BNE PRG001_AC40	 ; If Player is not already Raccoon, jump to PRG001_AC40

	JSR PowerUp_PlaySound	 ; Play Power Up sound
	BNE PRG001_AC52	 ; Jump (technically always) to PRG001_AC52

PRG001_AC40:

	; "Poof" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1

	; New Power up Effect
	LDA #$30
	STA Player_Grow

	; Change to Raccoon
	LDA #$04
	STA Player_QueueSuit

	; SB: New effect: Store previous power up
	LDA <Player_Suit
	STA <Player_OldSuit

PRG001_AC52:
	; Disable statue
	LDA #$00
	STA Player_Statue

	JMP PUp_GeneralCollect	 ; Jump to PUp_GeneralCollect

ObjInit_Vine:
	LDA #SPR_BEHINDBG
	STA Objects_FlipBits,X

	LDA #SPR_PAL1
	STA Objects_SprAttr,X

	RTS		 ; Return

	; Stores the high byte of the VRAM address
Vine_NTHigh:	.byte $20, $28

ObjNorm_Vine:

	; Vine moves at Y Vel = -$10
	LDA #-$10
	STA <Objects_YVel,X

	JSR Object_ApplyYVel	; Apply Y Velocity

	LDA <Objects_YHi,X
	BMI PRG001_AC80	 ; If vine goes off absolute top, jump to PRG001_AC80

	JSR Object_WorldDetectN1 ; Detect against world

	LDA Object_TileFeet
	PHA		 ; Save tile detected by vine

	; Calculate tile "quadrant"
	ASL A
	ROL A
	ROL A
	AND #$03
	TAY		 ; -> 'Y'

	PLA		 ; Restore tile detected by vine

	CMP Tile_AttrTable,Y
	BLT PRG001_AC86	 ; If vine is not within the solid tiles, jump to PRG001_AC86

PRG001_AC80:

	; Set vine to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	RTS		 ; Return

PRG001_AC86:
	LDA <Objects_Y,X
	AND #$0f
	BNE PRG001_AC92	 ; If vine has NOT covered a new tile, jump to PRG001_AC92
 
	STA Objects_FlipBits,X	; Clears flip bits
	JSR Vine_Set8x8s	; Instant graphics update while vine moves

PRG001_AC92:

	; SB: SMW+ style "piranha topper" vine growth
	LDA <Objects_Y,X
	AND #$08
	LSR A
	LSR A
	LSR A
	STA Objects_Frame,X

	JMP Object_ShakeAndDrawMirrored	 ; Draw sprite and don't come back!

Vine_Set8x8s:
	LDA <Objects_XHi,X
	ASL A		 ; Convert X Hi into 2 byte index
	TAY		 ; -> 'Y'

	; Get address of screen Vine is on (NOTE: Non-vertical level only!)
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1
	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var2	

	LDA <Objects_YHi,X
	BEQ PRG001_ACA9	 ; If vine is not on lower area of screen, jump to PRG001_ACA9

	INC <Temp_Var2	 ; Select address of lower tiles

PRG001_ACA9:
	LDA <Objects_Y,X
	AND #$f0	 ; Get current "row" of vine object
	STA <Temp_Var3	 ; -> Temp_Var3

	LDA <Objects_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3	 ; Merge column into lower 4 bits

	TAY		 ; -> 'Y'

	; Change tile to vine tile
	LDA #TILE1_VINE
	STA [Temp_Var1],Y

	LDA Objects_SprHVis,X
	CMP #$03
	BGE PRG001_AD23	; If vine object is off-screen horizontally, jump to PRG001_AD23 (RTS)

	LDA <Objects_Y,X	 ; A = Objects_Y

	LDY <Objects_YHi,X
	BNE PRG001_ACCE	 ; If the vine is on the low part of the screen, jump to PRG001_ACCE

	CMP #240
	BLT PRG001_ACD1	 ; If Y < 240, jump to PRG001_ACD1

	INY		 ; Y = 1 (uses the next nametable address in Vine_NTHigh)

PRG001_ACCE:
	ADD #16	 	; Next row

PRG001_ACD1:
	ASL A	
	ADC #$00
	ASL A	
	ADC #$00

	PHA		 ; Save VRAM column offset

	AND #$03	; Keep address from going out of range
	ORA Vine_NTHigh,Y	 ; Set the high bits

	LDY Graphics_BufCnt	 ; Y = current graphics buffer count

	; Set two rounds of high byte 
	STA Graphics_Buffer,Y	 
	STA Graphics_Buffer+5,Y	

	PLA		 ; Restore VRAM column offset
 
	AND #$c0
	STA <Temp_Var1

	; Store left column update
	LDA <Objects_X,X
	LSR A	
	LSR A	
	LSR A	
	ORA <Temp_Var1
	STA Graphics_Buffer+1,Y

	; Store right column update
	ADD #$01
	STA Graphics_Buffer+6,Y

	LDA #$82
	STA Graphics_Buffer+2,Y
	STA Graphics_Buffer+7,Y

	; Vine left 8x8 tiles
	LDA #$c4
	STA Graphics_Buffer+3,Y
	LDA #$c4
	STA Graphics_Buffer+4,Y

	; Vine right 8x8 tiles
	LDA #$c6
	STA Graphics_Buffer+8,Y
	LDA #$c6
	STA Graphics_Buffer+9,Y

	LDA #$00
	STA Graphics_Buffer+10,Y

	; Update run count
	TYA
	ADD #$0a	 ; Count += 10
	STA Graphics_BufCnt

PRG001_AD23:
	RTS		 ; Return

	; Basically this bumps the object up by 1 pixel...
ObjInit_PDoor:
	LDA <Objects_Y,X
	BNE PRG001_AD2A	 	; If object's Y <> 0, jump to PRG001_AD2A
	DEC <Objects_YHi,X	 ; Otherwise, decrement Y Hi (carry for next op)
PRG001_AD2A:
	DEC <Objects_Y,X	 ; Decrement object's Y
	
PRG001_AD7E:
 	RTS		 ; Return


ObjNorm_PDoor:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

	LDA Level_PSwitchCnt
	BEQ PRG001_AD7E	 ; If P-Switch is not active, jump to PRG001_AD7E (RTS)

	LDA <Player_HaltGame
	BNE PRG001_ADBB	 ; If gameplay is halted, jump to PRG001_ADBB

	LDA <Player_InAir
	BNE PRG001_ADBB	 ; If Player is mid air, jump to PRG001_ADBB

	LDA <Pad_Holding
	AND #PAD_UP
	BEQ PRG001_ADBB	 ; If Player is NOT pressing up, jump to PRG001_ADBB

	; If Player is NOT within range of the door X-wise, jump to PRG001_ADBB
	JSR Object_CalcCoarseXDiff	 
	LDA <Temp_Var15	
	ADD #$02	
	CMP #$04	
	BGE PRG001_ADBB

	; If Player is NOT within range of the door Y-wise, jump to PRG001_ADBB
	JSR Object_CalcCoarseYDiff
	INC <Temp_Var15		
	BNE PRG001_ADBB	 

	LDY #$01	 ; Y = 1

	LDA Level_PipeNotExit
	BEQ PRG001_ADB1	 ; If this level has pipes exit to map, jump to PRG001_ADB1

	LDY #$03	 ; Y = 3

PRG001_ADB1:
	STY Level_JctCtl ; Set appropriate junction type

	; Set map return status?
	LDA #$00
	STA Map_ReturnStatus

	STA <Player_XVel ; Halt Player horizontally

PRG001_ADBB:
	JMP Object_Draw16x32Sprite	 ; Draw the door and don't come back


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Object_CalcHomingVels
;;
;; How an 8-bit CPU can calculate aiming projectiles
;; towards the Player!  Returns values in respective
;; Objects_TargetingXVal and Objects_TargetingYVal
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Object_CalcHomingVels:
;	
;	LDA #$14
;	STA <Temp_Var2	 ; Temp_Var2 = $14
;	
;	; Backup 'X' and 'Y'
;	TXA
;	PHA
;	TYA
;	PHA
;
	; Backup Player_Y
;	LDA <Player_Y
;	PHA
;
;	CMP #$50
;	BGE PRG001_B08F	 ; If Player_Y >= $50, jump to PRG001_B08F
;
	; Otherwise, force Player_Y = $50
;	LDA #$50
;	STA <Player_Y
;
;PRG001_B08F:
;	JSR Level_ObjCalcYDiffs
;	STY <Temp_Var3		 ; Store above/below flag -> Temp_Var3
;
	; Get absolute value of Temp_Var16 (Y difference between Player and Koopaling)
;	LDA <Temp_Var16	
;	BPL PRG001_B09B	 
;	JSR Negate	 
;PRG001_B09B:
;	STA <Temp_Var13		 ; -> Temp_Var13
;
;	JSR Level_ObjCalcXDiffs
;	STY <Temp_Var4		 ; Store left/right of flag -> Temp_Var4
;
	; Get absolute value of Temp_Var16 (X difference between Player and Koopaling)
;	LDA <Temp_Var16	
;	BPL PRG001_B0A9	
;	JSR Negate
;PRG001_B0A9:
;	STA <Temp_Var14		 ; -> Temp_Var14
;
;	LDY #$00	 ; Y = 0
;
;	LDA <Temp_Var14
;	CMP <Temp_Var13
;	BGE PRG001_B0BC	 ; If Temp_Var14 (Player vs Koopaling X diff) >= Temp_Var13 (Player vs Koopaling Y diff), jump to PRG001_B0BC
;
;	INY		 ; Y = 1
;
	; Swap Temp_Var13 and Temp_Var14
;	PHA
;	LDA <Temp_Var13
;	STA <Temp_Var14
;	PLA
;	STA <Temp_Var13
;
;PRG001_B0BC:
;
	; At this point, Temp_Var13 >= Temp_Var14, guaranteed
;
	; What follows is some kind of algorithm that can "aim" a projectile
;	; towards a Player (e.g., Koopaling wand shots) but I'm not going to
;	; research the "why" at this time... it "just works"
;
;	LDA #$00
;	STA <Temp_Var12		; Temp_Var12 = 0
;	STA <Temp_Var1		; Temp_Var1 = 0
;	LDX <Temp_Var2		; X = Temp_Var2 (starts at $14)
;
;PRG001_B0C4:
;	LDA <Temp_Var12
;	ADD <Temp_Var13
;	CMP <Temp_Var14
;	BLT PRG001_B0D1		; If (Temp_Var12 + Temp_Var13) < Temp_Var14, jump to PRG001_B0D1
;
	; Otherwise...
;	SBC <Temp_Var14		; Subtract Temp_Var14 from Temp_Var12
;	INC <Temp_Var1		; Temp_Var1++
;
;PRG001_B0D1:
;	STA <Temp_Var12 	; Update Temp_Var12
;	DEX		 	; X--
;	BNE PRG001_B0C4	 	; While X > 0, loop!
;
;	TYA
;	BEQ PRG001_B0E3	 ; If Y = 0, jump to PRG001_B0E3
;
	; Swap Temp_Var1 and Temp_Var2
;	LDA <Temp_Var1
;	PHA		
;	LDA <Temp_Var2	
;	STA <Temp_Var1	
;	PLA		
;	STA <Temp_Var2	
;
;PRG001_B0E3:
;	LDA <Temp_Var1	
;	LDY <Temp_Var3	
;	BEQ PRG001_B0EE	
;
;	JSR Negate	
;	STA <Temp_Var1	
;
;PRG001_B0EE:
;	LDA <Temp_Var2	
;	LDY <Temp_Var4	
;	BEQ PRG001_B0F9	
;
;	JSR Negate	
;	STA <Temp_Var2	
;
;PRG001_B0F9:
;
	; Restore Player_Y
;	PLA
;	STA <Player_Y
;
	; Restore 'Y' and 'X'
;	PLA
;	TAY
;	PLA
;	TAX
;

;	; Temp_Var1 contains the "homing in" Y velocity
;	LDA <Temp_Var1
;	STA Objects_TargetingYVal,X
;
	; Temp_Var2 contains the "homing in" X velocity
;	LDA <Temp_Var2
;	STA Objects_TargetingXVal,X
;
;	RTS		 ; Return


ObjInit_Bowser:

	; Bowser takes 34 fireball hits!
	LDA #34
	STA Objects_HitCount,X

	; Bowser is giant!
	INC Objects_IsGiant,X

	RTS		 ; Return

	; frames:
	;	0 = Normal stand
	;	1 = Crouch down
	;	2 = About to spit fire
	;	3 = Puffed cheeks
	;	4 = Face forward
	;	5 = Turned head
	;	6 = Dropping 
	;	7 = Landed
	;	8 = Bowser turning

ObjNorm_BowserFinal:
	; Set Bowser's pattern table selections
	LDA #$3a
	STA PatTable_BankSel+4
	LDA #$3b
	STA PatTable_BankSel+5

	JSR Bowser_Draw	 ; Draw Bowser!

	LDA <Objects_Var5,X
	BEQ BF_NoCH

	JSR Bowser_CommonHit
	
BF_NoCH:
	LDA <Objects_Var5,X
	JSR DynJump
	
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_WaitForPlayer		; 0: Bowser waiting for you to show up...
	
	; Attack 1
	.word Bowser_InitFireBreathe	; 1: Prepare to breathe fire
	.word Bowser_BreatheFire3		; 2: Breathe fire
	
	; Common
	.word Bowser_HopUp				; 3: Crouch and jump
	.word Bowser_MoveUp				; 4: Moving upward
	.word Bowser_TargetPlayer		; 5: Target player to land on (aligned)
	.word Bowser_JumpOnPlayer		; 6: Jump down to player
	.word Bowser_WaitToReset		; 7: Wait to reset
	.word Bowser_BurnFlyUp			; 8: Burned!
	.word Bowser_TargetPlayer2		; 9: Target player (aligned to be safe)
	.word Bowser_FallAndSplat		; 10: Bowser fall (until he hits bottom, ba-bam! Only if dead, though)
	.word Bowser_WaitAndVictory		; 11: Wait until timer expires, then play victory song
	.word Bowser_DoTimeBonus		; 12: Convert remaining time to score
	.word Bowser_GoToEnding
	
	.word Bowser_WZEnding			; 14: Bowser World Zero Ending special
	.word Bowser_WZEndingDone		; 15: Landed

Bowser_InitFireBreathe:
	LDA #$40
	STA Objects_Timer,X

	LDA #3
	STA Objects_Var1,X

Bowser_DoneSpit:
	INC <Objects_Var5,X

	RTS


BBFire_Frames:	.byte 0, 0, 3, 2

Bowser_BreatheFire3:
	JSR Bowser_FacePlayer

	LDA Objects_Timer,X
	PHA
	LSR A
	LSR A
	LSR A
	LSR A
	TAY
	LDA BBFire_Frames,Y
	STA Objects_Frame,X

	PLA
	BEQ Bowser_DoneBreathe
	CMP #$20 
	BNE Bowser_NoFireYet

	JSR Bowser_BreatheFire

Bowser_NoFireYet:
	RTS

Bowser_DoneBreathe:
	DEC Objects_Var1,X
	BEQ Bowser_DoneSpit

	; Reset counter
	LDA #$40
	STA Objects_Timer,X
	
	RTS
	
	
Bowser_HopUp:
	LDA #1
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BEQ BHU_SetTimer
	CMP #1
	BNE BHU_Nothing

	LDA #-$7E
	STA <Objects_YVel,X
	
	LDA #SND_PLAYERJUMP
	STA Sound_QPlayer

	LDA #6
	STA Objects_Frame,X

	INC <Objects_Var5,X

BHU_Nothing:
	RTS

BHU_SetTimer:
	LDA #$30
	STA Objects_Timer,X
	RTS


Bowser_MoveUp:
	JSR Object_Move

	LDA <Objects_YVel,X
	BMI BMUP_YVelOK

	; Make sure Bowser is always traveling up :P
	LDA #-1
	STA <Objects_YVel,X

BMUP_YVelOK:

	LDA <Objects_YHi,X
	BPL BMUP_TooLow
	LDA <Objects_Y,X
	CMP #$C0
	BGE BMUP_TooLow
	
	INC <Objects_Var5,X

BMUP_TooLow:
	RTS

Bowser_TargetPlayer:
	LDA <Player_X
	ADD #12
	AND #~$1F
	STA <Objects_X,X

	LDA #0
	STA <Objects_YVel,X

	INC <Objects_Var5,X

	RTS

Bowser_JumpOnPlayer:
	LDA #2
	STA <Objects_Var4,X

	JSR Bowser_DetectTiles	  ; Detect tiles under Bowser's feet

	LDA <Objects_YVel,X
	CMP #$40
	BGS BJOP_YVelMaxed	 ; If Bowser's Y Velocity >= $40, jump to BJOP_YVelMaxed

	INC <Objects_YVel,X
	INC <Objects_YVel,X

BJOP_YVelMaxed:

	JSR Bowser_BustFloor	 ; Bust any bricks Bowser has hit

	LDA <Objects_DetStat,X
	AND #$04
	BEQ BJOP_NoHitGround	 ; If Bowser has not hit floor, jump to BJOP_NoHitGround

	JSR Object_HitGround	 ; Align to floor

	; Vibrate floor from impact
	LDA #$2c
	STA Level_Vibration

	; Ba-bam sound!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Object timer = $35
	LDA #$35
	STA Objects_Timer,X

	LDA #7
	STA Objects_Frame,X

	LDA Level_ChgTileEvent
	BNE BJOP_NoHitGround		; If hit a brick, jump to BJOP_NoHitGround
	
	INC <Objects_Var5,X

BJOP_NoHitGround:

	JSR Object_WorldDetectN1
	LDA Object_TileFeet
	CMP #TILE15_LAVABOTTOM
	BNE BJOP_BowserHasntFallen

	JSR Bowser_Splash

	; Bowser is falling maybe...
	;LDA <Objects_YHi,X
	;CMP #1
	;BNE BJOP_BowserHasntFallen

	; Bowser fell! Burn up!
	LDA #8
	STA <Objects_Var5,X
	
BJOP_BowserHasntFallen:
	RTS


Bowser_WaitToReset:

	LDA Objects_Timer,X
	BNE Bowser_NotReset
	
	; FIXME: Other states
	LDA #1
	STA <Objects_Var5,X

Bowser_NotReset:
	RTS


Bowser_BurnFlyUp:
	LDA #6
	STA Objects_Frame,X

	LDA SndCur_Level2
	BNE Bowser_BurnSound

	LDA #SND_LEVELSANDFILL
	STA Sound_QLevel2	
	
	JSR Bowser_BurnPoof
	
Bowser_BurnSound:
	LDA #-$30
	STA <Objects_YVel,X
	
	JSR Object_ApplyYVel

	LDA <Objects_YHi,X
	BPL BFUP_TooLow
	LDA <Objects_Y,X
	CMP #$C0
	BGE BFUP_TooLow

	INC Objects_Var2,X
	LDA Objects_Var2,X
	CMP #3
	BLT BFUP_NotDeadYet

	; Bowser's killed!
	LDA #10
	STA <Objects_Var5,X
	
	LDA #MUS1_BOWSERFALL
	STA Sound_QMusic1
	
	; Disable timer
	LDA #1
	STA Level_TimerEn

	; Set Bowser's frame to 6
	LDA #$06
	STA Objects_Frame,X	
	
	LDA Objects_SprAttr,X
	ORA #SPR_VFLIP
	STA Objects_SprAttr,X
	
	RTS

BFUP_NotDeadYet:
	INC <Objects_Var5,X

BFUP_TooLow:
	RTS


Bowser_BurnPoof:
	LDA #0
	STA Objects_SprHVis,X
	STA Objects_SprVVis,X

	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot or don't come back here!

	; The "poof" from when it appears	 
	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y

	; Set the poof where the box will be
	LDA <Objects_X,X
	ADD #8
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	ADD #32
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	ADC #0
	STA SpecialObj_YHi,Y

	; Set the "poof" counter
	LDA #$1f
	STA SpecialObj_Data,Y
	RTS
	

Bowser_TargetPlayer2:
	LDA <Player_X
	ADD #24
	AND #~$3F
	STA <Objects_X,X

	LDA #0
	STA <Objects_YVel,X

	LDA #6
	STA <Objects_Var5,X

	RTS
	

Bowser_GoToEnding:

	LDA Objects_Timer,X
	BNE Bowser_WaitForEnding

	JSR_THUNKC 30, Object_InvalidateCP
	
	LDA #0
	STA Map_ReturnStatus
	
	LDA #1
	STA Player_RescuePrincess
	STA Level_ExitToMap

Bowser_WaitForEnding:
	RTS


Bowser_WZEnding:
	LDA #6
	STA Objects_Frame,X

	JSR Object_Move

	LDA <Objects_DetStat,X
	AND #$04
	BEQ BWZE_NotLanded

	INC <Objects_Var5,X
	
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1
	
	LDA #$10
	STA Objects_Timer,X

BWZE_NotLanded:
	RTS
	
Bowser_WZEndingDone:
	LDA #7

	LDY Objects_Timer,X
	BNE BWZED_SetFrame

	LDA #4

BWZED_SetFrame:
	STA Objects_Frame,X
	RTS

	; X Velocity applied to Player when bouncing off Bowser's head
Bowser_HeadBounceXVel:	.byte $10, -$10

ObjNorm_Bowser:

	; Set Bowser's pattern table selections
	LDA #$3a
	STA PatTable_BankSel+4
	LDA #$3b
	STA PatTable_BankSel+5

	LDA <Player_HaltGame
	BNE PRG001_B8D3	 ; If gameplay is halted, jump to PRG001_B8D3

	LDA Bowser_Counter1
	BEQ PRG001_B8A1	 ; If Bowser_Counter1 = 0, jump to PRG001_B8A1

	DEC Bowser_Counter1	 ; Bowser_Counter1--

PRG001_B8A1:
	LDA Bowser_Counter2
	AND #%00011111	 
	BEQ PRG001_B8AB	 ; Every 32 ticks of Bowser's second counter, jump to PRG001_B8AB

	DEC Bowser_Counter2	 ; Bowser_Counter2--

PRG001_B8AB:
	JSR Bowser_DoVar5Action	; Do Bowser's internal state action
	JSR Bowser_HopAndBreatheFire	; Bowser hops and breathes fireballs

Bowser_CommonHit:
	JSR Player_HitEnemy	 	; Do hit detection

	LDA Objects_PlayerHitStat,X
	BEQ PRG001_B8D3		; If Player hasn't hit Bowser, jump to PRG001_B8D3

	; Player hit Bowser...

	; Set timer 2 to 8
	LDA #$08
	STA Objects_Timer2,X

	LDA <Player_YVel
	BMI PRG001_B8D3	 ; If Player is moving upward, jump to PRG001_B8D3

	; Player bounces off Bowser's head!
	LDA #-$30
	STA <Player_YVel

	JSR Bowser_CalcPlayersSide	 ; Calculate the side of his head Player bounced off of

	; Apply an X Velocity when bouncing off Bowser's head
	LDA Bowser_HeadBounceXVel,Y
	STA <Player_XVel

	; Bounce sound
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer

PRG001_B8D3:
	LDA <Objects_Var5,X
	BEQ PRG001_B8E0	 ; If the internal state = 0 (waiting to meet Player), jump to PRG001_B8E0

	JSR Bowser_Draw	 ; Draw Bowser!

	LDA <Objects_Var5,X	
	CMP #$01	 
	BEQ PRG001_B8E5	 ; If internal state = 1, jump to PRG001_B8E5 (RTS)

PRG001_B8E0:

	; Otherwise, mark Bowser as totally invisible horizontally (??)
	LDA #$ff
	STA Objects_SprHVis,X

PRG001_B8E5:
	RTS		 ; Return

Bowser_DoVar5Action:
	LDA <Objects_Var5,X
	JSR DynJump	 ; Jump dynamically by Objects_Var5

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_WaitForPlayer	; Internal state 0: Bowser waiting for Mario/Luigi to show up...
	.word Bowser_DoMovements	; Internal state 1: Bowser movements (jumping, busting floor, etc.)
	.word Bowser_FallAndSplat	; Internal state 2: Bowser fall (until he hits bottom, ba-bam! Only if dead, though)
	.word Bowser_WaitAndVictory	; Internal state 3: Wait until timer expires, then play victory song
	.word Bowser_DoTimeBonus	; Internal state 4: Convert remaining time to score
	.word Bowser_DoorAppear		; Internal state 5: Final door appears
	.word PRG001_B8E5		; Internal state 6: Do nothing

Bowser_WaitForPlayer:
	JSR Bowser_Draw

	LDA Objects_SprHVis,X
	BNE PRG001_B928	 ; If any of Bowser's sprites are horizontally off-screen, jump to PRG001_B928 (RTS)
	
	LDA <Horz_Scroll
	CMP #$07
	BGE PRG001_B928	 ; If Horz_Scroll >= 7, jump to PRG001_B928 (RTS)

	; Player got close enough; lock horizontal scroll and stop Player from moving
	LDA #$00
	STA <Horz_Scroll
	STA <Player_XVel

	; Player must land first
	LDA <Player_InAir
	BNE PRG001_B928	 ; If Player is midair, jump to PRG001_B928 (RTS)

	
	LDY Level_ObjectID,X
	CPY #OBJ_BOSS_BOWSERFINAL
	BNE Bowser_NotFinalSet

	; Final Bowser
	LDA #MUS2B_BOWSER
	BNE Bowser_NormalTune

Bowser_NotFinalSet:
	; Vert_Scroll = $EF (lowest scroll point)
	LDA #$ef
	STA <Vert_Scroll

	; Play Bowser's Theme
	LDA #MUS2B_BOSS

	LDY Level_ObjectID,X
	CPY #OBJ_BOSS_BOWSER2
	BNE Bowser_NormalTune

	LDA #MUS2C_BOSSEOW
	
Bowser_NormalTune:
	STA Sound_QMusic2

	INC LevelJctBQ_Flag	 ; LevelJctBQ_Flag = 1 (set like in a Big Question block area, i.e. no horizontal scrolling)

	; Lock vertical scroll
	LDA #$02
	STA Level_FreeVertScroll

	; Var4 = 3
	LDA #$03
	STA <Objects_Var4,X

	; Timer 3 = $30
	LDA #$30	 
	STA Objects_Timer3,X

	; Internal state = 1
	INC <Objects_Var5,X

PRG001_B928:
	RTS		 ; Return


Bowser_DoMovements:
	JSR Bowser_HandleIfDead	 ; Handle Bowser if he got killed

	LDA Level_NoStopCnt
	AND #%00011111
	ORA Bowser_Counter1
	BNE PRG001_B948	 ; If Bowser Counter 1 > 0 and except every 32nd tick, jump to PRG001_B948

	; Only when Bowser Counter 1 is expired and every 32 ticks of the no stop counter...

	LDA Objects_FlipBits,X

	PHA		 ; Save Bowser's flip bits

	JSR Bowser_FacePlayer	 ; Bowser face Player

	PLA		 ; Restore Bowser's flip bits

	CMP Objects_FlipBits,X
	BEQ PRG001_B948	 ; If Bowser has NOT changed facing direction, jump to PRG001_B948

	; Bowser changed facing direction

	; Set some bits on Bowser's Counter 2
	ORA #$13
	STA Bowser_Counter2

PRG001_B948:
	LDA <Objects_Var4,X
	JSR DynJump	 ; Jump dynamically by var 4

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_FallToFloor	; 0: Fall to floor
	.word Bowser_JumpAndLandOnFloor	; 1: Jump and land on floor
	.word Bowser_AlignAndFall	; 2: Align to tile on the way down (will also use part of Bowser_JumpAndLandOnFloor)
	.word Bowser_BustFloorLookAround; 3: Bowser busts floor and looks around

PRG001_B955:	.byte $08, $05, $04, $05, $08
PRG001_B95A:	.byte $40, $40, $00, $00, $00


Bowser_FallToFloor:
	JSR Bowser_Counter3Do	 ; Update Bowser_Counter3

	LDA Bowser_Counter2
	AND #$1f	 
	BEQ PRG001_B97C	 ; Every 32 ticks of Bowser_Counter2, jump to PRG001_B97C

	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7, slower rate than Bowser_Counter2

	LDA Bowser_Counter2
	AND #SPR_HFLIP
	EOR PRG001_B95A,Y
	STA Objects_FlipBits,X

	LDA PRG001_B955,Y

PRG001_B97C:
	STA Objects_Frame,X

	LDA Level_ActSwAction
	CMP #ACTSW_BOWSERBRIDGE
	BNE Bowser_CanJump	; If the Bowser bridge isn't collapsing, jump to Bowser_CanJump

	; Can't let Bowser jump as bridge is collapsing!
	LDA #0
	STA Objects_Timer,X
	STA Objects_Timer3,X

	BNE Bowser_JumpBypassCont

Bowser_CanJump:
	LDA Objects_Timer,X
	BNE PRG001_B9B5	 ; If timer is not expired, jump to PRG001_B9B5

Bowser_JumpBypassCont:
	JSR Bowser_DetectTiles	 ; Detect the tiles under Bowser

	; Bowser fall up to $40 Y Velocity...
	LDA <Objects_YVel,X
	CMP #$40	 
	BGS PRG001_B98F	 ; If Bowser's Y Velocity >= $40, jump to PRG001_B98F

	INC <Objects_YVel,X	 ; Bowser's gravity

PRG001_B98F:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_B9A4	 ; If Bowser has NOT hit floor, jump to PRG001_B9A4 (RTS)

	JSR Object_HitGround	 ; Align to floor

	LDA #$10	; A = $10

	LDY Objects_Timer3,X
	BNE PRG001_B9A1	 ; If Timer 3 is not expired, jump to PRG001_B9A1

	LDA #$b0	 ; A = $B0

PRG001_B9A1:
	; Set Timer as appropriate
	STA Objects_Timer,X

PRG001_B9A4:
	RTS		 ; Return

	; Base X velocities by Player's distance away from Bowser when he attempts to jump and land on you
Bowser_XVelByDist:
	.byte $08, $10, $18, $20, $28, $30, $38, $40, $48, $50, $50, $50, $50, $50, $50, $50

PRG001_B9B5:
	LDA Bowser_Counter2 
	AND #$1f 
	BNE PRG001_B9BF	 ; Only continue 1:32 ticks, otherwise jump to PRG001_B9BF
 
	INC Objects_Frame,X	 ; Bowser's frame++

PRG001_B9BF:
	LDA Objects_Timer,X 
	CMP #$01 
	BEQ PRG001_B9F3	 ; If timer expired, jump to PRG001_B9F3

	CMP #$80 
	BNE PRG001_B9F2	 ; If timer <> $80, jump to PRG001_B9F2 (RTS) 

	; Jump and land on floor mode
	LDA #$01 
	STA <Objects_Var4,X
 
	; Bowser jump!
	LDA #-$60 
	STA <Objects_YVel,X
 
	JSR Bowser_CalcPlayersSide 
	STY <Temp_Var1		 ; Temp_Var1 = 0 or 1, depending on side Player is on
 
	; Get absolute value of X difference
	LDA <Temp_Var16 
	BPL PRG001_B9DE 
	JSR Negate 
PRG001_B9DE:

	LSR A 
	LSR A 
	LSR A 
	LSR A 
	AND #$0f 
	TAY		 ; Y = 0 to 15, number of tiles away Player is
 
 
	; Calculate Bowser's X velocity to target Player!
	LDA Bowser_XVelByDist,Y
	LDY <Temp_Var1 
	DEY	
	BNE PRG001_B9F0 
	JSR Negate
PRG001_B9F0: 
	STA <Objects_XVel,X 
	RTS
	
PRG001_B9F2:

	; Secondary Bowser throws hammers!
	LDA <Counter_1
	AND #$0F
	BNE Bowser_NoHammer
	
	LDA Level_ObjectID,X
	CMP #OBJ_BOSS_BOWSER2
	BNE Bowser_NoHammer		; If not secondary Bowser, jump to Bowser_NoHammer
	
	; Hammer toss!
	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot or don't come back!

	; Set Hammer X/Y at Bowser's position
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	; Hammer Y velocity = -$30
	LDA #-$30
	STA SpecialObj_YVel,Y

	STY <Temp_Var1		 ; Temp_Var1 = Special Object slot index

	JSR Level_ObjCalcXDiffs

	LDA BHammer_XVel,Y	; Hammer towards Player X Vel
	LDY <Temp_Var1		 ; Y = Special Object slot index
	STA SpecialObj_XVel,Y	 ; Set X Velocity

	LDA #SOBJ_HAMMER ; Hammer Bro hammer
	STA SpecialObj_ID,Y	 ; Set Special Object ID

	; Pushes Bowser's object index into SpecialObj_Data upper 4 bits, sets lower 4 bits to $0F
	TXA
	ASL A
	ASL A
	ASL A
	ASL A
	ORA #$0f
	STA SpecialObj_Data,Y

	; SpecialObj_Var1 = 0
	LDA #$00
	STA SpecialObj_Var1,Y

	; Bowser hammer!
	LDA #$01
	STA SpecialObj_Var3,Y

Bowser_NoHammer:
	RTS		 ; Return

BHammer_XVel:	.byte $12, -$12

PRG001_B9F3:
	; Little hop
	LDA #-$10 
	STA <Objects_YVel,X
 
	RTS		 ; Return

	; Used as a bit 7 invert to determine if Bowser is moving 
	; away from or towards the Player
Bowser_VsPlayerXVelNegBit:
	.byte $00, $80


Bowser_JumpAndLandOnFloor:
	; SB: Prevent Bowser from moving too far over and trapping Player at switch
	LDA <Objects_X,X
	CMP #$C0
	BLT BJALOF_NotTooFar
	
	; Hard limit!
	LDA #$C0
	STA <Objects_X,X
	
BJALOF_NotTooFar:
	LDA <Objects_YVel,X	 
	BPL PRG001_BA01	 ; If Bowser is on floor or falling, jump to PRG001_BA01

	JSR Bowser_Counter3Do	 ; Update Bowser's Counter 3

PRG001_BA01:

	; Bowser frame 0
	LDA #$00
	STA Objects_Frame,X

	JSR Bowser_DetectTiles	 ; Detect tiles under Bowser's feet

	LDA <Objects_YVel,X
	BMI PRG001_BA11	 ; If Bowser is moving upward (jumping), jump to PRG001_BA11

	CMP #$50	 
	BGE PRG001_BA17	 ; If Bowser Y velocity >= $50, jump to PRG001_BA17

PRG001_BA11:

	; Bowser fall rate Y Vel += 3
	INC <Objects_YVel,X
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG001_BA17:

	LDA <Objects_YVel,X
	BPL PRG001_BA1F	 ; If Bowser is not moving upward, jump to PRG001_BA1F

	CMP #-$20
	BLT PRG001_BA4B	 ; If Bowser is moving upward faster than -$20, jump to PRG001_BA4B

PRG001_BA1F:

	; Bowser not moving upward... or not moving upward fast enough

	JSR Bowser_CalcPlayersSide	 ; Figure out which side Player is on

	LDA Bowser_VsPlayerXVelNegBit,Y
	EOR <Objects_XVel,X
	BPL PRG001_BA4B	 ; If Bowser's velocity is moving away from Player, jump to PRG001_BA4B

	JSR Level_ObjCalcYDiffs	 

	DEY		 ; Y--
	BEQ PRG001_BA4B	 ; If Y was 1, jump to PRG001_BA4B

	; Var4 = 2
	LDA #$02
	STA <Objects_Var4,X

	; Timer = $0A
	LDA #$0a
	STA Objects_Timer,X

	; Calculate an X position that targets Player and aligned to tile
	LDA <Objects_X,X
	ADD #$08
	AND #$f0
	STA Objects_TargetingXVal,X

	; Bowser jump!
	LDA #-$20
	STA <Objects_YVel,X

	; Stop Bowser's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

PRG001_BA4B:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_BA76	 ; If Bowser has NOT hit floor, jump to PRG001_BA76

	; Bowser has hit floor...

	JSR Object_HitGround	 ; Align to floor ('A' = 0 at the end of this, hence the following assignment)

	STA <Objects_XVel,X	 ; Stop Bowser's horizontal movement

	; Vibrate floor from impact
	LDA #$2c
	STA Level_Vibration

	; Ba-bam sound!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Object timer = $35
	LDA #$35
	STA Objects_Timer,X

	LDA RandomN,X
	AND #$1f	
	ADC #$67	
	STA Objects_Timer3,X	 ; Timer 3 = Random $67 to $86
	STA Objects_Var7,X	 ; -> Var7

	; Var4 = 3
	LDA #$03
	STA <Objects_Var4,X

PRG001_BA76:
	RTS		 ; Return


Bowser_AlignAndFall:
	; Reset Bowser Counter 1
	LDA #$00
	STA Bowser_Counter1

	; Set Bowser to frame 6 (Bowser's falling frame)
	LDA #$06
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BEQ PRG001_BA96	; If timer expired, jump to PRG001_BA96

	LDA <Objects_X,X
	CMP Objects_TargetingXVal,X
	BEQ PRG001_BA95	; If Bowser reached the alignment X, jump to PRG001_BA95

	; Bowser moves towards the tile alignment
	INC <Objects_X,X
	BCC PRG001_BA95	; If carry clear, jump to PRG001_BA95

	; Don't let Bowser's X wrap around!
	DEC <Objects_X,X
	DEC <Objects_X,X

PRG001_BA95:
	RTS		 ; Return

PRG001_BA96:
	JSR Bowser_DetectTiles	 ; Detect tiles under Bowser

	LDA <Objects_YVel,X
	BMI PRG001_BAA1	 ; If Bowser is moving upward, jump to PRG001_BAA1

	CMP #$70
	BGE PRG001_BAA6	 ; If Bowser's Y Velocity >= $70, jump to PRG001_BAA6 (RTS)

PRG001_BAA1:

	; Bowser's rapid stomp fall!
	ADD #$06
	STA <Objects_YVel,X

PRG001_BAA6:
	JMP PRG001_BA4B	 ; Jump to PRG001_BA4B 


Bowser_BustFloorLookAround:
	JSR Bowser_DetectTiles	  ; Detect tiles under Bowser's feet

	LDA <Objects_YVel,X
	CMP #$40
	BGS PRG001_BAB6	 ; If Bowser's Y Velocity >= $40, jump to PRG001_BAB6

	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG001_BAB6:
	JSR Bowser_BustFloor	 ; Bust any bricks Bowser has hit

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_BAC2	 ; If Bowser has not hit floor, jump to PRG001_BAC2

	JSR Object_HitGround	 ; Align to floor

PRG001_BAC2;
	LDA Objects_Timer,X
	BEQ PRG001_BACD		; If timer expired, jump to PRG001_BACD

	; Bowser slam frame
	LDA #$07
	STA Objects_Frame,X

	RTS		 ; Return

PRG001_BACD:
	LDA Objects_Timer3,X
	BNE PRG001_BAF1	 ; If timer 3 is not expired, jump to PRG001_BAF1

	; Var 4 back to zero
	LDA #$00
	STA <Objects_Var4,X

	LDA RandomN,X
	AND #$7f
	ORA #$80
	STA Objects_Timer3,X	 ; Timer 3 = $7F to $FF

	RTS		 ; Return

	; Bowser look around frame
Bowser_LookAroundFrames:	.byte $04, $05, $05, $05, $04, $05, $05, $05

	; Bowser look around flip bits
Bowser_LookAroundFlipBits:	.byte $00, $00, $00, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_HFLIP

PRG001_BAF1:
	CMP #$20
	BLT PRG001_BB0B	 ; If timer 3 < $20, jump to PRG001_BB0B

	; When Bowser lands, he looks around a bit for a second

	LSR A
	LSR A
	ADD Objects_Var7,X	; ?? Not used in anything else Bowser does?
	AND #$07
	TAY		 ; Y = 0 to 7 

	; Set frame
	LDA Bowser_LookAroundFrames,Y
	STA Objects_Frame,X

	; Set flip bits
	LDA Bowser_LookAroundFlipBits,Y
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG001_BB0B:
	CMP #$0c
	LDA #$05	 ; A = 5
	BGE PRG001_BB13	 ; If timer 3 >= 5, jump to PRG001_BB13

	LDA #$08	 ; Otherwise, A = 8

PRG001_BB13:
	STA Objects_Frame,X	 ; Set Bowser frame

Bowser_FacePlayer:
	JSR Bowser_CalcPlayersSide

	; Bowser face Player!
	LDA Bowser_FlipToFace,Y
	STA Objects_FlipBits,X

	RTS		 ; Return


	; Set proper flip bit for Bowser to face Player
Bowser_FlipToFace:
	.byte SPR_HFLIP, $00

Bowser_HoppingFrames:
	.byte $00, $00, $03, $02, $00, $00, $00, $00

Bowser_HopAndBreatheFire:
	LDA Bowser_Counter1
	BEQ PRG001_BB46	 ; If Bowser_Counter1 = 0, jump to PRG001_BB46 (RTS)

	LSR A
	LSR A
	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7

	; Bowser's little hopping animation
	LDA Bowser_HoppingFrames,Y
	STA Objects_Frame,X

	LDA Bowser_Counter1
	CMP #$10	 
	BNE PRG001_BB46	 ; If Bowser_Counter1 <> $10, jump to PRG001_BB46 (RTS)

	JSR Bowser_BreatheFire	 ; Bowser breathe's a fireball!

PRG001_BB46:
	RTS		 ; Return

	; Bowser's fireball X velocity and offset by direction
Bowser_FireballXVel:	.byte -$10, $10
Bowser_FireballXOff:	.byte -$08, $18

PRG001_BB4B:	.byte $00, $08, $10, $18, $08, $00, $00, $10
	
Bowser_BreatheFire:
	LDY #$04	; Y = 4
PRG001_BB55:
	LDA Objects_State,Y
	BEQ PRG001_BB5E	 ; If object is dead/empty, jump to PRG001_BB5E

	DEY		 ; Y--
	BPL PRG001_BB55	 ; While Y >= 0, loop

	RTS		 ; Return

PRG001_BB5E:
	TYA
	TAX		 ; X = new object's index

	JSR Level_PrepareNewObject	 ; Set up the new flame to be spawned 

	; Set object state to normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Bowser's fireball
	LDA #OBJ_BOSSATTACK
	STA Level_ObjectID,X

	; Set Bowser's internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	; Bowser fall
	LDA #$10
	STA Objects_YVel,Y

	LDX <SlotIndexBackup	 ; Restore 'X' to Bowser's object slot index

	; Set fireball Y to Bowser's +16
	LDA <Objects_Y,X
	ADD #16
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA Objects_YHi,Y

	LDA Objects_FlipBits,X
	ASL A
	ASL A
	ROL A
	AND #$01
	TAX	
	STX <Temp_Var1		; X = 0 or 1, depending on if Bowser's horizontally flipped

	; Set X Velocity as appropriate
	LDA Bowser_FireballXVel,X
	STA Objects_XVel,Y

	LDX <SlotIndexBackup	 ; Restore 'X' to Bowser's object slot index

	; X Hi is just copied
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; Set X appropriately offset from Bowser
	LDA <Objects_X,X
	LDX <Temp_Var1		
	ADD Bowser_FireballXOff,X
	STA Objects_X,Y	

	LDA RandomN,Y
	AND #$07	
	TAX		 ; X = random 0 to 7

	; A bit random how the fireball moves
	LDA PRG001_BB4B,X
	STA Objects_TargetingYVal,Y

	; Set fireball palette
	LDA #SPR_PAL1
	STA Objects_SprAttr,Y

	; Reset timer
	ASL A			; A = 0
	STA Objects_Timer,Y	

	; Fire breathing sound
	LDA #SND_LEVELFLAME
	STA Sound_QLevel2

	LDX <SlotIndexBackup	; Restore 'X' to Bowser's object slot index

	RTS		 ; Return


Bowser_Counter3Do:
	; If Bowser_Counter3 > 0, just decrement it.  Otherwise,
	; set it to some value $60 to $9F and set Bowser_Counter1 to $3F

	LDA Bowser_Counter3	  
	BNE PRG001_BBDC	 ; If Bowser_Counter3 <> 0, jump to PRG001_BBDC

	LDA RandomN,X
	AND #$3f
	ADC #$60
	STA Bowser_Counter3	 ; Bowser_Counter3 = $60 + (Random $00 to $3F)

	; Bowser Counter 1 = $3F
	LDA #$3f
	STA Bowser_Counter1

	RTS		 ; Return

PRG001_BBDC:
	DEC Bowser_Counter3	; Bowser_Counter3--
	RTS		 ; Return


	; Detect the left and right tiles underneath Bowser
Bowser_DetectTiles:
	; Apply Bowser's X and Y Velocities
	JSR Object_ApplyXVel	 
	JSR Object_ApplyYVel_NoLimit

	LDY <Objects_X,X	 ; Y = Bowser's X

	LDA <Objects_XVel,X
	BEQ PRG001_BBFC	 ; If Bowser is stopped horizontally, jump to PRG001_BBFC
	BMI PRG001_BBF4	 ; If Bowser is moving to the left, jump to PRG001_BBF4

	; Bowser moving to the right...

	; Prevent Bowser from moving off the right edge
	CPY #224
	BGE PRG001_BBF8	 ; If Bowser's X >= 224, jump to PRG001_BBF8
	BLT PRG001_BBFC	 ; Otherwise, jump to PRG001_BBFC

PRG001_BBF4:

	; Bowser moving to the left...

	; Prevent Bowser from moving off the left edge
	CPY #8
	BGE PRG001_BBFC	 ; If Bowser's X >= 8, jump to PRG001_BBFC

PRG001_BBF8:

	; Bowser could move off left or right edge, so stop him!
	LDA #$00
	STA <Objects_XVel,X

PRG001_BBFC:
	
	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_Var4,X
	CMP #$02
	BNE PRG001_BC0B	; If var 4 <> 2, jump to PRG001_BC0B

	; Store tile detected under Bowser's left
	LDA Object_TileFeet2
	STA Bowser_Tiles	 ; Store detected tile -> Bowser_Tiles

PRG001_BC0B:
	LDA <Objects_DetStat,X	; Get Bowser's detection status bits
	PHA		 	; Save them

	LDA <Objects_X,X	; Get Bowser's X
	PHA		 	; Save it

	; Detect the right tile under Bowser's feet
	ADD #16
	STA <Objects_X,X
	JSR Object_WorldDetectN1

	; Restore Bowser's X
	PLA
	STA <Objects_X,X

	PLA		 ; Restore Bowser's detection bits
	ORA <Objects_DetStat,X	 ; OR in the ones detected by the right tile check
	STA <Objects_DetStat,X	 ; Save the unified set (in case only one foot is actually on the floor)

	LDA <Objects_Var4,X
	CMP #$02
	BNE PRG001_BC2D	; If var 4 <> 2, jump to PRG001_BC2D

	; Store tile detected under Bowser's right
	LDA Object_TileFeet2
	STA Bowser_Tiles+1

PRG001_BC2D:
	RTS		 ; Return


	; X offsets to Bowser's tile under each side of him
Bowser_TileOffsets:	.byte 8, 24


	; Busts any breakable floor that Bowser has hit
Bowser_BustFloor:
	LDY #$01	 ; Y = 1 (two tiles to potentially smash)
PRG001_BC32:
	LDA Bowser_Tiles,Y	; Get this tile
	CMP #TILE15_BRICK
	BEQ Bowser_Tile15Alt
	CMP #TILE2_SOLIDBRICK
	BNE PRG001_BC69	 	; If this tile is not the solid brick tile, jump to PRG001_BC69

Bowser_Tile15Alt:
	; Bowser hit brick!
	LDA #$00
	STA Bowser_Tiles,Y	; Clear this tile

	; Queue a block change to erase to background!
	LDA #CHNGTILE_DELETETOBG
	STA Level_ChgTileEvent

	; Aligned Bowser impact Y
	LDA <Objects_Y,X
	ADD #$30
	AND #$f0
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	ADC #$00
	STA Level_BlockChgYHi

	; Aligned Bowser impact X
	LDA <Objects_X,X
	ADD Bowser_TileOffsets, Y
	AND #$f0
	STA Level_BlockChgXLo
	LDA <Objects_XHi,X
	ADC #$00
	STA Level_BlockChgXHi

	JMP PRG001_BC6D	 ; Jump to PRG001_BC6D

PRG001_BC69:
	DEY		; Y--
	BPL PRG001_BC32	; While Y >= 0, loop!

	RTS		 ; Return


PRG001_BC6D:

	; Smash block sound
	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; Copy the bust values over (mainly because Bowser uses both)

	; Set the brick bust
	LDA #$02
	STA BrickBust_En

	; Brick bust upper Y
	LDA Level_BlockChgYLo
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr

	; Brick bust lower Y
	ADD #$08
	STA BrickBust_YLwr

	; Brick bust X
	LDA Level_BlockChgXLo
	SUB <Horz_Scroll	
	STA BrickBust_X

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA BrickBust_XDist
	STA BrickBust_HEn

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel

	RTS		 ; Return


	; Bowser is a very large character drawn using 4x3 8x16-sized sprites
	; These are the patterns for every column of every row, by frame 
	; (12 sprites total per frame, last four values for padding?)
Bowser_SprPats:
	.byte $81, $83, $85, $71, $87, $89, $8B, $8D, $8F, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 0
	.byte $81, $83, $85, $71, $87, $89, $8B, $8D, $97, $99, $9B, $9D, $00, $00, $00, $00 ; Bowser frame 1
	.byte $9F, $A1, $A3, $A5, $A7, $A9, $AB, $AD, $8F, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 2
	.byte $9F, $A1, $B1, $A5, $B3, $B5, $B7, $AD, $B9, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 3
	.byte $71, $C3, $C3, $71, $C5, $C7, $C7, $C5, $C9, $CB, $CB, $C9, $00, $00, $00, $FF ; Bowser frame 4
	.byte $71, $CF, $D1, $71, $D3, $D5, $F7, $D9, $DB, $DD, $DF, $E1, $00, $00, $00, $00 ; Bowser frame 5
	.byte $E3, $E5, $E5, $E3, $E7, $E9, $E9, $E7, $EB, $ED, $ED, $EB, $00, $00, $00, $FF ; Bowser frame 6
	.byte $71, $C3, $C3, $71, $C5, $C7, $C7, $C5, $EF, $F1, $F1, $EF, $00, $00, $00, $FF ; Bowser frame 7
	.byte $71, $CF, $D1, $71, $D3, $D5, $C1, $CD, $F9, $FB, $FD, $FF, $00, $00, $00, $00 ; Bowser frame 8

	; Sprite X offsets per sprite, horizontally flipped or not horizontally flipped
Bowser_SprXNotHFlipped:	.byte $00, $08, $10, $18, $00, $08, $10, $18, $00, $08, $10, $18
Bowser_SprXHFlipped:	.byte $18, $10, $08, $00, $18, $10, $08, $00, $18, $10, $08, $00

	; Sprite Y offsets per sprite, vertically flipped or not vertically flipped
Bowser_SprYNotVFlipped:	.byte $00, $00, $00, $00, $10, $10, $10, $10, $20, $20, $20, $20
Bowser_SprYVFlipped:	.byte $20, $20, $20, $20, $10, $10, $10, $10, $00, $00, $00, $00

	; Similar to Bowser_SprVVisLUT, marks sprite that should be
	; invisible if marked horizontally invisible
Bowser_SprHVisLUT:
	.byte $80, $40, $20, $10

	; Bowser's sprites are drawn straight through; this marks the
	; ones that should not be handled if vertically invisible
Bowser_SprVVisLUT:
	.byte $01, $01, $01, $01	; Top sprites
	.byte $02, $02, $02, $02	; Middle sprites
	.byte $04, $04, $04, $04	; Bottom sprites

	; Bowser uses fixed Sprite_RAM offsets, alternating which set he used every other tick
Bowser_SprRAMOff:
	.byte $50, $54, $58, $5C	; Top sprites
	.byte $60, $64, $68, $6C	; Middle sprites
	.byte $70, $74, $78, $7C	; Bottom sprites

	.byte $00, $00, $00, $00	; Unused, for alignment only (switches between these sets via 4 ASLs)

	.byte $DC, $D8, $D4, $D0	; Top sprites
	.byte $EC, $E8, $E4, $E0	; Middle sprites
	.byte $FC, $F8, $F4, $F0	; Bottom sprites


	; Bowser is a very large character drawn using 4x3 8x16-sized sprites
Bowser_Draw:
	JSR Object_CalcSpriteXY_NoHi	; Calculate the Sprite X and Y Low parts	 

	; Temp_Var1 = Bowser's Sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; Temp_Var2 = Bowser's Sprite X
	LDA <Objects_SpriteX,X
	STA <Temp_Var2	

	; Temp_Var3 and Temp_Var4 = Bowser's FlipBits
	LDA Objects_FlipBits,X
	STA <Temp_Var3		
	STA <Temp_Var4		

	; Temp_Var5 = Bowser's horizontal visibility flags
	LDA Objects_SprHVis,X
	STA <Temp_Var5	

	; Temp_Var6 = Bowser's vertical visibility flags
	LDA Objects_SprVVis,X
	STA <Temp_Var6

	LDY Objects_Frame,X
	CPY #$01
	BEQ PRG001_BDB4		; If Bowser's frame = 1, jump to PRG001_BDB4

	CPY #$07
	BNE PRG001_BDBB	 	; If Bowser's frame <> 7, jump to PRG001_BDBB

PRG001_BDB4:

	; Frame 7 is slightly lower than the others

	LDA <Temp_Var1
	ADD #$04
	STA <Temp_Var1

PRG001_BDBB:
	CPY #$08
	BEQ PRG001_BDD2	 ; If Bowser's frame = 8, jump to PRG001_BDD2

	CPY #$04
	BEQ PRG001_BDC7	 ; If Bowser's frame = 4, jump to PRG001_BDC7

	CPY #$06	 
	BLT PRG001_BDD2	 ; If Bowser's frame < 6, jump to PRG001_BDD2

PRG001_BDC7:

	; Bowser frame 4

	LDA Objects_FlipBits,X
	AND #SPR_VFLIP
	STA <Temp_Var3	 ; Temp_Var3 = $00 or SPR_VFLIP, depending whether Bowser is flipped vertically

	ORA #SPR_HFLIP
	STA <Temp_Var4	 ; Always set horizontal flip in Temp_Var4

PRG001_BDD2:
	LDA Objects_Frame,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var15	 ; Temp_Var15 = frame * 16

	LDA #$00
	STA <Temp_Var16

PRG001_BDDF:

	; This determines which Sprite_RAM offset table set we use.
	; Either 0 or 16, alternating every other frame.
	LDA <Counter_1
	AND #$01
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	ADD <Temp_Var16	 ; Temp_Var16 = current sprite we're on
	TAY		 ; -> 'Y'

	LDA Bowser_SprRAMOff,Y
	TAY		 ; Index -> 'Y'

	LDX <Temp_Var16	 ; X = current sprite

	LDA <Temp_Var6	 	; Get Bowser's vertical visibility flags
	AND Bowser_SprVVisLUT,X	
	BNE PRG001_BE49	 	; If this sprite should not be drawn due to vertically being off-screen, jump to PRG001_BE49

	; Sprites are 0 through 12, so each horizontal sprite is by modulus 4
	TXA
	AND #$03	; Essentially mod 4
	TAX
	LDA <Temp_Var5	 ; Temp_Var5 = 0 to 3 based on which horizontal sprite we're doing

	AND Bowser_SprHVisLUT,X
	BNE PRG001_BE49	 ; If this sprite should not be drawn due to beging horizontally off-screen, jump to PRG001_BE49

	LDA <Temp_Var15	
	ADD <Temp_Var16	 ; Temp_Var16 = (Bowser's frame * 16 [Temp_Var15]) + (which sprite we're on)
	TAX		 ; -> 'X'

	; Store pattern of this Bowser sprite
	LDA Bowser_SprPats,X
	STA Sprite_RAM+1,Y

	LDX <Temp_Var16	 ; X = Temp_Var16

	LDA <Temp_Var3
	BPL PRG001_BE1A	 ; If Bowser is not vertically flipped, jump to PRG001_BE1A

	; Otherwise, use the vertically flipped lookups
	TXA
	ADD #(Bowser_SprYVFlipped - Bowser_SprYNotVFlipped)
	TAX

PRG001_BE1A:
	LDA <Temp_Var1	 	; A = Temp_Var1 (Bowser's Sprite Y)
	ADD Bowser_SprYNotVFlipped,X	; Offset Y as appropriate for this sprite
	STA Sprite_RAM,Y	; Set sprite Y

	LDX <Temp_Var16		; X = Temp_Var16
	TXA		 	
	AND #$03	 	; Get which horizontal sprite (of 4) we're on
	CMP #$02	 	; Horizontal sprite 2 would be the beginning of the "right half" of Bowser

	LDA <Temp_Var3		; A = Temp_Var3 (Bowser's flip bits)
	BLT PRG001_BE30	 	; If we are on the left half of Bowser, jump to PRG001_BE30

	LDA <Temp_Var4		; A = Temp_Var4 (Bowser's flip bits alternate)

PRG001_BE30:
	ORA #SPR_PAL3	 	; Lock in palette 3
	STA Sprite_RAM+2,Y	; Store sprite attributes

	LDA <Temp_Var3
	AND #SPR_HFLIP
	BEQ PRG001_BE40	 ; If Bowser is not horizontally flipped, jump to PRG001_BE40

	; Otherwise, use the horizontally flipped lookups
	TXA		 
	ADD #(Bowser_SprXHFlipped - Bowser_SprXNotHFlipped)
	TAX

PRG001_BE40:
	LDA <Temp_Var2		 ; A = Temp_Var2 (Bowser's Sprite X)
	ADD Bowser_SprXNotHFlipped,X	 ; Offset X as appropriate for this sprite
	STA Sprite_RAM+3,Y	 ; Set sprite X

PRG001_BE49:
	INC <Temp_Var16		 ; Temp_Var16++ (next sprite)

	; Bowser is made of a total of 12 sprites (4x3)
	LDA <Temp_Var16
	CMP #12	 
	BNE PRG001_BDDF	 ; If Temp_Var16 <> 12, loop!

	LDX <SlotIndexBackup	 ; Restore 'X' as Bowser's object slot index

	RTS		 ; Return

Bowser_CalcPlayersSide:

	; Backup Bowser's X
	LDA <Objects_X,X
	PHA

	; +8 Bowser's X; calculation of which side the Player is on is offset
	ADD #$08
	STA <Objects_X,X
	JSR Level_ObjCalcXDiffs

	; Restore Bowser's X
	PLA
	STA <Objects_X,X

	RTS		 ; Return


Bowser_HandleIfDead:
	; Handle Bowser if he's dead either from falling or weapon

	LDA <Objects_YHi,X	 
	CMP #$01
	BLS PRG001_BE6F	 ; If Bowser is way up high, jump to PRG001_BE6F

	; Bowser's not too high...

	LDA <Objects_SpriteY,X
	CMP #$88
	BGE PRG001_BE7F	 ; If Bowser's Y >= $88, jump to PRG001_BE7F

	; Bowser's not too low yet

PRG001_BE6F:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG001_BE98	 ; If Bowser's state is Normal, jump to PRG001_BE98 (RTS)

	; Bowser's state not Normal, now set it to Normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Bowser got killed by weapon, set Bowser's Y velocity to -$30
	LDA #-$30
	STA <Objects_YVel,X

PRG001_BE7F:

	; Set Bowser's internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	; Disable timer
	LSR A	; A = 1
	STA Level_TimerEn

	; Set Bowser's frame to 6
	LDA #$06
	STA Objects_Frame,X

	; Clear Bowser's X Velocity and counter 1
	LDA #$00
	STA <Objects_XVel,X
	STA Bowser_Counter1

	; Set timer 3 to $30 (Delay until dramatic drop "song" begins)
	LDA #$30
	STA Objects_Timer3,X

PRG001_BE98:
	RTS		 ; Return


Bowser_FallAndSplat:
	LDY Objects_Timer3,X
	DEY		 ; Y--
	BNE PRG001_BEA4	 ; If timer 3 not expired, jump to PRG001_BEA4

	; Play dramatic Bowser fall
	LDA #MUS1_BOWSERFALL
	STA Sound_QMusic1

PRG001_BEA4:
	LDA Objects_HitCount,X
	CMP #$01
	BGS PRG001_BEB2	 ; If Bowser has at least one hit left, jump to PRG001_BEB2

	ASL Objects_FlipBits,X
	SEC
	ROR Objects_FlipBits,X

PRG001_BEB2:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	CMP #$25
	BGS PRG001_BEBD	 ; If Y velocity >= $25, jump to PRG001_BEBD

	INC <Objects_YVel,X	 ; Gravity while falling 

PRG001_BEBD:
	LDA Level_ObjectID,X
	CMP #OBJ_BOSS_BOWSERFINAL
	BNE Bowser_NotFinalFall

	; Final Bowser 
	JSR Object_WorldDetectN1
	LDA Object_TileFeet
	CMP #TILE15_LAVABOTTOM
	BNE Bowser_NotFinalFall

	INC <Objects_Var5,X

	LDA #4
	STA <Objects_YHi,X

	; Set timer to $D0
	LDA #$d0
	STA Objects_Timer,X

Bowser_Splash:
	; Initialize splash
	LDA #$01
	STA Splash_Counter+1
	STA Splash_Counter+2
	STA Splash_NoScrollY+1
	STA Splash_NoScrollY+2

	; Set Splash Y
	LDA <Objects_Y,X
	ADD #12
	STA Splash_Y+1
	STA Splash_Y+2

	; Set Splash X
	LDA <Objects_X,X
	STA Splash_X+1
	ADD #16
	STA Splash_X+2
	
	LDA #SND_LEVELSANDFILL
	STA Sound_QLevel2
	
		
	RTS

Bowser_NotFinalFall:
	LDA <Objects_YHi,X
	CMP #$04	 
	BLS PRG001_BEDE	 ; If Bowser hasn't fallen down about 4 screens yet, jump to PRG001_BEDE

	; Bowser hits bottom...

	INC <Objects_Var5,X	 ; Objects_Var5 = 3

	; Set timer to $D0
	LDA #$d0
	STA Objects_Timer,X

	; Vibrate the floor 
	LDA #$80
	STA Level_Vibration

	; Ba-bam!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA <Player_InAir
	BNE PRG001_BEDE		; If Player is mid-air, jump to PRG001_BEDE

	; Bounce Player if he's on the ground
	LDA #-$40
	STA <Player_YVel

	; Mark Player as mid-air
	INC <Player_InAir

PRG001_BEDE:
	LDA <Objects_Y,X	; Get Bowser's Y
	PHA			; Save it
	ADD #16			; +16
	STA <Objects_Y,X	; -> Bowser's Y

	LDA <Objects_YHi,X	; Get Bowser's Y Hi
	PHA		 	; Save it
	ADC #$00	 	; Apply carry
	STA <Objects_YHi,X	; -> Bowser's Y Hi

	JSR Object_DetermineVertVis	; Check if Bowser is vertically invisible

	; Restore Y and Y Hi
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	RTS		 ; Return

DoorAppear_YUpr:	.byte $60, $70
DoorAppear_X:	.byte $E8, $E8

PRG001_BEFB:	.byte $80, $88

Bowser_WaitAndVictory:
	LDA Objects_Timer,X	  
	BNE PRG001_BF09	 ; If timer hasn't expired, jump to PRG001_BF09 (RTS)

	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BNE Bowser_NotDDComet

	JMP_THUNKC 30, Level_EndComet

Bowser_NotDDComet:
	LDA World_Num
	CMP #9
	BEQ Bowser_NoWZeroVictory	; No victory song on World Zero

	LDA #MUS1_BOSSVICTORY

	LDY Level_ObjectID,X
	CPY #OBJ_BOSS_BOWSERFINAL
	BNE BWAV_MusSet

	LDA #MUS1_WORLDVICTORY

	; Play victory fanfare
BWAV_MusSet:
	STA Sound_QMusic1

Bowser_NoWZeroVictory:
	INC <Objects_Var5,X	 ; Objects_Var5 = 3

PRG001_BF09:
	RTS		 ; Return

Bowser_DoTimeBonus:
	LDA World_Num
	CMP #9
	BNE Bowser_NotWZeroExit

	; Clear Arena Door 7
	LDA #7
	STA <Temp_Var1
	JSR_THUNKA 41, ArenaCtl_ExitBoss
	JMP Object_Delete

Bowser_NotWZeroExit:
	JSR DoTimeBonus	 ; Convert time to bonus score
	BNE PRG001_BF16	 ; If still counting down, jump to PRG001_BF16 (RTS)

	; Set timer to $40
	LDA #$40
	STA Objects_Timer,X

	INC <Objects_Var5,X	 ; Objects_Var5 = 4

PRG001_BF16:
	RTS		 ; Return


Bowser_DoorAppear:

	; SB: NOPE!  No more door; just unlock scrolling

	; Hold Player in place
	LDA #$FF
	STA Player_HaltTick

	; Until Player is roughly centered, we must move the screen back to prevent a scroll glitch
	LDA <Player_SpriteX
	AND #$FE
	CMP #$80

	; If no movement required, jump to PostBScroll_Done
	BEQ PostBScroll_Done

	; If Player is left of center, screen must move left; jump to PostBScroll_MoveLeft
	BLT PostBScroll_MoveLeft

	; If Player is right of center, screen must move right; jump to PostBScroll_MoveRight
	BGE PostBScroll_MoveRight
	
PostBScroll_Done:
	; Unlock scrolling
	LDA #0
	STA LevelJctBQ_Flag

	; Unlock Player
	LDA #$00
	STA Player_HaltTick

	; Bowser 1: Play somber music
	LDY #MUS2A_THRONEROOM
	
	LDA Level_ObjectID,X
	CMP #OBJ_BOSS_BOWSER
	BEQ PostBScroll_MusPlay
	
	; Bowser 2: Play princess music
	LDY #MUS2B_PRINCESS
	
PostBScroll_MusPlay:
	STY Sound_QMusic2

	; Bowser's done
	INC <Objects_Var5,X

	RTS		 ; Return

PostBScroll_MoveLeft:
	LDA #1
	STA Scroll_LastDir

	LDA Horz_Scroll
	SUB #2
	STA Horz_Scroll
	LDA Horz_Scroll_Hi
	SBC #0
	STA Horz_Scroll_Hi

	RTS
	
PostBScroll_MoveRight:
	LDA #0
	STA Scroll_LastDir

	LDA Horz_Scroll
	ADD #2
	STA Horz_Scroll
	LDA Horz_Scroll_Hi
	ADC #0
	STA Horz_Scroll_Hi

	RTS


; SB: Reverse gravity enemy creators
ObjInit_RGravEnmy:

	; Change to correct reverse gravity object
	LDA Level_ObjectID,X	; Get ID
	ADD #(OBJ_GREENTROOPA - OBJ_RGREENTROOPA)	; Offset to what object it SHOULD be
	STA Level_ObjectID,X	; Update ID

	; Fix the ObjGroupRel_Idx
	SUB #OBJ_GREENTROOPA
	STA ObjGroupRel_Idx

	; Enable reverse gravity
	INC Objects_ReverseGrav,X

	LDA #4	; Page 4 objects
	JMP ObjState_InitPageMismatch	; Jump to ObjState_InitReverseGrav

ObjInit_CoinSnake:

	; Play Coin Snake music
	LDA #MUS2B_PSWITCH
	STA Sound_QMusic2

	; Play raise sound
	LDA #SND_LEVELVINE
	STA Sound_QLevel1

	; SB: Doing this here because we couldn't call it in PRG030
	JSR Level_PrepareNewObject

	; Default up
	LDA #1
	STA Objects_Var1,X

	LDA #0
	STA Objects_Var3,X

	RTS

CoinSnake_DeltaHi:	.byte  $00,  $FF
CoinSnake_Delta:	.byte  $01, -$01

CoinSnake_JustDrawInd:
	JMP CoinSnake_JustDraw

CoinSnake_DeleteNoPopInd:
	JMP CoinSnake_DeleteNoPop

ObjNorm_CoinSnake:

	LDA <Player_HaltGame
	BNE CoinSnake_JustDrawInd	 ; If gameplay halted, jump to CoinSnake_JustDraw

	; If Var2 = 0 (no tile change flagged), jump to CoinSnake_NoChange
	LDA Objects_Var2,X
	BEQ CoinSnake_NoChange

	; Direction change?
	LDA Objects_Var3,X
	BEQ CoinSnake_NoDirChange

	; Apply direction change...
	SUB #1	; Normalize it
	STA Objects_Var1,X	; Store it!

	; Direction change request is over
	LDA #0
	STA Objects_Var3,X

CoinSnake_NoDirChange:

	; If a block change is active, can't do it yet, jump to CoinSnake_NoChange
	LDA Level_ChgTileEvent
	BNE CoinSnake_NoChange

	; Verify we haven't hit a solid tile...
	LDY #(12 * 3)	; Object_TileDetectOffsets Group 3
	JSR Object_DetectTile	; Get tile we would be changing...

	; Specific tiles to watch out for...
	CMP #TILEA_COIN
	BEQ CoinSnake_DeleteNoPopInd

	LDY Level_Tileset
	CPY #$05
	BNE CoinSnake_NotGhost

	; Ghost house specific tiles...
	SUB #TILE5_STAIRR1
	CMP #$04
	BLT CoinSnake_DeleteNoPopInd	; If hitting one of the stair tiles, abort! 

CoinSnake_NotGhost:
	LDA <Level_Tile
	SUB #TILEA_DOOR1
	CMP #$02
	BLT CoinSnake_DeleteNoPopInd	; If hitting one of the door tiles, abort! 

	; Calculate tile quadrant
	LDA <Level_Tile
	ASL A
	ROL A
	ROL A
	AND #$03
	TAY	; -> 'Y'

	LDA <Level_Tile
	CMP Tile_AttrTable,Y
	BGE CoinSnake_DeleteNoPopInd	; If solid, jump to CoinSnake_DeleteNoPopInd

	LDA #(CHNGTILE_FROZENCOIN | $80)
	STA Level_ChgTileEvent	 ; Store type of block change!

	; Store change Y Hi and Lo
	LDA <Objects_Y,X
	AND #$F0
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	STA Level_BlockChgYHi

	; Store change X Hi and Lo
	LDA <Objects_X,X
	AND #$F0
	STA Level_BlockChgXLo
	LDA <Objects_XHi,X
	STA Level_BlockChgXHi

	; Flag done!
	LDA #0
	STA Objects_Var2,X

CoinSnake_NoChange:


	; Animate!
	LDA <Counter_1
	LSR A
	LSR A
	AND #$03
	STA Objects_Frame,X

	LDA Objects_Var1,X
	CMP #$02
	BGE CoinSnake_Horz	; If direction >= 2 (left or right), jump to CoinSnake_Horz

	; Vertical coin snake...
	TAY

	; Queue a direction change? (Left/right only)
	LDA <Pad_Input
	AND #(PAD_RIGHT | PAD_LEFT)
	BEQ CoinSnakeV_NoLRChange	; If Player did not press left/right, jump to CoinSnakeV_NoLRChange

	; Player pressed left/right...
	LSR A	; Right = 0, Left = 1
	ADD #3	; 3/4 (+1 because zero means "no change")

	; Queue direction change (will happen at next alignment)
	STA Objects_Var3,X

CoinSnakeV_NoLRChange:
	LDA <Objects_Y,X
	ADD CoinSnake_Delta,Y
	STA <Objects_Y,X

	AND #$0F	; Testing if aligned to new row
	PHP		; Save flags

	LDA <Objects_YHi,X
	ADC CoinSnake_DeltaHi,Y
	STA <Objects_YHi,X

	BMI CoinSnake_Delete	; If we just went negative, abort!

	CMP #1
	BLT CoinSnake_NotLow	; If not too low yet, jump to CoinSnake_NotLow

	; Low coin snake...
	LDA <Objects_Y,X
	CMP #$B0
	BGE CoinSnake_Delete	; $1B0 would be too low, so abort!

CoinSnake_NotLow:
	JMP CoinSnake_Cont


CoinSnake_Horz:
	; Horizontal coin snake...
	AND #$01
	TAY

	; Queue a direction change? (Left/right only)
	LDA <Pad_Input
	AND #(PAD_DOWN | PAD_UP)
	BEQ CoinSnakeV_NoUDChange	; If Player did not press down/up, jump to CoinSnakeV_NoUDChange

	; Player pressed down/up...
	LSR A
	LSR A
	LSR A	; Down = 0, Up = 1
	ADD #1	; +1 because zero means "no change"

	; Queue direction change (will happen at next alignment)
	STA Objects_Var3,X

CoinSnakeV_NoUDChange:

	LDA <Objects_X,X
	ADD CoinSnake_Delta,Y
	STA <Objects_X,X

	AND #$0F	; Testing if aligned to new column
	PHP		; Save flags

	LDA <Objects_XHi,X
	ADC CoinSnake_DeltaHi,Y
	STA <Objects_XHi,X

	BMI CoinSnake_Delete	; If we just went negative, abort!

	SUB #1					; Correction for final screen
	CMP <Level_Width
	BGS CoinSnake_Delete	; If went off right side, abort!


CoinSnake_Cont:
	PLP		; Restore flags
	BNE CoinSnake_NotNewRow	; If not on a new row/column, jump to CoinSnake_NotNewRow

	; Flag that we need to do a block change when possible
	INC Objects_Var2,X

CoinSnake_NotNewRow:


CoinSnake_JustDraw:
	JSR Object_DetermineHorzVis	; Set flags based on which sprites of this object are horizontally visible
	JSR Object_DetermineVertVis	; Set flags based on which sprites of this object are vertically visible
	JSR Object_CalcSpriteXY_NoHi	; Calculate sprite info

	JSR Object_AnySprOffscreen
	BNE CoinSnake_NoDraw	 ; If any sprite is off-screen, jump to CoinSnake_NoDraw

	; Coin snake lead is simple 8x16 sprite

	; Grab pattern -> Temp_Var1
	LDA Objects_Frame,X
	TAY
	LDA ObjP20,Y
	STA <Temp_Var1

	LDY Object_SprRAM,X		 ; Y = starting Sprite_RAM offset

	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$00,Y

	LDA <Temp_Var1
	STA Sprite_RAM+$01,Y

	LDA Objects_SprAttr,X
	STA Sprite_RAM+$02,Y

	LDA <Objects_SpriteX,X
	ADD #4
	STA Sprite_RAM+$03,Y

CoinSnake_NoDraw:	
	RTS

CoinSnake_Delete:
	PLA	; Pop saved flags

CoinSnake_DeleteNoPop:
	LDA Level_PSwitchCnt
	BNE CoinSnake_NoMusRestore	; If a P-Switch is active, can't restore music, jump to CoinSnake_NoMusRestore

	LDA Level_MusicQueueRestore	 ; Y = regular BGM
	STA Sound_QMusic2

CoinSnake_NoMusRestore:
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X
	RTS


ObjInit_Checkpoint:
	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BEQ Checkpoint_NoForComet
	CMP #MAPOBJ_PURPLECOMET
	BEQ Checkpoint_NoForComet

	LDA <Objects_X,X
	ADD #8
	STA <Objects_X,X
	LDA <Objects_XHi,X
	ADC #0
	STA <Objects_XHi,X

	RTS

Checkpoint_NoForComet:
	JMP Object_Delete

ObjNorm_Checkpoint:
	LDA <Player_HaltGame
	BNE Checkpoint_JustDraw	 ; If gameplay is halted, jump to Checkpoint_JustDraw

	JSR Object_HitTestRespond
	JSR Object_DeleteOffScreen

Checkpoint_JustDraw:
	JSR Object_DetermineHorzVis		; Set flags based on which sprites of this object are horizontally visible
	JSR Object_DetermineVertVis		; Set flags based on which sprites of this object are vertically visible
	JSR Object_CalcSpriteXY_NoHi	; Calculate sprite info

	LDA Objects_SprVVis,X
	BNE Checkpoint_OffV		; If any vertical vis flags are set, we're off-screen vertical; jump to Checkpoint_OffV (RTS)
	
	LDY Object_SprRAM,X		 ; Y = starting Sprite_RAM offset

	; Left/right stars
	LDA Level_Tileset
	CMP #11
	BNE CPStars_Normal
	
	LDA #$5F
	BNE CPStars_UseGiantAlt
	
CPStars_Normal:
	LDA #$73	; SB: Changed to make room for flag; not really the same I guess
	
CPStars_UseGiantAlt:
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$0D,Y
	
	; Mushroom center
	LDA #$51
	STA Sprite_RAM+$05,Y
	STA Sprite_RAM+$09,Y

	; Set attributes
	LDA Objects_SprAttr,X
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y
	STA Sprite_RAM+$0E,Y
	
	ORA #SPR_HFLIP
	STA Sprite_RAM+$0A,Y

	; Set X and Y positions on 4 sprites if/until we hit an off-screen one
	LDA #3
	STA <Temp_Var1

	LDA <Objects_SpriteX,X
	STA <Temp_Var2

Checkpoint_SetV:
	ASL Objects_SprHVis,X
	BNE Checkpoint_OffV		; If this sprite is horizontally off-screen, jump to Checkpoint_OffV (RTS)
	
	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$00,Y

	; Set X positions
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y
	ADD #8
	STA <Temp_Var2

	; Y += 4 (next sprite)
	INY
	INY
	INY
	INY

	DEC <Temp_Var1		; Temp_Var1--
	BPL Checkpoint_SetV	; While Temp_Var1 >= 0, loop!

Checkpoint_OffV:
	RTS

ObjHit_Checkpoint:

	LDA <Player_Suit
	BNE CPHit_PlayerNotSmall

	; Player is small; act like a mushroom!
	JSR ObjHit_PUpMush
	JMP CPHit_Cont

CPHit_PlayerNotSmall:

	; Play pickup sound
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

CPHit_Cont:

	; "Poof" away
	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot or don't come back here!

	; The "poof" from when it appears	 
	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y

	; Set the poof where the box will be
	LDA <Objects_X,X
	ADD #8
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	; Set the "poof" counter
	LDA #$1f
	STA SpecialObj_Data,Y


ObjInit_CheckpointF:
	LDA Player_StarInv
	CMP #$21
	BLT OICPF_StarInvOK

	; Prevent bosses from being hit with invincibility
	LDA #$21
	STA Player_StarInv

OICPF_StarInvOK:
	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BEQ Checkpoint_NoForCometF
	CMP #MAPOBJ_PURPLECOMET
	BEQ Checkpoint_NoForCometF

	LDA Level_ObjectID,X
	CMP #OBJ_CHECKPOINT_FORCE
	BNE CPF_Cont	; If this isn't a "forced" checkpoint, jump to CPF_Cont

	; This object will not work in World Zero EXCEPT in the "Extended" tileset!
	; This is to avoid some boss rooms from taking over the checkpoint
	; in the final castle...
	LDA World_Num
	CMP #9
	BNE CPF_Cont	; Not World Zero? No problemo.
	
	LDA Level_Tileset
	CMP #15
	BEQ CPF_Cont	; World Zero and Extended Tileset? OK.

	; Otherwise, NO!
Checkpoint_NoForCometF:
	JMP Object_Delete
	

CPF_Cont:
	; Get offset to this Player's checkpoint data
	LDY Player_Current
	LDA LevCP_ByPlayer,Y
	TAY

	; Set checkpoint data...
	LDA LevCP_ActiveID
	STA LevCP_ID,Y
	
	; Layout pointer
	LDA Level_LayPtrOrig_AddrL
	STA LevCP_LayBackup,Y
	LDA Level_LayPtrOrig_AddrH
	STA LevCP_LayBackup+1,Y
	
	; Object pointer
	LDA Level_ObjPtrOrig_AddrL
	STA LevCP_ObjBackup,Y
	LDA Level_ObjPtrOrig_AddrH
	STA LevCP_ObjBackup+1,Y

	; Tileset and packed star coin value
	LDA Level_Tileset
	AND #$0F
	STA <Temp_Var2	; Tileset -> Temp_Var2
	
	; Backup 'Y'
	TYA
	PHA
	
	; Loop all star coins and pack
	LDY #2	; Y = 2 (loop counter)
	
	LDA #$40		; Right-most bit for star coin pack
	STA <Temp_Var1	; -> Temp_Var1
	

CPHit_SCLoop:
	LDA Inventory_Cards,Y	; Get this star coin
	BEQ CPHit_SCLoop_NoCoin	; If Player does not have this coin, jump to CPHit_SCLoop_NoCoin
	
	; Player has this coin!  Pack it!
	LDA <Temp_Var2
	ORA <Temp_Var1
	STA <Temp_Var2
	
CPHit_SCLoop_NoCoin:
	LSR <Temp_Var1		; Next bit weight

	DEY					; Y--
	BPL CPHit_SCLoop	; While Y >= 0, loop!
	
	; Restore 'Y'
	PLA
	TAY
	
	; Merge results into LevCP_TSSCBackup
	LDA <Temp_Var2
	STA LevCP_TSSCBackup,Y
	
	
	LDA Objects_X,X
	ADD #8
	STA LevCP_X,Y
	LDA Objects_XHi,X
	ADC #0
	STA LevCP_XHi,Y
	
	LDA Objects_Y,X
	SUB #16
	STA LevCP_Y,Y
	LDA Objects_YHi,X
	SBC #0
	STA LevCP_YHi,Y

	JMP Object_Delete


	; This will essentially become a green piranha spitting fire but aligned to tile instead of pipe
ObjInit_GreenPiranhaX:
	
		; Change to correct object
	LDA #OBJ_GREENPIRANHA_FIRE
	STA Level_ObjectID,X	; Update ID

	; Fix the ObjGroupRel_Idx
	SUB #OBJ_TILTINGPLATFORM
	STA ObjGroupRel_Idx
	
	; Shift left 8 pixels; will override correction in main piranha init
	LDA <Objects_X,X
	SUB #8
	STA <Objects_X,X

	LDA #5	; Page 5 objects
	JMP ObjState_InitPageMismatch	; Jump to ObjState_InitReverseGrav


ObjNorm_PipeRaise:

	; Y = 0 to 3, depending on which placeholder this is
	LDA Level_ObjectID,X
	SUB #OBJ_PIPERAISE1
	TAY

	LDA <Objects_Var5,X
	BEQ PipeRaise_WaitUntilOK	; If Var 5 = 0, jump to PipeRaise_WaitUntilOK

	; Pipe is raising...
	LDA #$FF
	STA <Player_HaltGame
	STA Player_HaltTick
	
	LDA Objects_Var1,X
	CMP #32
	BEQ PipeRaise_Complete	; If we're at tick 32, we're done; jump to PipeRaise_Complete

	AND #7
	BNE PipeRaise_NoNext	; On every 8th tick, we raise a little; otherwise, jump to PipeRaise_NoNext

	; Calculate tile change!
	LDA Objects_Var1,X
	LSR A	
	LSR A	
	LSR A
	ADD #CHNGTILE_PIPERAISE1
	STA Level_ChgTileEvent

	LDA <Objects_Y,X
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	STA Level_BlockChgYHi

	LDA <Objects_X,X
	STA Level_BlockChgXLo
	LDA <Objects_XHi,X
	STA Level_BlockChgXHi

PipeRaise_NoNext:
	INC Objects_Var1,X

	RTS
	
PipeRaise_Complete:
	; Pipe raise complete!  Release gameplay holds!
	LDA #0
	STA <Player_HaltGame
	STA Player_HaltTick
	
	; Mark as raised!
	LDA Level_PipeRaiseData
	ORA PipeRaise_AlreadyRaisedBits,Y
	STA Level_PipeRaiseData

	; Removing object this way because it never needs to come back!
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X
	RTS
	;JMP Object_Delete
	
PipeRaise_WaitUntilOK:

	LDA Level_PipeRaiseData
	AND PipeRaise_NeedRaiseBits,Y
	BEQ PipeRaise_NotReady		; If the appropriate bit for this placeholder is not set, jump to PipeRaise_NotReady (RTS)

	JSR Object_DeleteOffScreen

	LDA <Player_HaltGame
	ORA Level_ChgTileEvent
	BNE PipeRaise_NotReady	; If gameplay is halted or a tile change is already queued, jump to PipeRaise_NotReady (RTS)

	;LDA <Objects_X,X
	;CMP <Horz_Scroll
	;LDA <Objects_XHi,X
	;SBC <Horz_Scroll_Hi
	;BNE PipeRaise_NotReady	; SB: If pipe raise is horizontally off-screen, jump to PipeRaise_NotReady

	JSR Object_DetermineHorzVis		; Set flags based on which sprites of this object are horizontally visible
	JSR Object_DetermineVertVis		; Set flags based on which sprites of this object are vertically visible
	;JSR Object_CalcSpriteXY_NoHi	; Calculate sprite X/Y
	
	JSR Object_AnySprOffscreen
	BNE PipeRaise_NotReady	 ; If any sprite is off-screen, jump to PipeRaise_NotReady (RTS)
	
	; Ready!
	INC <Objects_Var5,X
	
	; Play powerup rising sound
	LDA Sound_QLevel1
	ORA #SND_LEVELRISE
	STA Sound_QLevel1
	
PipeRaise_NotReady:
	RTS

ObjInit_ChangeMusic:

	LDA <Objects_YHi,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var1
	LDA <Objects_Y,X
	LSR A
	LSR A
	LSR A
	LSR A	; Completes divide-by-16 (makes grid row position)
	ORA <Temp_Var1

	CMP SndCur_Music2
	BEQ ChangeMusic_DoNothing
	
	; Queue music
	STA Sound_QMusic2
	
ChangeMusic_DoNothing:

	JMP Object_Delete

Wing_YSprOff:	.byte 4,   0
Wing_XOff:		.byte 2, -10
Wing_YVel:		.byte $00, $04, $08, $04, $00, -$04, -$08, -$04

ObjNorm_ParaDryBones:

	LDA <Player_HaltGame
	BNE Draw_ParaDryBones

	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	LSR A
	ADD <SlotIndexBackup
	AND #7
	TAY
	LDA Wing_YVel,Y
	STA <Objects_YVel,X

	JSR Object_ApplyYVel

	JSR Bowser_FacePlayer

	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #1
	STA Objects_Frame,X

	JSR Object_HandleBumpUnderneath

Draw_ParaDryBones:
	LDA Object_SprRAM,X
	ADD #4
	STA Object_SprRAM,X
	
	LDA Objects_FlipBits,X
	ASL A
	ROL A
	ROL A		 ; Effectively, shift bit 6 to bit 0 (i.e. if $40, now 1)
	AND #$01	 ; Capping value to be sure
	STA <Temp_Var15

	; Save Dry Bones' Y/Hi
	LDA <Objects_YHi,X
	PHA		
	LDA <Objects_Y,X
	PHA		

	; Subtract 16 from Dry Bones' Y position
	SUB #16
	STA <Objects_Y,X
	BCS PRG001_B6F2
	DEC <Objects_YHi,X
PRG001_B6F2:

	; Draw Dry Bones
	LDY #$01	 ; 32 pixels height for Object_DetermineVertVisY
	JSR Object_DetermineVertVisY
	JSR Object_Draw16x32Sprite

	LDY <Temp_Var15
	LDA Object_SprRAM,X
	ADD Wing_YSprOff,Y		; Use Y coordinate from first or second sprite so wing is properly hidden
	TAY
	LDA Sprite_RAM+$00,Y

	LDY Object_SprRAM,X
	ADD #4
	STA Sprite_RAM-$04,Y

	LDY Object_SprRAM,X
	LDA Objects_Frame,X
	ASL A
	ADD #$D9
	STA Sprite_RAM-$03,Y

	LDA Sprite_RAM+$06,Y
	STA Sprite_RAM-$02,Y

	LDX <Temp_Var15
	LDA Sprite_RAM+$07,Y
	ADD Wing_XOff,X
	STA Sprite_RAM-$01,Y

	LDX <SlotIndexBackup

	; Restore Dry Bones' Y/Hi
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_YHi,X

	JSR Object_DetermineVertVis
	JMP Object_CalcSpriteXY_NoHi	 ; Calculate sprite X/Y and don't come back!


ObjNorm_GreenShell:
	LDA #OBJSTATE_KICKED
	STA Objects_State,X

	LDA #$60
	STA Objects_Timer3,X

	LDA #-$20
	STA <Objects_XVel,X
	
	JSR Object_ShakeAndDraw
	
LaunchStar_NoPurpleComet:
	RTS

ObjInit_LaunchStar:
	LDA <Map_EnterViaID
	CMP #MAPOBJ_PURPLECOMET
	BNE LaunchStar_NoPurpleComet

	JMP Object_Delete

ObjNorm_LaunchStar:
	; Hack: "PatTableSel" cannot support a bank value over 127, so must do so manually
	LDA #248
	STA PatTable_BankSel+4

	JSR LaunchStar_Draw

	LDA <Player_HaltGame
	BNE LaunchStar_Halt

	JSR Object_HitTestRespond
	
	LDA <Counter_1
	AND #3
	BNE LaunchStar_Halt
	
	LDA Objects_Frame,X
	ADD #1
	CMP #3
	BLT LaunchStar_FrameOK
	
	LDA #0
	
LaunchStar_FrameOK:
	STA Objects_Frame,X
	
LaunchStar_Halt:
	RTS


LaunchStar_Draw:
	LDA Objects_ReverseGrav,X
	BEQ LSDraw_NotReverse
	
	LDA #SPR_VFLIP
	STA Objects_FlipBits,X

LSDraw_NotReverse:
	; Actually need to move FOUR patterns at a time per frame...
	; Calc additional offset here
	LDA Objects_Frame,X
	ASL A
	STA <Temp_Var15

	JSR Object_ShakeAndCalcSprite

	TXA
	ADD <Temp_Var15
	TAX

	JSR Object_Draw16x16Sprite

	LDA <Temp_Var7	 ; Get Sprite_RAM offset (as determined by Object_ShakeAndCalcSprite)
	ADD #(4*2)
	TAY

	INX
	INX	; X += 2 (starting tiles index)

	; Temp_Var2 (Sprite X) += 16
	LDA #16
	ADD <Temp_Var2
	STA <Temp_Var2

	; Consider horizontal visiblity 2 sprites over...
	ASL <Temp_Var8
	ASL <Temp_Var8

	JSR Object_Draw16x16Sprite

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return


ObjHit_LaunchStar:

	LDA SndCur_Level1
	AND #(SND_LEVELRISE | SND_LEVELVINE)
	BNE OHLS_PlayingSound

	; If not playing either of those sounds, we need to play the "rise" sound
	LDA #SND_LEVELRISE
	STA Sound_QLevel1

OHLS_PlayingSound:
	; Spin player, mark in mid air
	LDA #1
	STA Player_TwisterSpin
	STA Player_InAir
	STA Player_VibeDisable
	
	; Get player centered vertically
	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	SUB #5
	ASL A
	ASL A 
	STA <Player_YVel
	
	LDA Player_ReverseGrav
	BEQ OHLS_PlayerNotReverse

	LDA <Player_YVel
	ADD #(7*4)
	NEG
	STA <Player_YVel

OHLS_PlayerNotReverse:
	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15
	ADD #2
	ASL A
	ASL A
	STA <Player_XVel

	; Cheating vibe disable...
	LDX #0
	JSR_THUNKA 8, Player_ApplyVelocity
	LDX <SlotIndexBackup


	LDA Objects_Timer,X
	BEQ OHLS_SetTimer
	CMP #1
	BNE OHLS_TimerNotDone

	JMP OHLS_SendAway	; Send player away!
	
OHLS_SetTimer:
	LDA #40
	STA Objects_Timer,X
		
OHLS_TimerNotDone:
	RTS


ObjInit_Topmaniac:
	LDA #32
	STA Objects_HitCount,X

Topmanic_Halt:
	RTS


Topmaniac_WallRebound:	.byte -$10, $10

ObjNorm_Topmaniac:
	LDA <Objects_Var5,X
	CMP #7
	BGE Topmaniac_DeadNoDraw

	JSR LaunchStar_Draw

Topmaniac_DeadNoDraw:
	LDA <Player_HaltGame
	BNE Topmanic_Halt

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ Topmaniac_Normal		; If Topmanic is in normal state, jump to Topmaniac_Normal

	LDA <Objects_Var5,X
	CMP #6
	BGE Topmaniac_Normal		; If Topmaniac is already dying, jump to Topmaniac_Normal
	
	LDA #6
	STA <Objects_Var5,X

Topmaniac_Normal:
	LDA <Objects_Var5,X
	JSR DynJump
	
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Topmaniac_Chase			; 0
	.word Topmaniac_KnockedOut		; 1
	.word Topmaniac_KnockedOutWait	; 2
	.word Topmaniac_Kicked			; 3
	.word Topmaniac_FlashHit		; 4
	.word Topmaniac_SpinUp			; 5
	.word Topmaniac_Explode			; 6
	.word Topmaniac_EndLevel		; 7
	.word Topmaniac_DeadTimeout		; 8

Topmaniac_Chase:
	LDA #0
	STA Objects_PlayerHitStat,X	

	JSR Object_HandleBumpUnderneath

	LDA Objects_PlayerHitStat,X
	BEQ Topmaniac_PlayerNoHit	 ; If Player is not hitting Topmaniac at all, jump to Topmaniac_PlayerNoHit (RTS)

	; Play squish sound
	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	; Player Y Vel = -$30 (bounce off)
	LDA #-$30
	STA <Player_YVel
	
	; Regain the hit (this doesn't count towards death)
	INC Objects_HitCount,X
		
	INC <Objects_Var5,X

	LDA #$07
	STA Objects_Timer,X
	
	LDA #3
	STA Objects_Frame,X
	
	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15
	ASL A
	ASL A
	NEG
	STA <Player_XVel

Topmaniac_PlayerNoHit:
	LDA Objects_Var2,X
	ADD <Objects_XVel,X
	STA Objects_Var2,X
	
	AND #%11100000
	BEQ Topmaniac_NotAnimChange
	
	LDA Objects_Var2,X
	AND #%00011111
	STA Objects_Var2,X

	JSR Topmaniac_AnimCycle
	
Topmaniac_NotAnimChange:
	;;;;;;;;
	
	JSR Topmaniac_MoveHitFloorCheck
	
	LDA Objects_DetStat,X
	AND #$03
	BEQ Topmaniac_NoWallHit

	LDA <Objects_XVel,X
	ASL A
	ROL A
	AND #1
	TAY
	
	LDA Topmaniac_WallRebound,Y
	BNE Topmaniac_AtSpeed
	
Topmaniac_NoWallHit:

; 	   And 'Y' is set to 0 if Player is to the right of object, 1 if to the left

	JSR Level_ObjCalcXDiffs

	CPY #1
	BEQ Topmaniac_PlayerIsLeft
	
	; Player is to the right... (Y = 0)

	; Don't move if hit wall on right
	LDA Objects_DetStat,X
	AND #$01
	BNE Topmaniac_NoMove	; Hit wall, don't move to the right

	LDA <Objects_XVel,X
	CMP #$10
	BGS Topmaniac_AtSpeed
	
	ADD #$01
	JMP Topmaniac_AtSpeed
	
Topmaniac_PlayerIsLeft:

	; Player is to the left... (Y = 1)

	; Don't move if hit wall on left
	LDA Objects_DetStat,X
	AND #$02
	BNE Topmaniac_NoMove	; Hit wall, don't move to the left

	LDA <Objects_XVel,X
	CMP #-$10
	BLS Topmaniac_AtSpeed
	
	SUB #$01
	JMP Topmaniac_AtSpeed

Topmaniac_NoMove:

	; Stop!
	LDA #0

Topmaniac_AtSpeed:
	STA <Objects_XVel,X

	RTS

Topmaniac_KnockedOut:
	LDA Objects_Timer,X
	BNE Topmaniac_NoAnimKO
	
	LDA #$07
	STA Objects_Timer,X
	
	INC Objects_Frame,X
	LDA Objects_Frame,X
	CMP #4
	BLT Topmaniac_NoAnimKO
	
	INC <Objects_Var5,X
	
	LDA #$60
	STA Objects_Timer,X
	
Topmaniac_NoAnimKO:
	RTS
	
	
Topmaniac_KnockedOutWait:
	LDA Objects_Timer,X
	BNE Topmaniac_StillKO

	LDA #0
	STA Objects_Frame,X
	STA <Objects_Var5,X

Topmaniac_StillKO:
	JSR Object_CalcCoarseXDiff

	LDA Level_ObjectID,X
	CMP #OBJ_TOPMAN
	BNE Topmaniac_AsBoss

	; Topman is sharing this code, but the ranges are shorter
	LDA <Temp_Var15
	CMP #2
	BEQ Topmaniac_KickRight	; If Temp_Var15 = 2, jump to Topmaniac_KickRight
	BGS Topmaniac_OORKick
	
	CMP #-2
	BEQ Topmaniac_KickLeft	; If Temp_Var15 = -6, jump to Topmaniac_KickLeft
	BLS Topmaniac_OORKick

Topmaniac_AsBoss:
	LDA <Temp_Var15

	; < -6 > 2
	; +2, bounce XVel
	
	CMP #2
	BEQ Topmaniac_KickRight	; If Temp_Var15 = 2, jump to Topmaniac_KickRight
	BGS Topmaniac_OORKick
	
	CMP #-6
	BEQ Topmaniac_KickLeft	; If Temp_Var15 = -6, jump to Topmaniac_KickLeft
	BLS Topmaniac_OORKick

Topmaniac_KickRight:
	LDA #$20
	BNE Topmanic_Kick

Topmaniac_KickLeft:
	LDA #-$20

Topmanic_Kick:
	STA <Temp_Var1		; Potential kick velocity
	
	JSR Object_CalcCoarseYDiff

	; TV15
	; 4 is safe for kicking
	; higher is too high

	LDA <Temp_Var15
	CMP #5
	BLT Topmanic_KickOK	; TV < 4, jump to Topmanic_KickOK
	
	; At least 5...
	SUB #5
	CMP #2
	BGE Topmaniac_OORKick
	BLT Topmaniac_OORKickAbove
	
Topmanic_KickOK:
	LDA #$30
	STA Objects_Timer,X

	; Play kick sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; Have Player do kick frame
	LDA #$0c
	STA Player_Kick

	LDA <Temp_Var1
	STA <Objects_XVel,X
	
	LDA #0
	STA <Player_XVel

	INC <Objects_Var5,X

Topmaniac_OORKickAbove:
	LDA #-$30
	STA <Player_YVel

	LDA #$60
	STA Objects_Timer,X

	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer

Topmaniac_OORKick:
	RTS
	

Topmaniac_Kicked:
	JSR Topmaniac_MoveHitFloorCheck
	
	LDA <Objects_XVel,X
	BEQ Topmaniac_KickStopped
	
	BMI Topmaniac_SlowNeg
	
	DEC <Objects_XVel,X
	
	BPL Topmaniac_Cont
	
Topmaniac_SlowNeg:
	INC <Objects_XVel,X
	
Topmaniac_Cont:
	LDA Object_TileWall
	SUB #TILE2_ZAPPER_L
	CMP #2
	BGE Topmaniac_NoZapperHit	; If not a zapping tile, jump to Topmaniac_NoZapperHit

	LDA Level_ObjectID,X
	CMP #OBJ_TOPMAN
	BEQ Topman_Die

	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA #-$30
	STA <Objects_YVel,X
	
	LDA <Objects_XVel,X
	NEG
	STA <Objects_XVel,X

	INC <Objects_Var5,X
	
	LDA #$40
	STA Objects_ColorCycle,X

Topmaniac_NoZapperHit:
	RTS

Topman_Die:
	LDA #$05
	JSR Score_PopUp

	LDA #SND_PLAYERKICK
	STA Sound_QPlayer

	JMP Object_PoofDie

Topmaniac_KickStopped:
	; If Topmaniac stops, revert state
	DEC <Objects_Var5,X	

	RTS

Topmaniac_MoveHitFloorCheck:
	JSR Object_Move

	LDA Objects_DetStat,X
	AND #$04
	BEQ Topmaniac_NotOnFloor

	JSR Object_HitGround ; Object hit ground, align

Topmaniac_NotOnFloor:
	RTS

Topmaniac_AnimCycle:
	LDA Objects_Frame,X
	ADD #1
	CMP #3
	BLT Topmaniac_NoFrameOvr
	
	LDA #0
	
Topmaniac_NoFrameOvr:
	STA Objects_Frame,X
	RTS

Topmaniac_FlashHit:
	JSR Topmaniac_MoveHitFloorCheck

	LDA Objects_DetStat,X
	AND #$04
	BEQ Topmaniac_FHNotOnFloor

	; On floor, stop moving
	LDA #0
	STA <Objects_XVel,X

	INC <Objects_Var5,X	

Topmaniac_FHNotOnFloor:
	RTS


Topmaniac_SpinUp:
	JSR Topmaniac_AnimCycle
	
	LDA Objects_ColorCycle,X
	BNE Topmaniac_StillFlashing

	INC Objects_Var3,X
	LDA Objects_Var3,X
	PHA
	
	ADD #8
	JSR Score_PopUp	
	
	LDA #SND_PLAYERKICK
	STA Sound_QPlayer
	
	PLA
	CMP #3
	BGE Topmanic_Die

	CMP #2
	BNE Topmaniac_NoSpit
	
	; Spit out topmans
	LDA #0
	STA <Temp_Var1
	JSR Topmaniac_SpitTopmans
	INC <Temp_Var1
	JSR Topmaniac_SpitTopmans

Topmaniac_NoSpit:
	LDA #0
	STA <Objects_Var5,X

Topmaniac_StillFlashing:
	RTS

Topmanic_Die:
	INC <Objects_Var5,X
	RTS

Topmaniac_Explode:
	LDA #1
	STA Level_TimerEn

	LDA <Counter_1
	AND #$07
	BNE Topmaniac_NoExplode

	INC Objects_Var6,X
	
	JSR Topmaniac_Poof

Topmaniac_NoExplode:

	LDA Objects_Var6,X
	CMP #10
	BLT Topmanic_ExplodeNotDone

	INC <Objects_Var5,X

	LDA #$40
	STA Objects_Timer,X
	
	LDA <Map_EnterViaID
	CMP #MAPOBJ_DAREDEVILCOMET
	BNE TopManiac_NotDDComet

	JMP_THUNKC 30, Level_EndComet

TopManiac_NotDDComet:
	LDA World_Num
	CMP #9
	BEQ Topmanic_NoFanfare	; No fanfare on World Zero
	
	; Victory fanfare
	LDA Sound_QMusic1
	ORA #MUS1_BOSSVICTORY
	STA Sound_QMusic1

Topmanic_NoFanfare:
	; Recycle Boom Boom's cool effect
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1
	JMP_THUNKA 3, Explode_Stars

Topmanic_ExplodeNotDone:
	RTS


Topmaniac_Poof:
	JSR SpecialObj_FindEmptyAbort

	LDA RandomN
	AND #$0F
	STA <Temp_Var1
	
	LDA RandomN+1
	AND #$07
	STA <Temp_Var2

	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y

	; Set the "poof" counter
	LDA #$1f
	STA SpecialObj_Data,Y
	
	; Set X/Y
	LDA <Objects_Y,X
	ADD <Temp_Var2
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	ADC #0
	STA SpecialObj_YHi,Y

	LDA <Objects_X,X
	ADD <Temp_Var1
	STA SpecialObj_XLo,Y

	; Ba-bam!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	RTS


Topmaniac_EndLevel:
	JSR DoTimeBonus	 ; Convert remaining time into score
	BNE Topmaniac_StillTimering	 ; If not done converting, jump to PRG003_A910 (RTS)

	; Set timer to $40
	LDA #$40
	STA Objects_Var1,X
	
	INC <Objects_Var5,X

Topmaniac_StillTimering:
	RTS


Topmaniac_DeadTimeout:
	DEC Objects_Var1,X
	BNE Topmaniac_StillTimering

	LDA World_Num
	CMP #9
	BNE Topmaniac_NoWZeroExit

	LDA #6
	STA <Temp_Var1
	JSR_THUNKA 41, ArenaCtl_ExitBoss
	JMP Object_Delete


Topmaniac_NoWZeroExit:
	; Exit to map!
	JSR_THUNKC 30, Object_InvalidateCP

	; Timer done, exit!
	LDA #0
	STA Map_ReturnStatus

	INC Level_ExitToMap
	RTS


ObjInit_Topman:
	LDA #$01
	STA Objects_HitCount,X

	LDA PatTable_BankSel+4
	CMP #76
	BEQ Topman_NoPatChg

	LDA #248
	STA PatTable_BankSel+4
	
Topman_NoPatChg:
	RTS

ObjNorm_Topman:
	LDA <Objects_Var5,X
	BEQ Topman_AnimNormal

	LDA #3
	BNE Topman_SetFlat

Topman_AnimNormal:
	LDA <Counter_1
	LSR A
	LSR A
	AND #1
	
Topman_SetFlat:
	STA Objects_Frame,X

	JSR Object_DeleteOffScreen

	JSR Object_ShakeAndDraw

	LDA <Objects_Var5,X
	JSR DynJump
	
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Topmaniac_Chase			; 0
	.word Topmaniac_KnockedOut		; 1
	.word Topmaniac_KnockedOutWait	; 2
	.word Topmaniac_Kicked			; 3

TopmanicSpit_XVel:	.byte -$10, $10

Topmaniac_SpitTopmans:
	JSR PrepareNewObjectOrAbort

	LDY <SlotIndexBackup

	; It's a Top man!!
	LDA #OBJ_TOPMAN
	STA Level_ObjectID,X

	LDA Objects_X,Y
	STA <Objects_X,X
	LDA Objects_XHi,Y
	STA <Objects_XHi,X

	LDA Objects_Y,Y
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	STA <Objects_YHi,X

	; Set Bob-omb's Y velocity
	LDA #-$30
	STA <Objects_YVel,X
		
	LDY <Temp_Var1
	LDA TopmanicSpit_XVel,Y
	STA <Objects_XVel,X
	
	LDX <SlotIndexBackup
	RTS
