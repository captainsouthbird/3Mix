; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg018.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------
Tile_Layout_TS6_TS8:
	; This defines the individual 8x8 blocks used to construct one of the tiles
	; Referenced by Address_Per_Tileset, addressed by Level_Tileset
	; Stored by upper left, then lower left, then upper right, then lower right

	; Remember that palette is determined by the upper 2 bits of a TILE (not the PATTERN)
	; I.e. tiles starting at index $00, $40, $80, $C0 are each on that respective palette

	; Upper left 8x8 pattern per tile
	.byte $FF, $DC, $FF, $05, $05, $E8, $FF, $99, $99, $FF, $62, $63, $7C, $7E, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $B8, $B8 ; Tiles $20 - $2F
	.byte $B8, $B8, $BC, $FF, $B0, $B1, $86, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DC, $05, $FC, $FC, $05, $05, $05, $05, $F4, $F4, $F4, $99, $1A, $4A, $4C, $FE ; Tiles $40 - $4F
	.byte $1E, $4A, $4C, $FE, $44, $46, $44, $79, $44, $21, $44, $5C, $31, $09, $4A, $D8 ; Tiles $50 - $5F
	.byte $98, $98, $98, $98, $98, $98, $92, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4 ; Tiles $60 - $6F
	.byte $B4, $B8, $98, $98, $98, $98, $A4, $EC, $E4, $C0, $D5, $B2, $4A, $4C, $FE, $FE ; Tiles $70 - $7F
	.byte $05, $40, $42, $48, $4A, $C4, $50, $52, $6C, $60, $FE, $84, $05, $F0, $F2, $80 ; Tiles $80 - $8F
	.byte $82, $8C, $8E, $4E, $04, $04, $48, $49, $49, $40, $50, $50, $50, $42, $52, $52 ; Tiles $90 - $9F
	.byte $52, $3C, $AE, $60, $AE, $68, $6A, $38, $62, $AE, $42, $42, $42, $8C, $8E, $8C ; Tiles $A0 - $AF
	.byte $8E, $8C, $8E, $8C, $8E, $52, $52, $50, $40, $42, $AC, $AE, $B8, $8C, $8E, $52 ; Tiles $B0 - $BF
	.byte $40, $05, $50, $42, $52, $8C, $8E, $AC, $AE, $4E, $04, $04, $48, $49, $49, $36 ; Tiles $C0 - $CF
	.byte $2A, $FF, $FF, $FF, $FF, $FF, $FF, $05, $B3, $CC, $FC, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $74, $0D, $0C, $FE, $68, $34, $35, $35, $5A, $36, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $02, $D7, $E0, $05, $94, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $F1, $F8, $FF ; Tiles $F0 - $FF

	; Lower left 8x8 pattern per tile
	.byte $FF, $DD, $FF, $06, $D6, $E9, $99, $99, $99, $FF, $FD, $FF, $7D, $7F, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $D7, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $B9, $B9 ; Tiles $20 - $2F
	.byte $B9, $B9, $BD, $FF, $B1, $B0, $86, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DD, $06, $FC, $FC, $06, $06, $06, $06, $F5, $F5, $F5, $99, $4C, $FE, $1B, $4B ; Tiles $40 - $4F
	.byte $4C, $FE, $1F, $4B, $54, $56, $54, $7B, $54, $23, $54, $5D, $33, $4C, $FE, $D9 ; Tiles $50 - $5F
	.byte $99, $99, $99, $99, $99, $99, $93, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5 ; Tiles $60 - $6F
	.byte $B5, $B9, $99, $99, $99, $99, $A5, $ED, $E4, $C1, $B2, $B2, $FE, $0B, $4B, $4B ; Tiles $70 - $7F
	.byte $06, $44, $46, $4C, $4E, $C4, $54, $56, $6D, $6D, $FE, $06, $06, $F2, $F2, $90 ; Tiles $80 - $8F
	.byte $90, $9C, $9E, $04, $04, $4E, $58, $59, $59, $41, $51, $51, $51, $43, $53, $53 ; Tiles $90 - $9F
	.byte $53, $3E, $AE, $61, $AE, $41, $41, $41, $63, $AE, $6C, $6E, $3A, $9C, $9E, $9C ; Tiles $A0 - $AF
	.byte $9E, $9C, $9E, $9C, $9E, $53, $53, $51, $41, $43, $AC, $AE, $B9, $9C, $9E, $53 ; Tiles $B0 - $BF
	.byte $41, $06, $51, $43, $53, $9C, $9E, $AC, $AE, $04, $04, $4E, $58, $59, $59, $36 ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $E6, $CD, $CD, $CD, $FE, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $75, $0A, $FE, $FE, $69, $5A, $36, $36, $5A, $36, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $12, $06, $E1, $06, $95, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $F0, $F9, $FF ; Tiles $F0 - $FF

	; Upper right 8x8 pattern per tile	
	.byte $FF, $DE, $FF, $07, $07, $EA, $99, $FF, $99, $FF, $62, $63, $7C, $7E, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $BA, $BA ; Tiles $20 - $2F
	.byte $BA, $BA, $BE, $FF, $B0, $B1, $FF, $86, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DE, $07, $FC, $FC, $07, $07, $07, $07, $F6, $F6, $F6, $FF, $4A, $1C, $FE, $4D ; Tiles $40 - $4F
	.byte $4A, $2E, $FE, $4D, $45, $47, $78, $47, $20, $47, $30, $5E, $47, $4A, $4A, $DA ; Tiles $50 - $5F
	.byte $9A, $9A, $9A, $9A, $9A, $9A, $CA, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6 ; Tiles $60 - $6F
	.byte $B6, $BA, $9A, $9A, $9A, $9A, $A6, $EE, $E5, $C2, $D5, $B2, $0A, $FE, $FE, $4D ; Tiles $70 - $7F
	.byte $07, $41, $43, $49, $4B, $C6, $51, $53, $6E, $61, $FE, $85, $07, $F1, $F3, $81 ; Tiles $80 - $8F
	.byte $83, $8D, $8F, $4F, $0D, $0D, $49, $49, $48, $40, $70, $70, $70, $42, $72, $72 ; Tiles $90 - $9F
	.byte $72, $AD, $3D, $AD, $64, $69, $69, $39, $AD, $66, $42, $42, $42, $8D, $8F, $8D ; Tiles $A0 - $AF
	.byte $8F, $8D, $8F, $8D, $8F, $72, $72, $70, $40, $42, $AD, $AF, $BA, $8D, $8F, $72 ; Tiles $B0 - $BF
	.byte $40, $07, $70, $42, $72, $8D, $8F, $AD, $AF, $4F, $0D, $0D, $49, $49, $48, $36 ; Tiles $C0 - $CF
	.byte $2B, $FF, $FF, $FF, $FF, $FF, $FF, $07, $B3, $CE, $FC, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $76, $09, $0C, $FE, $6A, $35, $35, $37, $36, $5B, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $03, $D7, $E2, $07, $96, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $F3, $FA, $FF ; Tiles $F0 - $FF

	; Lower right 8x8 pattern per tile
	.byte $FF, $DF, $FF, $08, $D6, $EB, $99, $99, $FF, $FF, $FD, $FF, $7D, $7F, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $D7, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $BB, $BB ; Tiles $20 - $2F
	.byte $BB, $BB, $BF, $FF, $B1, $B0, $FF, $86, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DF, $08, $FC, $FC, $08, $08, $08, $08, $F7, $F7, $F7, $FF, $FE, $4D, $4B, $1D ; Tiles $40 - $4F
	.byte $FE, $4D, $4B, $2F, $55, $57, $7A, $57, $22, $57, $32, $5F, $57, $FE, $FE, $DB ; Tiles $50 - $5F
	.byte $9B, $9B, $9B, $9B, $9B, $9B, $CB, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7 ; Tiles $60 - $6F
	.byte $B7, $BB, $9B, $9B, $9B, $9B, $A7, $EF, $E5, $C3, $B2, $B2, $4D, $4B, $4B, $0C ; Tiles $70 - $7F
	.byte $08, $45, $47, $4D, $4F, $C6, $55, $57, $6F, $6F, $FE, $08, $08, $F3, $F3, $91 ; Tiles $80 - $8F
	.byte $91, $9D, $9F, $0D, $0D, $4F, $59, $59, $58, $41, $71, $71, $71, $43, $73, $73 ; Tiles $90 - $9F
	.byte $73, $AD, $3F, $AD, $65, $41, $41, $41, $AD, $67, $6D, $6F, $3B, $9D, $9F, $9D ; Tiles $A0 - $AF
	.byte $9F, $9D, $9F, $9D, $9F, $73, $73, $71, $41, $43, $AD, $AF, $BB, $9D, $9F, $73 ; Tiles $B0 - $BF
	.byte $41, $08, $71, $43, $73, $9D, $9F, $AD, $AF, $0D, $0D, $4F, $59, $59, $58, $36 ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $E7, $CF, $CF, $CF, $FE, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $77, $0B, $FE, $FE, $6B, $36, $36, $5B, $36, $5B, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $13, $08, $E3, $08, $97, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $F2, $FB, $FF ; Tiles $F0 - $FF

Tile_Attributes_TS6_TS8:
	.byte $13, $4C, $91, $E2, $13, $4C, $91, $E2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS6
;
; Entry point for loading level layout data for Level_Tileset = 6
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS6:
	; Clear Tile memory
	LDY #$00	 
PRG018_A40A:
	LDA #TILE6_SKY
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$f0
	BNE PRG018_A40A

	JMP LevelLoad	; Begin actual level loading!



	; Vertical level's unique clear routine
	; (where 'Y' CAN cover the entire screen space!)
	; So, same deal: Affects all screens at once...
Tile_Mem_ClearV:
	STA Tile_Mem+$000,Y
	STA Tile_Mem+$0F0,Y
	STA Tile_Mem+$1E0,Y
	STA Tile_Mem+$2D0,Y
	STA Tile_Mem+$3C0,Y
	STA Tile_Mem+$4B0,Y
	STA Tile_Mem+$5A0,Y
	STA Tile_Mem+$690,Y
	STA Tile_Mem+$780,Y
	STA Tile_Mem+$870,Y
	STA Tile_Mem+$960,Y
	STA Tile_Mem+$A50,Y
	STA Tile_Mem+$B40,Y
	STA Tile_Mem+$C30,Y
	STA Tile_Mem+$D20,Y
	STA Tile_Mem+$E10,Y
	INY		 ; Y++
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS8
;
; Entry point for loading level layout data for Level_Tileset = 8
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS8:
	LDY #$00	 
PRG018_A477:
	LDA #TILE8_BLACK
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$f0
	BNE PRG018_A477
	
	JMP LevelLoad	; Begin actual level loading!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Generator_TS68
;
; Based on the values in Temp_Var15 and LL_ShapeDef, chooses an
; appropriate generator function to builds this piece of the
; level.  Tedious, but saves space and is paper-design friendly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG018_A483:
	.byte 0, 15, 30, 45, 60, 75, 90, 105

LoadLevel_Generator_TS68:
	; From level loader function:
	; * Temp_Var15, Temp_Var16, and LL_ShapeDef are three bytes read from the data


	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = upper 3 bits of Temp_Var15 (0-7) (selects a multiple of 15 as the base)

	LDA LL_ShapeDef
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = upper 4 bits of LL_ShapeDef shifted down
	ADD PRG018_A483,X	; Add multiple of 15
	TAX
	DEX
	TXA		 ; A = ((LL_ShapeDef >> 4) + PRG015_A483[X]) - 1


	; PRG018_A483 provides values well in excess of 57, but only 57
	; addresses are defined here; reserved for expansion...

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_SceneryVPipe		;  0 - Vertical scenery pipe (with pipe-cross detection)
	.word LoadLevel_ScenHPipe_RightWall	;  1 - "Right wall" Horizontal scenery pipe (with pipe-cross detection)
	.word LoadLevel_ScenHPipe_LeftWall	;  2 - "Left wall" Horizontal scenery pipe (with pipe-cross detection)
	.word LoadLevel_BGVPipe			;  3 - Vertical BG pipe
	.word LoadLevel_BGVMinipipe		;  4 - Vertical BG minipipe
	.word LoadLevel_BGHPipeLeft		;  5 - Horizontal left-ended BG pipe
	.word LoadLevel_BGHPipeRight		;  6 - Horizontal right-ended BG pipe
	.word LoadLevel_BGHMinipipe		;  7 - Horizontal BG minipipe
	.word LoadLevel_VMinipipe		;  8 - Vertical minipipe
	.word $0000		;  9 - Vertical run of Toad House blocks
	.word $0000	; 10 - Horizontal run of Toad House blocks with shadows underneath
	.word $0000		; 11 - Vertical run of Toad House shadow
	.word LoadLevel_UnderwaterScenery	; 12 - Vertical run of underwater plant things
	.word LoadLevel_UnderwaterScenery	; 13 - Vertical run of underwater circle things
	.word LoadLevel_DownwardSpikes		; 14 - Run of downward pointing spikes
	.word LoadLevel_BlockRun		; 15 - Run of bricks
	.word LoadLevel_BlockRun		; 16 - Run of '?' blocks with a coin
	.word LoadLevel_BlockRun		; 17 - Run of bricks with a coin
	.word LoadLevel_BlockRun		; 18 - Run of wood blocks
	.word LoadLevel_BlockRun		; 19 - Run of green note blocks (?)
	.word LoadLevel_BlockRun		; 20 - Run of note blocks
	.word LoadLevel_BlockRun		; 21 - Run of bouncing wood blocks
	.word LoadLevel_BlockRun		; 22 - Run of coins
	.word LoadLevel_VGroundPipeRun		; 23 - Vertical ground pipe 1 (alt level)
	.word LoadLevel_VGroundPipeRun		; 24 - Vertical ground pipe 2 (Big [?] area)
	.word LoadLevel_VGroundPipeRun		; 25 - Vertical ground pipe 3 (no entrance)
	.word LoadLevel_VCeilingPipeRun		; 26 - Vertical ceiling pipe 1 (alt level)
	.word LoadLevel_VCeilingPipeRun		; 27 - Vertical ceiling pipe 2 (no entrance)
	.word LoadLevel_HRightWallPipeRun	; 28 - Horizontal right-hand wall pipe (alt level)
	.word LoadLevel_HRightWallPipeRun	; 29 - Horizontal right-hand wall pipe (no entrance)
	.word LoadLevel_HLeftWallPipeRun	; 30 - Horizontal left-hand wall pipe (alt level)
	.word LoadLevel_HLeftWallPipeRun	; 31 - Horizontal left-hand wall pipe (no entrance)
	.word LoadLevel_Cannon			; 32 - Bullet bill cannon
	.word LoadLevel_CCBridge		; 33 - Cheep-Cheep style 'oo' bridge
	.word LoadLevel_CCBridge		; 34 - Would result in empty tiles?  (form of 33)
	.word LoadLevel_TopDecoBlocks		; 35 - Top-Deco Rectangle Waterfall
	.word LoadLevel_TopDecoBlocks		; 36 - Top-Deco Rectangle Left waving water pool
	.word LoadLevel_TopDecoBlocks		; 37 - Top-Deco Rectangle No current waving water pool
	.word LoadLevel_TopDecoBlocks		; 38 - Top-Deco Rectangle Right waving water pool
	.word LoadLevel_TopDecoBlocks		; 39 - Top-Deco Rectangle Water wrong-way BG
	.word LoadLevel_TopDecoBlocks		; 40 - Top-Deco Rectangle Diamond blocks (not really any deco on top)
	.word LoadLevel_TopDecoBlocks		; 41 - Top-Deco Rectangle Sand ground 
	.word LoadLevel_TopDecoBlocks		; 42 - Top-Deco Rectangle orange block??
	.word $0000		; 43 - UNUSED
	.word LoadLevel_VTransitPipeRun		; 44 - Vertical in-level transit pipe
	.word LoadLevel_VGroundPipe5Run		; 45 - Vertical ground pipe 5 (exits to common end area)
	.word LoadLevel_HRightWallPipeRun3	; 46 - Horizontal right-hand wall pipe 3 (no entrance)
	.word LoadLevel_TwoRowsWater		; 47 - Run of two rows of water (seems rather specific for water?)
	.word LoadLevel_GrayBlock		; 48 - Gray block which runs down to the orange block
	.word LoadLevel_OrangeBlock		; 49 - Rectangle of orange block terrain as used by water level
	.word $0000		; 50 - Horizontal run of black background tiles in a Toad House
	.word $0000		; 51 - Vertical run of black background tiles in a Toad House
	.word LoadLevel_Jelectro		; 52 - Jelectros!
	.word LoadLevel_HMinipipe		; 53 - Horizontal minipipe
	.word LoadLevel_UnderwaterCirclesH	; 54 - Horizontal run of the little circles
	.word LoadLevel_DonutLifts		; 55 - Run of donut lifts
	.word LoadLevel_UpwardSpikes		; 56 - Run of upward pointing spikes
	.word LoadLevel_WaterFill		; 57 - Rectangle of water tiles 
	.word LoadLevel_TopManiacZapper18	; 58 - Topmaniac Zapper
	.word LoadLevel_TopManiacZapper18	; 59 - Topmaniac Zapper
	.word LoadLevel_PurpleCoins		; 60 - Run of Purple coins
	.word LoadLevel_PurpleCoinR		; 61 - Rectangle of Purple Coins

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LeveLoad_FixedSizeGen_TS68
;
; Much simpler generators that are fixed-size, commonly used for 
; just single tile placement styles (although a couple relatively 
; complex ones exist in here as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LeveLoad_FixedSizeGen_TS68:
	; It is verified before calling this function that all of
	; the upper 4 bits of LL_ShapeDef are ZERO

	; So the upper 3 bits of Temp_Var15 serve as the most significant bits
	; to a value where LL_ShapeDef provide the 4 least significant bits

	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	ADD LL_ShapeDef	
	TAX		 	; Resultant index is put into 'X'
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_PipeElbows		;  0 - Upper left pipe elbow
	.word LoadLevel_PipeElbows		;  1 - Upper right pipe elbow
	.word LoadLevel_PipeElbows		;  2 - Lower left pipe elbow
	.word LoadLevel_PipeElbows		;  3 - Lower right pipe elbow
	.word LoadLevel_ArrowLifts		;  4 - Arrow lift UP
	.word LoadLevel_ArrowLifts		;  5 - Arrow lift RIGHT
	.word LoadLevel_ArrowLifts		;  6 - Arrow lift LEFT
	.word LoadLevel_ArrowLifts		;  7 - Arrow lift RANDOM
	.word LoadLevel_ActionSwitchR	;  8 - Toad House chest
	.word $0000		;  9 - REMOVED
	.word LoadLevel_Door2			; 10 - Door style 2
	.word LoadLevel_StarCoin1		; 11 - Star Coin 1
	.word LoadLevel_VerticalAltClear	; 12 - Commonly used to change the vertical level to the common black background!
	.word LoadLevel_LargeWater		; 13 - Large rectangle of water; fills to bottom of screen
	.word LoadLevel_StarCoin2		; 14 - Star Coin 2
	.word LoadLevel_StarCoin3		; 15 - Star Coin 3
	.word LoadLevel_PowerBlock		; 16 - ? block with flower
	.word LoadLevel_PowerBlock		; 17 - ? block with leaf 
	.word LoadLevel_PowerBlock		; 18 - ? block with star
	.word LoadLevel_PowerBlock		; 19 - ? block with coin OR star
	.word LoadLevel_PowerBlock		; 20 - ? block with coin (??)
	.word LoadLevel_PowerBlock		; 21 - Muncher Plant!
	.word LoadLevel_PowerBlock		; 22 - Brick with flower
	.word LoadLevel_PowerBlock		; 23 - Brick with leaf
	.word LoadLevel_PowerBlock		; 24 - Brick with star
	.word LoadLevel_PowerBlock		; 25 - Brick with coin OR star
	.word LoadLevel_PowerBlock		; 26 - Brick with 10-coin
	.word LoadLevel_PowerBlock		; 27 - Brick with 1-up
	.word LoadLevel_PowerBlock		; 28 - Brick with vine
	.word LoadLevel_PowerBlock		; 29 - Brick with P-Switch
	.word LoadLevel_PowerBlock		; 30 - Invisible coin
	.word LoadLevel_PowerBlock		; 31 - Invisible 1-up
	.word LoadLevel_PowerBlock		; 32 - Invisible note
	.word LoadLevel_PowerBlock		; 33 - Note block with flower
	.word LoadLevel_PowerBlock		; 34 - Note block with leaf
	.word LoadLevel_PowerBlock		; 35 - Note block with star
	.word LoadLevel_PowerBlock		; 36 - Wood block with flower
	.word LoadLevel_PowerBlock		; 37 - Wood block with leaf
	.word LoadLevel_PowerBlock		; 38 - Wood block with star
	.word LoadLevel_PowerBlock		; 39 - Invisible note to coin heaven
	.word LoadLevel_PowerBlock		; 40 - P-Switch
	.word LoadLevel_EndGoal			; 41 - The end goal
	.word LoadLevel_VineToGround	; 42 - Vine to ground
	.word LoadLevel_ActionSwitch	; 43 - Action Switch
	.word LoadLevel_PipeRaiseHelper1	; 44 - Pipe Raise Helper 1
	.word LoadLevel_PipeRaiseHelper2	; 45 - Pipe Raise Helper 2
	.word LoadLevel_PipeRaiseHelper3	; 46 - Pipe Raise Helper 3
	.word LoadLevel_PipeRaiseHelper4	; 47 - Pipe Raise Helper 4


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_SceneryVPipe
;
; Inserts a 1-16 height vertical scenery pipe which checks for
; crossing other pipes and uses appropriate crossing tiles.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; If the pipe being constructed crosses one of these...
LL_SceneryVPipe_CrossChk:	.byte TILE8_SCENPIPE_HT,     TILE8_SCENPIPE_HB,     TILE8_MINIPIPE_HM,     TILE1_PIPEHT,          TILE1_PIPEHB
LL_SceneryVPipe_CrossChk_End

	; Replace it with corresponding cross tile! 
LL_SceneryVPipe_CrossL:	.byte TILE8_SCENPIPE_VL_HTC, TILE8_SCENPIPE_VL_HBC, TILE8_SCENPIPE_VL_HMC, TILE8_SCENPIPE_VL_HTC, TILE8_SCENPIPE_VL_HBC
LL_SceneryVPipe_CrossR:	.byte TILE8_SCENPIPE_VR_HTC, TILE8_SCENPIPE_VR_HBC, TILE8_SCENPIPE_VR_HMC, TILE8_SCENPIPE_VR_HTC, TILE8_SCENPIPE_VR_HBC

LoadLevel_SceneryVPipe:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of pipe)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE8_SCENPIPE_ENDVL
	BNE PRG018_A59F	 	; If tile is not the end of a scenery pipe vertical left, jump to PRG018_A59F

	LDA #TILE1_PIPEVL	; Otherwise, use tile for standard vertical pipe
	JMP PRG018_A5A1	 	; Jump to PRG018_A5A1

PRG018_A59F:
	LDA #TILE8_SCENPIPE_ENDVL	; Keep it the same

PRG018_A5A1:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY			 ; Y++
	LDA [Map_Tile_AddrL],Y	 ; Get tile here

	CMP #TILE8_SCENPIPE_ENDVR
	BNE PRG018_A5AF	 	; If tile is not the end of a scenery pipe vertical right, jump to PRG018_A5AF

	LDA #TILE1_PIPEVR	; Otherwise, use tile for standard vertical pipe
	JMP PRG018_A5B1	 	; Jump to PRG018_A5B1

PRG018_A5AF:
	LDA #TILE8_SCENPIPE_ENDVR	; Keep it the same

PRG018_A5B1:
	STA [Map_Tile_AddrL],Y	; Store into tile mem
	JMP PRG018_A5C1	 	; Jump to PRG018_A5C1

PRG018_A5B6:
	JSR LL_SceneryVPipe_CheckCrossL	 ; Check for pipe crossing (left)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Y++

	JSR LL_SceneryVPipe_CheckCrossR	 ; Check for pipe crossing (i)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A5C1:

	; Go to next row by adding 16 to offset
	JSR LL18_NextRow

	DEC <Temp_Var3		; Temp_Var3-- (height decrement)
	BNE PRG018_A5B6	 	; While Temp_Var3 > 0, loop

	LDA #TILE8_SCENPIPE_ENDVL
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Y++

	LDA #TILE8_SCENPIPE_ENDVR
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


	; If pipe left side crosses another pipe, use the crossing tile!
LL_SceneryVPipe_CheckCrossL:
	LDX #(LL_SceneryVPipe_CrossChk_End - LL_SceneryVPipe_CrossChk - 1)
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
PRG018_A5E3:
	CMP LL_SceneryVPipe_CrossChk,X	 
	BEQ PRG018_A5F0	 	; If this tile is one of the ones in the list, jump to PRG018_A5F0
	DEX		 ; X--
	BPL PRG018_A5E3	 ; While X >= 0, loop!

	LDA #TILE1_PIPEVL	; Use standard vertical pipe tile
	JMP PRG018_A5F3	 	; Jump to PRG018_A5F3

PRG018_A5F0:
	LDA LL_SceneryVPipe_CrossL,X	 ; $A5F0 

PRG018_A5F3:
	RTS		 ; Return


	; If pipe right side crosses another pipe, use the crossing tile!
LL_SceneryVPipe_CheckCrossR:
	LDX #(LL_SceneryVPipe_CrossChk_End - LL_SceneryVPipe_CrossChk - 1)
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
PRG018_A5F8:
	CMP LL_SceneryVPipe_CrossChk,X	 
	BEQ PRG018_A605	 	; If this tile is one of the ones in the list, jump to PRG018_A5F0
	DEX		 ; X--
	BPL PRG018_A5F8	 ; While X >= 0, loop!

	LDA #TILE1_PIPEVR	; Use standard vertical pipe tile
	JMP PRG018_A608  	; Jump to PRG018_A5F3

PRG018_A605:
	LDA LL_SceneryVPipe_CrossR,X	 ; $A5F0 
PRG018_A608:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ScenHPipe_RightWall
;
; Inserts a 1-16 width horizontal scenery pipe which checks for
; crossing other pipes and uses appropriate crossing tiles.
; "Right wall" meaning the end is on the left with a middle segment.
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_SceneryHPipe_Mid:	.byte TILE8_SCENPIPE_HT, TILE8_SCENPIPE_HB
LL_SceneryHPipe_End:	.byte TILE8_SCENPIPE_ENDH1T, TILE8_SCENPIPE_ENDH1B

LoadLevel_ScenHPipe_RightWall:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of pipe)

	LDX #$00	 	; X = 0
	STX <Temp_Var5		 ; Temp_Var5 = 0

PRG018_A618:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

	LDA LL_SceneryHPipe_End,X	 ; Store pipe end
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG018_A62C	 	; Jump to PRG018_A62C

PRG018_A627:
	JSR LL_SceneryHPipe_CheckCross	; Check for crossing tiles while building pipe
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A62C:
	INY		 ; Next column; this is OK for vertical levels, nowhere to the right
	DEC <Temp_Var4	 ; Temp_Var4-- (width decrement)
	BPL PRG018_A627	 ; While Temp_Var4 >= 0, loop!

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	INX		 ; X++
	STX <Temp_Var5	 ; Temp_Var5 = X (backup update)
	CPX #$02	 
	BNE PRG018_A618	 ; If X <> 2, loop!

	RTS		 ; Return
	
	; If the pipe being constructed crosses one of these...
LL_SceneryHPipe_CrossChk:	.byte TILE1_PIPEVL, TILE1_PIPEVR, TILE8_MINIPIPE_VM
LL_SceneryHPipe_CrossChk_End

	; Replace it with corresponding cross tile! 
LL_SceneryHPipe_CrossT:	.byte TILE8_SCENPIPE_HT_VLC, TILE8_SCENPIPE_HT_VRC, TILE8_SCENPIPE_HT_VMC
LL_SceneryHPipe_CrossB:	.byte TILE8_SCENPIPE_HB_VLC, TILE8_SCENPIPE_HB_VRC, TILE8_SCENPIPE_HB_VMC

LL_SceneryHPipe_CheckCross:
	LDX #(LL_SceneryHPipe_CrossChk_End - LL_SceneryHPipe_CrossChk - 1)
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
PRG018_A655:
	CMP LL_SceneryHPipe_CrossChk,X	; Is thie tile one of the standard vertical pipe tiles?
	BEQ PRG018_A665	 	; If so, jump to PRG018_A665
	DEX		 	; X--
	BPL PRG018_A655	 	; While X >= 0, loop!

	LDX <Temp_Var5		 	; X = Temp_Var5
	LDA LL_SceneryHPipe_Mid,X	; Get appropriate horizontal pipe tile
	JMP PRG018_A672	 		; Jump to PRG018_A672

PRG018_A665:
	LDA <Temp_Var5
	BNE PRG018_A66F	 	; If Temp_Var5 <> 0, jump to PRG018_A66F

	LDA LL_SceneryHPipe_CrossT,X	 ; Get appropriate crossing tile (top)
	JMP PRG018_A672	 		; Jump to PRG018_A672

PRG018_A66F:
	LDA LL_SceneryHPipe_CrossB,X	 ; Get appropriate crossing tile (bottom)

PRG018_A672:
	LDX <Temp_Var5		 ; X = Temp_Var5
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ScenHPipe_LeftWall
;
; Inserts a 1-16 width horizontal scenery pipe which checks for
; crossing other pipes and uses appropriate crossing tiles.
; "Left wall" meaning the end is on the right with a middle segment.
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ScenHPipe_LeftWall:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDX #$00	 	; X = 0
	STX <Temp_Var5		 ; Temp_Var5 = 0

PRG018_A680:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

PRG018_A687:
	JSR LL_SceneryHPipe_CheckCross
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	INY		 	; Next column; this is OK for vertical levels, nowhere to the right
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BNE PRG018_A687	 	; While Temp_Var4 > 0, loop!

	LDA LL_SceneryHPipe_End,X	 ; Get pipe end
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH

	INX		 ; X++
	STX <Temp_Var5	 ; Temp_Var5 = X
	CPX #$02
	BNE PRG018_A680	 ; If X <> 2, jump to 018_A680

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGVPipe
;
; Inserts a 1-16 width double-ended vertical background pipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BGVPipe:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (width of pipe)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE8_BGPIPE_ENDVL	 ; BG pipe end vertical left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	LDA #TILE8_BGPIPE_ENDVR	 ; BG pipe end vertical right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG018_A6CB	 	; Jump to PRG018_A6CB

PRG018_A6C2:
	LDA #TILE8_BGPIPE_VL	; BG pipe middle vertical left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	LDA #TILE8_BGPIPE_VR	; BG pipe middle vertical right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A6CB:

	; Go to next row by adding 16
	JSR LL18_NextRow

	DEX		 ; X-- (height decrement)
	BNE PRG018_A6C2	 ; While X > 0, loop!

	LDA #TILE8_BGPIPE_ENDVL	 ; BG pipe end vertical left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	LDA #TILE8_BGPIPE_ENDVR	 ; BG pipe end vertical right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGVMinipipe
;
; Inserts a 1-16 height double-ended vertical background minipipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BGVMinipipe:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE8_BGPIPE_MVT	; BG minipipe vertical top
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG018_A6FC	 ; $A6F5 

PRG018_A6F8:
	LDA #TILE8_BGPIPE_MVM	; BG minipipe vertical middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A6FC:

	; Go to next line by adding 16
	TYA	
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BNE PRG018_A6F8	 ; While X > 0, loop!

	LDA #TILE8_BGPIPE_MVB	; BG minipipe vertical bottom
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGHPipeLeft
;
; Inserts a 1-16 width left-ended horizontal background pipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_BGPipeHMid:	.byte TILE8_BGPIPE_HT, TILE8_BGPIPE_HB
LL_BGPipeHEnd:	.byte TILE8_BGPIPE_ENDHT, TILE8_BGPIPE_ENDHB

LoadLevel_BGHPipeLeft:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of pipe)

	LDX #$00	 	; X = 0

PRG018_A71C:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3	
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

	LDA LL_BGPipeHEnd,X	 ; BG pipe vertical end
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG018_A730	 ; $A728 

PRG018_A72B:
	LDA LL_BGPipeHMid,X	 ; BG pipe vertical middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A730:
	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	DEC <Temp_Var4		 ; Temp_Var4--
	BPL PRG018_A72B	 	; While Temp_Var4 >= 0, loop!

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	INX		 ; X++
	CPX #$02
	BNE PRG018_A71C	 ; If X <> 2, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGHPipeRight
;
; Inserts a 1-16 width right-ended horizontal background pipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BGHPipeRight;
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of pipe)

	LDX #$00	 	; X = 0

PRG018_A753:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3	
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

PRG018_A75A:
	LDA LL_BGPipeHMid,X	 ; BG pipe vertical middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	DEC <Temp_Var4		 ; Temp_Var4--
	BNE PRG018_A75A	 	; While Temp_Var4 > 0, loop!

	LDA LL_BGPipeHEnd,X	 ; BG pipe vertical end
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	INX		 ; X++
	CPX #$02
	BNE PRG018_A753	 ; If X <> 2, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGHMinipipe
;
; Inserts a 1-16 width double-ended horizontal background minipipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BGHMinipipe:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (width of pipe)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE8_BGPIPE_MHL	 ; BG Minipipe horizontal left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG018_A792	 	; Jump to PRG018_A792

PRG018_A78E:
	LDA #TILE8_BGPIPE_MHM	 ; BG Minipipe horizontal middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A792:
	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	DEX		 ; X-- (width decrement)
	BNE PRG018_A78E	 ; While X > 0, loop

	LDA #TILE8_BGPIPE_MHR	 ; BG Minipipe horizontal right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_HMinipipe
;
; Inserts a 1-16 width double-ended horizontal minipipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_HMinipipe:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE8_MINIPIPE_HL	; Minipipe horizontal left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG018_A7AF	 	; Jump to PRG018_A7AF

PRG018_A7AB:
	LDA #TILE8_MINIPIPE_HM	; Minipipe horizontal middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A7AF:
	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	DEX		 ; X-- (width decrement)
	BNE PRG018_A7AB	 ; While X > 0, loop

	LDA #TILE8_MINIPIPE_HR	; Minipipe horizontal right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VMinipipe (SB)
;
; Inserts a 1-16 height double-ended vertical minipipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VMinipipe:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE8_MINIPIPE_VT	; Minipipe top
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP LLVMP_RowEnd	 	; Jump to PRG018_A7AF

LLVMP_MidSection:
	LDA #TILE8_MINIPIPE_VM	; Minipipe vertical middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

LLVMP_RowEnd:
	JSR LL18_NextRow	; Next row
	
	DEX		 ; X-- (width decrement)
	BNE LLVMP_MidSection	 ; While X > 0, loop

	LDA #TILE8_MINIPIPE_VB	; Minipipe vertical bottom
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_UnderwaterScenery
;
; Generates a variable 1-16 height version of the underwater plant 
; things or the water circle things (what ARE those anyway?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_UnderwaterScenery:
	.byte TILE6_UNDERWATERPLANT_T, TILE6_UNDERWATERCIRCLE
	.byte TILE6_UNDERWATERPLANT_M, TILE6_UNDERWATERCIRCLE

LoadLevel_UnderwaterScenery:
	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	SUB #$d0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	PLA		 ; Restore LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_UnderwaterScenery,X 	; Get top tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	JMP PRG018_A7DE	 		; Jump to PRG018_A7DE

PRG018_A7D9:
	LDA LL_UnderwaterScenery+2,X	; Get mid tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

PRG018_A7DE:

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEC <Temp_Var3	 ; Temp_Var3-- (height decrement)
	BPL PRG018_A7D9	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PipeElbows
;
; One of those things linking a pipe at a 90 degree junction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Each column is one elbow, all four rows belong to a single elbow in one column
LL_PipeElbows:
	.byte TILE8_PIPEELBOW_CUL, TILE8_PIPEELBOW_UL, TILE8_PIPEELBOW_UL, TILE8_PIPEELBOW_UL
	.byte TILE8_PIPEELBOW_UR, TILE8_PIPEELBOW_CUR, TILE8_PIPEELBOW_UR, TILE8_PIPEELBOW_UR
	.byte TILE8_PIPEELBOW_LL, TILE8_PIPEELBOW_LL, TILE8_PIPEELBOW_CLL, TILE8_PIPEELBOW_LL
	.byte TILE8_PIPEELBOW_LR, TILE8_PIPEELBOW_LR, TILE8_PIPEELBOW_LR, TILE8_PIPEELBOW_CLR

LoadLevel_PipeElbows:
	LDX LL_ShapeDef	 	; X = LL_ShapeDef
	LDY TileAddr_Off	; Y = TileAddr_Off

	LDA LL_PipeElbows,X	 ; Get upper left tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	LDA LL_PipeElbows+4,X	 ; Get upper right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	JSR LL18_NextRow

	LDA LL_PipeElbows+8,X	 ; Get lower left tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	LDA LL_PipeElbows+12,X	 ; Get lower right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_UpwardSpikes
;
; Inserts a 1-16 width run of upward pointing spikes
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_UpwardSpikes:
	LDX #$01	; X = 1 (Upward spikes)
	BNE PRG018_A833	; Jump (technically always) to PRG018_A833

LL_Spikes:	.byte TILE8_SPIKE_DOWN, TILE8_SPIKE_UP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DownwardSpikes
;
; Inserts a 1-16 width run of downward pointing spikes
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_DownwardSpikes:
	LDX #$00	; X = 0 (Downward spikes)

PRG018_A833:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of spike run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG018_A83D:
	LDA LL_Spikes,X	 	; Get spike tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3	 ; Temp_Var3-- (width decrement)
	BPL PRG018_A83D	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VerticalAltClear
;
; Alternate clear to all black tiles for vertical level
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VerticalAltClear:
	LDY #$00	
PRG018_A84A:
	LDA #TILE8_BLACK
	JSR Tile_Mem_ClearV
	CPY #$f0
	BNE PRG018_A84A

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_TwoRowsWater
;
; Inserts a 1-16 width run of two rows of water
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_TwoRowsWater:
	; Backup Map_Tile_AddrL/H to Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDX #$01	 	; X = 1

PRG018_A868:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

PRG018_A86C:
	LDA #TILE6_WATER	; Water
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BPL PRG018_A86C	 	; While Temp_Var4 >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY	

	DEX		 ; X-- (row decrement)
	BPL PRG018_A868	 ; While X >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GrayBlock
;
; Inserts a 1-16 width gray block that runs until it hits an 
; orange block tile (the main terrain of underwater levels)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_GrayLeft:	.byte TILE6_GRAYPLATFORM_UL, TILE6_GRAYPLATFORM_ML
LL_GrayMiddle:	.byte TILE6_GRAYPLATFORM_UM, TILE6_GRAYPLATFORM_MM
LL_GrayRight:	.byte TILE6_GRAYPLATFORM_UR, TILE6_GRAYPLATFORM_MR

LoadLevel_GrayBlock:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDX #$00	 ; X = 0

PRG018_A8A4:
	LDA <Temp_Var3
	STA <Temp_Var4	; Temp_Var4 = Temp_Var3

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE6_ORANGEBLK_UL
	BLT PRG018_A8B5	 	; If tile is less than the orange block's tiles, jump to PRG018_A8B5

	CMP #TILE6_ORANGEBLK_UR	 
	BLT PRG018_A8EA	 	; If in range of the orange block tiles, jump to PRG018_A8EA (RTS)

PRG018_A8B5:
	LDA LL_GrayLeft,X	; Left gray block
	JMP PRG018_A8BE	 	; Jump to PRG018_A8BE

PRG018_A8BB:
	LDA LL_GrayMiddle,X	 ; Middle gray block

PRG018_A8BE:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BNE PRG018_A8BB	 	; While Temp_Var4 >= 0, loop

	LDA LL_GrayRight,X	 ; Right gray block

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$01	 	; X = 1 (use mid blocks for rest of run)
	JMP PRG018_A8A4	 	; Jump to PRG018_A8A4

PRG018_A8EA:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_OrangeBlock
;
; Rectangle of 1-256 x 1-16 of orange block terrain as common to
; the water levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_OrangeLeft:	.byte TILE6_ORANGEBLK_UL, TILE6_ORANGEBLK_LL
LL_OrangeMiddle:.byte TILE6_ORANGEBLK_UM, TILE6_ORANGEBLK_LM
LL_OrangeRight:	.byte TILE6_ORANGEBLK_UR, TILE6_ORANGEBLK_LR

LoadLevel_OrangeBlock:
	; Get byte from layout data
	LDY #$00	 
	LDA [Level_LayPtr_AddrL],Y
	STA <Temp_Var4

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of block)

	LDX #$00	 	; X = 0

PRG018_A915:
	LDA <Temp_Var4
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var4 (width copy)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_OrangeLeft,X	; Get left tile
	JMP PRG018_A925	 	; Jump to PRG018_A925

PRG018_A922:
	LDA LL_OrangeMiddle,X	 ; Get middle tile

PRG018_A925:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BNE PRG018_A922	 	; While Temp_Var5 >= 0, loop

	LDA LL_OrangeRight,X	 ; Get right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$01	 ; X = 1 (repeat bottom tiles)
	DEC <Temp_Var3	 ; Temp_Var3-- (height decrement)
	BPL PRG018_A915	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_UnderwaterCirclesH
;
; Run of 1-16 of those underwater circle things
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_UnderwaterCirclesH:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG018_A98C:
	LDA #TILE6_UNDERWATERCIRCLE
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X-- (width of run)
	BPL PRG018_A98C	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WaterFill
;
; 1-256 x 1-32 rectangle of water 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_WaterFill:
	LDY #$00
	LDA [Level_LayPtr_AddrL],Y	; Get another byte from layout data
	STA <Temp_Var3		 	; Store into Temp_Var3

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$1f
	STA <Temp_Var4		 ; Temp_Var4 = lower 5 bits of Temp_Var4

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDX <Temp_Var3		 ; X = Temp_Var3 (width)
 
PRG018_A9BE:
	LDA #TILE6_WATERTOP	; Top of water tile 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X-- 
	CPX #$ff	  
	BNE PRG018_A9BE	 ; While X >= 0, loop!
 
	JMP PRG018_A9DB	 ; Jump to PRG018_A9DB 

PRG018_A9CD:
	LDX <Temp_Var3		 ; X = Temp_Var3 
PRG018_A9CF:
	LDA #TILE6_WATER	; Water tile 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X-- 
	CPX #$ff 
	BNE PRG018_A9CF	 ; While X >= 0, loop!

PRG018_A9DB: 
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1 
	STA <Map_Tile_AddrL 
	LDA <Temp_Var2 
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 
	JSR LL18_NextRow
	STA <Temp_Var2 
	DEC <Temp_Var4		 ; Temp_Var4-- (height decrement)
	BPL PRG018_A9CD	 	; While Temp_Var4 >= 0, loop! 
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ArrowLifts
;
; Insert one of the four arrow lifts
; Vertical pipe maze type level only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_ArrowLifts:
	.byte TILE8_ARROWLIFT_UPL, TILE8_ARROWLIFT_RIGHTL, TILE8_ARROWLIFT_LEFTL, TILE8_ARROWLIFT_RANDOML
	.byte TILE8_ARROWLIFT_UPR, TILE8_ARROWLIFT_RIGHTR, TILE8_ARROWLIFT_LEFTR, TILE8_ARROWLIFT_RANDOMR

LoadLevel_ArrowLifts:
	LDA LL_ShapeDef
	SUB #$04
	TAX		 ; X = relative index

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_ArrowLifts,X	 ; Get arrow lift left tile 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 ; Next column; this is OK for vertical levels, nowhere to the right

	LDA LL_ArrowLifts+4,X	 ; Get arrow lift right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LargeWater
;
; Inserts a potentially VERY large rectangle of water!  First row
; is always the top of water, followed by water tiles underneath.
; Width is 256 tiles.  Height can vary, appears to be intended as
; up to 26 rows (full screen height)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LargeWater:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	; This determines height of the water rectangle, which is number of rows to bottom of screen
	LDA <Temp_Var15	
	AND #%00011111	; lower 5 bits of Temp_Var15 used here

	STA <Temp_Var3
	LDA #26		; Full screen rows
	SUB <Temp_Var3	
	STA <Temp_Var3	; Temp_Var3 = $1a - lower 5 bits

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDX #$ef	 	; X = $EF
PRG018_AA3A:
	LDA #TILE6_WATERTOP	; Top of water
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	CPX #$ff	 
	BNE PRG018_AA3A	 ; While X <> $FF, loop

	JMP PRG018_AA55	 ; $AA46 

PRG018_AA49:
	LDA #TILE6_WATER	 ; Water tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column
	DEX		 ; X--
	CPX #$ff
	BNE PRG018_AA49	 ; While X <> $FF, loop!


PRG018_AA55:

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	JSR LL18_NextRow
	STA <Temp_Var2

	LDX #$ef	 ; X = $EF
	DEC <Temp_Var3	 ; Temp_Var3-- (height decrement)
	BPL PRG018_AA49	 ; While Temp_Var3 >= 0, loop!

	RTS		 ; Return



LL18_NextRow:
	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ActionSwitchR
;
; Adds a reverse action switch
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ActionSwitchR:

	LDA #TILE8_EXSWITCHR

	LDY TileAddr_Off ; Y = TileAddr_Off
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem


	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_TopManiacZapper18
;
; Puts down 1-16 Top Maniac 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_TMZ_Top18:	.byte TILE8_ZAPPER_TL, TILE8_ZAPPER_TR
LL_TMZ_Mid18:	.byte TILE8_ZAPPER_L, TILE8_ZAPPER_R

LoadLevel_TopManiacZapper18:
	LDA LL_ShapeDef	 
	AND #$0f	 
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDA LL_ShapeDef	 
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	AND #1
	TAX

	LDY TileAddr_Off	; Y = TileAddr_Off

	LDA LL_TMZ_Top18,X
	STA [Map_Tile_AddrL],Y

LL_TMZ_Loop18:
	JSR LoadLevel_TileMemNextRow	; Next row

	LDA LL_TMZ_Mid18,X
	STA [Map_Tile_AddrL],Y

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL LL_TMZ_Loop18	 	; While Temp_Var3 >= 0, loop...

	RTS		 ; Return


	; Broken into another file for ease of integration in NoDice editor
	.include "PRG/levels/Water.asm"	
	.include "PRG/levels/PipeMaze.asm"	
	
