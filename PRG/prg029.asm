; Source generated by DCC6502 version v1.4
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg029.bin, File Size: 8193, ORG: $C000
;     -> NES mode enabled
;---------------------------------------------------------------------------


	; SB: Purged empty


	; This defines a table of lookups that point to the start of
	; each Player_Frame's six patterns
SPPF_LookupByFrame:
	.word PF00, PF01, PF02, PF03, PF04, PF05, PF06, PF07
	.word PF08, PF09, PF0A, PF0B, PF0C, PF0D, PF0E, PF0F
	.word PF10, PF11, PF12, PF13, PF14, PF15, PF16, PF17
	.word PF18, PF19, PF1A, PF1B, PF1C, PF1D, PF1E, PF1F
	.word PF20, PF21, PF22, PF23, PF24, PF25, PF26, PF27
	.word PF28, PF29, PF2A, PF2B, PF2C, PF2D, PF2E, PF2F
	.word PF30, PF31, PF32, PF33, PF34, PF35, PF36, PF37
	.word PF38, PF39, PF3A, PF3B, PF3C, PF3D, PF3E, PF3F
	.word PF40, PF41, PF42, PF43, PF44, PF45, PF46, PF47
	.word PF48, PF49, PF4A, PF4B, PF4C, PF4D, PF4E, PF4F
	.word PF50, PF51, PF52, PF53, PF54, PF55, PF56, PF57
	.word PF58, PF59, PF5A, PF5B, PF5C

	; The six Patterns per Player_Frame to start each of the six Player sprites with!
	; Note the order is the three patterns for the three sprites that make the upper 
	; half followed by the next three for the lower half.
	; $F1 is a magic value reserved as a "don't display this sprite" flag

SPPF_Table:
PF00:	.byte $01, $03, $F1, $05, $07, $09
PF01:	.byte $0B, $0D, $F1, $0F, $29, $2B
PF02:	.byte $2D, $2F, $F1, $19, $1B, $1D
PF03:	.byte $2D, $2F, $F1, $19, $1B, $09
PF04:	.byte $21, $21, $F1, $23, $23, $F1
PF05:	.byte $25, $25, $F1, $27, $27, $F1
PF06:	.byte $01, $03, $F1, $05, $07, $F1
PF07:	.byte $31, $33, $F1, $35, $37, $39
PF08:	.byte $01, $03, $F1, $05, $07, $39
PF09:	.byte $01, $03, $F1, $05, $07, $09
PF0A:	.byte $01, $03, $F1, $05, $07, $3B
PF0B:	.byte $F1, $F1, $F1, $3D, $3F, $F1
PF0C:	.byte $01, $03, $F1, $05, $07, $F1
PF0D:	.byte $0B, $0D, $F1, $0F, $29, $F1
PF0E:	.byte $2D, $2F, $F1, $19, $1B, $F1
PF0F:	.byte $31, $33, $F1, $35, $37, $F1
PF10:	.byte $09, $2F, $F1, $1D, $1F, $F1
PF11:	.byte $2D, $2F, $F1, $39, $3B, $F1
PF12:	.byte $31, $31, $F1, $33, $33, $F1
PF13:	.byte $35, $35, $F1, $37, $37, $F1
PF14:	.byte $3D, $3D, $F1, $3F, $3F, $F1
PF15:	.byte $2D, $2F, $F1, $19, $1B, $F1
PF16:	.byte $0B, $0D, $F1, $0F, $29, $2B
PF17:	.byte $2D, $2F, $F1, $19, $1B, $1D
PF18:	.byte $2D, $2F, $F1, $A9, $AB, $F1
PF19:	.byte $2D, $2F, $F1, $A9, $AD, $F1
PF1A	.byte $01, $03, $05, $07, $09, $0B
PF1B:	.byte $0D, $0F, $39, $3B, $3D, $3F
PF1C:	.byte $19, $1B, $1D, $1F, $21, $23
PF1D:	.byte $25, $27, $29, $2B, $2D, $2F
PF1E:	.byte $31, $33, $F1, $35, $37, $F1
PF1F:	.byte $25, $29, $2D, $33, $37, $0D
PF20:	.byte $25, $29, $2D, $33, $37, $0F
PF21:	.byte $19, $1D, $21, $1B, $1F, $23
PF22:	.byte $25, $29, $2D, $27, $2B, $2F
PF23:	.byte $25, $29, $2D, $33, $37, $3B
PF24:	.byte $01, $01, $F1, $03, $03, $F1
PF25:	.byte $05, $05, $F1, $07, $07, $F1
PF26:	.byte $09, $09, $F1, $0B, $0B, $F1
PF27:	.byte $31, $33, $F1, $35, $37, $F1
PF28:	.byte $31, $35, $F1, $39, $3D, $F1
PF29:	.byte $01, $03, $F1, $05, $07, $09
PF2A:	.byte $01, $03, $F1, $0B, $0D, $0F
PF2B:	.byte $01, $03, $F1, $21, $23, $25
PF2C:	.byte $31, $33, $F1, $35, $37, $F1
PF2D:	.byte $27, $19, $F1, $1D, $1F, $F1
PF2E:	.byte $F1, $F1, $F1, $35, $37, $F1
PF2F:	.byte $F1, $F1, $F1, $31, $33, $F1
PF30:	.byte $29, $2B, $F1, $2D, $2F, $F1
PF31:	.byte $39, $3B, $F1, $3D, $3F, $F1
PF32:	.byte $F1, $F1, $F1, $2F, $2F, $F1
PF33:	.byte $F1, $F1, $F1, $2B, $2D, $F1
PF34:	.byte $29, $2B, $F1, $0D, $0F, $27
PF35:	.byte $29, $2B, $F1, $09, $0B, $25
PF36:	.byte $29, $2B, $F1, $01, $03, $3F
PF37:	.byte $29, $2B, $F1, $01, $03, $05
PF38:	.byte $29, $2B, $F1, $01, $03, $07
PF39:	.byte $29, $2B, $F1, $31, $33, $3D
PF3A:	.byte $29, $2B, $F1, $35, $37, $3D
PF3B:	.byte $29, $2B, $F1, $39, $3B, $3D
PF3C:	.byte $29, $2B, $F1, $0D, $1F, $25
PF3D:	.byte $29, $2B, $F1, $0D, $2D, $2F
PF3E:	.byte $F1, $F1, $F1, $05, $07, $F1
PF3F:	.byte $F1, $F1, $F1, $01, $03, $F1
PF40:	.byte $F1, $F1, $F1, $19, $1B, $F1
PF41:	.byte $F1, $F1, $F1, $21, $23, $F1
PF42:	.byte $F1, $F1, $F1, $1D, $1F, $F1
PF43:	.byte $05, $07, $F1, $A9, $AB, $F1
PF44:	.byte $05, $07, $F1, $A9, $AD, $F1
PF45:	.byte $29, $2B, $F1, $01, $03, $05
PF46:	.byte $F1, $F1, $F1, $25, $27, $F1
PF47:	.byte $F1, $F1, $F1, $29, $2B, $F1
PF48:	.byte $F1, $F1, $F1, $29, $2F, $F1
PF49:	.byte $F1, $F1, $F1, $25, $2D, $F1
PF4A:	.byte $F1, $F1, $F1, $09, $0B, $F1
PF4B:	.byte $F1, $F1, $F1, $0D, $0D, $F1
PF4C:	.byte $F1, $F1, $F1, $31, $33, $F1
PF4D:	.byte $F1, $F1, $F1, $35, $37, $F1
PF4E:	.byte $F1, $F1, $F1, $0F, $3F, $F1
PF4F:	.byte $19, $1B, $F1, $1D, $21, $F1
PF50:	.byte $19, $1B, $F1, $1D, $21, $23
PF51:	.byte $1D, $1F, $F1, $2B, $3B, $F1
PF52:	.byte $F1, $F1, $F1, $39, $3B, $F1
PF53:	.byte $01, $03, $F1, $05, $07, $F1
PF54:	.byte $09, $0B, $F1, $0D, $0F, $F1
PF55:	.byte $09, $0B, $F1, $0D, $0F, $3F
PF56:	.byte $F1, $F1, $F1, $21, $23, $F1
PF57:	.byte $11, $13, $F1, $21, $23, $F1
PF58:	.byte $15, $17, $F1, $25, $27, $F1
PF59:	.byte $F1, $F1, $F1, $19, $1B, $F1
PF5A:	.byte $F1, $F1, $F1, $1D, $1F, $F1
PF5B:	.byte $11, $13, $F1, $21, $23, $F1
PF5C:	.byte $15, $17, $F1, $25, $27, $3D

; We should be good now up to 128 frames

	; Selects a VROM page offset per Player_Frame
Player_FramePageOff:
	.byte 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 00 - 0F
	.byte 0,  0,  2,  2,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1	; 10 - 1F
	.byte 1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2	; 20 - 2F
	.byte 2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3	; 30 - 3F
	.byte 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3	; 40 - 4F
	.byte 3,  0,  3,  4,  4,  4,  2,  4,  4,  2,  2,  4,  4

PRG029_CE88:
	.byte -8, 10, -8, 18,  8, 10,  8, 18,  1,  9,  0,  8,  2, 10, -2, 6

	; Specified root VROM page for a given power up
Player_PUpRootPage:
	;             Small, Big, Fire, Leaf, Penguin, Rabbit, Hammer
PURP_Mario:	.byte 151,   156, 156,  161,  166,  171,     176	; Mario
PURP_Luigi:	.byte 181,   186, 186,  191,  196,  201,     206	; Luigi
PURP_Toad:	.byte 211,   216, 216,  221,  226,  231,     236	; Toad

Player_PUpRootIndex:
	.byte (PURP_Mario - Player_PUpRootPage)		; Mario
	.byte (PURP_Luigi - Player_PUpRootPage)		; Luigi
	.byte (PURP_Toad - Player_PUpRootPage)		; Toad

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Draw
;
; Not literally "draw", but configure the sprites for the Player
; to be drawn!  With the given data set of where the screen is
; scrolled, the Player's animation frame, invincibility status,
; etc. all handled by this major subroutine...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Draw:
	LDX <Player_Frame
	LDA Player_FramePageOff,X
	STA <Temp_Var1		 ; Get VROM page offset for this animation frame -> Temp_Var1

	LDY Player_Current		; Y = Current Player index (0 = 1P, 1 = 2P)
	LDA Player_Character,Y	; Get this player's select character
	TAY						; -> 'Y'
	
	LDA <Player_Suit			; Get current suit
	ADD Player_PUpRootIndex,Y	; Add the base index for this character
	TAY							; -> 'Y'
	
	LDA Player_PUpRootPage,Y ; Get VROM root page for this power up
	ADD <Temp_Var1		 ; Add appropriate offset to the VROM base for the animation frame

	STA PatTable_BankSel+2	 ; Set VROM bank switch for sprites 1/4

	LDA <Player_X
	SUB <Horz_Scroll
	STA <Player_SpriteX	 ; Player_SpriteX = Player_X - Horz_Scroll

	LDA <Player_Y
	SUB Level_VertScroll
	STA <Player_SpriteY	; Player_SpriteY = Player_Y - Level_VertScroll

	LDA <Player_YHi	
	SBC Level_VertScrollH
	STA Player_AboveTop	 ; Player_Above top calculated if Player is off top of screen

	LDA Player_FlashInv
	BEQ PRG029_CED7	 	; If Player_FlashInv = 0, jump to PRG029_CED7

	DEC Player_FlashInv	; Player_FlashInv--
	AND #$02	 
	BEQ PRG029_CED7	 	; Every 2 ticks, draw Player
	JMP PRG029_D094	 	; Every other 2 ticks, don't!

PRG029_CED7:
	LDA Player_StarOff
	BNE PRG029_CEEA	 	; If Player_StarOff <> 0 (star invincibility wearing off), jump to PRG029_CEEA

	LDA Player_StarInv
	BEQ PRG029_CF0B	 	; If Player_StarInv = 0 (not star invincible), jump to PRG029_CF0B

	LDA <Counter_1
	AND #$01
	BEQ PRG029_CEEA		; Every other tick, jump to PRG029_CEEA

	DEC Player_StarInv	 ; Player_StarInv--

	; SB: Supporting SMW style invincibility Kill Tally
	BNE PRG029_CEEA	; If Star Man has not worn off yet, jump to PRG029_CEEA

	; Since invincibility has worn off, don't count as stomping kill tally
	LDA #0
	STA Kill_Tally

PRG029_CEEA:
	LDA <Counter_1
	AND #$0f	; A = 0-15 ticks

	LDY Player_StarOff
	BNE PRG029_CF07	 ; If Player_StarOff <> 0 (star invincibility wearing off), jump to PRG029_CF07

	LDY Player_StarInv
	CPY #32
	BNE PRG029_CF05	 ; If Player_StarInv <> 32, jump to PRG029_CF05

	; At precisely star invincibility tick 32...

	LDY Level_PSwitchCnt
	BNE PRG029_CF05	 	; If P-Switch is active, jump to PRG029_CF05

	; Otherwise, restore level BGM music now that invincibility is wearing off
	LDY Level_MusicQueueRestore
	STY Sound_QMusic2

PRG029_CF05:
	BCS PRG029_CF09	 ; If we're NOT doing the "wearing off" star invincibility, jump to PRG029_CF09

PRG029_CF07:
	; These shifts are used to produce the "slower" color cycle
	; when the star invincibility is wearing off...
	LSR A
	LSR A

PRG029_CF09:
	AND #$03	 ; Cap it 0-3 in any case (select one of the four sprite palettes, basically)

PRG029_CF0B:
	STA <Temp_Var1	 ; Store cycle tick into Temp_Var1 (0 if not invincible, sprite palette 0)

	LDA Level_PipeMove
	LDA Player_Behind
	ORA Player_SandSink
	BEQ PRG029_CF1E	 ; If Player is behind the scenes, jump to PRG029_CF1E

	; Set priority over background (normal most game sprite behavior)
	LDA #$20
	ORA <Temp_Var1
	STA <Temp_Var1

PRG029_CF1E:
	; X = Player_Frame

	TXA
	ASL A	; 2 byte lookup
	TAX
	
	LDA SPPF_LookupByFrame,X
	STA <Player_SprWorkL
	LDA SPPF_LookupByFrame+1,X
	STA <Player_SprWorkH

	LDX Player_SprOff	 ; X = Root offset where Player sprite should begin
	LDY #0

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$0D,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$11,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$15,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$01,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$05,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$09,X	 

	LDA <Player_FlipBits
	AND #$c0
	ORA <Temp_Var1		 ; Merge with possible other attributes (the star invincibility palette cycle)

	; Store attributes to all Player sprites
	STA Sprite_RAM+$02,X
	STA Sprite_RAM+$06,X
	STA Sprite_RAM+$0A,X
	STA Sprite_RAM+$0E,X
	STA Sprite_RAM+$12,X
	STA Sprite_RAM+$16,X

	LDA Sprite_RAM+$01,X
	CMP Sprite_RAM+$05,X
	BNE PRG029_CF88		; If the patterns to the first two sprites are not the same, jump to PRG029_CF88

	; If they ARE the same, this is a mirrored sprite (like Mario "looking towards screen" etc.)
	; So the "right half" sprites must mirror the "left half"

	LDA Sprite_RAM+$0E,X
	AND #~SPR_HFLIP	 	; Keep all attributes EXCEPT horizontal flip
	STA Sprite_RAM+$02,X
	STA Sprite_RAM+$0E,X
	ORA #SPR_HFLIP	 	; Force horizontal flip
	STA Sprite_RAM+$06,X
	STA Sprite_RAM+$12,X

PRG029_CF88:

	; First row sprites
	LDA <Player_SpriteY
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

	; Second row sprites
	ADD #16
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

	; Left column
	LDA <Player_SpriteX
	STA Sprite_RAM+$03,X
	STA Sprite_RAM+$0F,X

	; Middle column
	ADD #8
	STA Sprite_RAM+$07,X
	STA Sprite_RAM+$13,X

	; Right column
	ADD #8
	STA Sprite_RAM+$0B,X
	STA Sprite_RAM+$17,X

	LDA <Player_FlipBits
	AND #$40
	BEQ PRG029_D010	 ; If Player sprite is NOT horizontally flipped, jump to PRG029_D010

	; Reverse these patterns
	LDA Sprite_RAM+$01,X	 
	PHA		 
	LDA Sprite_RAM+$05,X	 
	STA Sprite_RAM+$01,X	 
	PLA		 
	STA Sprite_RAM+$05,X	 

	; Reverse these X values
	LDA Sprite_RAM+$0B,X	 
	ADD #-24
	STA Sprite_RAM+$0B,X	 
	STA Sprite_RAM+$17,X	

	; Reverse these patterns 
	LDA Sprite_RAM+$0D,X	 
	PHA		 
	LDA Sprite_RAM+$11,X	 
	STA Sprite_RAM+$0D,X	 
	PLA		 
	STA Sprite_RAM+$11,X		 


	LDA Player_Flip
	BEQ PRG029_D010	; If Player is not somersaulting, jump to PRG029_D010

	; Otherwise all of the sprites are pushed to the right by 8

	LDA Sprite_RAM+$03,X	 
	ADD #8
	STA Sprite_RAM+$03,X
	STA Sprite_RAM+$0F,X

	LDA Sprite_RAM+$07,X	 
	ADD #8
	STA Sprite_RAM+$07,X
	STA Sprite_RAM+$13,X
	 
	LDA Sprite_RAM+$0B,X	 
	ADD #8
	STA Sprite_RAM+$0B,X	 
	STA Sprite_RAM+$17,X	 


PRG029_D010:

	; SB
	LDA Player_ReverseGrav
	BEQ PDraw_NoRevGrav	; If Player is not reversed gravity, jump to PDraw_NoRevGrav

	; Reverse sprite Ys
	; Second row sprites
	LDA <Player_SpriteY
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

	; First row sprites
	ADD #16
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

	; Apply V-Flip to all Player sprites
	LDA Sprite_RAM+$02,X
	ORA #SPR_VFLIP
	STA Sprite_RAM+$02,X
	STA Sprite_RAM+$0E,X
	STA Sprite_RAM+$0A,X

	LDA Sprite_RAM+$06,X
	ORA #SPR_VFLIP
	STA Sprite_RAM+$06,X
	STA Sprite_RAM+$12,X
	STA Sprite_RAM+$16,X


PDraw_NoRevGrav:
	LDA Player_Kuribo
	BEQ PRG029_D050	 ; If Player is not in a Kuribo's shoe, jump to PRG029_D050

	; Sprite vertical offset on Yoshi
	LDY #-12
	LDA <Player_Suit
	BNE PRG029_D01D
	LDY #-12
PRG029_D01D:
	STY <Temp_Var1
	
	; Check if Yoshi is tounge-out; if so, need to offset a little lower
	LDY Player_Kuribo
	DEY
	LDA Objects_Var5,Y
	BEQ Yoshi_No8Offset

	LDA <Temp_Var1
	ADD #8
	STA <Temp_Var1

Yoshi_No8Offset:
	LDA <Player_InAir
	BEQ PRG029_D036	 ; If Player is not mid-air, jump to PRG029_D036

	LDA <Player_YVel
	BPL PRG029_D029	 ; If Player is falling, jump to PRG029_D029

	EOR #$ff	 ; Otherwise negate it (sort of)

PRG029_D029:
	LSR A
	LSR A
	LSR A
	LSR A
	SUB #$03	; The "whole" part of the Y Velocity, minus 3

	EOR #$ff	 ; Negate that (sort of)
	BPL PRG029_D036	 ; If the result is positive, jump to PRG029_D036

	LDA #$00	 ; Otherwise if it slipped below zero, just use zero

PRG029_D036:
	ADD <Temp_Var1	 ; Add that to the initial offset
	ADD <Player_SpriteY	 ; And add in the Player's sprite Y position

	; Store that as the new Y position on the "first row" sprites
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X
	
	; SB
	ADD #16
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

	; The "second row" sprites (the shoe part in this case) use a different palette
	;LDA Sprite_RAM+$02,X
	;ORA #$02
	;STA Sprite_RAM+$02,X
	;STA Sprite_RAM+$06,X

PRG029_D050:
	LDA <Player_Frame
	CMP #PF_KICK_BIG 
	BNE PRG029_D076	 ; If Player_Frame <> PF_KICK_BIG (kicking shell, etc. when not small), jump to PRG029_D076

	; Otherwise the third "first row" sprite is pulled down to "second row"
	; This becomes the foot involved in the kick!
	LDA Sprite_RAM+$00,X
	STA Sprite_RAM+$14,X

	; If Player is not horizontally flipped, A = -8, otherwise A = 16
	LDA #-8
	LDY <Player_FlipBits
	BEQ PRG029_D064
	LDA #16
PRG029_D064:

	; The aforementioned foot sprite is offset into proper X position
	ADD Sprite_RAM+$0F,X
	STA Sprite_RAM+$17,X

	LDA #$1b
	STA Sprite_RAM+$15,X	; The foot sprite is forced to pattern $1B

	LDA Sprite_RAM+$0E,X
	STA Sprite_RAM+$16,X	; Attributes are copied (is this necessary?)

PRG029_D076:
	LDA <Player_FlipBits
	AND #$80	 
	BEQ PRG029_D094	 

	; If Player is vertically flipped, all sprite Y values must be reversed too!

	LDA Sprite_RAM+$00,X
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

	ADD #-16
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

PRG029_D094:
	LDA #$00
	STA Player_OffScreen	 ; Player_OffScreen = 0 (not off screen until we decide so!)

	LDY #$ff

	LDA Player_AboveTop
	BPL PRG029_D0AE	 	; If Player is not above top of screen, jump to PRG029_D0AE

	LDA <Player_SpriteY
	ADD #16
	LDA #$00
	ADC Player_AboveTop

	BNE PRG029_D0BC	 ; If Player is completely off the top of screen, jump to PRG029_D0BC
	BEQ PRG029_D0D3	 ; If Player is not at all off the top of screen, jump to PRG029_D0D3

PRG029_D0AE:
	BNE PRG029_D0BC	 ; Jump reserved for when Player is already known as off screen, so jump (technically always) to PRG029_D0BC

	LDA <Player_SpriteY
	CMP #$c0	 
	BGE PRG029_D0BC	 ; If Player_SpriteY >= $C0, he's below the status bar, so jump to PRG029_D0BC

	CMP #$b0
	BGE PRG029_D0C9	 ; If Player_SpriteY >= $B0, he's halway below the status bar, so jump to PRG029_D0C9
	BLT PRG029_D0D3	 ; Otherwise, Player is totally visible, jump to PRG029_D0D3

PRG029_D0BC:
	INC Player_OffScreen	; Player is off screen

	; Prevent "second row" sprites from being displayed
	TYA		 	; A = $FF
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

PRG029_D0C9:

	; Prevent "first row" sprites from being displayed
	TYA		 	; A = $FF
	STA Sprite_RAM+$00,X	
	STA Sprite_RAM+$04,X	
	STA Sprite_RAM+$08,X	

PRG029_D0D3:


	; $F1 is a magic value reserved as a "don't display this sprite" flag
	; So let's check if any sprite is using that value right now...
	LDY #$05	 ; Y = 5 (looping through all six Player sprites)

PRG029_D0D5:
	LDA Sprite_RAM+$01,X
	CMP #$f1	 
	BNE PRG029_D0E1	 ; If this sprite is NOT using pattern $F1, PRG029_D0E1

	; Pattern $F1 is the "don't use" pattern, so set this sprite's Y to $F8 (make invisible)
	LDA #$f8	 
	STA Sprite_RAM+$00,X

PRG029_D0E1:
	INX
	INX
	INX
	INX		 ; X -= 4 (previous sprite)
	DEY		 ; Y--
	BPL PRG029_D0D5	 ; While Y >= 0, loop!

	LDA Level_PipeMove
	BEQ PRG029_D13A	 ; If Level_PipeMove = 0, jump to PRG029_D13A (RTS)

	; When Player is going through pipe, a special "cover sprite" is used
	; at the pipe entrance which masks the Player...

	; Mask sprite X
	LDA <Pipe_PlayerX
	SUB <Horz_Scroll
	STA Sprite_RAM+$03
	STA Sprite_RAM+$07
	ADD #$08
	STA Sprite_RAM+$0B
	STA Sprite_RAM+$0F

	; Mask sprite Y
	LDA <Pipe_PlayerY
	SUB Level_VertScroll
	PHA
	CMP #$f0
	BLT PRG029_D10E
	LDA #$00	
PRG029_D10E:
	STA Sprite_RAM+$00
	STA Sprite_RAM+$08
	PLA
	ADD #16
	STA Sprite_RAM+$04
	STA Sprite_RAM+$0C


	; The pattern doesn't really matter so long as it is opaque
	; since the masking sprite is not intended to be visible
	; (not that certain glitches or ill behavior don't reveal
	; it once in a while)

	; Uses pattern $77 ("metal block" from used up [?], should be completely opaque)
	LDA #$77
	STA Sprite_RAM+$01
	STA Sprite_RAM+$05
	STA Sprite_RAM+$09
	STA Sprite_RAM+$0D

	; Must appear behind tiles
	LDA #SPR_BEHINDBG
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06
	STA Sprite_RAM+$0A
	STA Sprite_RAM+$0E


PRG029_D13A:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DrawAndDoActions
;
; Have to give this one its props; this function does an entire
; mess of routines, from adjusting the Player during autoscroll,
; going to coin heaven, the airship intro, going through pipes,
; changing power ups... all the things that happen to the Player
; object, though none of the instigation code is here!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DrawAndDoActions:
	LDA Player_HaltTick
	BEQ PRG029_D1CE	 	; If Player_HaltTick = 0 (not halted), jump to PRG029_D1CE

	; This code is only executed if the Player is halted

	DEC Player_HaltTick	; Player_HaltTick--

	JSR Player_Draw	 	; Draw Player's sprite!

	LDA Level_AScrlConfig
	BEQ PRG029_D1CD	 		; If Level_AScrlConfig = 0 (no auto scroll going on), jump to PRG029_D1CD

	JSR AutoScroll_CalcPlayerY	; Adjust Player_Y and Player_YHi for auto scroll

PRG029_D1CD:
	RTS		 ; Return


PRG029_D1CE:
	LDA <Player_IsDying
	BEQ PRG029_D1D5	 ; If Player is not dying, jump to PRG029_D1D5

	JMP PRG029_D6BC	 ; Jump to PRG029_D6BC (the Player's death routine)

PRG029_D1D5:
	LDA Level_CoinHeav
	BPL PRG029_D205	 ; If Level_CoinHeav >= 0, jump to PRG029_D205

	; Note that by above logic, Level_CoinHeav must be <= -1...
	; Technically, it is set to $80 (-128) at start!

	; Release holding anything and stop horizontal movement
	LDA #$00	 
	STA Player_IsHolding
	STA <Player_XVel

	; Produces an initial burst of upward Y velocity which slows down
	INC Level_CoinHeav	; Level_CoinHeav++
	LDA Level_CoinHeav
	STA <Player_YVel
	BNE PRG029_D1EE	 	; If Level_CoinHeav <> 0, jump to PRG029_D1EE

	INC Level_CoinHeav	; Level_CoinHeav++

PRG029_D1EE:
	LDA Player_ReverseGrav
	BEQ Player_CoinHeavNoRev

	; Reverse gravity...
	LDA <Player_YHi
	CMP #1
	BLT Player_CoinHeavNoRev	; If Player is not way below, jump to Player_CoinHeavNoRev
	LDA <Player_Y
	CMP #$B0
	BLT Player_CoinHeavNoRev	; If Player is not way below, jump to Player_CoinHeavNoRev
	
	; Otherwise, change level!
	BGE Player_CoinHeavExecute

Player_CoinHeavNoRev:
	LDA <Player_YHi
	BPL PRG029_D205	 ; If Player hasn't gone above top of screen yet, jump to PRG029_D205

	; Once Player crosses top of screen, he is then placed at halfway 
	; above the status bar (16 pixels above the death point!)
	LDA #$01
	STA <Player_YHi	; Player_YHi = 1 (really low)
	LDA #$b0	 
	STA <Player_Y	; Player_Y = $B0 (near the bottom)

	LDA #$d0
	STA Level_CoinHeav

	; SB: If Level_PipeNotExit is NOT set, let's exit to map instead!

Player_CoinHeavExecute:
	LDA Level_PipeNotExit
	BEQ CoinHeav_ExitInstead

	; Change to coin heaven (technically, this is the "general" level junction)
	LDA #$03	
	STA Level_JctCtl ; Level_JctCtl = 3

	RTS		 ; Return

CoinHeav_ExitInstead:
	LDA #0
	STA Map_ReturnStatus

	INC Level_ExitToMap
	RTS

PRG029_D205:
	LDA Player_SuitLost
	BEQ PRG029_D20E	 ; If Player_SuitLost = 0, jump to PRG029_D20E

	JSR Player_SuitLost_DoPoof	; Do the suit lost poof

	RTS		 ; Return


PRG029_D20E:
	LDA Player_StarOff
	BEQ PRG029_D224	 ; If Player_StarOff = 0 (invincibility is not wearing off), jump to PRG029_D224

	CMP #31
	BNE PRG029_D21D	 ; If Player_StarOff <> 31, jump to PRG029_D21D

	DEC Player_StarOff ; Player_StarOff--
	JMP PRG029_D224	   ; Jump to PRG029_D224

PRG029_D21D:
	JSR Player_Draw	   ; Draw Player
	DEC Player_StarOff ; Player_StarOff--

	RTS		 ; Return

PRG029_D224:
	LDA Player_Grow
	BEQ PRG029_D257	 ; If Player is not transforming into "Super", jump to PRG029_D257

	; SB: Values of $30+ are the "new power up effect"
	CMP #$30
	BGE Player_NewPUpEffect

	LSR A
	LSR A
	TAX		 ; X = Player_Grow >> 2

	LDY <Player_Suit ; Y = Player_Suit
	BNE PRG029_D238	 ; If Y <> 0 (small), jump to PRG029_D238

	STX <Temp_Var1
	LDA #$0b
	SUB <Temp_Var1
	TAX		 ; Otherwise, X = $0B - (Player_Grow >> 2)

PRG029_D238:
	AND #$01
	PHP		 ; Save result

	LDA Player_GrowFrames,X	 ; Get this grow frame
	STA <Player_Frame	 ; Set as current frame

	JSR Player_Draw		 ; Draw Player

	; 156 = big, 151 = small, 176 = hammer
	; Small = $50, big = $54, hammer = $44
	; growing: $45, $54  -- so it is $55 / $54, just SUB #$10 makes $45
	; shrinking: $44, $57 -- so it is $54 / $57, just SUB #$10 makes $44

	LDY Player_Current
	LDA Player_Character,Y
	TAY
	LDA Player_PUpRootIndex,Y
	TAY

	; Changes the Sprite 1/4 VROM bank as appropriate
	LDA Player_PUpRootPage+1,Y
	PLP		 ; Restore result
	BEQ PRG029_D250
	LDA Player_PUpRootPage+6,Y
	ADD #1
PRG029_D250:
	STA PatTable_BankSel+2

	DEC Player_Grow	 ; Player_Grow--

	RTS		 ; Return

PRG029_D257:
	LDA Player_EndLevel
	BEQ PRG029_D279	 ; If we're not doing the end of level run, jump to PRG029_D279

	LDA Player_Kuribo
	BEQ PRG029_D26B	; If Player was not in a Kuribo's shoe, jump to PRG029_D26B

	; If Player was in Kuribo's shoe at the end goal, "poof" it away!

	LDA #$00
	STA Player_Kuribo

	LDA #$18
	STA Player_SuitLost	 ; Player_SuitLost = $18

PRG029_D26B:

	; SB: Now supporting a little air time while doing the end level run-off
	LDA #$14
	STA <Player_XVel	; Player_XVel = $14

	LDA <Player_InAir
	BNE PlayerRunOff_ApplyXVel	; If Player is mid-air, jump to PRG029_D279

	DEC Player_EndLevel	; Player_EndLevel--

	JMP PRG029_D457	 	; Jump to PRG029_D457 

PlayerRunOff_ApplyXVel:
	JSR Player_ApplyXVelocity
	BNE PRG029_D279		; Jump (technically always) to PRG029_D279

Player_NewPUpEffect:
	SUB #$30	; zero-base it

	; Player_Grow++
	INC Player_Grow

	; If we've covered $20 ticks, we're done
	LDA Player_Grow
	SUB #$30	; zero-base it
	AND #$1F
	BEQ Player_NewPUpEffect_Done

Player_NewPUpEffect_Draw:

	TAY	; 'A' -> 'Y' (save Player_Grow value)

	; Backup the actual power up in case we're doing the "Super" toggle
	LDA <Player_Suit
	PHA	; Save actual powerup

	TYA	; 'Y' -> 'A' (restore Player_Grow value)

	AND #$08
	BEQ Player_NewPUpEffect_Odd

	; Do "previous powerup" toggle!
	LDA <Player_OldSuit
	STA <Player_Suit

Player_NewPUpEffect_Odd:

	; Set grab frame as appropriate by suit
	LDY <Player_Suit
	LDA Airship_JumpFrameByPup,Y
	STA <Player_Frame

	; Set power up's correct palette
	JSR Level_SetPlayerPUpPal

	JSR Player_Draw		 ; Draw Player

	; Restore powerup
	PLA
	STA <Player_Suit

	RTS


Player_NewPUpEffect_Done:
	LDA #0
	STA Player_Grow
	BEQ Player_NewPUpEffect_Draw	; Jump (technically always) to Player_NewPUpEffect_Draw

PRG029_D279:
	LDA Level_AirshipCtl
	BNE PRG029_D281	 ; If Level_AirshipCtl <> 0, jump to PRG029_D281

	JMP PRG029_D33E	 ; Otherwise, jump to PRG029_D33E

PRG029_D281:

	; Level_AirshipCtl <> 0...

	PHA		 ; Save Level_AirshipCtl

	LDA #$00
	STA <Scroll_LastDir	; Force screen to have "last moved right"

	INC <Horz_Scroll	; Screen scrolls to the right
	BNE PRG029_D28C	 	; If it hasn't rolled over, jump to PRG029_D28C
	INC <Horz_Scroll_Hi	; Otherwise, apply carry

PRG029_D28C:
	LDA <Horz_Scroll_Hi
	BNE PRG029_D296	 	; If Horz_Scroll_Hi <> 0, jump to PRG029_D296

	LDA <Horz_Scroll
	CMP #$60	
	BLT PRG029_D2AF	 ; If Horz_Scroll < $60, jump to PRG029_D2AF

PRG029_D296:
	INC Level_AirshipH	 ; Level_AirshipH++

	LDA Level_AirshipH
	ADD Counter_Wiggly	 ; Increase height of the airship in a bit of a wobbly way
	BCC PRG029_D2AF	 	; If it hasn't overflowed, jump to PRG029_D2AF

	INC <Vert_Scroll

	LDA <Objects_Y+4
	SUB #$01
	STA <Objects_Y+4	; Anchor's Y minus 1
	BCS PRG029_D2AF
	DEC <Objects_YHi+4	; If overflow occurred, propogate the carry
PRG029_D2AF: 

	PLA		 ; Restore Level_AirshipCtl
	JSR DynJump	 ; Dynamic jump based on Level_AirshipCtl... 
	
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word AirshipCtl_DoNothing	; 0 - Do nothing (not used)
	.word AirshipCtl_RunAndJump	; 1 - Run and jump (when horizontal scroll hits $80)
	.word AirshipCtl_Catch		; 2 - Catch anchor
	.word AirshipCtl_HoldAnchor	; 3 - Hold onto anchor
	.word AirshipCtl_LandOnDeck	; 4 - Land Player on deck

AirshipCtl_DoNothing:
	RTS		 ; Return

AirshipCtl_RunAndJump:
	LDA #$ef
	STA Level_VertScroll	 ; Level_VertScroll = $EF

	LDA <Horz_Scroll
	CMP #$80
	BLT PRG029_D2D0	 ; If Horz_Scroll < $80, jump to PRG029_D2D0

	; Player makes the jump!
	LDA #-$60
	STA <Player_YVel	 ; Player_YVel = -$60
	INC Level_AirshipCtl	 ; Next Level_AirshipCtl!

PRG029_D2D0:
	LDA #$01
	STA <Player_FlipBits	 ; Player_FlipBits = 1

	LDA #$20
	STA <Player_XVel	 ; Player_XVel = $20

	JMP PRG029_D457	 ; $D2D8 


AirshipCtl_Catch:
	LDA <Player_X
	CMP #$36	
	BLT PRG029_D2FF	 ; If Player_X < $36, jump to PRG029_D2FF

	; Apply Player's velocities
	JSR Player_ApplyYVelocity
	JSR Player_ApplyXVelocity

	LDA <Player_YVel
	ADD #$04
	STA <Player_YVel ; Player_YVel += 4

	CMP #$0f
	BLS PRG029_D2F5	 ; If Player_YVel < $0F, jump to PRG029_D2F5

	INC Level_AirshipCtl	 ; Otherwise, next Level_AirshipCtl!

PRG029_D2F5:

	; Set mid-air jump frame as appropriate by suit and draw Player...
	LDY <Player_Suit
	LDA Airship_JumpFrameByPup,Y
	STA <Player_Frame
	JMP Player_Draw	

PRG029_D2FF:
	JMP PRG029_D457	 ; Jump to PRG029_D457


AirshipCtl_HoldAnchor:
	LDA #$02
	STA <Player_FlipBits	 ; Player_FlipBits = 2 (use "caught anchor" frame)

	LDA #-$14
	STA <Player_YVel ; Player_YVel = -$14
	JSR PRG029_D457	 ; Continue using the "run" code

	LDA <Vert_Scroll
	CMP #$70
	BLT PRG029_D31B	 ; If Vert_Scroll < $70, jump to PRG029_D31B (RTS)

	LDA #$03	 
	STA Level_JctCtl	 ; Level_JctCtl = 3 (general purpose junction)

	INC Level_AirshipCtl	 ; Next Level_AirshipCtl!

PRG029_D31B:
	RTS		 ; Return


AirshipCtl_LandOnDeck:

	; SB: Disabling this requirement so I can use it elsewhere
	;LDA Level_AScrlConfig
	;BEQ PRG029_D33D	 ; If autoscroll not enabled, jump to PRG029_D33D

	JSR Player_ApplyYVelocity	 ; Apply Player's Y velocity

	LDA <Player_YVel
	BMI PRG029_D330	 	; If Player's Y velocity is negative (still rising), jump to PRG029_D330

	LDA #$00
	STA Level_AirshipCtl	; Level_AirshipCtl = 0 (airship sequence complete)
	STA Level_TimerEn	; Level_TimerEn = 0 (level timer enabled!)

PRG029_D330:
	LDA <Player_YVel
	ADD #$04
	STA <Player_YVel ; Player_YVel += 4 (Player falling to airship)

	JSR Player_DoScrolling	; Update scrolling at Player's position

	JSR PRG029_D2F5	 ; Mid-air frame as appropriate

PRG029_D33D:
	RTS		 ; Return


PRG029_D33E:
	LDA Level_GetWandState
	CMP #$03
	BLS PRG029_D361	 ; If Level_GetWandState < 3 (wand grabbed), jump to PRG029_D361

	CMP #$07
	BLS PRG029_D354	 ; If Level_GetWandState < 7, jump to PRG029_D354

	; Player's slow decent...
	LDA <Player_Y
	ADD #$02
	STA <Player_Y	 ; Player_Y += 2

	BCC PRG029_D354	 ; If no carry, jump to PRG029_D354
	INC <Player_YHi	 ; Otherwise, apply carry

PRG029_D354:
	; Player holding wand!
	LDY <Player_Suit ; Y = Player_Suit
	LDA Airship_JumpFrameByPup,Y	 
	STA <Player_Frame	; Use proper "mid-air" frame
	JSR Player_Draw	 	; Draw Player
	JMP Wand_Offset_BySuit	 	; Jump to Wand_Offset_BySuit

PRG029_D361:

	; Level_PipeMove is set to $8x when we are EXITING from
	; a pipe OR moving through it (in-level transit style),
	; but NOT when a non-transit pipe is entered; just being
	; clear, the "BPL" is for jumping when Level_PipeMove is
	; NOT holding an $8x value (and it might be zero, but 
	; that check is coming up next...)
	LDA Level_PipeMove
	BPL PRG029_D369		; If not transiting or exiting, jump to PRG029_D369

	JMP Level_PipeTransitOrExit	 ; Otherwise jump to Level_PipeTransitOrExit

PRG029_D369:
	BNE Level_PipeEnter	 ; If Level_PipeMove is not zero (and not in the $8x range), jump to Level_PipeEnter

	JMP PRG029_D3EC	 ; Otherwise, jump to PRG029_D3EC

Level_PipeEnter:

	; For when you've just entered a pipe of any sort...

	LDA Event_Countdown
	BNE PRG029_D3A0	 ; If Event_Countdown <> 0, jump to PRG029_D3A0

	; Init...

	LDA Level_PipeMove
	AND #%00011100	 ; Examine just bits 2-4 (determines what the pipe will do)
	CMP #%00010100	 
	BNE PRG029_D384	 ; If this is NOT an in-level transit pipe, jump to PRG029_D384

	LDA #$05
	STA Level_PipeExitDir	 ; Otherwise, Level_PipeExitDir = 5 (in-level transit flag)
	JMP PRG029_D395	 	; Jump to PRG029_D395

PRG029_D384:

	; Non in-level transit pipe...

	LSR A
	LSR A		 ; Shift down twice so the pipe behavior value is index based
	STA Level_JctCtl ; Push it right into Level_JctCtl!
	CMP #$01	 ; Although Level_JctCtl = 1 is not valid, this is used as "return to map"...
	BNE PRG029_D395	 ; If Level_JctCtl <> 1, jump to PRG029_D395

	INC <Level_ExitToMap	 ; Level_ExitToMap = 1 (return to map)

	LDA #$00
	STA Map_ReturnStatus	 ; Map_ReturnStatus = 0 (completed level, i.e. did not die)

	RTS		 ; Return


PRG029_D395:

	; Entered into an in-level transit pipe...

	; Level_PipeMove will hold the direction and bit 7, which flags the in-level transit pipe
	LDA Level_PipeMove
	AND #$03
	ORA #$80
	STA Level_PipeMove	 

	RTS		 ; Return

PRG029_D3A0:

	; While traveling in a pipe (but not an in-level transit style)

	LDA Level_PipeMove
	AND #%00000011	 ; Just keep the lower 2 bits (direction)
	CMP #$02
	BGS PRG029_D3CB	 ; If direction is down/up, jump to PRG029_D3CB

	; Left/right pipe

	LDA Event_Countdown
	CMP #16
	BLS PRG029_D3CA  ; If Event_Countdown < 16, jump to PRG029_D3CA (RTS)

	PHA		 ; Save Event_Countdown

	JSR PipeMove_LeftRight	 ; Move through pipe horizontally

	PLA		 ; Restore Event_Countdown

	CMP #36
	BGS PRG029_D3CA	 ; If Event_Countdown >= 36, jump to PRG029_D3CA

	; Remove Player's edge sprites as he vanishes into pipe
	LDX Player_SprOff
	LDA #$f8
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X

PRG029_D3CA:
	RTS		 ; Return

PRG029_D3CB:

	; Up/down pipe

	JSR PipeMove_UpDown	 ; Move through pipe vertically

	LDA Event_Countdown
	CMP #16
	BGE PRG029_D3EB	 	; If Event_Countdown >= 16, jump to PRG029_D3EB (RTS)

	LDA Player_SprOff

	LDX <Player_YVel
	BPL PRG029_D3DF	 ; If Player_YVel >= 0 (going down), jump to PRG029_D3DF

	ADD #$0c	 ; Remove other half of Player


	; Gets rid of appropriate half of Player sprites as he disappears into pipe
PRG029_D3DF:
	TAX 	; X = Player_SprOff

	LDA #$f8
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

PRG029_D3EB:
	RTS		 ; Return


PRG029_D3EC:

	; Nothing to do with pipes...

	JMP PRG008_A224	 ; Jump to PRG008_A224


	; When Player has grabbed wand, offset from Player X/Y by suit / power-up
Wand_XOff_BySuitL:	.byte -5, -5, -5, -5, -7, -5, -5
Wand_XOff_BySuitR:	.byte  6,  6,  6,  6,  8,  6,  6
Wand_YOff_BySuit:	.byte  1, -9, -9, -9,  3, -9, -9

Wand_Offset_BySuit:
	LDY Object_SprRAM+5	; Y = 5th index object Sprite RAM offset
	LDX <Player_Suit	; X = Player's suit

	LDA <Player_FlipBits
	PHP		 	; Save Player flip bits

	LDA Wand_XOff_BySuitR,X	; Wand offset, held right

	PLP		 	; Restore Player flip bits
	BNE PRG029_D415	 	; If Player is not flipped, jump to PRG029_D415

	LDA Wand_XOff_BySuitL,X	; Wand offset, held left

PRG029_D415:
	ADD <Player_SpriteX	; Add offset to Player sprite X
	STA Sprite_RAM+$03,Y	; -> Sprite X

	ADD #$08		; +8
	STA Sprite_RAM+$07,Y	; -> Sprite X

	; Temp_Var1 = Player_YHi
	LDA <Player_YHi
	STA <Temp_Var1

	LDA Wand_YOff_BySuit,X
	BPL PRG029_D42C	 	; If Y offset is positive, jump to PRG029_D42C

	DEC <Temp_Var1		; Otherwise, Temp_Var1--

PRG029_D42C:
	ADD <Player_SpriteY	; Add offset to Player Y
	BCC PRG029_D433	 	; If no carry, jump to PRG029_D433

	INC <Temp_Var1		; Otherwise, apply carry

PRG029_D433:
	LDX <Temp_Var1		; X = Temp_Var1
	CPX #$01
	BPL PRG029_D454	 	; If off-screen, jump to PRG029_D454

	; Store Wand Sprites Y
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Store Wand Sprite Patterns
	LDA #$99
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	; Palette cycling of wand
	LDA <Counter_1
	AND #$06
	LSR A
	STA Sprite_RAM+$02,Y

	; Mirrored half
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y

PRG029_D454:
	RTS		 ; Return

Level_EndFlipBits:
	.byte $00, $40

PRG029_D457:

	; The "run forward" bit at the end of a level...
	; OR the run & jump for the airship!

	LDA <Player_FlipBits
	AND #$02
	BEQ PRG029_D468	 ; If (Player_FlipBits & 2) = 0, jump to PRG029_D468

	JSR Player_ApplyYVelocity	 ; Apply Y velocity

	; Used by airship only (the "caught anchor" frames)
	LDY <Player_Suit
	LDA Player_ClimbFrame,Y ; Get "caught anchor" frame
	JMP PRG029_D49B	 	  ; Jump to PRG029_D49B

PRG029_D468:
	LDA <Player_FlipBits
	AND #$01
	TAY		; Y = Player_FlipBits & 1 
	LDA Level_EndFlipBits,Y	 ; Get proper flip bit
	ORA <Player_FlipBits	
	STA <Player_FlipBits	 ; Level_EndFlipBits |= Level_EndFlipBits[Y]

	JSR Player_ApplyXVelocity ; Apply X Velocity

	LDA <Counter_1
	AND #$06	
	LSR A		
	STA <Temp_Var1	 ; Temp_Var1 = (Counter_1 & 6) >> 1  (0-3)


PRG029_D47E:	; Jump point for horizontal pipe-walking

	LDA <Player_Suit
	ASL A
	ASL A		
	ORA <Temp_Var1
	TAY		; Y = (Player_Suit << 2) | Temp_Var1 (0 to 3)
	LDA Player_WalkFramesByPUp,Y	; Get appropriate frame

PRG029_D49B:
	STA <Player_Frame	; Whatever the result, store as Player frame!
	JSR Player_Draw	 	; Draw Player
	RTS		 ; Return


Pipe_Move_JumpTable:
	.word Player_Die_NotDying	; 0 - Not used
	.word Pipe_Move_Up		; 1 - Moving Up
	.word Pipe_Move_Down		; 2 - Down
	.word Pipe_Move_Right		; 3 - Right
	.word Pipe_Move_Left		; 4 - Left
	.word Pipe_Transit		; 5 - In-level transit

	; For horizontal pipe movement, X velocity right and left, respectively
PipeMove_XVel:	.byte 8, -8

	; For vertical pipe movement, Y velocity down and up, respectively
PipeMove_YVel:	.byte 8, -8

	; This sets the Scroll_LastDir variable based on travel direction (right and left, respectively)
PipeMove_LR_Dir:	.byte 0, 1

	; This adds to Horz_Scroll based on travel direction (right and left, respectively)
PipeMove_LR:	.byte 1, -1

	; High byte sign extension to values in table immediately above
PipeMove_LRH:	.byte $00, $FF

Level_PipeTransitOrExit:
	; Jump here when Level_PipeExitDir is one of the $8x varities
	; indicating that we're moving through the pipe (in-level
	; transit or simply exiting out one end of it)

	; Splash_DisTimer = 8 (halt Player splashing in water when in-pipe)
	LDA #$08
	STA Splash_DisTimer

	LDA Level_PipeExitDir
	ASL A		 
	TAY		

	; Dynamic jump based on Level_PipeExitDir index into Pipe_Move_JumpTable table 
	LDA Pipe_Move_JumpTable,Y
	STA <Temp_Var1	
	LDA Pipe_Move_JumpTable+1,Y
	STA <Temp_Var2		
	JMP [Temp_Var1]

Player_Die_NotDying:
	RTS		 ; Return

Pipe_Move_Up:
	; Level_PipeMove = $83 (indicates Player is moving up through pipe, no additional action to be taken)
	LDA #$83
	STA Level_PipeMove

	JSR PipeMove_UpDown_RG	; Do pipe movement and draw Player

Player_PipeUD_Cont:
	LDA Event_Countdown
	BNE PRG029_D4DF	 	; If Event_Countdown <> 0, jump to PRG029_D4DF

	JMP Player_StopMovement	; Jump to Player_StopMovement

PRG029_D4DF:
	CMP #32
	LDA Player_SprOff
	BLT PRG029_D4E9	 ; If Event_Countdown < 32, jump to PRG029_D4E9 (RTS)

	JMP PRG029_D3DF ; Jump to PRG029_D3DF

PRG029_D4E9:
	RTS		 ; Return

Pipe_Move_Down:
	; Level_PipeMove = $82 (indicates Player is moving down through pipe, no additional action to be taken)
	LDA #$82
	STA Level_PipeMove
	STA <Player_InAir 	; Flag Player as being mid-air (going to fall out the bottom)

	LDA #$30
	STA <Player_YVel 	; Player_YVel = $30 

	; SB: I'm overriding my override! (In Player_ApplyYVelocity)
	LDA Level_PipeMove
	PHA
	LDA #0
	STA Level_PipeMove

	JSR Player_ApplyYVelocity ; Apply Player's Y velocity

	PLA
	STA Level_PipeMove
	
	JSR PipeMove_UpDown_RG	 ; Move through pipe vertically

	LDA Event_Countdown
	BNE PRG029_D50E	 	; If Event_Countdown <> 0, jump to PRG029_D50E

	LDA #$00	 
	STA Player_IsDucking	; Clear ducking flag (since Player pressed down on a pipe, it's incorrectly set)
	STA Level_PipeMove	; Not moving through a pipe anymore
	STA <Player_XVel	; Not horizontally moving, period

	LDA #$38
	STA <Player_YVel	; Player_IsDucking = $38 (fall out the bottom)

PRG029_D50E:
	RTS		 ; Return

Pipe_Move_Right:
	; Level_PipeMove = $80 (indicates Player is moving right through pipe, no additional action to be taken)
	LDA #$80
	STA Level_PipeMove

	LDA #$40
	STA <Player_FlipBits ; Player_FlipBits = $40 (facing right)

	LDY #$00	 ; Y = 0 (moving right)

PRG029_D51A:
	LDA <Counter_1
	LSR A		
	BCC PRG029_D53B	 ; Basically, every other tick, jump to PRG029_D53B

	; And on the other ticks...

	LDA PipeMove_LR_Dir,Y
	STA <Scroll_LastDir

	LDA <Horz_Scroll

	LDX <Horz_Scroll_Hi
	BNE PRG029_D52E	 	; If Horz_Scroll_Hi = 0, jump to PRG029_D52E

	; Horz_Scroll_Hi <> 0...

	CMP #$80	 
	BLT PRG029_D53B	 ; If Horz_Scroll < $80, jump to PRG029_D53B

PRG029_D52E:
	ADD PipeMove_LR,Y
	STA <Horz_Scroll	; Horz_Scroll += PipeMove_LR[Y]

	; Add matching sign extension and any carry
	LDA PipeMove_LRH,Y
	ADC <Horz_Scroll_Hi
	STA <Horz_Scroll_Hi

PRG029_D53B:
	JSR PipeMove_LeftRight	 ; Move through pipe horizontally

	LDX Player_SprOff	 ; X = Player's root sprite position

	; Remove one of the masking sprites??
	LDA #$f8
	STA Sprite_RAM+$08,X

	LDA Event_Countdown
	BNE PRG029_D54E	 ; If Event_Countdown <> 0, jump to PRG029_D54E (RTS)

	JSR Player_StopMovement	 ; Stop movement exiting pipe!

PRG029_D54E:
	RTS		 ; Return

Pipe_Move_Left:
	; Level_PipeMove = $81 (indicates Player is moving left through pipe, no additional action to be taken)
	LDA #$81
	STA Level_PipeMove

	LDA #$00
	STA <Player_FlipBits ; Player_FlipBits = $00 (facing left)

	LDY #$01	 ; Y = 1 (moving left)

	JMP PRG029_D51A	; Jump to PRG029_D51A

	; Y Offset based on direction (down and up respectively)
PipeTransit_YOff:
	.byte 31, 0

Pipe_Transit:
	LDA Level_7Vertical
	BNE PRG029_D5DC	 ; If level is a vertical pipe maze type level, jump to PRG029_D5DC

	; Pipe transit for non-vertical levels
	;
	; This version is functionally limited in non-vertical levels 
	; such that only vertical runs of in-level transit pipes are
	; supported; none of the bends and such of a pipe maze level.
	;
	; But there is no Level_Tileset in the non-vertical realm that
	; has the graphics to support the bends and whatnot anyway, so
	; they clearly weren't planning on it...
	;
	; Further these pipes intend to bring you from the lowest scroll
	; point to the uppermost scroll point and visually act strangely
	; if you try to go somewhere short of that at either end.

	LDA #-2		 ; A = -2 (scroll upward)
	LDX #$01	 ; X = 1
	LDY <Player_YVel ; Y = Player_YVel
	BMI PRG029_D56F	 ; If Player_YVel < 0, jump to PRG029_D56F

	; If Player_Vel >= 0...
	LDA #$02	 ; A = 2 (scroll downward)
	DEX		 ; X = 0

PRG029_D56F:
	STA Pipe_TransYDelta	 ; Pipe_TransYDelta = -2 (going up) or 2 (going down)

	ADD <Vert_Scroll
	STA <Vert_Scroll 	; Vert_Scroll += A
	STA Level_VertScroll	; Level_VertScroll += A

	LDY <Player_YVel	; Y = Player_YVel
	BPL PRG029_D584	 	; If Player_YVel >= 0, jump to PRG029_D584

	BCS PRG029_D59B	 	; If carry occurred from addition to Vert_Scroll, jump to PRG029_D59B

	; Otherwise...

	; Inter-level vertical pipes stop moving upward when scroll reaches $00
	LDA #$00	 ; A = 0 
	BEQ PRG029_D58A	 ; Jump (technically always) to PRG029_D58A

PRG029_D584:
	CMP #$ef	 
	BLT PRG029_D59B	 ; If Vert_Scroll < $EF, jump to PRG029_D59B

	; Inter-level vertical pipes stop moving downward when scroll reaches $EF
	LDA #$ef	 ; Otherwise, A = $EF (bottom scroll)

PRG029_D58A:
	; Common termination point when exiting inter-level vertical pipe
	STA <Vert_Scroll ; Update Vert_Scroll

	LDA #$00	; Level_PipeExitDir = 1 (exiting up) (SB: Starting 1 less for rev grav trick)

	LDY <Player_YVel
	BMI PRG029_D598	 	; If Player_YVel < 0, jump to PRG029_D598

	ADD #1	 ; Otherwise, Level_PipeExitDir = 2 (exiting down) (SB: Starting 1 less for rev grav trick)

PRG029_D598:
	EOR Player_ReverseGrav	; Reverse gravity will swap up/down exit direction
	ADD #1					; +1 for correction (so now 1 or 2 like it should be)
	STA Level_PipeExitDir	; -> Level_PipeExitDir

	JMP PRG008_A38E	 ; Jump to PRG008_A38E (Player exits pipe)

PRG029_D59B:
	; X = 0 (going down) or 1 (going up)

	LDA PipeTransit_YOff,X
	STA <Temp_Var10	 ; Temp_Var10 = PipeTransit_YOff[X] (appropriate Y offset)

	LDA #$08
	STA <Temp_Var11	 ; Temp_Var11 = 8

	JSR Player_GetTileAndSlope	; Get tile
	SUB #TILE1_PIPETB4_L	 	
	CMP #$02	 
	BLT PRG029_D5C3	 	; If tile is one of the transit pipe top/bottom tiles, jump to PRG029_D5C3 (RTS)

	LDA #16	 	; A = 16
 
	CPX #$00	 
	BEQ PRG029_D5B8	 ; If Player was going down, jump to PRG029_D5B8

	; Player was going up

	DEC <Player_YHi	 ; Player_YHi--
	LDA #-16	 ; A = 16

PRG029_D5B8:
	ADD <Player_Y	
	AND #$f0	
	STA <Player_Y	 ; Player_Y = (Player_Y + A) & $F0  (tile-aligned move)

	BCC PRG029_D5C3	 ; If no carry, jump to PRG029_D5C3

	INC <Player_YHi	 ; Otherwise, apply carry

PRG029_D5C3:
	RTS		 ; Return

	; Defines Y and X offset pairs, for two different rotation possibilities
	; when Player hits an elbow (does he go from up to right, or up to left? etc.)
	; Indexed per lower 2 bits of Level_PipeMove, shifted up by 2
PipeTransit_XYOffsets:
	;    YO1 XO1 YO2 XO2
	.byte 30, 18,  2, 18	; Moving right
	.byte 30,  2,  2,  2	; Moving left
	.byte 30, 14, 30,  2	; Moving up
	.byte  2, 14,  2,  2	; Moving down

	; This is actually access as a contiguous array, but might as well be clear
PipeTransit_YDelta:	.byte 2, -2	; Y Deltas while moving through pipes (down and up)
PipeTransit_XDelta:	.byte 2, -2	; X Deltas while moving through pipes (right and left)

	; Sets Level_PipeExitDir appropriately based on direction
Level_PipeExitDirTable:	.byte $02, $03, $01, $00	; SB: These are all -1 from stock SMB3 for reverse gravity sense

PRG029_D5DC:

	; Pipe transit in vertical levels

	LDA Level_PipeMove
	AND #$03	 ; Just the lower 2 bits of Level_PipeMove (the direction)
	PHA		 ; Save it

	TAY		 ; Y = the direction of Level_PipeMove

	LDX #$00	 		; Index Player's X

	CPY #$02
	BLS PRG029_D605	 ; If direction is right or left, jump to PRG029_D605

	; Direction is down or up

	LDX #(Player_Y - Player_X)	; Index Player's Y instead

	LDA PipeTransit_YDelta,Y	; Get delta
	BPL PRG029_D5FD	 		; If it's not negative, jump to PRG029_D5FD

	LDA <Player_SpriteY
	CMP #$68
	LDA #$00
	BLT PRG029_D608	 ; If Player_SpriteY < $68, jump to PRG029_D608

	DEC <Player_XHi,X ; Decrement approprate Player Hi
	JMP PRG029_D605	 ; Jump to PRG029_D605

PRG029_D5FD:
	LDA <Player_SpriteY
	CMP #$38	 
	LDA #$00	 
	BGE PRG029_D608	 ; If Player_SpriteY >= $38, jump to PRG029_D608

PRG029_D605:
	LDA PipeTransit_YDelta,Y 	; Get delta

PRG029_D608:
	ADD <Player_X,X		; Apply delta to Player X or Y (as appropriate)
	AND #$fe	 	; Align to nearest 2 pixels
	STA <Player_X,X	 	; Store it

	BCC PRG029_D613	 	; If no carry, jump to PRG029_D613

	INC <Player_XHi,X	; Otherwise, apply carry

PRG029_D613:
	AND #$0f	 ; Lower 4 bits of Player's X or Y
	TAX		 ; -> 'X'

	CPY #$02
	BLS PRG029_D651	 ; If direction is right or left, jump to PRG029_D651

	; Down or up

	LDA <Player_X
	AND #$f0
	ORA #$08
	STA <Player_X	 ; Player_X = (Player_X & $F0) | 8  (nearest column, centered)

	LDA #$01
	STA <Scroll_LastDir ; Scroll_LastDir = 1 (down)

	LDA PipeTransit_YDelta,Y	; Get delta
	BPL PRG029_D630	 		; If delta is not negative, jump to PRG029_D630

	; Negative delta means up, so...

	DEC <Scroll_LastDir	 ; Scroll_LastDir = 0 (up)
	DEC Level_VertScrollH	 ; Level_VertScrollH--

PRG029_D630:
	STA Pipe_TransYDelta	 ; Store into Pipe_TransYDelta
	ADD Level_VertScroll	
	STA Level_VertScroll	 ; Level_VertScroll += Pipe_TransYDelta
	BCC PRG029_D63F	 	; If no carry, jump to PRG029_D63F

	INC Level_VertScrollH	 ; Otherwise, apply carry

PRG029_D63F:
	LDY Level_VertScrollH	 ; Y = Level_VertScrollH

	JSR LevelJct_GetVScreenH ; Adjust coordinates for vertical

	; Update scrolls
	STA <Vert_Scroll
	STY <Vert_Scroll_Hi

	LDA <Player_Y
	SUB Level_VertScroll
	STA <Player_SpriteY	 ; Player_SpriteY = relative Y position

PRG029_D651:
	PLA		 ; Restore the lower 2 bits of Level_PipeMove (the direction)

	; 'X' was last left as lower 4 bits of Player's X or Y position
	; (i.e. distance across cell horizontally or vertically; a value
	; of zero indicates Player has just aligned with a new tile)
	CPX #$00
	BNE PRG029_D69B	 ; If Player has not reached a new tile, jump to PRG029_D69B

	; Player has reached a new tile...

	ASL A
	ASL A		 ; direction of pipe move, shifted left 2

	LDX #$01	 ; X = 1

	TAY		 ; Y = the direction of the pipe move, shifted left 2 (0, 4, 8, 12)

PRG029_D65B:
	LDA PipeTransit_XYOffsets,Y
	STA <Temp_Var10	 ; Temp_Var10 = Y offset

	LDA PipeTransit_XYOffsets+1,Y
	STA <Temp_Var11	 ; Temp_Var11 = X offset

	JSR Player_GetTileAndSlope	; Get tile
	STA <Temp_Var1		 ; Store into Temp_Var1

	SUB #TILE8_SCENPIPE_ENDVR
	CMP #$02	
	BGE PRG029_D674	 ; If tile is NOT a vertical scenery pipe's left or right end, jump to PRG029_D674

	JMP PRG029_D69C	 ; Otherwise, jump to PRG029_D69C

PRG029_D674:
	LDA <Temp_Var1	 
	CMP #TILE8_SCENPIPE_ENDH1B
	BNE PRG029_D67D	 ; If tile is NOT a horizontal scenery pipe's bottom tile, jump to PRG029_D67D

	JMP PRG029_D69C	 ; Otherwise, jump to PRG029_D69C

PRG029_D67D:
	LDA <Temp_Var1
	SUB #TILE8_PIPEELBOW_CUL
	CMP #$04	 
	BGE PRG029_D696	 ; If tile is NOT a pipe elbow corner tile, jump to PRG029_D696

	; Otherwise...
	STX <Temp_Var1	 	; Temp_Var1 = 1 OR 0 (depending which iteration, which will change which way it rotates)
	LDA Level_PipeMove
	AND #%10000010		; Keep only the up/down vs left/right bit and the "in-transit" bit
	EOR #%00000010		; Turn corner 
	ORA <Temp_Var1		; -> Temp_Var1

	STA Level_PipeMove	; Update Level_PipeMove
	LDX #$00	 	; X = 0

PRG029_D696:
	INY		 ; Y++
	INY		 ; Y++ (next Y/X offset pair)

	DEX		 ; X-- (if Player turned corner, this will result in a negative)
	BPL PRG029_D65B	 ; If X >= 0, loop!

PRG029_D69B:
	RTS		 ; Return


PRG029_D69C:

	; In-transit pipe, hit an end

	LDA Level_PipeMove
	AND #%00000011	 
	TAY		 	; Y = lower 2 bits of Level_PipeMove (the direction)
	BNE PRG029_D6AB	 	; If direction is not rightward, jump to PRG029_D6AB

	; Otherwise, add 16 to Player_X
	LDA <Player_X
	ADD #16
	STA <Player_X

PRG029_D6AB:

	; Set Level_PipeExitDir appropriately
	LDA Level_PipeExitDirTable,Y
	EOR Player_ReverseGrav	; Reverse gravity will swap up/down exit direction
	ADD #1					; +1 for correction (so now 1 or 2 like it should be)
	STA Level_PipeExitDir

	JMP PRG008_A38E	 ; Jump to PRG008_A38E

Player_Die_JumpTable:
	.word Player_Die_NotDying	; 0 - Player isn't dying!  Do nothing
	.word Player_Die_Dying		; 1 - Dying normal
	.word Player_Die_FellOff	; 2 - Dying by having fallen off screen
	.word Player_Die_TimeUp		; 3 - Dying due to time up
	.word Player_Die_TimeUp		; 4 - Dying due to game over

PRG029_D6BC:
	; Player is dying!

	LDA <Player_IsDying
	ASL A		 
	TAY		 ; Y = Player_IsDying << 1

	LDA Player_Die_JumpTable,Y
	STA <Temp_Var1
	LDA Player_Die_JumpTable+1,Y
	STA <Temp_Var2

	JMP [Temp_Var1]	 ; Jump to appropriate "Player is dying" routine...

Player_Die_Dying_RevChk:
	LDA Player_AboveTop
	BNE PRG029_D6E5	 ; If Player is above top of screen, jump to PRG029_D6E5
	BEQ PRG029_D6DA	 ; Otherwise, jump to PRG029_D6DA
	

Player_Die_Dying:
	LDA Player_ReverseGrav
	BNE Player_Die_Dying_RevChk	; If Player gravity is reversed, jump to Player_Die_Dying_RevChk

	LDA Player_AboveTop
	BNE PRG029_D6DA	 ; If Player is above top of screen, jump to PRG029_D6DA

	LDA <Player_SpriteY
	AND #$f0
	CMP #$b0
	BEQ PRG029_D6E5	 ; If Player_SpriteY >= $B0 && Player_SpriteY <= $BF (Player is halfway below status bar), jump to PRG029_D6E5

PRG029_D6DA:
	LDA Event_Countdown
	BNE PRG029_D6E2	 ; If Event_Countdown <> 0 (time until drop to map), jump to PRG029_D6E2
	JMP PRG029_D768	 ; Otherwise, jump to PRG029_D6E2

PRG029_D6E2:
	JMP PRG029_D771	 ; Jump to PRG029_D771 if Event_Countdown <> 0

PRG029_D6E5:
	LDA Event_Countdown
	BNE PRG029_D6EF	; If Event_Countdown > 0 (time until drop to map), jump to PRG029_D6EF

	; Reload Event_Countdown
	LDA #64
	STA Event_Countdown	; Event_Countdown = 64

PRG029_D6EF:
	CMP #$01
	BNE PRG029_D6F5	 ; If Event_Countdown <> 1, jump to PRG029_D6F5 (RTS)
	BEQ PRG029_D6FB	 ; If Event_Countdown = 1, jump to PRG029_D6FB

PRG029_D6F5:
	RTS		 ; Return


Player_Die_FellOff:
	LDA Event_Countdown
	BNE PRG029_D6F5	 ; If Event_Countdown <> 0, jump to PRG029_D6F5 (RTS)
	
PRG029_D6FB:
	INC <Level_ExitToMap	; Level_ExitToMap = 1

	LDA #$01
	STA Map_ReturnStatus	 ; Map_ReturnStatus = 1 (Player died, level is not clear)

	LDX Player_Current
	LDA Player_Lives,X
	BNE PRG029_D6F5		; If not game over, jump to PRG029_D6F5

	; Entering Game Over continue menu
	JSR Sprite_RAM_Clear
	
	LDX #0
	STX Level_PauseSelect
	JSR Gameover_Menu_Draw

	LDY #(TIMEUP_Sprites - CONTINUE_Sprites - 1)
Gameover_DrawContinue:

	LDA <Pipe_PlayerX
	ADD #16
	STA Sprite_RAM+$00,X

	LDA CONTINUE_Sprites,Y
	STA Sprite_RAM+$01,X

	LDA #SPR_PAL1
	STA Sprite_RAM+$02,X

	LDA TIMEUP_SpriteXs,Y
	STA Sprite_RAM+$03,X
	
	INX
	INX
	INX
	INX

	DEY
	BPL Gameover_DrawContinue

	LDY #(YESNO_SpriteXs - YESNO_Sprites - 1)
Gameover_DrawYesNo:

	LDA YESNO_SpriteYs,Y
	STA Sprite_RAM+$00,X

	LDA YESNO_Sprites,Y
	STA Sprite_RAM+$01,X

	LDA #SPR_PAL1
	STA Sprite_RAM+$02,X

	LDA YESNO_SpriteXs,Y
	STA Sprite_RAM+$03,X
	
	INX
	INX
	INX
	INX

	DEY
	BPL Gameover_DrawYesNo

Gameover_Continue_Menu:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for VSync

	JSR Level_DoAnimations

	LDA Level_PauseSelect
	ASL A
	ASL A
	ASL A
	ASL A
	ADD #$75
	STA Sprite_RAM+$FC
	
	LDA #$0F
	STA Sprite_RAM+$FD
	
	LDA #SPR_PAL1
	STA Sprite_RAM+$FE
	
	LDA #$60
	STA Sprite_RAM+$FF

	LDA <Pad_Input
	AND #(PAD_UP | PAD_DOWN)
	BEQ Gameover_Menu_NotUD

	LDA Level_PauseSelect
	EOR #1
	STA Level_PauseSelect

Gameover_Menu_NotUD:
	LDA <Pad_Input
	AND #(PAD_A | PAD_START)
	BEQ Gameover_Menu_NotAS
	
	LDA Level_PauseSelect
	BNE Gameover_Menu_No
		
	LDA #SND_LEVEL1UP
	STA Sound_QLevel1

Gameover_Wait1Up:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for VSync
	JSR Level_DoAnimations
	
	LDA SndCur_Level1
	BNE Gameover_Wait1Up
	
	JSR Sprite_RAM_Clear
	
	; Give you 5 lives (you'll lose one on exit)
	LDX Player_Current
	LDA #5
	STA Player_Lives,X

	; SCORE IS GONE
	LDA #0
	STA Score_Earned
	STA Player_Score
	STA Player_Score+1
	STA Player_Score+2

	; Lose a midway point too
	LDA LevCP_ByPlayer,X
	TAX
	LDA #$FF
	STA LevCP_ID,X
	

	RTS

Gameover_LevCP

Gameover_Menu_NotAS:
	JMP Gameover_Continue_Menu
	
Gameover_Menu_No:
	; Current player is dead...
	
	LDA Total_Players
	CMP #1
	BEQ PlayerDie_GO1P	; If 1P game, jump to PlayerDie_GO1P
	
	; 2P mode, need to see if both players are done
	LDA Player_Current
	EOR #1
	TAX
	
	LDA Player_Lives,X
	CMP #$FF
	BNE PRG029_D702	; If the other player is still in, jump to PRG029_D702
	
PlayerDie_GO1P:	
	;JSR_THUNKA 26, Palette_DoFadeOut
	
	; Else, reset (??)
	LDA #0
	STA Reset_Latch
	
PRG029_D702:
	RTS		 ; Return

YESNO_Sprites:
	.byte $0D	; Y
	.byte $0B	; E
	.byte $1D	; S
	.byte $1F	; N
	.byte $2F	; O

YESNO_SpriteXs:
	.byte $68, $70, $78, $68, $70

YESNO_SpriteYs:
	.byte $75, $75, $75, $85, $85

CONTINUE_Sprites:
	.byte $01	; C
	.byte $03	; ON
	.byte $05	; NT
	.byte $07	; IN
	.byte $09	; NU
	.byte $0B	; E

	; Patterns for TIME-UP
TIMEUP_Sprites:
	.byte $21	; T
	.byte $23	; I
	.byte $25	; M
	.byte $27	; E
	.byte $29	; -
	.byte $2B	; U
	.byte $2D	; P

	; Patterns for GAMEOVER
GAMEOVER_Sprites:
	.byte $31	; G
	.byte $33	; A
	.byte $35	; M
	.byte $37	; E
	.byte $39	; O
	.byte $3B	; V
	.byte $3D	; E
	.byte $3F	; R
TIMEUPGAMEOVER_SpriteEnd

	; X positions for each letter in TIME-UP
TIMEUP_SpriteXs:
	.byte $60, $68, $70, $78, $80, $88, $90

	; X positions for each letter in GAMEOVER
GAMEOVER_SpriteXs:
	.byte $60, $68, $70, $78, $80, $88, $90, $98


Player_Die_TUGO_Check:
	LDA Player_ReverseGrav
	BEQ PDTUGO_NotRev
	
	; Reverse gravity...
	LDA Player_AboveTop
	BNE PDTUGO_IsOffScreen	; If off top of screen, jump to PDTUGO_IsOffScreen
	BEQ PDTUGO_CheckNotOffScreen

PDTUGO_NotRev:
	LDA Level_7Vertical
	BNE PDTUGO_NotVert
	
	; Fix for Big Bertha: If Player's Y Hi is really big in a non-vertical level, count it!
	LDA <Player_YHi
	CMP #2
	BGE PDTUGO_IsOffScreen

PDTUGO_NotVert:
	LDA Player_AboveTop
	BNE PDTUGO_CheckNotOffScreen	 ; If Player is off top of screen, jump to PRG029_D71E

	LDA <Player_SpriteY
	AND #$f0
	CMP #$b0
	BEQ PDTUGO_IsOffScreen	 ; If Player_SpriteY >= $B0 && Player_SpriteY <= $BF (Player is halfway below status bar), jump to PRG029_D729

PDTUGO_CheckNotOffScreen:
	CLC
	RTS

PDTUGO_IsOffScreen:
	SEC
	RTS



Player_Die_TimeUp:
	JSR Player_Die_TUGO_Check
	BCS PRG029_D729		; If Player is off-screen, jump to PRG029_D729

	LDA Event_Countdown
	BNE PRG029_D726	 ; If Event_Countdown <> 0, jump to PRG029_D726

	JMP PRG029_D768	 ; Jump to PRG029_D768

PRG029_D726:
	JMP PRG029_D771	 ; Jump to PRG029_D768 if Event_Countdown <> 0

PRG029_D729:
	DEC <Pipe_PlayerY	; Pipe_PlayerY--

	LDA <Pipe_PlayerX
	CMP #$60
	BLT PRG029_D73B	 ; If Pipe_PlayerX < $60, jump to PRG029_D73B

	ADD <Pipe_PlayerY
	STA <Pipe_PlayerX	; Pipe_PlayerX += Pipe_PlayerY

	LDA #112
	STA Event_Countdown	 ; Event_Countdown = 112

PRG029_D73B:
	LDA Event_Countdown
	BEQ PRG029_D6FB_fix	 ; If Event_Countdown = 0, jump to PRG029_D6FB

	LDA #$32
	STA PatTable_BankSel+2	 ; Set sprites 1/4 VROM page for the TIME UP sprites

	LDX Player_SprOff	 ; Starting from Player's sprite offset

	LDY #(GAMEOVER_Sprites - TIMEUP_Sprites - 1) 	 ; TIME-UP sprites

	LDA <Player_IsDying
	CMP #4
	BNE PRG029_D74A

Gameover_Menu_Draw:
	LDY #(TIMEUPGAMEOVER_SpriteEnd - TIMEUP_Sprites - 1) 	 ; GAME OVER sprites

PRG029_D74A:
	LDA <Pipe_PlayerX
	STA Sprite_RAM+$00,X

	LDA TIMEUP_Sprites,Y
	STA Sprite_RAM+$01,X

	LDA #$01
	STA Sprite_RAM+$02,X

	LDA TIMEUP_SpriteXs,Y
	STA Sprite_RAM+$03,X

	INX
	INX
	INX
	INX
	DEY		; Y--
	CPY #(GAMEOVER_Sprites - TIMEUP_Sprites - 1)
	BEQ TOorGOSpritesDone
	CPY #-1
	BNE PRG029_D74A	 ; While Y >= 0, loop

TOorGOSpritesDone:
	RTS		 ; Return

PRG029_D6FB_fix:
	JMP PRG029_D6FB

PRG029_D768:
	; Player gravity while dying
	INC <Player_YVel
	INC <Player_YVel ; Player_YVel += 2

	LDX #$00	 ; X = 0 (?)

	JSR Player_ApplyYVelocity	 ; Applies Player's Y velocity

PRG029_D771:
	LDA #PF_DIE
	STA <Player_Frame ; Player_Frame = PF_DIE

	JSR Player_Draw	 ; Draw Player
	RTS		 ; Return


	; Move Player left/right within pipe
PipeMove_LeftRight:
	LDA Level_PipeMove 
	AND #$01	 ; Just determining left or right (see def for Level_PipeMove)
	TAY		 ; Y = 0 (right) or 1 (left) 

	LDA PipeMove_XVel,Y	 	; Get appropriate X velocity
	STA <Player_XVel	 	; Set it!

	JSR Player_ApplyXVelocity 	; Apply Player's X velocity

	; A little "step up" into the pipe
	DEC <Player_Y
	DEC <Player_Y	 ; Player_Y -= 2

	LDA <Counter_1
	AND #$0c	
	LSR A		
	LSR A		 
	STA <Temp_Var1	 ; Temp_Var1 = (Counter_1 & $C) >> 2 (0 to 3, walking animation)

	JSR PRG029_D47E	 ; Do walking animation and draw Player

	; Undo "step up"
	INC <Player_Y
	INC <Player_Y	 ; Player_Y += 2

	RTS		 ; Return

PipeMove_UpDown_RG:
	LDA Level_PipeMove
	EOR Player_ReverseGrav
	JMP PipeMove_UpDown_Cont

	; Move Player up/down within pipe
PipeMove_UpDown:
	LDA Level_PipeMove
	
PipeMove_UpDown_Cont:
	AND #$01	 ; Just determining up or down (see def for Level_PipeMove)
	TAY		 ; Y = 0 (down) or 1 (up)

	LDA PipeMove_YVel,Y	 	; Get appropriate Y velocity
	STA <Player_YVel	 	; Set it!

	JSR Player_ApplyYVelocity	; Apply Player's Y velocity

	JSR PipeMove_SetPlayerFrame	; Set appropriate frame for pipe traversal
	JMP Player_Draw	 		; Jump to draw Player!

Player_StopMovement:
	LDA #$00
	STA Level_PipeMove	; Not moving through a pipe
	STA <Player_XVel	; Player stopped horizontall
	STA <Player_YVel	; Player stopped vertically
	STA <Player_InAir	; Not mid-air
	RTS		 ; Return

SuitLost_Poof_Patterns:
	.byte $47, $45, $43, $41

Player_SuitLost_DoPoof:
	DEC Player_SuitLost	; Player_SuitLost-- 
	AND #$0c
	LSR A	
	LSR A	
	TAY		 ; Y = 0-3, changing every 4 ticks

	LDA SuitLost_Poof_Patterns,Y	; Get poof pattern
	STA <Temp_Var2		 ; Store into Temp_Var2

	LDY Player_SprOff	 ; Y = Player_SprOff (Player sprite beginning offset)

	LDA #%11000001	; Flipped horizontal and vertical, and palette 1
	STA <Temp_Var1	; -> Temp_Var1

PRG029_D7D3:
	; Sprite Y
	LDA <Player_SpriteY
	ADD #$08	 	; Start at 8 pixels below Player sprite Y pos
	STA Sprite_RAM+$00,Y	 ; Store into sprite Y

	; Poof pattern
	LDA <Temp_Var2
	STA Sprite_RAM+$01,Y

	; Attribute
	LDA <Temp_Var1
	STA Sprite_RAM+$02,Y

	; Sprite X
	LDA <Player_X
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	LDA <Temp_Var1
	AND #$f0	
	BEQ PRG029_D7FC	 ; If we're the unflipped one, jump to PRG029_D7FC

	; Otherwise, put it to the right of the first one
	LDA Sprite_RAM+$03,Y
	ADD #$08	
	STA Sprite_RAM+$03,Y

PRG029_D7FC:
	INY
	INY
	INY
	INY		 ; Y += 4

	; Other sprite is not H/V flipped
	LDA <Temp_Var1
	SUB #%11000000
	STA <Temp_Var1

	BCS PRG029_D7D3	 ; Loop if not the second sprite

	RTS		 ; Return
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BlockChange_Do
;
; Performs a Block Change command, if one is needed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BlockChange_Do:
	LDA Level_7Vertical	 
	BEQ PRG029_DC36	 ; If level is not vertical, jump to PRG029_DC36

	; Vertical level only...

	; Fix Block Change Y coordinates for vertical world
	LDA Level_BlockChgYLo
	LDY Level_BlockChgYHi
	JSR LevelJct_GetVScreenH
	STA Level_BlockChgYLo
	STY Level_BlockChgYHi

	; Get tile here
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Temp_Var6 = block change screen Y aligned to grid
	LDA Level_BlockChgYLo
	AND #$f0
	STA <Temp_Var6

	; Build row/column offset value -> Temp_Var5
	LDA Level_BlockChgXLo
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var6
	STA <Temp_Var5

	; Temp_Var7 = 0
	LDA #$00
	STA <Temp_Var7

	BEQ PRG029_DC7C	 ; Jump (technically always) to PRG029_DC7C

PRG029_DC36:

	; Non-vertical level only...

	LDA Level_BlockChgXHi
	ASL A		 ; Multiply by 2 (2 byte index per Tile_Mem_Addr)
	TAX		 ; -> 'X'

	; Set address in tile memory to Map_Tile_AddrL/H
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	; Temp_Var7 = 0
	LDA #$00
	STA <Temp_Var7

	LDA Level_BlockChgYHi
	BEQ PRG029_DC50	 ; If block change is not on the lower part of the screen, jump to PRG029_DC50

	INC <Map_Tile_AddrH	; Otherwise, jump to lower screen address

PRG029_DC50:

	; Construct a row/column offset -> Temp_Var5
	LDA Level_BlockChgYLo
	AND #$f0
	STA <Temp_Var6
	LDA Level_BlockChgXLo
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var6
	STA <Temp_Var5

	LDA Level_BlockChgYHi
	BNE PRG029_DC70	 ; If Level_BlockChgYHi <> 0 (block change is down low on the lower screen space), jump to PRG029_DC70

	; Block change is on upper screen space... 

	LDA Level_BlockChgYLo
	AND #$f0	 ; Align to grid
	CMP #$f0
	BNE PRG029_DC7C	 ; If not TOO low, jump to PRG029_DC7C

PRG029_DC70:

	; Block is on upper part of screen but at the 240 line
	; This logic calculates an alternate address because the code that actually
	; applies the tile change needs to have a 32 byte jump to the next line,
	; and use $F0 would overflow back to $10 and misalign the tile change!!

	; Temp_Var6 = 0-ish
	LDA Level_BlockChgYLo
	ADD #$10
	STA <Temp_Var6

	; Temp_Var7 = 1 (carry)
	LDA #$01
	STA <Temp_Var7

PRG029_DC7C:
	LDA Level_ChgTileEvent
	BNE PRG029_DC82	 ; If Level_ChgTileEvent <> 0, jump to PRG029_DC82

	; Otherwise, do nothing... seems like they should've checked for
	; this BEFORE bothering with all those calculations!  :)

FixAttr_OffScreen:
	RTS		 ; Return

PRG029_DC82:

	; SB: New feature: If bit 7 is set, also update the attributes after setting the tile!
	; Note this will only work correctly with "TileChng_OneTile" events, so be nice plz
	AND #$80
	BEQ TileChng_Normal

	; Bit 7 set...
	LDA Level_ChgTileEvent
	AND #$7F			; Clear bit 7
	STA Level_ChgTileEvent

	JSR TileChng_Normal		; Change the tile, as always

	LDA Level_BlockChgXLo
	CMP <Horz_Scroll
	LDA Level_BlockChgXHi
	SBC <Horz_Scroll_Hi
	BNE FixAttr_OffScreen	; SB: If tile change is horizontally off-screen, jump to FixAttr_OffScreen (RTS)

	JMP TileChng_OneTile_FixAttr	; Now patch the attributes!

TileChng_Normal:
	LDA Level_ChgTileEvent
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word TileChng_DoNothing	; $00 - NOT USED (Level_ChgTileEvent = 0 not valid)
	.word TileChng_OneTile		; $01 - CHNGTILE_DELETECOIN
	.word TileChng_OneTile		; $02 - CHNGTILE_DELETETOBG
	.word TileChng_OneTile		; $03 - CHNGTILE_TOGNOTEBLOCK
	.word TileChng_OneTile		; $04 - CHNGTILE_TOBOUNCEWOOD
	.word TileChng_OneTile		; $05 - CHNGTILE_TONOTEBLOCK
	.word TileChng_OneTile		; $06 - CHNGTILE_COINHEAVEN
	.word TileChng_OneTile		; $07 - CHNGTILE_TOBRICK
	.word TileChng_OneTile		; $08 - CHNGTILE_TOMETALPLATE
	.word TileChng_OneTile		; $09 - CHNGTILE_PSWITCHSTOMP
	.word TileChng_OneTile		; $0A (Change to Fortress light cable??)
	.word TileChng_OneTile		; $0B - CHNGTILE_TOBRICKCOIN
	.word TileChng_OneTile		; $0C - CHNGTILE_DELETETOBGALT (not sure about this one)
	.word TileChng_OneTile		; $0D - not different from $02??
	.word TileChng_OneTile		; $0E - CHNGTILE_PIPEJCT
	.word TileChng_OneTile		; $0F - CHNGTILE_DELETEDONUT
	.word TileChng_OneTile		; $10 - CHNGTILE_FROZENMUNCHER
	.word TileChng_OneTile		; $11 - CHNGTILE_FROZENCOIN
	.word TileChng_OneTile		; $12 - CHNGTILE_PSWITCHAPPEAR
	.word TileChng_OneTile		; $13 - CHNGTILE_ACTSWAPPEAR
	.word TileChng_OneTile		; $14 - CHNGTILE_QUICKSAND_TOP9
	.word TileChng_OneTile		; $15 - CHNGTILE_QUICKSAND_MID9
	.word TileChng_OneTile		; $16 - CHNGTILE_ACTQBLOCK
	.word TileChng_OneTile		; $17 - CHNGTILE_PSWITCHSTOMPR
	.word TileChng_OneTile		; $18 - CHNGTILE_ACTSWAPPEAR_R
	.word TileChng_OneTile		; $19 - RESERVE
	.word TileChng_OneTile		; $1A - RESERVE
	.word TileChng_OneTile		; $1B - RESERVE
	.word TileChng_OneTile		; $1C - RESERVE
	.word TileChng_OneTile		; $1D - RESERVE
	.word TileChng_OneTile		; $1E - RESERVE
	.word TileChng_OneTile		; $1F - RESERVE
	.word ChngTile_32x32		; $20 - CHNGTILE_4WAYCANNON
	.word ChngTile_32x32		; $21 - GiantBlock_BrickBust
	.word ChngTile_32x32		; $22 - GiantBlock_BlockHit
	.word ChngTile_32x32		; $23 - GiantBlock_BrickRestore
	.word ChngTile_32x32		; $24 - CHNGTILE_PIPERAISE1
	.word ChngTile_32x32		; $25 - CHNGTILE_PIPERAISE2
	.word ChngTile_32x32		; $26 - CHNGTILE_PIPERAISE3
	.word ChngTile_32x32		; $27 - CHNGTILE_PIPERAISE4
	.word $0000					; $28 - RESERVE
	.word $0000					; $29 - RESERVE
	.word $0000					; $2A - RESERVE
	.word $0000					; $2B - RESERVE
	.word $0000					; $2C - RESERVE
	.word $0000					; $2D - RESERVE
	.word $0000					; $2E - RESERVE
	.word $0000					; $2F - RESERVE
	.word ChngTile_FenceRot		; $30 - CHNGTILE_FENCEROT1
	.word ChngTile_FenceRot		; $31 - CHNGTILE_FENCEROT2
	.word ChngTile_FenceRot		; $32 - CHNGTILE_FENCEROT3
	.word ChngTile_SandTopMid	; $33 - CHNGTILE_SANDTOPMID

	;.word TileChng_DoorAppear	; $xx - CHNGTILE_DOORAPPEAR
	;.word TileChng_ToadBoxOpen	; $xx - CHNGTILE_TOADBOXOPEN


	; Tile to "change to"; just for updating the level grid
	; NOTES: 
	; TILE2_HANGGLOBE_CABLE -- only tile that made visual sense as a standalone ??
	; TILE9_PIPEWORKS_CRACK -- not sure about this one
	; TILE2_SPIKEUP -- only tile that made visual sense as a standalone ??
OneTile_ChangeToTile:
	.byte TILEA_COINREMOVED		; $01 - CHNGTILE_DELETECOIN
	.byte TILE1_SKY			; $02 - CHNGTILE_DELETETOBG
	.byte TILEA_GNOTE		; $03 - CHNGTILE_TOGNOTEBLOCK
	.byte TILEA_WOODBLOCKBOUNCE	; $04 - CHNGTILE_TOBOUNCEWOOD
	.byte TILEA_NOTE		; $05 - CHNGTILE_TONOTEBLOCK
	.byte TILEA_HNOTE		; $06 - CHNGTILE_COINHEAVEN
	.byte TILEA_BRICK		; $07 - CHNGTILE_TOBRICK
	.byte TILEA_BLOCKEMPTY		; $08 - CHNGTILE_TOMETALPLATE
	.byte TILEA_PSWITCH_PRESSED	; $09 - CHNGTILE_PSWITCHSTOMP
	.byte TILE2_HANGGLOBE_CABLE	; $0A
	.byte TILEA_BRICKCOIN		; $0B - CHNGTILE_TOBRICKCOIN
	.byte TILE9_PIPEWORKS_CRACK	; $0C - CHNGTILE_DELETETOBGALT
	.byte TILE1_SKY			; $0D
	.byte TILE9_PIPEWORKS_JCT		; $0E - CHNGTILE_PIPEJCT
	.byte TILE2_DONUTLIFT		; $0F - CHNGTILE_DELETEDONUT
	.byte TILE4_MUNCHER		; $10 - CHNGTILE_FROZENMUNCHER
	.byte TILEA_COIN		; $11 - CHNGTILE_FROZENCOIN
	.byte TILEA_PSWITCH		; $12 - CHNGTILE_PSWITCHAPPEAR
	.byte TILEA_EXSWITCH	; $13 - CHNGTILE_ACTSWAPPEAR
	.byte TILE9_QUICKSAND_TOP	; $14 - CHNGTILE_QUICKSAND_TOP9
	.byte TILE9_QUICKSAND_MID	; $15 - CHNGTILE_QUICKSAND_MID9
	.byte TILEA_WOODBLOCKSTAR	; $16 - CHNGTILE_ACTQBLOCK
	.byte TILE8_EXSWITCHR_PRESS	; $17 - CHNGTILE_PSWITCHSTOMPR
	.byte TILE8_EXSWITCHR	; $18 - CHNGTILE_ACTSWAPPEAR_R


	; Defines each of the four 8x8 patterns that make up the tile
	; Too bad Nintendo couldn't keep things like this in one spot :)
OneTile_ChangeToPatterns:
	.byte $05, $07, $06, $08	; $01 - CHNGTILE_DELETECOIN
	.byte $05, $07, $06, $08	; $02 - CHNGTILE_DELETETOBG
	.byte $B8, $BA, $B9, $BB	; $03 - CHNGTILE_TOGNOTEBLOCK
	.byte $C0, $C2, $C1, $C3	; $04 - CHNGTILE_TOBOUNCEWOOD
	.byte $B8, $BA, $B9, $BB	; $05 - CHNGTILE_TONOTEBLOCK
	.byte $B8, $BA, $B9, $BB	; $06 - CHNGTILE_COINHEAVEN
	.byte $B4, $B6, $B5, $B7	; $07 - CHNGTILE_TOBRICK
	.byte $D8, $DA, $D9, $DB	; $08 - CHNGTILE_TOMETALPLATE
	.byte $FF, $FF, $E6, $E7	; $09 - CHNGTILE_PSWITCHSTOMP
	.byte $60, $61, $6D, $6F	; $0A
	.byte $B4, $B6, $B5, $B7	; $0B - CHNGTILE_TOBRICKCOIN
	.byte $52, $50, $62, $60	; $0C - CHNGTILE_DELETETOBGALT
	.byte $05, $07, $06, $08	; $0D
	.byte $18, $1A, $19, $1B	; $0E - CHNGTILE_PIPEJCT
	.byte $5C, $5E, $5D, $5F	; $0F - CHNGTILE_DELETEDONUT
	.byte $92, $CA, $93, $CB	; $10 - CHNGTILE_FROZENMUNCHER
	.byte $DC, $DE, $DD, $DF	; $11 - CHNGTILE_FROZENCOIN
	.byte $E0, $E2, $E1, $E3	; $12 - CHNGTILE_PSWITCHAPPEAR
	.byte $F8, $FA, $F9, $FB	; $13 - CHNGTILE_ACTSWAPPEAR
	.byte $D5, $D5, $B2, $B2	; $14 - CHNGTILE_QUICKSAND_TOP9
	.byte $B2, $B2, $B2, $B2	; $15 - CHNGTILE_QUICKSAND_MID9
	.byte $98, $9A, $99, $9B	; $16 - CHNGTILE_ACTQBLOCK
	.byte $2A, $2B, $FF, $FF	; $17 - CHNGTILE_ACTQBLOCK
	.byte $F1, $F3, $F0, $F2	; $18 - CHNGTILE_ACTSWAPPEAR_R


TileChng_OneTile:
	LDX Level_ChgTileEvent
	DEX		 ; X = Level_ChgTileEvent - 1 (because zero is no-action)

	LDY <Temp_Var5	 ; Y = Temp_Var5 (row/column offset value)

	; Change the tile to the proper target tile
	LDA OneTile_ChangeToTile,X
	STA [Map_Tile_AddrL],Y

	LDA Level_BlockChgXLo
	CMP <Horz_Scroll
	LDA Level_BlockChgXHi
	SBC <Horz_Scroll_Hi
	BNE TileChng_OffScreen	; SB: If tile change is horizontally off-screen, jump to TileChng_OffScreen

	; X *= 4 (index into OneTile_ChangeToPatterns)
	TXA
	ASL A
	ASL A
	TAX

	LDY #$00	 ; Y = 0
PRG029_DD22:
	LDA OneTile_ChangeToPatterns,X	 ; Get pattern
	STA TileChng_Pats,Y	 ; Copy into TileChng_Pats

	INX		 ; X++ (next pattern)
	INY		 ; Y++ (count of patterns)
	CPY #$04
	BNE PRG029_DD22	 ; While Y < 4, loop!

	LDA <Temp_Var6	 ; Get tile Y (aligned to grid, so bits 0-3 are zero)
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0 (result: Former bit 6-7 are now bit 0-1)
	PHA		 ; Save this value

	AND #%00001111	 ; Only keep lower 4 bits (bits 2 and 3 are still zero)
	ORA #$20	 ; Set high part of video address

	LDY <Temp_Var7
	BEQ PRG029_DD41	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to PRG029_DD41

	ORA #$08	 ; Set $28 high address

PRG029_DD41:
	STA TileChng_VRAM_H	 ; Store the high byte of the tile change base address

	PLA		; Restore value from before
	AND #%11110000	; Keep the upper 4 bits
	STA <Temp_Var2	; -> Temp_Var2

	LDA Level_BlockChgXLo
	LSR A
	LSR A
	LSR A		; A = Level_BlockChgXLo / 8
	ORA <Temp_Var2	
	STA TileChng_VRAM_L	 ; Store the low byte of the tile change base address

TileChng_OffScreen:
	; Level_ChgTileEvent = 0 (we handled it)
	LDA #$00
	STA Level_ChgTileEvent

TileChng_DoNothing:
	RTS		 ; Return

TileChng_DoorBufCmds:
	; First two bytes for both are to-be-determined VRAM addres
	.byte $00, $00, VU_VERT | VU_REPEAT | 4, $FC	; Left 4 patterns of door
	.byte $00, $00, VU_VERT | VU_REPEAT | 4, $FC	; Right 4 patterns of door
	.byte $00	; Terminator
TileChng_DoorBufCmds_End

TileChng_DoorAppear:

	; Level_ChgTileEvent = 0 (we're handling it)
	LDA #$00
	STA Level_ChgTileEvent

	LDY <Temp_Var5	 ; Y = Temp_Var5 (row/column offset value)

	; Set upper tile of door
	LDA #TILEA_DOOR1
	STA [Map_Tile_AddrL],Y

	; +16 (next row of tiles)
	TYA
	ADD #16
	TAY

	BCC PRG029_DD77	 ; If no carry, jump to PRG029_DD77

	INC <Map_Tile_AddrH	; Apply carry

PRG029_DD77:

	; Set lower tile of door
	LDA #TILEA_DOOR1
	STA [Map_Tile_AddrL],Y

	LDY #$00	 ; Y = 0

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

PRG029_DD80:
	LDA TileChng_DoorBufCmds,Y	; Get next command byte
	STA Graphics_Buffer,X	 	; Store into graphics buffer

	INX		 ; X++ (one more byte in the graphics buffer)
	INY		 ; Y++ (next command byte)

	CPY #(TileChng_DoorBufCmds_End - TileChng_DoorBufCmds)
	BNE PRG029_DD80	; While more to commit, loop!

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	LDA <Temp_Var6	 ; Get tile Y (aligned to grid, so bits 0-3 are zero)
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0 (result: Former bit 6-7 are now bit 0-1)
	PHA		 ; Save this value

	AND #%00001111	 ; Only keep lower 4 bits (bits 2 and 3 are still zero)
	ORA #$20	 ; Set high part of video address

	LDY <Temp_Var7
	BEQ PRG029_DDA2	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to PRG029_DDA2

	ORA #$08	 ; Set $28 high address

PRG029_DDA2:

	; Commit high addresses to graphics buffer
	STA Graphics_Buffer,X
	STA Graphics_Buffer+$04,X

	PLA		; Restore value from before
	AND #%11110000	; Keep the upper 4 bits
	STA <Temp_Var2	; -> Temp_Var2

	LDA Level_BlockChgXLo
	LSR A
	LSR A
	LSR A		; A = Level_BlockChgXLo / 8
	ORA <Temp_Var2	

	; Set low address for left column of patterns of door
	STA Graphics_Buffer+$01,X

	ADD #$01	 ; Next column of door

	; Set low address for right column of patterns of door
	STA Graphics_Buffer+$05,X

	; Add array size -1 to graphics buffer count
	LDA Graphics_BufCnt
	ADD #(TileChng_DoorBufCmds_End - TileChng_DoorBufCmds - 1)
	STA Graphics_BufCnt

	RTS		 ; Return


	; Change Big Buffer Command offset
CBIG_BCOff .func \1 - Chng4Way_90Degrees

	; Get initial offset to proper set of commands to be used
CBig_Offsets:
	.byte CBIG_BCOff(Chng4Way_90Degrees)	; 4-way cannon at 90 degrees
	.byte CBIG_BCOff(Chng4Way_45Degrees)	; 4-way cannon at 45 degrees

	.byte CBIG_BCOff(CBig_GiantBlock_BrickBust)	; GiantBlock_BrickBust
	.byte CBIG_BCOff(CBig_GiantBlock_BlockHit)	; GiantBlock_BlockHit
	.byte CBIG_BCOff(CBig_GiantBlock_BrickRestore)	; GiantBlock_BrickRestore
	
	.byte CBIG_BCOff(Chng_PipeRaise)	; Pipe raise stage 1
	.byte CBIG_BCOff(Chng_PipeRaise)+7	; Pipe raise stage 2
	.byte CBIG_BCOff(Chng_PipeRaise)+14	; Pipe raise stage 3
	.byte CBIG_BCOff(Chng_PipeRaise)+21	; Pipe raise stage 4

Chng4Way_90Degrees:
	.byte $00, $00, $04, $FF, $A6, $A7, $FF
	.byte $00, $00, $04, $8D, $B2, $BC, $8D
	.byte $00, $00, $04, $9D, $B3, $BD, $9D
	.byte $00, $00, $04, $FF, $AE, $AF, $FF
	.byte $00

Chng4Way_45Degrees:
	.byte $00, $00, $04, $09, $28, $36, $49
	.byte $00, $00, $04, $EC, $ED, $EE, $EF
	.byte $00, $00, $04, $E8, $E9, $EA, $EB
	.byte $00, $00, $04, $F8, $F9, $FA, $FB
	.byte $00

CBig_GiantBlock_BrickBust:
	.byte $00, $00, $04, $05, $07, $05, $07
	.byte $00, $00, $04, $06, $08, $06, $08
	.byte $00, $00, $04, $05, $07, $05, $07
	.byte $00, $00, $04, $06, $08, $06, $08
	.byte $00

CBig_GiantBlock_BlockHit:
	.byte $00, $00, $04, $04, $0D, $0D, $0E
	.byte $00, $00, $04, $24, $FE, $FE, $27
	.byte $00, $00, $04, $24, $FE, $FE, $27
	.byte $00, $00, $04, $34, $48, $48, $37
	.byte $00

CBig_GiantBlock_BrickRestore:
	.byte $00, $00, $04, $00, $01, $02, $03
	.byte $00, $00, $04, $10, $11, $12, $10
	.byte $00, $00, $04, $20, $21, $22, $23
	.byte $00, $00, $04, $30, $31, $32, $33
	.byte $00

	; SB: Provides a "raising pipe" a la Paper Mario
	; Still pushes as much data as the above entries,
	; but starts at different offsets going down to
	; provide a "raising up" effect...
Chng_PipeRaise:	
	.byte $00, $00, $04, $FF, $FF, $FF, $FF
	.byte $00, $00, $04, $FF, $FF, $FF, $FF
	.byte $00, $00, $04, $FF, $FF, $FF, $FF
	.byte $00, $00, $04, $8C, $8D, $8E, $8F		; Stage 1 End
	.byte $00, $00, $04, $9C, $9D, $9E, $9F		; Stage 2 End
	.byte $00, $00, $04, $AC, $AD, $AE, $AF		; Stage 3 End
	.byte $00, $00, $04, $AC, $AD, $AE, $AF		; Stage 4 End
	.byte $00

CBIG_BCSize = Chng4Way_45Degrees - Chng4Way_90Degrees

PRG029_DECA:
	.byte $96, $92

CBig_ChngTiles:
	.byte TILE10_4WAYCANNON_90_UL, TILE10_4WAYCANNON_90_UR, TILE10_4WAYCANNON_90_LL, TILE10_4WAYCANNON_90_LR ; 4-way cannon 90 degrees
	.byte TILE10_4WAYCANNON_45_UL, TILE10_4WAYCANNON_45_UR, TILE10_4WAYCANNON_45_LL, TILE10_4WAYCANNON_45_LR ; 4-way cannon 45 degrees
	.byte TILE11_SKY, TILE11_SKY, TILE11_SKY, TILE11_SKY	; Giant World brick bust tile clear
	.byte TILE11_METAL_UL, TILE11_METAL_UR, TILE11_METAL_LL, TILE11_METAL_LR	; Giant World [?] block hit
	.byte TILE11_BRICK_UL, TILE11_BRICK_UR, TILE11_BRICK_LL, TILE11_BRICK_LR	; Giant World brick bump
	.byte TILE1_SKY, TILE1_SKY, TILE1_SKY, TILE1_SKY					; Pipe raise stage 1
	.byte TILE1_SKY, TILE1_SKY, TILE1_PIPETB1_L, TILE1_PIPETB1_R		; Pipe raise stage 2
	.byte TILE1_SKY, TILE1_SKY, TILE1_PIPETB1_L, TILE1_PIPETB1_R		; Pipe raise stage 3
	.byte TILE1_PIPETB1_L, TILE1_PIPETB1_R, TILE1_PIPEVL, TILE1_PIPEVR	; Pipe raise stage 4


ChngTile_32x32:
	LDX #$00	; X = 0

	LDA Level_ChgTileEvent
	CMP #CHNGTILE_4WAYCANNON
	BNE PRG029_DEF3	 ; If this is not the 4-way cannon change, jump to PRG029_DEF3

	; 4-way cannon change only...

	LDY <Temp_Var5	 ; Y = Temp_Var5 (row/column offset value)

	LDA [Map_Tile_AddrL],Y	 ; Get tile currently here
	CMP #TILE10_4WAYCANNON_45_UL
	BEQ PRG029_DEF9	 ; If cannon is at 45 degree position, jump to PRG029_DEF9
	BNE PRG029_DEF8	 ; Otherwise, jump to PRG029_DEF8

PRG029_DEF3:

	; Not the 4-way cannon...
	SUB #CHNGTILE_GIANTBRICKBUST	; Make relative
	TAX		 ; -> 'X'
	INX		 ; X++

PRG029_DEF8:
	INX		 ; X++ (X = 1 for 4-way cannon, 2+ for the others)

PRG029_DEF9:
	LDY CBig_Offsets,X	 ; Y = initial command offset

	STX <Temp_Var11		 ; Temp_Var11 = X (index into CBig_Offsets)

	LDX Graphics_BufCnt	 ; X = graphics buffer count

	; Temp_Var1 = total number of bytes we're going to copy (CBIG_BCSize)
	LDA #CBIG_BCSize
	STA <Temp_Var1

PRG029_DF05:
	LDA Chng4Way_90Degrees,Y	; Get next command byte
	STA Graphics_Buffer,X	 	; Store into graphics buffer

	INX		 ; X++ (one more byte in the graphics buffer)
	INY		 ; Y++ (next command byte)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG029_DF05	 ; While Temp_Var1 > 0, loop!

	; Temp_Var11 (index into CBig_Offsets) multiplied by 4
	LDA <Temp_Var11
	ASL A
	ASL A
	STA <Temp_Var11

	; Temp_Var3 = 0
	LDA #$00
	STA <Temp_Var3

PRG029_DF1B:
	LDA <Temp_Var5	; A = Temp_Var5 (row/column offset value)
	AND #$f0	; Just keep the row part

	LDY <Temp_Var7	; Y = Temp_Var7
	BEQ PRG029_DF26	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to PRG029_DF26

	ADD #$10	 ; Next row

PRG029_DF26:
	STA <Temp_Var6	 ; -> Temp_Var6

	LDA <Temp_Var5	; A = Temp_Var5 (row/column offset value)
	AND #$0f	; Just keep the column part
	ASL A		; Multiply by 2
	STA <Temp_Var8	; -> Temp_Var8

	LDA <Temp_Var6	 ; Get tile Y (aligned to grid, so bits 0-3 are zero)
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0 (result: Former bit 6-7 are now bit 0-1)
	PHA		 ; Save this value

	AND #%00000011	 ; Only keep lower 2 bits
	ORA #$20	 ; Set high part of video address

	LDY <Temp_Var7	; Y = Temp_Var7
	BEQ PRG029_DF42	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to PRG029_DF42

	ORA #$08	 ; Set $28 high address

PRG029_DF42:
	STA <Temp_Var9	 ; -> Temp_Var9

	LDX #$00	 ; X = 0 (first tile row buffer offset)

	LDA <Temp_Var3
	BEQ PRG029_DF4C	 ; If Temp_Var3 = 0 (loop first pass), jump to PRG029_DF4C

	LDX #$0e	 ; Otherwise, X = $0E (second tile row buffer offset)

PRG029_DF4C:

	; X += current graphics buffer count
	TXA
	ADD Graphics_BufCnt
	TAX

	; Commit high addresses to graphics buffer
	LDA <Temp_Var9
	STA Graphics_Buffer,X
	STA Graphics_Buffer+$07,X

	PLA		; Restore value from before
	AND #%11110000	; Keep the upper 4 bits
	ORA <Temp_Var8	; The column value
	STA <Temp_Var4	; -> Temp_Var4

	; Set low address in graphics buffer
	STA Graphics_Buffer+$01,X

	ADD #32		; +32 is next row

	; Set low address in graphics buffer
	STA Graphics_Buffer+$08,X

	LDY <Temp_Var5	 ; Y = Temp_Var5
	LDX <Temp_Var11	 ; X = Temp_Var11

	LDA CBig_ChngTiles,X	 ; Get tile 
	STA [Map_Tile_AddrL],Y	 ; Set tile
	INY		 ; Next column
	LDA CBig_ChngTiles+1,X	 ; Get tile
	STA [Map_Tile_AddrL],Y	 ; Set tile

	; Temp_Var5 += 16 (next tile row)
	LDA <Temp_Var5
	ADD #16
	STA <Temp_Var5

	; Apply carry if needed
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	; Temp_Var11 += 2
	INC <Temp_Var11
	INC <Temp_Var11

	INC <Temp_Var3	; Temp_Var3++

	LDA <Temp_Var3
	CMP #$02
	BNE PRG029_DF1B	 ; While Temp_Var3 < 2, loop!

	; Add array size -1 to graphics buffer count
	LDA Graphics_BufCnt
	ADD #(CBIG_BCSize - 1)
	STA Graphics_BufCnt

	; Level_ChgTileEvent = 0 (redundant!)
	LDA #$00
	STA Level_ChgTileEvent

	INC Level_SkipStatusBarUpd	; Set Level_SkipStatusBarUpd (skip status bar for a frame, priority update!)

	RTS		 ; Return


	; Extended method to fix attributes after updating tile (non-vertical)
TileChng_OneTile_FixAttr:

	; Will be used as offset if on lower screen
	LDA #0
	STA <Temp_Var6

	; SB: Due to the shape of the nametable (256 x 240), this makes it not evenly divisible by 32
	; in the total vertical size.  This means if we're working with a tile that is on the lower 
	; screen, we must subtract 1 row to remain properly aligned to the tile grid!
	LDA Level_BlockChgYHi
	BNE FixAttr_Lower
	LDA Level_BlockChgYLo
	CMP #$F0
	BLT FixAttr_NotLower

FixAttr_Lower:

	; Lower screen offset:
	LDA #$10
	STA <Temp_Var6

	; Take value
	; Add $10
	; Mask it 
	; Subtract $10

	; On lower screen, need to maintain pattern of
	; $F0 -> $F0
	; $00 -> $F0
	; $10 -> $10
	; $20 -> $10
	; etc...
	LDA <Temp_Var5
	ADD #$10
	AND #%11101110
	SUB #$10

	; SB: Fixing a fringe situation here...
	BCS FixAttr_InitNoCarry	; First off, if we haven't wrapped backward (i.e. this didn't happen: Y=$00 -> Y=$F0), jump to FixAttr_InitNoCarry

	; The only time we do anything is if we're on the second row of the bottom screen, which is $10x...
	; The attribute square aligns on the previous row, which is $0Fx...
	; So to get the 4 tiles we need to jump back one row in tile memory for the first two...
	; However, we'll also get a carry signal for row $0Fx, which is improper, and we need to ignore that

	LDY Level_BlockChgYHi
	BEQ FixAttr_InitNoCarry	; If not actually on row $10x, jump to FixAttr_InitNoCarry

	; We're on the fringe row $10x, need to backtrack
	DEC Map_Tile_AddrH

FixAttr_InitNoCarry:
	JMP FixAttr_Cont

FixAttr_NotLower:

	; To align, mask off bit 0 of column and bit 0 of row, so...

	; Get four tiles in affected quad
	LDA <Temp_Var5	 ; A = Temp_Var5 (row/column offset value)
	AND #%11101110	; 'Y' now points to the appropriate upper left corner of affected attribute zone

FixAttr_Cont:
	TAY

	; Each "row" of attribute is 8 bytes.  A "row" is found by taking
	; Level_BlockChgY and dividing by 32 (shifting right 5) and then
	; multiplying by 8 (shifting left 3) so net shift is right 2

	LDA Level_BlockChgYLo	; 111. ....
	ADD <Temp_Var6		; Offset if appropriate
	LSR A			; .111 ....
	LSR A			; ..11 1...
	AND #%00111000		; Keep row bits only
	STA <Temp_Var5		; -> Temp_Var5


	; Each "column" of attribute is 1 byte.  A "col" is found by taking
	; Level_BlockChgX and dividing by 32 (shifting right 5.)
	
	LDA Level_BlockChgXLo	; 111. .... .
	ROL A			; 11.. .... 1
	ROL A			; 1... ...1 1
	ROL A			; .... ..11 1
	ROL A			; .... .111 .
	AND #%00000111		; Keep column bits only
	ORA <Temp_Var5		; Combine with "row" bits
	STA <Temp_Var5		; -> Temp_Var5 (this is the offset into the attribute table)


	; Get top two tiles of affected zone
	LDA [Map_Tile_AddrL],Y
	STA <Temp_Var1
	INY
	LDA [Map_Tile_AddrL],Y
	STA <Temp_Var2

	TYA
	ADD #15
	TAY
	BCC FixAttr_TileNoCarry

	INC <Map_Tile_AddrH

FixAttr_TileNoCarry:

	; Get bottom two tiles of affected zone
	LDA [Map_Tile_AddrL],Y
	STA <Temp_Var3
	INY
	LDA [Map_Tile_AddrL],Y
	STA <Temp_Var4

	; Pack an attribute quadrant

	; Upper left tile will be implicitly shifted over since we're using Temp_Var1

	; Upper right tile
	LDA <Temp_Var2
	JSR TileUpdAttr_MergeAndShift

	; Lower left tile
	LDA <Temp_Var3
	JSR TileUpdAttr_MergeAndShift

	; Lower right tile
	LDA <Temp_Var4
	JSR TileUpdAttr_MergeAndShift

	; Finally time to build graphics buffer...
	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt


	; If Level_BlockChgYHi set, we're on the "lower" screen (so use NT2)
	LSR <Temp_Var6	; ... is now 0 or 8
	LDA #$23
	ADD <Temp_Var6	; $23 for upper screen or $2B for lower
	STA Graphics_Buffer+$00,X

	; Set the offset
	LDA <Temp_Var5
	ADD #$C0
	STA Graphics_Buffer+$01,X

	; Going to insert 1 byte
	LDA #1
	STA Graphics_Buffer+$02,X	

	; Insert the attribute byte
	LDA <Temp_Var1
	;LDA #0
	STA Graphics_Buffer+$03,X

	; Terminator
	LDA #0
	STA Graphics_Buffer+$04,X

	; Update Graphics_BufCnt
	TXA
	ADD #4
	STA Graphics_BufCnt

	RTS


TileUpdAttr_MergeAndShift:
	; Move over top two attribute bits (make room for next tile)
	LSR <Temp_Var1	; .11. ....
	LSR <Temp_Var1	; ..11 ....

	; For the new tile...
	AND #%11000000	; Attribute bits only
	ORA <Temp_Var1	; Merge with existing bits
	STA <Temp_Var1	; Update Temp_Var1
	RTS


	; Change Fence Rotation Command offset
FROT_BCOff .func \1 - Chng_FenceRot1

	; Get initial offset to proper set of commands to be used
FROT_Offsets:
	.byte FROT_BCOff(Chng_FenceRot1)	; Fence rotation 1
	.byte FROT_BCOff(Chng_FenceRot2)	; Fence rotation 2
	.byte FROT_BCOff(Chng_FenceRot3)	; Fence rotation 3

Chng_FenceRot1:
	.byte $00, $00, $06, $0A, $30, $30, $30, $30, $0B
	.byte $00, $00, $06, $31, $34, $34, $34, $34, $33
CFR1_R2:	.byte $00, $00, $06, $31, $34, $34, $34, $34, $33
	.byte $00, $00, $06, $31, $34, $34, $34, $34, $33
CFR1_R3:	.byte $00, $00, $06, $31, $34, $34, $34, $34, $33
	.byte $00, $00, $06, $0E, $32, $32, $32, $32, $0F
	.byte $00

Chng_FenceRot2:
	.byte $00, $00, $06, $05, $0A, $30, $30, $0B, $06
	.byte $00, $00, $06, $07, $31, $34, $34, $33, $08
	.byte $00, $00, $06, $05, $31, $34, $34, $33, $06
	.byte $00, $00, $06, $07, $31, $34, $34, $33, $08
	.byte $00, $00, $06, $05, $31, $34, $34, $33, $06
	.byte $00, $00, $06, $07, $0E, $32, $32, $0F, $08
	.byte $00

Chng_FenceRot3:
	.byte $00, $00, $06, $05, $06, $0A, $0B, $05, $06
	.byte $00, $00, $06, $07, $08, $31, $33, $07, $08
	.byte $00, $00, $06, $05, $06, $31, $33, $05, $06
	.byte $00, $00, $06, $07, $08, $31, $33, $07, $08
	.byte $00, $00, $06, $05, $06, $31, $33, $05, $06
	.byte $00, $00, $06, $07, $08, $0E, $0F, $07, $08
	.byte $00

FROT_BCSize = Chng_FenceRot2 - Chng_FenceRot1

Chng_FenceRot_TileBufOffset:	.byte $00, CFR1_R2 - Chng_FenceRot1, CFR1_R3 - Chng_FenceRot1

ChngTile_FenceRot:
	LDA Level_ChgTileEvent
	SUB #CHNGTILE_FENCEROT1
	TAX
	
	LDY FROT_Offsets,X	 ; Y = initial command offset

	STX <Temp_Var11		 ; Temp_Var11 = X (index into FROT_Offsets)

	LDX Graphics_BufCnt	 ; X = graphics buffer count

	; Temp_Var1 = total number of bytes we're going to copy (FROT_BCSize)
	LDA #FROT_BCSize
	STA <Temp_Var1

	; Initial buffer copy loop
FenceRot_DF05:
	LDA Chng_FenceRot1,Y	; Get next command byte
	STA Graphics_Buffer,X	 	; Store into graphics buffer

	INX		 ; X++ (one more byte in the graphics buffer)
	INY		 ; Y++ (next command byte)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE FenceRot_DF05	 ; While Temp_Var1 > 0, loop!
	; End initial buffer copy loop

	; Temp_Var3 = 0 (tile row count)
	LDA #$00
	STA <Temp_Var3

FenceRot_DF1B:
	LDA <Temp_Var5	; A = Temp_Var5 (row/column offset value)
	AND #$f0	; Just keep the row part

	LDY <Temp_Var7	; Y = Temp_Var7
	BEQ FenceRot_DF26	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to FenceRot_DF26

	ADD #$10	 ; Fringe offset fix

FenceRot_DF26:
	STA <Temp_Var6	 ; -> Temp_Var6

	LDA <Temp_Var5	; A = Temp_Var5 (row/column offset value)
	AND #$0f	; Just keep the column part
	ASL A		; Multiply by 2
	STA <Temp_Var8	; -> Temp_Var8

	; Calculate high video address
	LDA <Temp_Var6	 ; Get tile Y (aligned to grid, so bits 0-3 are zero)
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0 (result: Former bit 6-7 are now bit 0-1)
	PHA		 ; Save this value
	AND #%00000011	 ; Only keep lower 2 bits
	ORA #$20	 ; Set high part of video address

	LDY <Temp_Var7	; Y = Temp_Var7
	BEQ FenceRot_DF42	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to FenceRot_DF42

	ORA #$08	 ; Set $28 high address

FenceRot_DF42:
	STA <Temp_Var9	 ; -> Temp_Var9 (high video address)

	; Get offset into buffer for this tile row
	LDX <Temp_Var3	; X = Temp_Var3 (tile row count)
	LDA Chng_FenceRot_TileBufOffset,X
	TAX

	; Offset 'X' to where we started in buffer...
	; X += current graphics buffer count
	TXA
	ADD Graphics_BufCnt
	TAX

	; Commit high addresses to graphics buffer
	LDA <Temp_Var9
	STA Graphics_Buffer,X
	STA Graphics_Buffer+$09,X

	PLA		; Restore value from before
	AND #%11110000	; Keep the upper 4 bits
	ORA <Temp_Var8	; The column value
	STA <Temp_Var4	; -> Temp_Var4

	; Set low address in graphics buffer
	STA Graphics_Buffer+$01,X

	ADD #32		; +32 is next row

	; Set low address in graphics buffer
	STA Graphics_Buffer+$0A,X

	; Temp_Var5 += 16 (next tile row)
	LDA <Temp_Var5
	ADD #16
	STA <Temp_Var5

	; Next tile row
	INC <Temp_Var3	; Temp_Var3++

	LDA <Temp_Var3
	CMP #$03
	BNE FenceRot_DF1B	 ; While Temp_Var3 < 3, loop!

	; Add array size -1 to graphics buffer count
	LDA Graphics_BufCnt
	ADD #(FROT_BCSize - 1)
	STA Graphics_BufCnt

	; Level_ChgTileEvent = 0 (redundant!)
	LDA #$00
	STA Level_ChgTileEvent

	INC Level_SkipStatusBarUpd	; Set Level_SkipStatusBarUpd (skip status bar for a frame, priority update!)

	RTS		 ; Return


ChngTile_SandTopMid:
	
	; The atomic operation should be an attribute-included single tile change
	; along with a no-attribute single tile change
	
	; Do the lower tile first
	LDA #CHNGTILE_QUICKSAND_MID9
	STA Level_ChgTileEvent
	
	LDA Level_BlockChgYLo
	PHA
	ADD #16
	STA Level_BlockChgYLo
	LDA Level_BlockChgYHi
	PHA
	ADC #0
	STA Level_BlockChgYHi
	
	JSR BlockChange_Do

	; Will need to commit this one via graphics buffer
	; Normally this is done in PRG026, so doing it manually here
	
	LDX Graphics_BufCnt
	
	; Address of top two patterns
	LDA TileChng_VRAM_H
	STA Graphics_Buffer+$00,X
	LDA TileChng_VRAM_L
	STA Graphics_Buffer+$01,X
	
	; Two patterns coming
	LDA #2
	STA Graphics_Buffer+$02,X
	
	; And there they are
	LDA TileChng_Pats
	STA Graphics_Buffer+$03,X
	LDA TileChng_Pats+1
	STA Graphics_Buffer+$04,X

	; Address of bottom two patterns
	LDA TileChng_VRAM_H
	STA Graphics_Buffer+$05,X
	LDA TileChng_VRAM_L
	ADD #32
	STA Graphics_Buffer+$06,X
	
	; Two patterns coming
	LDA #2
	STA Graphics_Buffer+$07,X
	
	; And there they are
	LDA TileChng_Pats+2
	STA Graphics_Buffer+$08,X
	LDA TileChng_Pats+3
	STA Graphics_Buffer+$09,X

	; Terminator
	LDA #0
	STA Graphics_Buffer+$0A,X
	
	TXA
	ADD #$0A
	STA Graphics_BufCnt
	
	; Do the top tile now...
	
	PLA
	STA Level_BlockChgYHi
	PLA
	STA Level_BlockChgYLo
	
	LDA #($00 | CHNGTILE_QUICKSAND_TOP9)
	STA Level_ChgTileEvent
	JSR BlockChange_Do

	RTS

VibrationOffset:
	.byte 0,  2,  3,  1	; For when 0 >= Vert_Scroll >= $7F
	.byte 0, -2, -3, -1	; For when $80 >= Vert_Scrol >= $FF

	; Simple function which updates the "Shake" effect from something heavy
Player_DoVibration29:
	DEC Level_Vibration	 ; Level_Vibration--
	AND #$03	 	; Cap 0 - 3

	LDY <Vert_Scroll
	BPL PRG008_A4B1	 ; If Vert_Scroll < $80, jump to PRG008_A4B1

	ORA #$04	 ; Otherwise, use value 4 - 7

PRG008_A4B1:
	TAY		 	; index value -> 'Y'
	LDA VibrationOffset,Y	; Get offset 
	PHA		 	; Save it
	ADD Level_VertScroll	
	STA Level_VertScroll	; Level_VertScroll += offset
	PLA		 	; Restore it

	STA Vert_Scroll_Off	 ; Update Vert_Scroll_Off
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_PowerUpdate
;
; Handles updating the "Power Meter" as appropriate,
; and plays the annoying "ringing" noise :)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_PowerUpdate29:
	LDY Player_FlyTime	 
	BEQ PRG008_A4E4	 ; If Player is not flying (or at least high-speed jumping), jump to PRG008_A4E4

	CPY #$ff
	BEQ Sound_FullPowerRing	 ; If Player_FlyTime = $FF (P-Wing active), jump to Sound_FullPowerRing

	LDA <Counter_1
	AND #$01
	BEQ PRG008_A4D5	 ; Every other tick, jump to PRG008_A4D5

	DEY			 
	STY Player_FlyTime ; Player_FlyTime--

PRG008_A4D5:
	TYA		 ; Y (Player_FlyTime) -> A 
	BNE Sound_FullPowerRing	 ; If Player_FlyTime <> 0, jump to Sound_FullPowerRing

	STY Player_Power ; Otherwise, clear Player_Power

Sound_FullPowerRing:

	; Full power ringing sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPOWER
	STA Sound_QPlayer

	RTS		 ; Return

PRG008_A4E4:
	LDA Player_Power
	CMP #$7f
	BNE PRG008_A4F8	 ; If Player_Power <> $7F (max power), jump to PRG008_A4F8

	JSR Sound_FullPowerRing	 ; Play full power ringing sound

	LDA Player_RunFlag
	BEQ PRG008_A4F8	 ; If Player is not running, jump to PRG008_A4F8

	LDY #$10	 ; Y = $10
	JMP PRG008_A51A	 ; Jump to PRG008_A51A

PRG008_A4F8:
	LDA Player_PMeterCnt
	BNE PRG008_A523	 ; If Player_PMeterCnt <> 0, jump to PRG008_A523

	SEC		 ; Set carry
	ROL Player_Power ; Player_Power is shifted left 1, its old bit 7 in the carry, and '1' introduced at bit 0

	LDA Player_RunFlag
	BNE PRG008_A50C	 ; If Player is running, jump to PRG008_A50C

	ROR Player_Power ; Restore Player_Power
	LSR Player_Power ; Shift it 1 to the right

PRG008_A50C:
	LDY #$18	 ; Y = $18

	LDA Player_Power
	BEQ PRG008_A520	 ; If Player_Power = 0, jump to PRG008_A520

	LDA Player_RunFlag
	BEQ PRG008_A51A	 ; If Player is not running, jump to PRG008_A51A

	LDY #$08	 ; Otherwise, Y = $8

PRG008_A51A:
	STY Player_PMeterCnt	 ; Set Player_PMeterCnt

	JMP PRG008_A523	 ; Jump to PRG008_A523

PRG008_A520:
	STA Player_FlyTime ; Clear Player_FlyTime

PRG008_A523:

	LDA #$00
	STA Player_RunFlag ; Player_RunFlag = 0

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SetSpecialFramesAndDraw
;
; SB: Used to be Player_SetSpecialFrames and a call made to
; Player_Draw29 afterward; moved here because space problems.
;
; Set one of the "special" frames, i.e. "spread eagle" running,
; somersaulting, holding, pipe facing, kicking, twirling, and
; even the forced-to-standing frame of "vibrationally disabled"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Frames used when Player is running at high speed!
Player_SpreadEagleFrames:
	.byte PF_RUNBIG_BASE, PF_RUNBIG_BASE+1, PF_RUNBIG_BASE+2, PF_RUNBIG_BASE+1	; Player is not small
	.byte PF_RUNSMALL_BASE, PF_RUNSMALL_BASE+1, PF_RUNSMALL_BASE, PF_RUNSMALL_BASE+1	; Player is small

	; This sets the sprite's H/V flip bits for the somersault
Player_SomersaultFlipBits:
	.byte $00, $00, $00, $00, $C0, $C0, $C0, $C0, $80, $01

Player_HoldingFrames:
	.byte PF_HOLDBIG_BASE, PF_HOLDBIG_BASE+1, PF_HOLDBIG_BASE+2, PF_HOLDBIG_BASE+1	; Player is not small
	.byte PF_HOLDSMALL_BASE, PF_HOLDSMALL_BASE+1, PF_HOLDSMALL_BASE, PF_HOLDSMALL_BASE+1	; Player is small

TwisterSpin_FlipBits:	.byte $00, $40

Player_TwisterSpinFrames:
	.byte PF_SPINSMALLORPENGUIN_BASE+12, PF_SPINSMALLORPENGUIN_BASE, PF_SPINSMALLORPENGUIN_BASE+12, PF_SPINSMALLORPENGUIN_BASE	; small or penguin
	.byte PF_SPINSLIDESUITS_BASE+10, PF_SPINSLIDESUITS_BASE, PF_SPINSLIDESUITS_BASE+10, PF_SPINSLIDESUITS_BASE+1	; suits that slide
	.byte PF_SPINOTHER_BASE, PF_SPINOTHER_BASE+2, PF_SPINOTHER_BASE, PF_SPINOTHER_BASE+3	; otherwise

Player_VibeDisableFrame:
	.byte PF_WALKSMALL_BASE		; Small
	.byte PF_WALKBIG_BASE+2		; Big
	.byte PF_WALKBIG_BASE+2		; Fire
	.byte PF_WALKSPECIAL_BASE+2	; Leaf
	.byte PF_WALKBIG_BASE+2	; Penguin
	.byte PF_WALKBIG_BASE+2	; Rabbit
	.byte PF_WALKBIG_BASE+2		; Hammer

Player_DigSandFrames:
	.byte PF_DIGSAND_BASE, PF_DIGSAND_BASE+1
	.byte PF_DIGSAND_SMALL_BASE, PF_DIGSAND_SMALL_BASE+1
	.byte PF_DIGSAND_RACCOON_BASE, PF_DIGSAND_RACCOON_BASE+1

Player_SetSpecialFramesAndDraw:

	; Get absolute value of Player_XVel
	LDA <Player_XVel
	BPL PRG029_AECA
	NEG
PRG029_AECA:

	CMP #$37
	BLT PRG029_AEF0	 ; If magnitude of Player's horizontal velocity is < $37, jump to PRG029_AEF0

	LDA Player_FlyTime
	BNE PRG029_AEF0	 ; If Player already has flight time, jump to PRG029_AEF0

	LDA Player_IsDucking
	ORA Player_Kuribo
	ORA Player_IsClimbing
	ORA Player_Slide
	BNE PRG029_AEF0	 ; If Player is ducking, in a Kuribo's shoe, climbing a vine, or sliding, jump to PRG029_AEF0!!

	LDY <Player_WalkFrame	; Y = Player_WalkFrame (0 - 3)

	LDA <Player_Suit
	BNE PRG029_AEEB	 ; If Player is NOT small, jump to PRG029_AEEB

	INY
	INY
	INY
	INY		 ; Otherwise, Y += 4

PRG029_AEEB:
	LDA Player_SpreadEagleFrames,Y	 ; Get cooresponding spread-eagle frame
	STA <Player_Frame		 ; Store that!

PRG029_AEF0:
	LDA Player_Flip
	BEQ PRG029_AF0F	 ; If Player is NOT somersaulting, jump to PRG029_AF0F

	LDA <Counter_1
	LSR A		; A = Counter_1 >> 1
	PHA		 ; Save it

	AND #$07	 ; Cap 0 - 7
	TAY		 ; -> 'Y'

	LDA Player_SomersaultFlipBits,Y	 ; Get proper somersault flip bits

	LDY <Player_XVel
	BPL PRG029_AF05	 ; If Player_XVel >= 0, jump to PRG029_AF05

	EOR #SPR_HFLIP	 ; Otherwise, horizontally flip!

PRG029_AF05:
	STA <Player_FlipBits		 ; Update Player flip bits
	PLA		 ; Restore Counter_1 >> 1

	AND #$03	 ; Cap 0 - 3
	ADD #PF_SOMERSAULT_BASE	 ; Add base somersault frame
	STA <Player_Frame ; Update Player_Frame!

PRG029_AF0F:
	LDA Player_IsHolding
	BEQ PRG029_AF2F	 ; If Player is NOT holding something, jump to PRG029_AF2F

	LDY <Player_WalkFrame	 ; Y = PRG029_AF2F

	LDA Player_InAir_OLD
	BEQ PRG029_AF22	 ; If Player was NOT in air, jump to PRG029_AF22

	LDY #$00	; Otherwise, Y = 0

	LDA <Player_Suit
	BNE PRG029_AF22	
	INY		 ; ... unless small, in which case, Y = 1

PRG029_AF22:
	LDA <Player_Suit
	BNE PRG029_AF2A	 ; If Player is NOT small, jump to PRG029_AF2A

	INY
	INY
	INY
	INY		 ; Otherwise, Y += 4

PRG029_AF2A:
	LDA Player_HoldingFrames,Y ; Get appropriate "holding" frame
	STA <Player_Frame	 ; Update Player frame!

PRG029_AF2F:
	LDA Player_PipeFace
	BNE PRG029_AF45	 ; If Player is facing forward, jump to PRG029_AF45

	LDA Player_IsHolding
	BEQ PRG029_AF52	 ; If Player is NOT holding something, jump to PRG029_AF52

	LDA <Player_FlipBits
	CMP Player_FlipBits_OLD
	BEQ PRG029_AF52	 ; If Player's flip bits haven't changed, jump to PRG029_AF52

	LDA #$07
	STA Player_PipeFace ; Otherwise, Player_PipeFace = 7 (Player briefly faces forward while turning around holding something)

PRG029_AF45:
	DEC Player_PipeFace	 ; Player_PipeFace--

	LDA #PF_INPIPE_BIG	; Face-forward frame when Player is NOT small

	LDY <Player_Suit
	BNE PRG029_AF50	 ; If Player is NOT small, jump to PRG029_AF50

	LDA #PF_INPIPE_SMALL	 ; Face-forward frame when Player is small

PRG029_AF50:
	STA <Player_Frame ; Update Player frame !

PRG029_AF52:
	LDA Player_Kuribo
	BEQ PSSFAD_NotRidingYoshi	; If Player is NOT riding Yoshi, jump to PSSFAD_NotRidingYoshi
	
	; Set riding frame
	LDY #PF_RIDEYOSHI_SMALL
	
	LDA <Player_Suit
	BEQ PSSFAD_FrameSet	; If small, set frame
	
	; Not small...
	LDY #PF_RIDEYOSHI
	
	CMP #$03
	BNE PSSFAD_FrameSet	; If not small and not raccoon, set frame
	
	; Raccoon only
	LDY #PF_RIDEYOSHI_RACCOON
	
PSSFAD_FrameSet:
	STY <Player_Frame

PSSFAD_NotRidingYoshi:
	LDA Player_Kick
	BEQ PRG029_AF69	 ; If Player is NOT kicking something, jump to PRG029_AF69

	LDA #$00
	STA Player_TailAttack	 ; Player_TailAttack = 0 (stop tail attack effect if active!)

	LDY #PF_KICK_SMALL	 ; Kick frame when small

	LDA <Player_Suit
	BEQ PRG029_AF64	 ; If Player is small, jump to PRG029_AF64

	LDY #PF_KICK_BIG	 ; Kick frame when NOT small

PRG029_AF64:
	STY <Player_Frame ; Update Player frame!

	DEC Player_Kick	 ; PRG029_AF64--

PRG029_AF69:
	LDA Player_TwisterSpin
	BEQ PRG029_AFA1	 ; If Player is NOT twirling, jump to PRG029_AFA1

	DEC Player_TwisterSpin	 ; Player_TwisterSpin--

	LDY #$00	; Y = 0 (base index for small or penguin)

	LDA <Player_Suit
	BEQ PRG029_AF87	 ; If Player is small, jump to PRG029_AF87

	LDY #$04	 ; Y = 4 (base index all suits that can slide on slopes)

	CMP #$05
	BEQ PRG029_AF87	 ; If Player is Rabbit, jump to PRG029_AF87

	CMP #$03
	BNE PRG029_AF87	; If Player is not Raccoon, jump to PRG029_AF87

	; SB: Old logic, not portable due to bank change
	;TAX		 ; Power up -> 'X'

	;LDA PowerUp_Ability,X
	;AND #$01	 
	;BEQ PRG029_AF87	 ; If able to slide on slopes, jump to PRG029_AF87

PRG029_AF85:
	LDY #$08	 ; Y = 8 (base value otherwise)

PRG029_AF87:
	STY <Temp_Var1	 ; Temp_Var1 = 0, 4, or 8

	LDA <Counter_1
	AND #$0c	 ; Cap value 0 - 11
	LSR A		 
	LSR A		 ; >> 2 (0 - 3)
	PHA		 ; Save it

	LSR A		 ; Shift down one more time
	TAY		 ; -> 'Y'
	LDA TwisterSpin_FlipBits,Y ; Get appropriate flip bits
	STA <Player_FlipBits	  ; ... and set them!

	PLA		 ; Restore (0 - 2)

	ADD <Temp_Var1	 ; Add base index
	TAY		 ; -> 'Y'

	LDA Player_TwisterSpinFrames,Y	 ; Get appropriate spin frame
	STA <Player_Frame		 ; Update Player frame!

PRG029_AFA1:
	LDA Player_VibeDisable
	BEQ PRG029_AFAD	 ; If Player is not "vibrationally disabled", jump to PRG029_AFAD

	LDY <Player_Suit
	LDA Player_VibeDisableFrame,Y	 ; Get appropriate "vibrationally disabled" frame (typ. standing)
	STA <Player_Frame	; Update Player frame!

PRG029_AFAD:
	LDA Player_DigSand
	BEQ PSSFAD_NotDigging

	PHA		; Save Player_DigSand

	LDA #$00
	STA Player_TailAttack	 ; Player_TailAttack = 0 (stop tail attack effect if active!)

	DEC Player_DigSand	; Player_DigSand--
	
	LDY #2	; Y = 2 if small
	
	LDA <Player_Suit
	BEQ PSSFAD_Yset		; If small, jump to PSSFAD_Yset
	
	LDY #0	; Y = 0 if anything else but raccoon
	
	CMP #$03
	BNE PSSFAD_Yset		; If not raccoon, jump to PSSFAD_Yset
	
	LDY #4	; Y = 4 if raccoon
	
PSSFAD_Yset:
	PLA 	; Restore Player_DigSand
	
	CMP #$08
	BGE PSSFAD_YOK	; If before second frame, jump to PSSFAD_YOK
	
	; Second frame
	INY

PSSFAD_YOK:
	LDA Player_DigSandFrames,Y
	STA <Player_Frame

PSSFAD_NotDigging:
	JMP Player_Draw
