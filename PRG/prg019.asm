; Super Mario Bros. 3Mix by Southbird 2014
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; All 3Mix new code by Southbird!
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; FILENAME: prg019.bin, File Size: 8193, ORG: $A000
;     -> NES mode enabled
;---------------------------------------------------------------------------
Tile_Layout_TS11_TS13:
	; This defines the individual 8x8 blocks used to construct one of the tiles
	; Referenced by Address_Per_Tileset, addressed by Level_Tileset
	; Stored by upper left, then lower left, then upper right, then lower right

	; Remember that palette is determined by the upper 2 bits of a TILE (not the PATTERN)
	; I.e. tiles starting at index $00, $40, $80, $C0 are each on that respective palette

	; Upper left 8x8 pattern per tile
	.byte $FC, $DC, $2C, $05, $05, $E8, $2E, $FC, $FC, $38, $05, $2D, $2D, $23, $05, $05 ; Tiles $00 - $0F
	.byte $FC, $2B, $FF, $FF, $FF, $58, $64, $FC, $FC, $FC, $FC, $6D, $FC, $5E, $7F, $0C ; Tiles $10 - $1F
	.byte $4F, $FD, $FD, $FD, $FD, $12, $12, $FF, $FF, $FF, $FF, $FF, $D0, $D0, $B8, $B8 ; Tiles $20 - $2F
	.byte $B8, $B8, $BC, $94, $B0, $B1, $FD, $FD, $12, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DC, $05, $FC, $FC, $05, $05, $05, $F4, $F4, $F4, $22, $04, $5A, $24, $26, $44 ; Tiles $40 - $4F
	.byte $46, $64, $66, $04, $0D, $24, $FE, $4F, $4F, $6C, $6E, $04, $5A, $24, $26, $D8 ; Tiles $50 - $5F
	.byte $98, $98, $98, $98, $98, $98, $92, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4 ; Tiles $60 - $6F
	.byte $B4, $B8, $98, $98, $98, $98, $A4, $EC, $E4, $C0, $00, $02, $20, $22, $FF, $FF ; Tiles $70 - $7F
	.byte $05, $18, $19, $FC, $FE, $C4, $FD, $FE, $3A, $05, $05, $FD, $7A, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $88, $FE, $48, $49, $4E, $04, $4E, $49, $68, $6A, $72, $72 ; Tiles $90 - $9F
	.byte $60, $AE, $62, $AE, $8C, $4A, $8E, $9C, $6A, $9E, $AC, $FE, $AE, $8C, $8E, $8C ; Tiles $A0 - $AF
	.byte $8E, $8C, $8E, $8C, $8E, $52, $52, $50, $40, $42, $AC, $AE, $B8, $8C, $8E, $52 ; Tiles $B0 - $BF
	.byte $F4, $05, $F8, $FD, $05, $05, $FD, $0B, $0C, $05, $3C, $05, $FD, $1C, $1E, $3C ; Tiles $C0 - $CF
	.byte $08, $05, $05, $05, $FD, $FD, $FD, $05, $B3, $CC, $FC, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $78, $7A, $7A, $54, $7A, $7A, $44, $46, $46, $74, $75, $76, $14, $FF ; Tiles $E0 - $EF
	.byte $4C, $D7, $E0, $05, $63, $0A, $28, $2A, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Lower left 8x8 pattern per tile
	.byte $FC, $DD, $3C, $06, $D6, $E9, $3E, $38, $FC, $FC, $0E, $06, $06, $06, $48, $4A ; Tiles $00 - $0F
	.byte $1A, $2A, $FF, $FF, $FF, $68, $6A, $FC, $5E, $5F, $FC, $6D, $FC, $FC, $FC, $1C ; Tiles $10 - $1F
	.byte $1E, $FD, $16, $FD, $5A, $22, $13, $FF, $FF, $FF, $FF, $FF, $D1, $D1, $B9, $B9 ; Tiles $20 - $2F
	.byte $B9, $B9, $BD, $95, $B1, $B0, $16, $5A, $13, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DD, $05, $FC, $FC, $06, $06, $06, $F5, $F5, $F5, $32, $14, $16, $34, $36, $54 ; Tiles $40 - $4F
	.byte $56, $74, $76, $24, $FE, $34, $48, $13, $13, $7C, $7E, $14, $16, $34, $36, $D9 ; Tiles $50 - $5F
	.byte $99, $99, $99, $99, $99, $99, $93, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5 ; Tiles $60 - $6F
	.byte $B5, $B9, $C1, $C1, $C1, $C1, $A5, $ED, $E4, $C1, $10, $12, $30, $32, $FF, $FF ; Tiles $70 - $7F
	.byte $06, $28, $29, $FC, $FE, $C4, $FD, $FE, $28, $61, $60, $FD, $FD, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $89, $FE, $58, $59, $04, $04, $04, $59, $71, $71, $6C, $6E ; Tiles $90 - $9F
	.byte $61, $AE, $63, $AE, $58, $FE, $78, $AC, $FE, $AE, $AC, $FE, $AE, $9C, $9E, $9C ; Tiles $A0 - $AF
	.byte $9E, $9C, $9E, $9C, $9E, $53, $53, $51, $41, $43, $AC, $AE, $B9, $9C, $9E, $53 ; Tiles $B0 - $BF
	.byte $F5, $06, $F9, $00, $02, $06, $0A, $06, $FD, $0D, $3D, $02, $FD, $2C, $06, $3B ; Tiles $C0 - $CF
	.byte $4E, $34, $36, $36, $30, $32, $32, $E6, $CD, $CD, $CD, $FE, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $FD, $62, $62, $06, $66, $66, $06, $06, $06, $FD, $FD, $FD, $24, $FF ; Tiles $E0 - $EF
	.byte $5C, $06, $E1, $06, $18, $1A, $38, $3A, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Upper right 8x8 pattern per tile	
	.byte $FC, $DE, $2D, $07, $07, $EA, $2F, $FC, $38, $FC, $06, $2E, $21, $2E, $07, $07 ; Tiles $00 - $0F
	.byte $FC, $FC, $FF, $FF, $FF, $5B, $6F, $FC, $FC, $FC, $6D, $FC, $7D, $5E, $FC, $4F ; Tiles $10 - $1F
	.byte $0F, $FD, $27, $10, $10, $FD, $FD, $FF, $FF, $FF, $FF, $FF, $D2, $D2, $BA, $BA ; Tiles $20 - $2F
	.byte $BA, $BA, $BE, $96, $B0, $B1, $27, $10, $FD, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DE, $06, $FC, $FC, $07, $07, $07, $F6, $F6, $F6, $23, $68, $0E, $25, $27, $45 ; Tiles $40 - $4F
	.byte $47, $65, $67, $0D, $0E, $FE, $27, $4F, $4F, $6D, $6F, $68, $0E, $25, $27, $DA ; Tiles $50 - $5F
	.byte $9A, $9A, $9A, $9A, $9A, $9A, $CA, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6 ; Tiles $60 - $6F
	.byte $B6, $BA, $9A, $9A, $9A, $9A, $A6, $EE, $E5, $C2, $01, $03, $21, $23, $FF, $FF ; Tiles $70 - $7F
	.byte $07, $18, $19, $FC, $FE, $C6, $FD, $39, $18, $07, $60, $FD, $07, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $8A, $FE, $49, $49, $4F, $0D, $4F, $48, $69, $6B, $72, $72 ; Tiles $90 - $9F
	.byte $AD, $64, $AD, $66, $49, $4B, $8F, $69, $6B, $9F, $AD, $7B, $AF, $8D, $8F, $8D ; Tiles $A0 - $AF
	.byte $8F, $8D, $8F, $8D, $8F, $72, $72, $70, $40, $42, $AD, $AF, $BA, $8D, $8F, $72 ; Tiles $B0 - $BF
	.byte $F6, $07, $FA, $FD, $06, $07, $0A, $FD, $07, $0D, $07, $3F, $FD, $1D, $1F, $07 ; Tiles $C0 - $CF
	.byte $3F, $07, $07, $07, $FD, $FD, $FD, $07, $B3, $CE, $FC, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $79, $7A, $7B, $79, $7A, $57, $45, $45, $47, $75, $75, $77, $15, $FF ; Tiles $E0 - $EF
	.byte $4D, $D7, $E2, $07, $09, $0B, $29, $2B, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Lower right 8x8 pattern per tile
	.byte $FC, $DF, $3D, $08, $D6, $EB, $3F, $FC, $FC, $38, $0F, $08, $08, $08, $49, $4B ; Tiles $00 - $0F
	.byte $6E, $6E, $FF, $FF, $FF, $69, $6B, $7E, $5E, $FC, $6D, $FC, $FC, $FC, $FC, $1D ; Tiles $10 - $1F
	.byte $1F, $FD, $17, $20, $11, $FD, $59, $FF, $FF, $FF, $FF, $FF, $D3, $D3, $BB, $BB ; Tiles $20 - $2F
	.byte $BB, $BB, $BF, $97, $B1, $B0, $17, $11, $59, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DF, $07, $FC, $FC, $08, $08, $08, $F7, $F7, $F7, $33, $15, $17, $35, $37, $55 ; Tiles $40 - $4F
	.byte $57, $75, $77, $FE, $27, $48, $37, $5F, $5F, $7D, $7F, $15, $17, $35, $37, $DB ; Tiles $50 - $5F
	.byte $9B, $9B, $9B, $9B, $9B, $9B, $CB, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7 ; Tiles $60 - $6F
	.byte $B7, $BB, $9B, $9B, $9B, $9B, $A7, $EF, $E5, $C3, $11, $10, $31, $33, $FF, $FF ; Tiles $70 - $7F
	.byte $08, $28, $29, $FC, $FE, $C6, $FD, $FE, $28, $62, $FD, $FD, $7A, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $8B, $FE, $59, $59, $0D, $0D, $0D, $58, $71, $71, $6D, $6F ; Tiles $90 - $9F
	.byte $AD, $65, $AD, $67, $59, $5B, $79, $AD, $7B, $AF, $AD, $7B, $AF, $9D, $9F, $9D ; Tiles $A0 - $AF
	.byte $9F, $9D, $9F, $9D, $9F, $73, $73, $71, $41, $43, $AD, $AF, $BB, $9D, $9F, $73 ; Tiles $B0 - $BF
	.byte $F7, $08, $FB, $01, $03, $08, $08, $0B, $0C, $FD, $03, $3E, $FD, $08, $2F, $60 ; Tiles $C0 - $CF
	.byte $4F, $35, $35, $37, $31, $31, $33, $E7, $CF, $CF, $CF, $FE, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $61, $62, $63, $65, $66, $67, $08, $08, $08, $FD, $FD, $FD, $08, $FF ; Tiles $E0 - $EF
	.byte $5D, $08, $E3, $08, $19, $1B, $39, $3B, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

Tile_Attributes_TS11_TS13:
	.byte $1F, $4B, $96, $E2, $2E, $4B, $96, $EE


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS11
;
; Entry point for loading level layout data for Level_Tileset = 11
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS11:
	LDY #$00

PRG019_1B:
	LDA #TILE11_SKY		; Clear everything to sky
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$f0
	BNE PRG019_1B

	JMP LevelLoad	; Begin actual level loading!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS13
;
; Entry point for loading level layout data for Level_Tileset = 13
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS13:
	LDY #$00

PRG019_A41B:
	LDA #TILE13_SKY		; Clear everything to sky
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$f0
	BNE PRG019_A41B

	JMP LevelLoad	; Begin actual level loading!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Generator_TS1113
;
; Based on the values in Temp_Var15 and LL_ShapeDef, chooses an
; appropriate generator function to builds this piece of the
; level.  Tedious, but saves space and is paper-design friendly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG019_A42A:
	.byte 0, 15, 30, 45, 60, 75, 90, 105

LoadLevel_Generator_TS1113:
	; From level loader function:
	; * Temp_Var15, Temp_Var16, and LL_ShapeDef are three bytes read from the data


	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = upper 3 bits of Temp_Var15 (0-7) (selects a multiple of 15 as the base)

	LDA LL_ShapeDef
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = upper 4 bits of LL_ShapeDef shifted down
	ADD PRG019_A42A,X	; Add multiple of 15
	TAX
	DEX
	TXA		 ; A = ((LL_ShapeDef >> 4) + PRG015_A419[X]) - 1


	; PRG019_A42A provides values well in excess of 51, but only 51
	; addresses are defined here; reserved for expansion...

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_GiantBlock		;  0 - Generate run of giant Judgems Clouds
	.word LoadLevel_GiantBlock		;  1 - Generate run of giant Bricks
	.word LoadLevel_GiantBlock		;  2 - Generate run of giant [?] blocks (with a coin)
	.word LoadLevel_GiantBlock		;  3 - Generate run of giant [?] blocks (with a powerup, super leaf)
	.word LoadLevel_GiantBlock		;  4 - Generate run of giant wood blocks
	.word LoadLevel_GiantBlock		;  5 - Generate run of giant metal (post [?] block) blocks
	.word LoadLevel_GiantBlock		;  6 - Generate run of giant ground blocks
	.word LoadLevel_GiantPipe		;  7 - Generate giant pipe
	.word LoadLevel_GiantCoral		;  8 - Generate run of 2x2 giant coral blocks
	.word $0000				;  9 - Generates vertical mini pipe 1 (top only, height specified, Tileset 5 only)
	.word $0000				; 10 - Generates vertical mini pipe 2 (top only, height specified, Tileset 5 only)
	.word LoadLevel_LongCloud_WB		; 11 - Generate long cloud (blue sky background)
	.word LoadLevel_LongCloud_WB		; 12 - Generate long cloud (white cloud background)
	.word LoadLevel_DoubleCloud		; 13 - Generate rectangle of layered clouds
	.word LoadLevel_PointyCloud		; 14 - Generate pointy edge clouds
	.word LoadLevel_BlockRun		; 15 - Run of bricks
	.word LoadLevel_BlockRun		; 16 - Run of '?' blocks with a coin
	.word LoadLevel_BlockRun		; 17 - Run of bricks with a coin
	.word LoadLevel_BlockRun		; 18 - Run of wood blocks
	.word LoadLevel_BlockRun		; 19 - Run of green note blocks (?)
	.word LoadLevel_BlockRun		; 20 - Run of note blocks
	.word LoadLevel_BlockRun		; 21 - Run of bouncing wood blocks
	.word LoadLevel_BlockRun		; 22 - Run of coins
	.word LoadLevel_VGroundPipeRun		; 23 - Vertical ground pipe 1 (alt level)
	.word LoadLevel_VGroundPipeRun		; 24 - Vertical ground pipe 2 (Big [?] area)
	.word LoadLevel_VGroundPipeRun		; 25 - Vertical ground pipe 3 (no entrance)
	.word LoadLevel_VCeilingPipeRun		; 26 - Vertical ceiling pipe 1 (alt level)
	.word LoadLevel_VCeilingPipeRun		; 27 - Vertical ceiling pipe 2 (no entrance)
	.word LoadLevel_HRightWallPipeRun	; 28 - Horizontal right-hand wall pipe (alt level)
	.word LoadLevel_HRightWallPipeRun	; 29 - Horizontal right-hand wall pipe (no entrance)
	.word LoadLevel_HLeftWallPipeRun	; 30 - Horizontal left-hand wall pipe (alt level)
	.word LoadLevel_HLeftWallPipeRun	; 31 - Horizontal left-hand wall pipe (no entrance)
	.word LoadLevel_Cannon			; 32 - Bullet bill cannon
	.word LoadLevel_CCBridge		; 33 - Cheep-Cheep style 'oo' bridge
	.word LoadLevel_CCBridge		; 34 - Would result in empty tiles?  (form of 33)
	.word LoadLevel_TopDecoBlocks		; 35 - Top-Deco Rectangle Waterfall
	.word LoadLevel_TopDecoBlocks		; 36 - Top-Deco Rectangle Left waving water pool
	.word LoadLevel_TopDecoBlocks		; 37 - Top-Deco Rectangle No current waving water pool
	.word LoadLevel_TopDecoBlocks		; 38 - Top-Deco Rectangle Right waving water pool
	.word LoadLevel_TopDecoBlocks		; 39 - Top-Deco Rectangle Water wrong-way BG
	.word LoadLevel_TopDecoBlocks		; 40 - Top-Deco Rectangle Diamond blocks (not really any deco on top)
	.word LoadLevel_TopDecoBlocks		; 41 - Top-Deco Rectangle Sand ground 
	.word LoadLevel_TopDecoBlocks		; 42 - Top-Deco Rectangle orange block??
	.word $0000		; 43 - UNUSED
	.word LoadLevel_VTransitPipeRun		; 44 - Vertical in-level transit pipe
	.word LoadLevel_CloudGoal		; 45 - Generate long, thick cloud into goal area
	.word LoadLevel_RoundCloudTop		; 46 - Generate long run of round cloud tops
	.word LoadLevel_HPipeRun		; 47 - Generate a run of horizontal pipe (no ends)
	.word LoadLevel_CloudSpace		; 48 - Generate a rectangle of white cloud space
	.word LoadLevel_VGroundPipe5Run		; 49 - Vertical ground pipe 5 (exits to common end area)
	.word LoadLevel_HRightWallPipeRun3	; 50 - Horizontal right-hand wall pipe 3 (no entrance)
	.word LoadLevel_Lava			; 51 - Lava?  Not used in these modes I don't think... (it's green in Tileset 5/13!)
	.word LoadLevel_PurpleCoins		; 52 - Run of Purple coins
	.word LoadLevel_PurpleCoinR		; 53 - Rectangle of Purple Coins


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LeveLoad_FixedSizeGen_TS1113
;
; Much simpler generators that are fixed-size, commonly used for 
; just single tile placement styles (although a couple relatively 
; complex ones exist in here as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LeveLoad_FixedSizeGen_TS1113:
	; It is verified before calling this function that all of
	; the upper 4 bits of LL_ShapeDef are ZERO

	; So the upper 3 bits of Temp_Var15 serve as the most significant bits
	; to a value where LL_ShapeDef provide the 4 least significant bits

	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	ADD LL_ShapeDef	
	TAX		 	; Resultant index is put into 'X'
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word $0000				;  0 - Alternating muncher 1
	.word $0000				;  1 - Alternating muncher 2
	.word LoadLevel_PrefabBGClouds		;  2 - 7x10 block of prefab background clouds
	.word LoadLevel_AltClearToCloud		;  3 - Alternate clear map to clouds
	.word LoadLevel_Stars			;  4 - Adds random stars to top (part of lost effect)
	.word LoadLevel_GiantHill		;  5 - Giant World background hill
	.word LoadLevel_PrefabBGClouds2		;  6 - 4x5 block of prefab background clouds
	.word LoadLevel_PrefabBGClouds2		;  7 - 3x5 block of prefab background clouds
	.word LoadLevel_StarCoin1		;  8 - Star Coin 1
	.word LoadLevel_StarCoin2		;  9 - Star Coin 2
	.word LoadLevel_StarCoin3		; 10 - Star Coin 3
	.word LoadLevel_VineToGround		; 11 - Constructs a vine from the start down to next non-sky tile
	.word $0000				; 12 - NULL?
	.word $0000				; 13 - NULL?
	.word $0000				; 14 - NULL?
	.word $0000				; 15 - NULL?
	.word LoadLevel_PowerBlock		; 16 - ? block with flower
	.word LoadLevel_PowerBlock		; 17 - ? block with leaf 
	.word LoadLevel_PowerBlock		; 18 - ? block with star
	.word LoadLevel_PowerBlock		; 19 - ? block with coin OR star
	.word LoadLevel_PowerBlock		; 20 - ? block with coin (??)
	.word LoadLevel_PowerBlock		; 21 - Muncher Plant!
	.word LoadLevel_PowerBlock		; 22 - Brick with flower
	.word LoadLevel_PowerBlock		; 23 - Brick with leaf
	.word LoadLevel_PowerBlock		; 24 - Brick with star
	.word LoadLevel_PowerBlock		; 25 - Brick with coin OR star
	.word LoadLevel_PowerBlock		; 26 - Brick with 10-coin
	.word LoadLevel_PowerBlock		; 27 - Brick with 1-up
	.word LoadLevel_PowerBlock		; 28 - Brick with vine
	.word LoadLevel_PowerBlock		; 29 - Brick with P-Switch
	.word LoadLevel_PowerBlock		; 30 - Invisible coin
	.word LoadLevel_PowerBlock		; 31 - Invisible 1-up
	.word LoadLevel_PowerBlock		; 32 - Invisible note
	.word LoadLevel_PowerBlock		; 33 - Note block with flower
	.word LoadLevel_PowerBlock		; 34 - Note block with leaf
	.word LoadLevel_PowerBlock		; 35 - Note block with star
	.word LoadLevel_PowerBlock		; 36 - Wood block with flower
	.word LoadLevel_PowerBlock		; 37 - Wood block with leaf
	.word LoadLevel_PowerBlock		; 38 - Wood block with star
	.word LoadLevel_PowerBlock		; 39 - Invisible note to coin heaven
	.word LoadLevel_PowerBlock		; 40 - P-Switch
	.word LoadLevel_EndGoal			; 41 - The end goal


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GiantBlock
;
; Generates Giant World common blocks, all 2x2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_GiantBlocks:
	.byte TILE11_JCLOUD_UL, TILE11_BRICK_UL, TILE11_QBLOCKC_UL, TILE11_QBLOCKP_UL, TILE11_WOOD_UL, TILE11_METAL_UL, TILE11_GROUND_UL
	.byte TILE11_JCLOUD_UR, TILE11_BRICK_UR, TILE11_QBLOCKC_UR, TILE11_QBLOCKP_UR, TILE11_WOOD_UR, TILE11_METAL_UR, TILE11_GROUND_UR
	.byte TILE11_JCLOUD_LL, TILE11_BRICK_LL, TILE11_QBLOCKC_LL, TILE11_QBLOCKP_LL, TILE11_WOOD_LL, TILE11_METAL_LL, TILE11_GROUND_LL
	.byte TILE11_JCLOUD_LR, TILE11_BRICK_LR, TILE11_QBLOCKC_LR, TILE11_QBLOCKP_LR, TILE11_WOOD_LR, TILE11_METAL_LR, TILE11_GROUND_LR

LoadLevel_GiantBlock:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2 
	LDA <Map_Tile_AddrL 
	STA <Temp_Var1 
	LDA <Map_Tile_AddrH 
	STA <Temp_Var2
 
	LDA LL_ShapeDef 
	PHA		 ; Save LL_ShapeDef
 
	SUB #$10
	LSR A	 
	LSR A	 
	LSR A	 
	LSR A	 
	TAX		; X = relative index
 
	PLA		 ; Restore LL_ShapeDef
 
	AND #$0f 
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)
 
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3 
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3
 
PRG019_A552:
	LDA LL_GiantBlocks,X	 ; Get tile for upper left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	LDA LL_GiantBlocks+7,X	 ; Get tile for upper right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BPL PRG019_A552	 	; While Temp_Var4 >= 0, loop!

	
	JSR LL19_ReturnTileAndNextRow	 ; Return to beginning, then go to next row

PRG019_A569:
	LDA LL_GiantBlocks+14,X	 ; Get tile for lower left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	LDA LL_GiantBlocks+21,X	 ; Get tile for lower right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3		 ; Temp_Var3-- (width decrement)
	BPL PRG019_A569	 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GiantPipe
;
; Generates a Giant World pipe, which is 3 x Height
; The height being what comes in with LL_ShapeDef
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_GiantPipe:
	.byte TILE11_PIPE_UL, TILE11_PIPE_ML, TILE11_PIPE_LL
	.byte TILE11_PIPE_UM, TILE11_PIPE_MM, TILE11_PIPE_LM
	.byte TILE11_PIPE_UR, TILE11_PIPE_MR, TILE11_PIPE_LR

LoadLevel_GiantPipe:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	
	AND #$0f	
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of thing)

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDX #$00		 ; X = 0

PRG019_A59B:
	LDA LL_GiantPipe,X	 ; Get tile for pipe left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	LDA LL_GiantPipe+3,X	 ; Get tile for pipe middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	LDA LL_GiantPipe+6,X	 ; Get tile for pipe right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LL19_ReturnTileAndNextRow	 ; Return to beginning, then go to next row

	CPX #$02	 
	BEQ PRG019_A5B8	 ; If X = 2, jump to PRG019_A5B8
	INX		 ; Otherwise, X++

PRG019_A5B8:
	DEC <Temp_Var3		 ; Temp_Var3-- (height decrement)
	BPL PRG019_A59B	 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GiantCoral
;
; Generates a run of Giant Coral blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG019_A5BD:
	.byte TILE11_CORAL_UL, TILE11_CORAL_UR, TILE11_CORAL_LL, TILE11_CORAL_LR

LoadLevel_GiantCoral:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	
	AND #$0f	
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of things)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDX #$00	 ; X = 0

PRG019_A5D5:
	LDA <Temp_Var3 
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

PRG019_A5D9:
	LDA PRG019_A5BD,X	 ; Get tile for ??
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA PRG019_A5BD+2,X	 ; Get tile for ??
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	DEC <Temp_Var4		 ; Temp_Var4--
	BPL PRG019_A5D9	 	; While Temp_Var4 >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	JSR LoadLevel_NextColumn ; Next column

	STY TileAddr_Off	 ; TileAddr_Off = Y

	; Update backup
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	INX		 ; X++
	CPX #$02
	BNE PRG019_A5D5	 ; If X <> 2, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_HPipeRun
;
; Generates a run of horizontal pipe (no ends, just pipe)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_HPipeTB:
	.byte TILE1_PIPEHT, TILE1_PIPEHB

LoadLevel_HPipeRun:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of pipe)

	LDX #$00	 	; X = 0
PRG019_A671:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

PRG019_A678:
	LDA LL_HPipeTB,X	 ; Get horizontal pipe tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BPL PRG019_A678	 	; While Temp_Var4 >= 0, loop!

	JSR LL19_ReturnTileAndNextRow	 ; Return to beginning, then go to next row
	INX		 ; X++ (do bottom of pipe)
	CPX #$02	 
	BNE PRG019_A671	 ; If X <> 2, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PrefabBGClouds
;
; Intelligently inserts a 7x10 block of prefabricated 
; background clouds... the "intelligent" part is that it won't
; deliberately overwrite other tiles as it can help it...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 7 rows of pregenerated background cloud patterns
	; The TILE13_SKY sky tiles are actually treated as skips!
	; $FFs are terminators
LL_LargeBGClouds:
	.byte TILE13_SKY, TILE13_SKY, TILE13_SKY, TILE13_SKY, TILE13_LARGEROUND_UL, TILE13_BALLCLOUD_UR, TILE13_SKY, TILE13_SKY, TILE13_SKY, TILE13_SKY, $FF
	.byte TILE13_SKY, TILE13_SKY, TILE13_SKY, TILE13_BALLCLOUD_UL, TILE13_CLOUD, TILE13_CLOUD, TILE13_LARGEROUND_UR, TILE13_SKY, TILE13_SKY, TILE13_SKY, $FF
	.byte TILE13_SKY, TILE13_SKY, TILE13_LARGEROUND_UL, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_BALLCLOUD_UR, TILE13_SKY, TILE13_SKY, $FF
	.byte TILE13_SKY, TILE13_BALLCLOUD_UL, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_LARGEROUND_UR, TILE13_SKY, $FF
	.byte TILE13_LARGEROUND_UL, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_LARGEROUND_UR, $FF
	.byte TILE13_BALLCLOUD_LL, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_LARGEROUND_LR, $FF
	.byte TILE13_SKY, TILE13_LARGEROUND_LL, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_BALLCLOUD_LR, TILE13_SKY, $FF

LL_LargeBGCloudChecks:
	.byte TILE13_BALLCLOUD_UL, TILE13_LARGEROUND_UL, TILE13_BALLCLOUD_UR, TILE13_LARGEROUND_UR, TILE13_BALLCLOUD_LL, TILE13_LARGEROUND_LL, TILE13_BALLCLOUD_LR, TILE13_LARGEROUND_LR
LL_LBGCC_End


LoadLevel_PrefabBGClouds:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$06	 
	STA <Temp_Var3	 ; Temp_Var3 = 6 (rows we're doing)

	LDX #$00	 ; X = 0
	LDY TileAddr_Off ; Y = TileAddr_Off

PRG019_A6F3:
	LDA LL_LargeBGClouds,X	 ; Get next tile from set
	CMP #TILE13_SKY	 
	BEQ PRG019_A73C	 	; If it's a sky tile, jump to PRG019_A73C (sky tiles are actually skipped!)

	; Not a sky tile...
	CMP #$ff	 
	BEQ PRG019_A743	 	; If this is a terminator, jump to PRG019_A743

	; Not a sky tile or a terminator...
	LDA [Map_Tile_AddrL],Y	 ; Get tile already here
	CMP #TILE13_SKY	 
	BEQ PRG019_A737	 	; If what's here is a sky tile, jump to PRG019_A737 (OK to place)

	; What's already here is NOT a sky tile...
	CMP #TILE13_CLOUD
	BEQ PRG019_A73C	 	; If what's here is general white cloud space, jump to PRG019_A73C (skip putting something here)

	; The tile here is not sky and it's not cloud space...
	STY <Temp_Var5		; Temp_Var5 = 'Y' (backup)

	; What's present is not sky and not cloud space, so we look for a replacement...
	LDY #(LL_LBGCC_End - LL_LargeBGCloudChecks - 1)
PRG019_A70C:
	CMP LL_LargeBGCloudChecks,Y
	BEQ PRG019_A719	 		; If this a tile in the table, jump to PRG019_A719

	DEY		 ; Y--
	BPL PRG019_A70C	 ; While Y >= 0, loop!

	LDY <Temp_Var5	 ; Restore 'Y' from backup
	JMP PRG019_A737	 ; Jump to PRG019_A737 (we're placing it anyway)

PRG019_A719:
	; We found the tile in the check table

	TYA
	LSR A	; shift right...
	ASL A	; ... shift left; same as AND $FE ?
	TAY
	INY		 ; Y = (Y & $FE) + 1   <-- overall, same as "OR #1" ??

	; Second check -- I'll admit I'm not sure what this one does exactly?
PRG019_A71E:
	LDA LL_LargeBGClouds,X	 	; Again, get the tile we're supposed to place 
	CMP #TILE13_CLOUD	 
	BEQ PRG019_A732	 		; If we were to put down a cloud tile, jump to PRG019_A732 (skip it)

	CMP LL_LargeBGCloudChecks,Y	
	BEQ PRG019_A732	 		; If equal to the check, jump to PRG019_A732

	DEY		 ; Y--
	TYA		 
	AND #$01	 
	BEQ PRG019_A71E	 ; Loop if bit 0 set

	LDA #TILE13_CLOUD	 ; If all else fails, use cloud space tile

PRG019_A732:
	LDY <Temp_Var5	 ; Restore 'Y'
	JMP PRG019_A73A	 ; Jump to PRG019_A73A

PRG019_A737:
	LDA LL_LargeBGClouds,X	 ; $A737 

PRG019_A73A:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG019_A73C:
	JSR LoadLevel_NextColumn ; Next column
	INX		 	; X++
	JMP PRG019_A6F3	 	; Jump to PRG019_A6F3

PRG019_A743:
	; Terminator hit...
	INX		 ; X++
	JSR LL19_ReturnTileAndNextRow	 ; Return to beginning, then go to next row
	DEC <Temp_Var3		; Temp_Var3-- (row decrement)
	BPL PRG019_A6F3	 ; While Temp_Var3 >= 0, loop...

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_AltClearToCloud
;
; Clears the entire tilespace to cloud space tiles (all white)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_AltClearToCloud:
	LDY #$50
PRG019_A74E:
	LDA #TILE13_CLOUD
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$f0	 
	BNE PRG019_A74E	 

	LDY #$00	 
PRG019_A75C:
	LDA #TILE13_CLOUD
	JSR Tile_Mem_ClearB
	INY		 
	CPY #$f0	 
	BNE PRG019_A75C	 

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Stars
;
; Randomly adds some stars near the top of the level; appears to
; be part of a lost effect using gradients to have a level darken
; going upward until a starry sky is reached...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Stars:	.byte TILE13_STARS1, TILE13_STARS2, TILE13_STARS3
LL_DarkSky:	.byte TILE13_SKY_DARK, TILE13_SKY_DARKTOBLACK
LL_DarkSkyStar:	.byte TILE13_SKY_DARKSTAR, TILE13_SKY_DARKTOBLACKS

LoadLevel_Stars:
	LDA #$60
	STA Misc_Counter ; Misc_Counter = $60

PRG019_A773:
	JSR Randomize	 ; Shake up the random number generator
	LDA RandomN	 ; Get random value
	AND #$03	
	STA <Temp_Var15	 ; Temp_Var15 = random value 0-3

	LDA RandomN+1	 ; Get another random value
	TAX		 ; Store into -> 'X'

	AND #$f0	 ; Value AND'ed with $F0
	CMP #$f0	
	BNE PRG019_A78C	 ; If value is not $F0, jump to PRG019_A78C

	; Otherwise, add $20 (becomes $10)
	TXA
	ADD #$20
	TAX	

PRG019_A78C:
	STX <Temp_Var16	 ; Temp_Var16 = random value

	; Cap value 0-2
	TXA		 
	AND #$03
	CMP #$03
	BNE PRG019_A798
	SUB #$02	

PRG019_A798:
	PHA		 ; Save value

	JSR LoadLevel_Set_TileMemAddr	 ; Set tile address?

	PLA		 ; Restore random 0-2 value
	TAX		; -> 'X'

	LDY TileAddr_Off ; Y = TileAddr_Off
	LDA LL_Stars,X	 ; Get random star tile
	STA <Temp_Var1	 ; -> Temp_Var1

	LDX #$01	 ; X = 1
	LDA [Map_Tile_AddrL],Y	 ; Get tile already here

PRG019_A7AA:
	CMP LL_DarkSky,X
	BEQ PRG019_A7C1	 ; If the tile already there is one of these dark sky tiles, jump to PRG019_A7C1

	DEX		 ; X--
	BPL PRG019_A7AA	 ; While X >= 0, loop!

	; Tile was not a dark sky tile
	LDX #$01	 ; X = 1
PRG019_A7B4:
	CMP LL_DarkSkyStar,X
	BEQ PRG019_A7C6	 ; If the tile already there is one of the dark sky star tiles, jump to PRG019_A7C6

	DEX		 ; X--
	BPL PRG019_A7B4	; While X >= 0, loop!

	; It was not one of the recognized tiles; just use the random star tile we wanted!
	LDA <Temp_Var1	 ; Reload star tile
	JMP PRG019_A7C4	 ; Jump to PRG019_A7C4

PRG019_A7C1:
	LDA LL_DarkSkyStar,X	 ; Load a dark sky with star

PRG019_A7C4:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG019_A7C6:
	DEC Misc_Counter ; Misc_Counter--
	BPL PRG019_A773	 ; $A7C9 
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LongCloud_WB
;
; Generates a long cloud platform of variable width in the middle,
; choice of blue sky or white cloud background; only for Tileset 13!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_LongCloudWB:
	.byte TILE13_LONGCLOUDBLUE_UL, TILE13_LONGCLOUDBLUE_LL, TILE13_LONGCLOUDWHIT_UL, TILE13_LONGCLOUDWHIT_LL
	.byte TILE13_LONGCLOUDBLUE_UM, TILE13_LONGCLOUDBLUE_LM, TILE13_LONGCLOUDWHIT_UM, TILE13_LONGCLOUDWHIT_LM
	.byte TILE13_LONGCLOUDBLUE_UR, TILE13_LONGCLOUDBLUE_LR, TILE13_LONGCLOUDWHIT_UR, TILE13_LONGCLOUDWHIT_LR


LoadLevel_LongCloud_WB:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	SUB #$c0
	AND #$f0
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	PLA		 ; Restore LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of cloud)

PRG019_A7F2:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3	
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

	LDA LL_LongCloudWB,X	 ; Load left
	JMP PRG019_A802	 	; Jump to PRG019_A802

PRG019_A7FF:
	LDA LL_LongCloudWB+4,X	 ; Load middle

PRG019_A802:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BNE PRG019_A7FF	 	; While Temp_Var4 >= 0, loop

	LDA LL_LongCloudWB+8,X	 ; Load right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LL19_ReturnTileAndNextRow	 ; Return to beginning, then go to next row
	INX		 	; X++ (change to lower tiles)
	TXA		 
	AND #$01	 
	BNE PRG019_A7F2	 ; Only 2 passes, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DoubleCloud
;
; Generates a potentially large (1-256 x 1-8) rectangle of layered
; clouds; this is noted to be unused except in a lost level...
; Tileset 13 only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_DoubleCloud:
	.byte TILE13_DBLCLOUD_UL, TILE13_DBLCLOUD_ML, TILE13_DBLCLOUD_LL, TILE13_DBLCLOUD_BL
	.byte TILE13_DBLCLOUD_UM, TILE13_DBLCLOUD_MM, TILE13_DBLCLOUD_LM, TILE13_DBLCLOUD_BM
	.byte TILE13_DBLCLOUD_UR, TILE13_DBLCLOUD_MR, TILE13_DBLCLOUD_LR, TILE13_DBLCLOUD_BR

LoadLevel_DoubleCloud:	
	JSR LL19_GetLayoutByte_AndBackup	; Get byte from layout -> Temp_Var3, and backup Map_Tile_AddrL/H into Temp_Var1/2

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var4		 ; Temp_Var4 = lower 4 bits of LL_ShapeDef

	LDX #$00	 	; X = 0
PRG019_A832:
	LDY TileAddr_Off	; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3

	LDA LL_DoubleCloud,X	 ; Get left tile
	JMP PRG019_A842	 	; Jump to PRG019_A842

PRG019_A83F:
	LDA LL_DoubleCloud+4,X	 ; Get middle tile

PRG019_A842:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BNE PRG019_A83F	 	; While Temp_Var5 > 0, loop!

	LDA LL_DoubleCloud+8,X	 ; Get right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LL19_ReturnTileAndNextRow	 ; Return to beginning, then go to next row

	DEC <Temp_Var4		 ; Temp_Var4-- (height decrement)

	LDA <Temp_Var4
	BMI PRG019_A86A	 	; If Temp_Var4 < 0, jump to PRG019_A86A (RTS)

	; This last part selects the appropriate tile type based on how much height (Temp_Var4) is left,
	; if it should be doing the "middle", "lower", or "bottom"

	LDX #$03		; X = 3 (bottom)
	CMP #$00
	BEQ PRG019_A832	 	; If Temp_Var4 = 0, jump to PRG019_A832

	LDX #$02	 	; X = 2 (lower)
	CMP #$01
	BEQ PRG019_A832	 	; If Temp_Var4 = 1, jump to PRG019_A832

	LDX #$01	 	; X = 1 (middle, repeats this one)
	JMP PRG019_A832	 	; Jump to PRG019_A832

PRG019_A86A:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PointyCloud
;
; Generates a variable width 1-16 "pointy edge" cloud, automatically
; switching between "blue sky" and "white cloud" versions of the
; tiles as appropriate (i.e. if it's overwriting sky or not)
; Tileset 13 only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_PointyCloud:
	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3	 	; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of cloud)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDX #TILE13_POINTYCLOUDBLU_L	 ; Pointy cloud left with blue sky BG

	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE13_SKY	
	BEQ PRG019_A88C	 	; If there's sky here, jump to PRG019_A88C

	LDX #TILE13_POINTYCLOUDWHT_L	 ; Pointy cloud left with white cloud BG
	JMP PRG019_A88C	 		; Jump to PRG019_A88C

PRG019_A882:
	LDX #TILE13_POINTYCLOUDBLU_M	 ; Pointy cloud middle with blue sky BG

	LDA [Map_Tile_AddrL],Y	 	; Get tile here
	CMP #TILE13_SKY	 
	BEQ PRG019_A88C	 		; If there's sky here, jump to PRG019_A88C
	LDX #TILE13_POINTYCLOUDWHT_M	 ; Pointy cloud middle with white cloud BG

PRG019_A88C:
	TXA		 	; Tile to store 'X' -> 'A'
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BNE PRG019_A882	 	; While Temp_Var3 >= 0, loop!

	LDX #TILE13_POINTYCLOUDBLU_R	 ; Pointy cloud right with blue sky BG

	LDA [Map_Tile_AddrL],Y	 	; Get tile here
	CMP #TILE13_SKY
	BEQ PRG019_A8A0	 		; If there's sky here, jump to PRG019_A8A0
	LDX #TILE13_POINTYCLOUDWHT_R	 ; Pointy cloud right with white cloud BG

PRG019_A8A0:
	TXA		 	; Tile to store 'X' -> 'A'
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_CloudGoal
;
; Generates a long (1-256), thick cloud designed to run into the 
; end goal area and patch in cloud tiles along the bottom of it
; Tileset 13 only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_CloudGoal:
	.byte TILE13_DBLCLOUD_UM, TILE13_THICKCLOUD_LM, TILE13_GOALBLACK, TILE13_GOALEDGE, TILE13_GOALBLACKCLOUD, TILE13_GOALEDGECLOUD

LoadLevel_CloudGoal:
	JSR LL19_GetLayoutByte_AndBackup	; Get byte from layout -> Temp_Var3, and backup Map_Tile_AddrL/H into Temp_Var1/2
	LDX #$00	 	 ; X = 0

PRG019_A8AF:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3 (width copy)

PRG019_A8B6:
	STX <Temp_Var4		 ; Temp_Var4 = X

	LDA LL_CloudGoal,X	 	; Get left tile
	CMP #TILE13_THICKCLOUD_LM
	BEQ PRG019_A8D3	 		; If we're doing the TILE13_THICKCLOUD_LM tile, jump to PRG019_A8D3

	; Otherwise...
	LDX #$01	 	; X = 1
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
PRG019_A8C3:
	CMP LL_CloudGoal+2,X	 ; Check if this is the goal's edge
	BEQ PRG019_A8D0	 	; If it is, jump to PRG019_A8D0

	DEX		 ; X = 0
	BPL PRG019_A8C3	 ; Check if this is the goal's blackness; if so, jump to PRG019_A8D0 (is how that'll turn out)

	; If not the goal edge or blackness...
	LDA #TILE13_DBLCLOUD_UM	 ; Just use standard middle tile
	JMP PRG019_A8D3	 ; Jump to PRG019_A8D3

PRG019_A8D0:
	LDA LL_CloudGoal+4,X	 ; Get appropriate alternate goal tile with cloud coverage at the bottom

PRG019_A8D3:
	LDX <Temp_Var4		 ; X = Temp_Var4
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BPL PRG019_A8B6	 	; While Temp_Var5 >= 0, loop!

	JSR LL19_ReturnTileAndNextRow	 ; Return to beginning, then go to next row
	INX		 ; X++ (next row)
	CPX #$02	
	BNE PRG019_A8AF	 ; If X <> 2, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_RoundCloudTop
;
; Generates a long (1-256), run of the round cloud tops, used as
; ground in some sky levels
; Tileset 13 only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LL_RoundCloudTops:
	.byte TILE13_ROUNDCLOUDBLU_T, TILE13_ROUNDCLOUDLAY_T

	; Search for the following tiles
LL_RoundCloudSearch:
	.byte TILE13_BALLCLOUD_LL, TILE13_LARGEROUND_LL, TILE13_LARGEROUND_LR, TILE13_BALLCLOUD_LR, TILE13_CLOUD

	; ... if match, replace with cooresponding tile from here
LL_RoundCloudReplace:
	.byte TILE13_ROUNDCLOUDLAR_LT, TILE13_ROUNDCLOUDLAR_LT, TILE13_ROUNDCLOUDLAR_RT, TILE13_ROUNDCLOUDLAR_RT, TILE13_ROUNDCLOUDWHT_T


LoadLevel_RoundCloudTop:
	JSR LL19_GetLayoutByte_AndBackup	; Get byte from layout -> Temp_Var3, and backup Map_Tile_AddrL/H into Temp_Var1/2
	LDX #$00	 	; X = 0

PRG019_A8F8:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3

PRG019_A8FF:
	STX <Temp_Var4		 ; Temp_Var4 = X

	LDA LL_RoundCloudTops,X	 	; Get round cloud top
	CMP #TILE13_ROUNDCLOUDLAY_T
	BEQ PRG019_A91C	 		; If we got the TILE13_ROUNDCLOUDLAY_T tile, jump to PRG019_A91C

	; Otherwise...
	LDX #(LL_RoundCloudReplace - LL_RoundCloudSearch - 1)
	LDA [Map_Tile_AddrL],Y	 	; Get tile here
PRG019_A90C:
	CMP LL_RoundCloudSearch,X
	BEQ PRG019_A919	 		; If it matches a tile we're looking for, jump to PRG019_A919

	; Otherwise...
	DEX		 ; X--
	BPL PRG019_A90C	 ; While X >= 0, loop!

	; If we didn't match any...
	LDA #TILE13_ROUNDCLOUDBLU_T	; Just use round cloud in blue sky
	JMP PRG019_A91C	 		; Jump to PRG019_A91C

PRG019_A919:
	LDA LL_RoundCloudReplace,X	; Get appropriate cloud top tile

PRG019_A91C:
	LDX <Temp_Var4		 ; X = Temp_Var4

	STA [Map_Tile_AddrL],Y	 ; Store appropriate cloud top tile into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BPL PRG019_A8FF	 	; While Temp_Var5 >= 0, loop!
 
	JSR LL19_ReturnTileAndNextRow	 ; Return to beginning, then go to next row
	INX		 ; X++ (next row)
	CPX #$02	 
	BNE PRG019_A8F8	 ; If X <> 2, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GiantHill
;
; Builds a Giant World background hill that stretches from the
; start downward until it hits something "not sky"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_GiantHill:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE11_HILL_PEAK
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	LDX #$00	 ; X = 0
	STX <Temp_Var3	 ; Temp_Var3 = 0
	JMP PRG019_A95F	 ; Jump to PRG019_A95F

PRG019_A946:
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE11_SKY
	BNE PRG019_A99F	 	; If this is not sky here, jump to PRG019_A99F

	LDA #TILE11_HILL_LSLOPE
	JMP PRG019_A953	 		; Jump to PRG019_A953

PRG019_A951:
	LDA #TILE11_HILL_MID

PRG019_A953:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEX		 ; X--
	BNE PRG019_A951	 ; While X > 0, loop

	LDA #TILE11_HILL_RSLOPE
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG019_A95F:

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	DEY		
	TYA		
	AND #$0f	
	CMP #$0f	
	BNE PRG019_A991	 

	; Go to previous screen by subtracting $1B0, updating Temp_Var1/2 backup
	LDA <Map_Tile_AddrL
	SUB #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	SBC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2	

	INY	
	TYA	
	AND #$f0
	ORA #$0f
	TAY		 ; Y is now at other edge of screen

PRG019_A991:
	STY TileAddr_Off	 ; TileAddr_Off = Y

	LDA <Temp_Var3
	ADD #$02	
	STA <Temp_Var3	 ; Temp_Var3 += 2

	TAX		 ; X = A
	JMP PRG019_A946	 ; Jump to PRG019_A946

PRG019_A99F:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PrefabBGClouds2
;
; Inserts a 4x5 or 3x5 block of prefabricated cloud background.
; Unlike LoadLevel_PrefabBGClouds, does not check anything and
; just blindly overwrites!  
; Tileset 12 only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_LargeBGClouds2:
	.byte TILE13_CLOUD, TILE13_CLOUD, TILE13_CLOUD, TILE13_BALLCLOUD_LR, TILE13_LARGEROUND_LL, $FF
	.byte TILE13_BALLCLOUD_LR, TILE13_LARGEROUND_LL, TILE13_LARGEROUND_LR, TILE13_SKY, TILE13_LARGEROUND_UL, $FF
	.byte TILE13_LARGEROUND_UR, TILE13_SKY, TILE13_SKY, TILE13_BALLCLOUD_UL, TILE13_CLOUD, $FF
	.byte TILE13_CLOUD, TILE13_BALLCLOUD_UR, TILE13_LARGEROUND_UL, TILE13_CLOUD, TILE13_CLOUD, $FF

LL_LargeBGClouds2B:
	.byte TILE13_BALLCLOUD_LR, TILE13_LARGEROUND_LL, TILE13_BALLCLOUD_LR, TILE13_LARGEROUND_LL, TILE13_CLOUD, $FF
	.byte TILE13_LARGEROUND_UR, TILE13_SKY, TILE13_SKY, TILE13_SKY, TILE13_BALLCLOUD_LL, $FF
	.byte TILE13_CLOUD, TILE13_BALLCLOUD_UR, TILE13_BALLCLOUD_UL, TILE13_LARGEROUND_UR, TILE13_LARGEROUND_UL, $FF
LL_LBGC2_StartIdx:	.byte 0, (LL_LargeBGClouds2B - LL_LargeBGClouds2)
LL_LBGC2_Rows:		.byte 3, 2


LoadLevel_PrefabBGClouds2:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	SUB #$06	
	TAX		 ; X = relative index

	LDA LL_LBGC2_Rows,X
	STA <Temp_Var3		 ; Temp_Var3 = LL_LBGC2_Rows[X]

	LDA LL_LBGC2_StartIdx,X	
	TAX		 	; X = LL_LBGC2_StartIdx[X]

	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG019_A9E9:
	LDA LL_LargeBGClouds2,X	 ; Get next tile
	CMP #$ff	 
	BEQ PRG019_A9F9	 	; If it's a terminator, jump to PRG019_A9F9

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	INX		 ; X++
	JMP PRG019_A9E9	 ; Jump to PRG019_A9E9

PRG019_A9F9:
	INX		 ; X++
	JSR LL19_ReturnTileAndNextRow	 ; Return to beginning, then go to next row

	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG019_A9E9	 ; While Temp_Var3 >= 0, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_CloudSpace
;
; Generates a rectangle (1-256 x 1-8) of white cloud space
; Tileset 13 only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_CloudSpace:
	JSR LL19_GetLayoutByte_AndBackup	; Get byte from layout -> Temp_Var3, and backup Map_Tile_AddrL/H into Temp_Var1/2

	LDA LL_ShapeDef
	AND #$0f	
	TAX		 ; X = lower 4 bits of LL_ShapeDef (height of rectangle)

PRG019_AA0B:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

PRG019_AA12:
	LDA #TILE13_CLOUD	 ; White cloudspace
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	LDA <Temp_Var4		
	CMP #$ff	 
	BNE PRG019_AA12	 	; While Temp_Var4 > 0, loop!

	JSR LL19_ReturnTileAndNextRow	 ; Return to beginning, then go to next row

	DEX		 ; X-- (height decrement)
	BPL PRG019_AA0B	 ; While X >= 0, loop!

	RTS		 ; Return



	; Routine to get a byte from the layout, put it into Temp_Var3,
	; and advance the Level_LayPtr_Addr pointer...
	; Also backup Map_Tile_AddrL/H into Temp_Var1/2
LL19_GetLayoutByte_AndBackup:
	LDY #$00	 		; Y = 0
	LDA [Level_LayPtr_AddrL],Y	; Get another byte from layout
	STA <Temp_Var3	 		; -> Temp_Var3

	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	RTS		 ; Return

	; Goes to next row and updates backup variable Temp_Var2
LL19_ReturnTileAndNextRow:
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2	; Update Map_Tile_AddrH backup

	RTS		 ; Return


	; Broken into another file for ease of integration in NoDice editor
	.include "PRG/levels/Sky.asm"
	.include "PRG/levels/Giant.asm"

